*
*	Amiga-specific portions of galaga
*
* (c) JOTD 2024
*

.include "../src/galaga.inc"
.include "../src/structs.inc"
.include "custom.i"
.include "exec_lvos.i"
.include "dos_lvos.i"
.include "graphics_lvos.i"

AttnFlags = 0x128
AFB_68010 = 0
AFB_68020 = 1
NO68020 = 1

SPRITE_Y_CORRECTION = -8
SPRITE_X_CORRECTION = 8

BASE_BPLCON2_VALUE = 0x0000   | sprites behind
SCREEN_ADDRESS = 0x8000

* dynamic color change + stars lifted from my previous Galaxian port
STAR_SPRITE_INDEX = 7
STAR_SPRITE_COLOR_REG = color+(STAR_SPRITE_INDEX/2)*8+34

copper_stars_offset = 12
copper_row_size = 32
copper_8x8_row_size = copper_stars_offset+copper_row_size*8

MAX_ROW_X = 31

BORDERBLANK = 0
SCORE_FILE_SIZE = 9*5

* if the alloc_sprite & update_sprite routines
* are reused, changing those offsets can make
* a quick reuse from game to game as most sprite
* RAMs have 4 bytes per sprite, only the order
* and some bits differ

SPRITE_BLOCK_OFFSET = 256			| len of each sprite info table times 2

PREVIOUS_SPRITE_SIZE = 12
CURRENT_SPRITE_SIZE = 2

PREVIOUS_SPRITE_X = 0
PREVIOUS_SPRITE_Y = 2
PREVIOUS_Y_START = 4
PREVIOUS_SPRITE_HEIGHT = 6
PREVIOUS_ACTIVE_BITPLANE_MASK = 8   | for optimized bitplane erase
PREVIOUS_SPRITE_CODE = 9
PREVIOUS_SPRITE_COLOR = 10

TARGET_SPRITE_X_1 = 1+SPRITE_BLOCK_OFFSET
TARGET_SPRITE_X_2 = 1+SPRITE_BLOCK_OFFSET*2
TARGET_SPRITE_COLOR = 1
TARGET_SPRITE_CODE = 0
TARGET_SPRITE_ATTRIBUTES = SPRITE_BLOCK_OFFSET*2
TARGET_SPRITE_Y = SPRITE_BLOCK_OFFSET

DOUBLE_SHOT_CODE = 0x7F

	.ifdef	RELEASE
OPT_ENABLE_PROFILING = 0         | DO NOT CHANGE THIS
OPT_ENABLE_LOGGING = 0           | DO NOT CHANGE THIS
ONE_TICK = 1
	.else
OPT_ENABLE_LOGGING = 0
OPT_ENABLE_PROFILING = 0
* set to higher values than 1 to speed game up
ONE_TICK = 1


	.endif
	

OPT_ENABLE_DOUBLE_BUFFERING = 1

_custom = 0xDFF000


NB_PLAYFIELD_PLANES = 5
NB_BOBS_PLANES = 4
TOTAL_NB_COLORS = 1<<NB_BOBS_PLANES
NB_BYTES_PER_ROW = 40
NB_ROWS = 36
NB_LINES = NB_ROWS*8  | 288
Y_MAX = NB_LINES

NB_PLAYFIELD_LINES = NB_LINES

* add 32 bytes in the end, in case sprites are drawn below the limit
* (which happens!)
BG_SCREEN_PLANE_SIZE = NB_BYTES_PER_ROW*(NB_PLAYFIELD_LINES+32)
BG_SCREEN_SIZE =  BG_SCREEN_PLANE_SIZE*NB_PLAYFIELD_PLANES

NB_HOST_SPRITES = 6

* hardware can take 64 sprites max like Xevious. What a beast for 1981!

NB_TARGET_SPRITES = 64

* for host sprites
SPRITE_X = 0
SPRITE_Y = 1
SPRITE_CODE = 2
SPRITE_CLUT = 3
SPRITE_SIZEOF = 4

	.ifdef	RELEASE
	.macro	CHECK_BLITTER_BOUNDS
	.endm
	.else
	* debug mode: check if blitter start address (in A1) at least
	* is within the 4 first planes, with an error margin of 16 rows
	.macro	CHECK_BLITTER_BOUNDS
	movem.l	d0/a0-a2,-(a7)
	move.l	bg_drawed_screen_ptr(pc),d0
	sub.l	d0,a1
	jpl		110f
111:
	* dest blit address too low: below drawed screen address
	move.l	a1,a0
	movem.l	d1-d4/a3,-(a7)
	move.l	a1,a3
	move.l	#BG_SCREEN_PLANE_SIZE*NB_BOBS_PLANES,d1
	move.l	bg_drawed_screen_ptr(pc),a2
	lea		blitter_address_too_low_error(pc),a1
	move.w	last_x_blit,d2
	move.w	last_y_blit,d3
	move.w	last_blit_height,d4
	jbsr	osd_break
	movem.l	(a7)+,d1-d4/a3
	jra		112f
113:
	move.l	a1,a0
	movem.l	d1-d4/a3,-(a7)
	move.l	a1,a3
	add.l	bg_drawed_screen_ptr(pc),a3
	move.l	#BG_SCREEN_PLANE_SIZE*NB_BOBS_PLANES,d1
	move.l	bg_drawed_screen_ptr(pc),a2
	lea		blitter_address_too_high_error(pc),a1
	move.w	last_x_blit,d2
	move.w	last_y_blit,d3
	move.w	last_blit_height,d4
	jbsr	osd_break
	movem.l	(a7)+,d1-d4/a3
	jra		112f
110:
	cmp.l	#BG_SCREEN_PLANE_SIZE*NB_BOBS_PLANES,a1
	bcc.b	113b
112:
	movem.l	(a7)+,d0/a0-a2
	.endm	
	.endif
	
| write current PC value to some address
.macro LOGPC	address
	.ifndef	RELEASE
     bsr    .next_\@
.next_\@:
      addq.l    #6,(a7) | skip this & next instruction
      move.l    (a7)+,0x\address
	.endif
.endm

.macro	WAIT_BLIT
	move.w	#0x8400,(dmacon,a5)		| blitter high priority
wait\@:
	BTST	#6,(dmaconr,a5)
	BNE.S	wait\@
	move.w	#0x0400,(dmacon,a5)		| blitter normal priority
.endm

.macro MUL_TABLE value,len
mul\value\()_table:
	.set    mulv,0
	.rept	\len
	dc.w	mulv
	.set	mulv,mulv+\value
	.endr
.endm


* debug macro that colors the screen until LMB pressed
.macro 	blitz_bypass
	move.w	d0,-(a7)
	clr.w	d0
loop\@:
	move.w	d0,_custom+color
	btst	#6,0xbfe001
	beq.b	out\@
	addq.w	#1,d0
	bra.b	loop\@
out\@:
	move.w	(a7)+,d0
	nop
.endm

* same thing but if LMB is pressed when entering, macro waits for release)
.macro blitz
w\@:
	btst	#6,0xbfe001
	beq.b	w\@
	blitz_bypass
.endm

start:
	move.l	a7,old_stack
	bra	_user
    
	

* exports

	  .global _user
		.global _player_start
		.global _demo_end

* osd layer		
		.global osd_interrupt_control
		.global osd_ack_vblank_interrupt
		.global osd_break		| for debug	
		.global osd_blitz		| for debug
		.global osd_w_videoram_no_update
		.global osd_w_videoram
		.global osd_w_colorram
		.global osd_r_videoram
		.global osd_update_inputs
		.global osd_get_random
		.global osd_read_dsw_1
		.global osd_read_dsw_2
		.global osd_read_dsw_3
		.global osd_read_dsw_4
		.global osd_read_dsw_5
		.global osd_read_dsw_6
		.global osd_read_nb_fighters
		.global osd_read_in_2
		.global osd_read_in_0
		.global osd_read_high_scores
		.global osd_write_high_scores
		.global osd_sound_start
		.global osd_sound_stop
		.global osd_loop_stop
		.global	osd_update_palette_bank
		.global	osd_wait

	
	.include	"ReadJoypad.i"
	.include	"whdload_funcs.i"
		.text


.list

	.ifne	OPT_ENABLE_PROFILING
	* init profiling if enabled
	.include	"profiler.68k"
	.endif

	    
_user:
    * if D0 contains "WHDL"
    * A0 contains resload
        
    cmp.l   #0x05748444c,D0	| WHDL
    bne.b   .standard
	move.b	d1,_keyexit
    move.l a0,_resload

	move.l	a0,a2
	lea	(_tag,pc),a0
	jsr	(resload_Control,a2)
	
	* resolve indirection for start level (better on command line: all levels can be selected)
	lea		start_levels_whd(pc),a0
	move.l	start_level_option,d0
	and.w	#0x3F,d0
	move.b	(a0,d0.w),d0
	subq	#1,d0		| zero indexed after all!
	move.b	d0,start_level_option+3
	
    bra		.no_forbid
.standard:
	
    * open dos library, graphics library
    move.l  0x4.W,a6
    lea dosname,a1
    moveq.l #0,d0
    jsr _LVOOpenLibrary(a6)
    move.l  d0,_dosbase

	lea	read_args_string(pc),a0
	lea	program_args(pc),a1
	move.l	#program_args_end-program_args,d0
	lsr.l	#2,d0		| number of longs
	

	bsr	get_args_BCPL

0:	
	lea		program_args,a0

	move.l	(A0)+,D0	| INVINCIBLE/S
	beq.b	1f
	or.l	#1,cheat_flags
	st.b	cheat_used
1:
	move.l	(A0)+,D0	| INFLIVES/S
	beq.b	2f
	or.l	#2,cheat_flags
	st.b	cheat_used
2:
	move.l	(A0)+,D0	| PERFECT/S
	beq.b	2f
	or.l	#4,cheat_flags
	st.b	cheat_used
2:
	move.l	(A0)+,D0	| CHEATKEYS/S
	beq.b	2f
	* cheat isn't used as long as no cheat key is used
	or.l	#0x10,cheat_flags
2:


	move.l	(A0)+,D0	| STARTLIVES/S
	beq.b	2f
	bsr		bcpl_string_to_int
	subq.b	#3,d0
	bmi.b	2f
	move.l	d0,dip_switch_start_lives
	bra.b	3f
2:
	move.l	#0,dip_switch_start_lives		| 3 lives default
3:
	move.l	(A0)+,D0		| STARTLEVEL/K/N
	beq.b	2f
	bsr		bcpl_string_to_int
	subq	#1,d0
	move.l	d0,start_level_option
2:
	lea		_custom,a5
	lea		debug_copperlist,a0
	move.l	a0,cop1lc(a5)

	move.l	4.W,A6
	lea graphicsname,a1
    moveq.l #0,d0
    jsr _LVOOpenLibrary(a6)
    move.l  d0,_gfxbase
    move.l	d0,a6
	move.l	38(a6),old_syscoplist
	move.l	34(A6),old_actiview		| gb_ActiView

	sub.l	a1,a1
	jsr	_LVOLoadView(a6)
	jsr	_LVOWaitTOF(a6)
	jsr	_LVOWaitTOF(a6)

	bsr		load_highscores

    * check if "floppy" file is here
    
    move.l  _dosbase(pc),a6
    move.l   #floppy_file,d1
    move.l  #1005,d2   | MODE_OLDFILE
    jsr     _LVOOpen(a6)
    move.l  d0,d1
    beq.b   .no_floppy
    
    * "floppy" file found
    jsr     _LVOClose(a6)
    * wait 2 seconds for floppy drive to switch off
    move.l  #100,d1
    jsr     _LVODelay(a6)
.no_floppy:

.startup:

* no multitask
    tst.l   _resload
    bne.b   .no_forbid
    *move.l  _gfxbase(pc),a4
    *move.l StartList(a4),gfxbase_copperlist

	
    move.l  4,a6
    jsr _LVOForbid(a6)

    
	sub.l	A1,A1
	jsr	_LVOFindTask(a6)		| find ourselves
	move.l	D0,A0
	move.l	#-1,184(A0)	| pr_WindowPtr: no more system requesters (insert volume, write protected...)

.no_forbid:
	moveq	#0,d0
	
	move.b	dip_switch_start_lives+3(pc),d0
	
*   bit 3 : \bonus at
*   bit 2 : / 00 = 7000  01 = 10000  10 = 15000  11 = 20000: leave to 0 (7000)
*   bit 1 : \ 00 = 3 lives  01 = 4 lives
*   bit 0 : / 10 = 5 lives  11 = 6 lives

	move.b	d0,dip_switches
	
	move.l	misc_options(pc),d1
	.ifndef	RELEASE
	btst	#31,d1
	sne		break_at_startup_flag
	.endif
	btst	#0,d1
	sne		slow_machine
	sne		half_fps


	move.l	start_level_option,d0
	move.b	d0,start_level

	move.l	cheat_flags,d0
	btst	#0,d0
	sne		invincible_flag
	btst	#1,d0
	sne		infinite_lives_flag
	btst	#2,d0
	sne		perfect_challenge_stage_flag

	and.w	#7,d0
	sne		cheat_used

	jsr	 _detect_controller_types 
	clr.b	controller_joypad_0
	clr.b	controller_joypad_1

	bsr		load_palette_in_copperlist
	bsr		show_stars


	jra		demo_game


* < D0: bcpl string (with leading size byte)
* < A1: dest C string
bcpl_arg_string_copy:
    movem.l D0-D2/A0-A1,-(a7)
	lsl.l	#2,d0
	moveq.l	#0,d2
    move.l  d0,a0
	move.b	(a0)+,d2	| size
	beq.b	1f
	subq	#1,d2
0:
	move.b	(a0)+,(a1)+
	dbf		d2,0b
1:
    movem.l (a7)+,D0-D2/A0-A1
    rts


bcpl_string_to_int:
    movem.l A0/A1,-(a7)
    lea temp_filename_buffer(pc),a1
    bsr bcpl_arg_string_copy
    * convert to integer
    move.l  a1,a0
    * < A0: pointer on C string
    * > D0: value
    * > D1: -1 if ok, position of the string if error
    bsr parse_integer
    movem.l  (a7)+,a0/a1
	rts
	
* parse integer from string
* < A0: pointer on C string
* > D0: value
* > D1: -1 if ok, position of the string if error
parse_integer:
    movem.l  d2/d3,-(a7)
    * go to end of string
    moveq.l #-1,d1
.loop1:
    addq.l  #1,d1
    tst.b   (a0,d1.w)
    bne.b   .loop1
    * d1 is the number of chars
    moveq.l #0,d0
    moveq.l #0,d2
    subq.l  #2,d1   | 10th power minus 1
.loop2:
    move.b  (a0)+,d2
    beq.b   .out
    
    cmp.b   #32,d2
    beq.b   .skip
    sub.b   #48,d2
    bcs.b   .error
    cmp.b   #10,d2
    bcc.b   .error
    move.w  d1,d3
    bmi.b   .doadd
.muloop:
    mulu    #10,d2
    dbf d3,.muloop
.doadd:
    add.l   d2,d0
.skip:
    subq.l  #1,d1
    bra.b   .loop2
.out:    
    movem.l  (a7)+,d2/d3
    rts
.error:
    moveq.l #0,d0
    bra.b   .error
	
    * thanks Toni for this 1.3 read argument code
BCPL_RdArgs = 78
	
	* a1 = pointer to result array. Must be LONG aligned!
	* a0 = formatting string. BSTR!
	* d0 = size of result array (number of LONGs)
get_args_BCPL:
	movem.l d2/d3/d4,-(sp)
	move.l d0,d3
	moveq #BCPL_RdArgs,d0
	move.l a0,d1
	lsr.l #2,d1
	move.l a1,d2
	lsr.l #2,d2
	moveq #0,d4
	bsr.s call_bcpl
	movem.l (sp)+,d2/d3/d4
	rts

	* d0 = gv index
	* d1-d4 = bcpl parms

BCPL_STACK = 3000

call_bcpl:
	movem.l d2-d7/a2-a6,-(sp)

	move.l d0,d6
	move.l d1,d5

	move.l 4.w,a6
	move.l	_dosbase(pc),a5


	sub.l a1,a1
	jsr	_LVOFindTask(a6)
	move.l d0,a4

	* allocate BCPL stack
	move.l #BCPL_STACK,d0
	move.l #65536+1,d1
	jsr	_LVOAllocMem(a6)
	move.l d0,d7
	beq.s 0f
	
	movem.l d7/a5/a6,-(sp)

	moveq #0,d0
	move.l d5,d1
	sub.l a0,a0
	move.l d7,a1
	lea 3*4(a1),a1
	move.l 136(a4),a2
	lsl.w #2,d6
	move.l 0(a2,d6.w),a4
	movem.l 46(a5),a5/a6
	jsr (a5) | call bcpl!
	
	movem.l (sp)+,d7/a5/a6

0:
	move.l d7,a1
	move.l #BCPL_STACK,d0
	jsr	_LVOFreeMem(a6)


	movem.l (sp)+,d2-d7/a2-a6
	rts


NB_STAR_ROWS = 32		| height: 256

show_stars:
	move.l	a5,-(a7)
	lea	bg_color_table,a3
	lea	stars_palette_rgb4,a2
	lea	stars_copper_row_pointers(pc),a5
	
	clr.w	d7		| 8-row counter
	clr.w	d2		| palette index
2:
	* get address for the next 8 rows
	move.l	(a3)+,a1
	add.w	#copper_stars_offset,a1

	moveq	#8-1,d6
	cmp.w	#28,d7
	bne.b	3f
	moveq	#3-1,d6		| special row
3:
	move.l	a1,(a5)+
4:
	* pick random x
	bsr		random
	btst	#15,d0
	beq.b	1f	| 50% chance of displaying a star
	and.w	#0xFF,d0
	cmp.w	#240,d0		| empiric
	bcc.b	4b
	add.w	#6*8,d0	| add 48 offset because of screen centering
	move.w	#0,d1	| max Y, else glitchy stars
	move.l	a1,-(a7)
	lea		HW_SpriteYTable_0,a1	
	bsr		store_sprite_pos
	move.l	(a7)+,a1
	* store color
	move.w	(a2,d2.w),(2,a1)		| change offset if copper sprite struct changes
	addq.w	#2,d2
	cmp.w	#128,d2		| 64 colors?
	bne.b	0f
	clr.w	d2			| wrap
0:

	* D0 is the sprite pos/control word
	move.w	d0,(10,a1)		| change offset if struct changes
	swap	d0
	move.w	d0,(6,a1)		| change offset if struct changes

	add.w	#32,a1
	dbf		d6,3b
	addq.w	#1,d7
	cmp.w	#NB_STAR_ROWS,d7
	jne		2b
	sub.l	#stars_copper_row_pointers,a5
	move.w	A5,d0
	lsr.w	#2,d0
	move.w	d0,stars_copper_pointers_count
	move.l	(a7)+,a5
	tst.b	slow_machine
	bne.b	3f
	st.b	enable_star_scroll
3:
	rts
1:
	clr.l	d0
	bra.b	0b
	
scroll_stars:
	tst.b	enable_star_scroll
	bne.b	0f
	rts
0:
	lea		stars_copper_row_pointers(pc),a5
	move.w	stars_copper_pointers_count(pc),d7
	move.w	d7,d6
	add.w	d6,d6
	add.w	d6,d6
	add.w	d6,a5		| point at the end of the row pointers
	subq.w	#1,d7
	* save last line first

	
	lea		temp_copper_buffer(pc),a3
	move.l	-(a5),a4
	move.w	(2,a4),(a3)+
	move.w	(10,a4),(a3)+
	move.w	(6,a4),(a3)
	subq	#1,d7
	* then overwrite each next line with previous one
0:
	move.l	(a5),a4	| destination
	move.l	-(a5),a3	| source
	move.w	(2,a3),(2,a4)
	move.w	(10,a3),(10,a4)
	move.w	(6,a3),(6,a4)

	dbf	d7,0b
	* restore last line into the first one
	move.l		stars_copper_row_pointers(pc),a4	| first item
	lea		temp_copper_buffer(pc),a3
	move.w	(a3)+,(2,a4)
	move.w	(a3)+,(10,a4)
	move.w	(a3),(6,a4)
	
	rts


	
random:
    move.l  previous_random(pc),d0
	* EAB simple random generator
    * thanks meynaf
    mulu #0xa57b,d0
    addi.l #0xbb40e62d,d0
    rol.l #6,d0
    move.l  d0,previous_random
    rts
	
	
	
get_hiscore_name:
    lea normal_hiscorename,a0
	rts
	
load_highscores:
	bsr.b		get_hiscore_name
    move.l  _resload(pc),d0
    bne.b   1f

    move.l  _dosbase(pc),a6
    move.l  a0,d1
    move.l  #1005,d2
    jsr     (_LVOOpen,a6)
    move.l  d0,d1
    beq.b   1f
    move.l  d1,d4
    move.l  #SCORE_FILE_SIZE,d3
    move.l  #high_score_buffer,d2
    jsr (_LVORead,a6)
    move.l  d4,d1
    jsr (_LVOClose,a6)   
	st.b	highscore_loaded
1:
    rts

save_highscores:
	tst.l	_resload
	bne.b	1f
    tst.b   highscore_needs_saving
    beq.b   1f
    move.l  _dosbase(pc),a6
	bsr.b		get_hiscore_name
    move.l  a0,d1
    move.l  #1006,d2
    jsr     (_LVOOpen,a6)
    move.l  d0,d1
    beq.b   1f
    move.l  d1,d4
    move.l  #SCORE_FILE_SIZE,d3
    move.l  #high_score_buffer,d2
    jsr (_LVOWrite,a6)
    move.l  d4,d1
    jsr (_LVOClose,a6)   
1:	
    rts
    
	
* To get the core to run, you just need to jump to galaga_reset after
* you've initialised the platform (Amiga) stuff. That essentially does a
* Z80 reset. You also need to call galaga_im1_irq from the Amiga vblank
* routine. They are the only 2 entry points required for the core to run,
* even if there's no other I/O.


demo_game:
		move		#0x4000,_custom+intena						| disable interrupts
		move		#0x7FFF,_custom+intreq						| ack all interrupts
		bsr			platform_init					| amiga-specific init
		
0:
	* init video & color ram with improbable crap so attributes & video are forced
	* to refresh even when "0" is written into them
	move.w	#0x1FF,d1
	move.l	#-1,d0
	lea		bg_videoram,a0
0:
	move.l	d0,(a0)+
	dbf		d1,0b

	* resets both CPUs
	jbra		galaga_reset	| pass control to the galaga core
		
	
* just in case some hardware calls nmi
_nmi:
	move.w	#0x7FFF,_custom+intreq
	move.w	#0x7FFF,_custom+intreq
	rts
	
_vblank:
    movem.l d0-d7/a0-a6,-(a7)
	lea		_custom,a5
	move.w	(intreqr,a5),d0
	btst	#5,d0
	beq.b		1f

	bsr		scroll_stars

	clr.b	skip_screen_update
	move.l	_joypad_state(pc),d1
	moveq	#1,d0
	jsr	_read_joystick
	move.l	d0,_joypad_state
	
	* CD32 "play" is disabled but it's free to read
	* 3rd button on a Sega 3-button so 3rd button is pause
	btst	#JPB_BTN_PLAY,d0
	beq.b	0f
	btst	#JPB_BTN_PLAY,d1
	bne.b	0f
	bsr		toggle_pause
0:
	* here music doesn't loop. We have to stop it when it ends
	move.w	music_tick(pc),d1
	beq.b	13f
	
	subq	#1,d1

	.ifndef	RELEASE
	move.w	d1,0xF8
	.endif
	move.w	d1,music_tick
	bne.b	13f
	move.b	music_track_start_number,d2
	bsr		osd_sound_stop
	cmp.b	#10,d2
	jne		13f
	* special case end of "PERFECT" play attack sound
	move.w	#ATTACK_SND,d0
	jbsr	osd_sound_start
13:
	lea		_custom,a5
	
	* ack vbl twice (040/pistorm bug)
	move.w	#0x20,(intreq,a5)
	move.w	#0x20,(intreq,a5)	
	jra	3f
1:
	***************************************
	* has to be copper
	* we're going to ack copper interrupt now
	* do it twice (040/pistorm bug)
	move.w	#0x10,(intreq,a5)
	move.w	#0x10,(intreq,a5)
	
	moveq	#ONE_TICK,d1
    move.w  vbl_counter(pc),d0
    addq.w  #1,d0
    cmp.w   #5,d0
    bne.b   22f
    * update a second time, simulate 60Hz
	moveq	#ONE_TICK*2,d1
	clr.w d0    
22:
	move.b	d1,vb_ticks_count
    move.w  d0,vbl_counter
	
	tst.b	pause_flag
	bne.b	23f

	sub.w	d1,delay_timer
	

	
	* declare that we're in interrupt mode so osd_disable_interrupts/osd_enable_interrupts
	* also set SR accordingly
	st.b	interrupt_mode
	jbsr		galaga_irq
	cmp.b	#ONE_TICK*2,vb_ticks_count
	bne.b	0f
	jbsr		galaga_irq	
0:
	* forbid interrupts as galaga_irq could have enabled them within the IRQ
	* (this is strange but if we disable this interrupt enabling, then the game
	* freezes...). Now disable again, else on slow machines , the sprite update
	* could be interrupted by the next tick and mess everything up
	move.w	#0x2300,SR
	clr.b	interrupt_mode
	tst.b	skip_screen_update
	bne.b	1f
	tst.b	half_fps
	beq.b	0f			| 50Hz update!
	eor.b	#1,flip_flop
	bne.b	1f
0:
	jbsr	really_update_sprites

	.ifne  OPT_ENABLE_DOUBLE_BUFFERING
	bsr		switch_screen_buffers
	.endif
1:
	clr.b	skip_screen_update
23:
	* now we check copper interrupt again
	move.w	_custom+intreqr,d0
	btst	#4,d0
	beq.b	3f		| clear: ok
	tst.b	half_fps
	beq.b	24f		| cannot cope with 50 fps
	tst.b	flip_flop
	beq.b	25f
24:
	* copper interrupt has been called, which means that
	* rendering was so slow that we couldn't cope within a frame
	* skip a tick and ack again, we lose one update frame
	* and it happened when no rendering was requested
	* (else it's expected that it happens as 50 fps is too much)
	st.b	skip_screen_update
	.ifndef	RELEASE
	move.w	#0xF00,_custom+color
	.endif
25:
	move.w	#0x10,_custom+intreq
3:
    movem.l (a7)+,d0-d7/a0-a6
    rte
	

osd_blitz:
	blitz
	rts
	
osd_break:
	* sends a WinUAE command to enter WinUAE debugger
	.ifndef	RELEASE
	move.l	D0,-(a7)
	pea     0.w
	* Normally it would point to where the result of the command is written, but since the last parameter (first pushed)
	* indicating the number of bytes to write is 0, nothing is written.
	pea     0.w	
	pea     1003f-1002f
	pea     1002f(pc)
	pea     -1.w
	pea     82.w
	jsr     0xf0ff60
	lea     24(sp),sp
	move.l	(a7)+,d0
	.endif
    rts
		
1002: .asciz    "AKS_ENTERDEBUGGER 1"
1003:
        .align	
	


	


	
	
really_update_sprites:

	* first, make sure we have the proper palette (TODO challenging stages)
	
	bsr		update_hardware_sprites
	bsr		update_bobs
	bsr		refresh_status_bar
	rts
	
sprite_toggle:
	dc.w	0
	
refresh_status_bar:
	lea			hardware_sprite_flag_table,a2
	* previous sprites are now current sprites
	move.l		bob_previous_drawed_sprites(pc),a4
	clr.b		d5		| done at right flag
	clr.b		d4		| done at left flag
	clr.b		d6		| on current buffer
	****************************************
	* CHECK IF LOW SPRITE ON LEFT OR RIGHT *
	****************************************
	
	moveq	#NB_TARGET_SPRITES-1,d7
1:
	moveq	#0,d0
	move.w	(PREVIOUS_SPRITE_X,a4),d0
	jeq		11f		| x=0: was inactive

	moveq	#0,d2
	move.b	(PREVIOUS_SPRITE_CODE,a4),d2
	tst.b	(a2,d2.w)					| is this sprite a HW sprite?
	jne		11f		| hardware sprite: don't consider
	move.w	(PREVIOUS_SPRITE_Y,a4),d1
	add.w	(PREVIOUS_SPRITE_HEIGHT,a4),d1	| Y bottom for sprite
	cmp.w	#Y_MAX+1,d1
	jcs		11f
	* conflict: sprite probably overwrote tiles: redraw
	* redraw left part if not already done
	tst.b	d4
	jne		11f
	moveq	#0,d3
	* optimize: redraw just the ships, for that we need to
	* know how many lives are left
	move.b	ds_plyr_actv+_b_nships,d3
	jeq		12f			| no more lives, no need to redraw
	cmp.b	#7,d3
	bcs.b	13f
	move.b	#6,d3		| max 6 lives displayed
13:
	addq.w	#2,d3		| take blitter shifting into account
	lsl.w	#4,d3		| 16 pixels per ship, max 6 ships
	cmp.w	d3,d0
	bcc.b	12f
	lea		_custom,a5
	WAIT_BLIT
	* really redraw left part with the ships
	movem.w	d4/d5/d7,-(a7)
	moveq	#0x0014,d7
	move.w	#12-1,d4
	jbsr	redraw_2_rows
	movem.w	(a7)+,d4/d5/d7
	st.b	d4
12:
	lea		_custom,a5
	WAIT_BLIT
	* redraw right part if not already done
	tst.b	d5
	bne.b	11f
	cmp.w	#NB_ROWS*8-112-16,d0
	bcs.b	11f
	* really redraw right part
	exg	d5,d4
	movem.w	d4/d5/d7,-(a7)
	move.w	#0x2,d7
	move.w	#12-1,d4
	jbsr	redraw_2_rows
	movem.w	(a7)+,d4/d5/d7
	* d4 is aleady FF
	st.b	d5

11:
	move.b	d4,d0
	and.b	d5,d0
	bne.b	0f		| both sides redrawn: quit loop
	lea		(PREVIOUS_SPRITE_SIZE,a4),a4
	addq	#CURRENT_SPRITE_SIZE,a0
	dbf		d7,1b
0:
	rts
	
redraw_2_rows:	
	lea		bg_videoram,a5
0:
	move.b	(a5,d7.w),d0		| read video
	cmp.b	#0x24,d0
	beq.b	1f		| nothing here: no need to redraw anything on this column
	move.w	d4,-(a7)
	move.w	d7,-(a7)
	bsr		update_bg_tile
	move.w	(a7),d7
	add.w	#0x20,d7
	move.b	(a5,d7.w),d0		| read video
	bsr		update_bg_tile
	move.w	(a7)+,d7
	move.w	(a7)+,d4
1:
	addq.w	#0x1,d7
	dbf		d4,0b
	rts
	
update_hardware_sprites:
	lea		sfr_sprite_code_8B80,a0

	* clear host sprites
	moveq	#NB_HOST_SPRITES-1,d0
	
	lea		sprite_table,a4
	lea		host_sprites(pc),a2
0:
	clr.b	(SPRITE_X,a2)	| clear X is enough to know it's free
	st.b	(SPRITE_CLUT,a2) | invalid clut
	addq.w	#SPRITE_SIZEOF,a2
	dbf		d0,0b

	* check active sprites, we'll disable the sprites that aren't active anymore
	lea		hardware_sprite_flag_table,a5
	moveq	#NB_TARGET_SPRITES-1,d7
1:
	* code = 0 and clut = 0 => disabled
	moveq	#0,d2
	move.b	(TARGET_SPRITE_CODE,a0),d2
	
	tst.b	(a5,d2.w)		| is that a sprite
	beq.b	2f
	* -1 for ignored bobs
	bmi.b	2f

	* code to check if sprite exists/is "assembled" (feature introduced moon patrol)
*	moveq	#0,d3
*	move.w	d2,d4
*	bclr	#7,d4
*	add.w	d4,d4
*	add.w	d4,d4
*	tst.l	(a4,d4.w)	| test pointer
*	bmi.b	2f			| assembled: skip
*	beq.b	2f			| not a sprite: skip
	
	bsr		compute_sprite_xy
	tst		d0
	beq.b	2f			| X set to 0: not shown
	
	.ifne	SPRITE_Y_CORRECTION
	add.w	#SPRITE_Y_CORRECTION,d1
	.endif
	.ifne	SPRITE_X_CORRECTION
	add.w	#SPRITE_X_CORRECTION,d0
	.endif
	
	move.b	(TARGET_SPRITE_ATTRIBUTES,a0),d3
	and.b	#0x3F,d3	| get attributes

* < D2: sprite code & flags
* < D3: sprite color (clut index)
* > D6: allocated sprite index

	* sprite active: allocate a sprite in host table
	* it HAS to succeed (in Pengo it did, here I'm less sure)
	bsr		alloc_sprite
2:
	addq.w	#CURRENT_SPRITE_SIZE,a0
	dbf		d7,1b
	
	* all sprites are allocated: now display them
	lea		host_sprites(pc),a2		| input structure
	lea		sprites,a3				| copperlist
	moveq	#0,d6
10:
	move.b	(SPRITE_X,a2),d0
	bne.b	20f		
	* slot free: replace sprite by blank
	move.l	#blank_sprite,d4
	move.w	d4,(6,a3)
	swap	d4
	move.w	d4,(2,a3)
	jra		30f
20:
	* lookup sprite code
	
	and.w	#0xFF,d0
	moveq	#0,d1
	move.b	(SPRITE_Y,a2),d1
	moveq	#0,d2
	move.b	(SPRITE_CODE,a2),d2
	bclr	#7,d2
	sne		d5
	move.w	d2,d4
	add.w	d4,d4
	add.w	d4,d4
	move.l	(a4,d4.w),d4	| get pointer
*   filtering of BOBs & attached sprites has been done
*   above, let's trust the values to be valid
	bne.b	25f
	.ifdef	RELEASE
	jra		30f
	.else
	* sprite doesn't exist: blitz and bail out
	blitz
	move.b	d1,d1
	move.b	d2,d2
	.endif
	jra		30f
25:
	
	move.l	d4,a5
	move.w	d6,d4					| add sprite slot
	add.w	d4,d4
	add.w	d4,d4
	move.l	(a5,d4.W),a5			| get buffer for this sprite index
	* now a5 points to a table of 1-4 pointers of variously oriented sprite pics
	* for this slot
	* we'll add 0 to 12 to select the proper orientation depending on the attributes
	moveq	#0,d3
	move.b	(SPRITE_CLUT,a2),d3

	bclr	#7,d3
	beq.b	26f
	addq	#8,a5		| y flip
26:
	tst.b	d5
	beq.b	27f
	addq	#4,a5		| x mirror
27:
	move.l	(a5),d4
	jne		28f
	* orientation not available for that sprite
	move.b	(SPRITE_CLUT,a2),d3
	move.b	(SPRITE_CODE,a2),d2
	move.w	#0x0F0,0xDFF180
	bra		30f
28:

	move.l	d4,a5

	.ifne	SPRITE_Y_CORRECTION
	add.w	#SPRITE_Y_CORRECTION,d1
	.endif
	.ifne	SPRITE_X_CORRECTION
	add.w	#SPRITE_X_CORRECTION,d0
	.endif	

	bsr		store_sprite_pos_16

	move.l	d0,(a5)
	* set colors
	lea		sprite_cluts+2,a6

	lsl.w	#3,d3		| clut times 8

	add.w	d3,a6
	* check if CLUT doesn't contain only color zero
	* (we may as well cache the values in spare registers)
	move.l	(a6)+,d3
	move.w	(a6)+,d7
*	bne.b	24f
*	tst.l	d3
*	bne.b	24f
*	* all black sprites would hide galaga sprites & tiles
*	* we want to hide them instead (no need to change palette)
*	* inherited from pengo, probably not required
*	move.l	#blank_sprite,d4
*	bra.b	25f
*24:
	move.l	a5,d4		| sprite pointer
	* d6 is the sprite index: compute/set proper color
	move.w	d6,d5
	bclr	#0,d5
	lsl.w	#2,d5	| times 4*2
	move.w	d5,d2
	add.w	d2,d2
	lea		sprite_cols+6,a5	| sprite palette + 2 (first color skipped)
	add.w	d2,a5
	* copy 3 colors from cached registers into sprite color copperlist
	move.w	d3,(4,a5)
	swap	d3
	move.w	d3,(a5)
	move.w	d7,(8,a5)
25:
	* set sprite in copperlist
	move.w	d4,(6,a3)
	swap	d4
	move.w	d4,(2,a3)	
30:
	* next sprite
	addq.w	#8,a3		| advance in copperlist
	lea		(SPRITE_SIZEOF,a2),a2
	addq	#1,d6
	cmp.w	#NB_HOST_SPRITES,d6
	jne	10b	
	rts
	
* < A0: sprite table
* > D0,D1: X,Y
compute_sprite_xy:
	moveq	#0,d0
	moveq	#0,d1
	move.b	(TARGET_SPRITE_X_1,a0),d0  | sprite X low (amiga Y)
	sub.w	#40,d0
	move.b	(TARGET_SPRITE_X_2,a0),d1
	and.b	#3,d1		| 3 seems not possible as X would be too big
	lsl.w	#8,d1		| times 0x100
	add.w	d1,d0
	beq		2f
	bpl		3f
2:
	* one of the X,Y coord is zero: zero both and return
	* (makes amiga-side handling much easier)
	moveq	#0,d0
	moveq	#0,d1
	rts
	
3:
	moveq	#0,d1
	move.b	(TARGET_SPRITE_Y,a0),d1  | sprite Y
	beq		2b
	tst		d1
	bmi		2b

	addq	#1,d1		| sprites are buffered and delayed by one scanline
	exg		d0,d1		| display is rotated 90 degrees!
	
	.ifndef	RELEASE
	cmp.w	#0x200,d0
	bcs.b	0f
	cmp.w	#0x200,d1
	bcs.b	0f
	move.l	#sfr_sprite_code_8B80,d0
	sub.l	a0,d0
	lea		coordinates_out_of_range_error(pc),a1
	jbsr	osd_break
	illegal
	
0:
	.endif
	
	rts
	
update_bobs:
	.ifndef	RELEASE
	clr.w	lines_blitted
	clr.w	lines_erased
	clr.w	objects_blitted
	clr.w	objects_erased
	.endif
	
	lea			hardware_sprite_flag_table,a2
	
	move.l		bob_previous_drawed_sprites(pc),a4
	lea		sfr_sprite_code_8B80,a3
	move.l	a3,a0
	
	**********************
	* ERASE THE OLD BOBS *
	**********************
	
	moveq	#NB_TARGET_SPRITES-1,d7
1:
	moveq	#0,d2
	move.w	(PREVIOUS_SPRITE_X,a4),d2
	beq.b	11f		| x=0: was inactive

	* we have to compute current sprite x & y
	bsr		compute_sprite_xy

	cmp.w	d2,d0
	bne.b	12f		| prev x != x: perform erase
	cmp.w	(PREVIOUS_SPRITE_Y,a4),d1
	bne.b	12f		| prev y != y: perform erase
	* previous X and Y and current X Y are the same: compare code
	* (we can ditch d0,d1 from now on)
	moveq	#0,d2
	move.b	(PREVIOUS_SPRITE_CODE,a4),d2
	tst.b	(a2,d2.w)					| is this sprite a HW sprite?
	bne.b	11f		| hardware sprite: no need to restore background either!
	move.b	(TARGET_SPRITE_CODE,a0),d0
	and.b	#0x7F,d0
	cmp.b	d0,d2
	bne.b	12f			| different code: do erase
	* last check: previous vs current color. This happens when a boss is hit
	* if we skip erase at this point, the old boss shadow remains
	move.b	(PREVIOUS_SPRITE_COLOR,a4),d2
	move.b	(TARGET_SPRITE_COLOR,a0),d0
	and.b	#0x3F,d0
	cmp.b	d0,d2
	beq.b	11f			| same X,Y,code and color: skip erase
12:
	move.w	(PREVIOUS_SPRITE_X,a4),d0	
	move.w	(PREVIOUS_SPRITE_Y,a4),d1
	moveq	#0,d2
	move.b	(PREVIOUS_SPRITE_CODE,a4),d2
	
	* clear 16x16 area where the sprite was
	.ifne	SPRITE_Y_CORRECTION
	add.w	#SPRITE_Y_CORRECTION,d1
	.endif
	.ifne	SPRITE_X_CORRECTION
	add.w	#SPRITE_X_CORRECTION,d0
	.endif

	lea		double_size_flag_table,a1
	tst.b	(a1,d2.w)
	beq.b	16f
	* sprites 0x20,0x24,0x28,0x2C are double width/height (ship explosion)
	* double shots (fake code 0x7f) are double width
	* height is set in PREVIOUS_SPRITE_HEIGHT so both cases can be processed here
	move.w	(PREVIOUS_SPRITE_HEIGHT,a4),d4
	bsr		restore_32x_background	
	jra		11f

16:
	move.b	(PREVIOUS_ACTIVE_BITPLANE_MASK,a4),d3	| erase only needed bitplanes
	add.w	(PREVIOUS_Y_START,a4),d1				| add Y start offset
	jpl		13f
	* negative? make it 0 else erase is going to fail
	moveq	#0,d1
13:	
	move.w	(PREVIOUS_SPRITE_HEIGHT,a4),d4
	bsr		restore_16x_background
11:
	lea		(PREVIOUS_SPRITE_SIZE,a4),a4
	addq	#CURRENT_SPRITE_SIZE,a0
	dbf		d7,1b
	
	*********************
	* DRAW THE NEW BOBS *
	*********************
	
	* game takes its source from 3 different tables, indexed the same way!
	* we gathered the tables so they can be accessed with only one address register
	* each table is 128 bytes long (64*2)
		
	move.l	a3,a0
	move.l	bob_previous_drawed_sprites(pc),a6
	moveq	#NB_TARGET_SPRITES-1,d7
1:																	| speedup kludge
						
	bsr		compute_sprite_xy
	move.w	d1,(PREVIOUS_SPRITE_Y,a6)			| store current sprite attributes to previous ones
	move.w	d0,(PREVIOUS_SPRITE_X,a6)			| store current sprite attributes to previous ones
	jeq		211f

	
	moveq	#0,d2
	move.b	(TARGET_SPRITE_CODE,a0),d2
	bclr	#7,d2		| discard last bit
	
	move.b	(TARGET_SPRITE_ATTRIBUTES,a0),d4

	btst	#1,d4		| clear & test X mirror mode (flipx, but screen is rotated)
	sne		d6			| d6 nonzero means we'll use mirrored bob data

	btst	#0,d4
	sne		d5			| d5 nonzero means we'll reverse blit
	
	moveq	#0,d3
	move.b	(TARGET_SPRITE_COLOR,a0),d3
	and.b	#0x3F,d3	| discard high bits
	tst.b	(a2,d2.w)
	jne	211f			| hardware sprite: skip

	* save previous sprite color too
	move.b	d3,(PREVIOUS_SPRITE_COLOR,a6)

	cmp.b	#0x30,d2
	jne		0f
	btst	#3,d4
	jeq		0f
	move.b	#DOUBLE_SHOT_CODE,d2	| change sprite code (special case)
0:
	move.b	d2,(PREVIOUS_SPRITE_CODE,a6)
	move.w	d2,d4
	add.w	d4,d4
	add.w	d4,d4
	lea		bob_table,a4
	move.l	(a4,d4.w),d4	| test pointer
	jmi		211f			| hardware sprite: skip
	bne.b	11f
	.ifndef	RELEASE
	* not known/registered: we should log that!
	move.w	#0xF00,_custom+color
	move.b	d2,d2
	.endif
	jra	211f
11:

	

	* < D2: sprite code & flags
	* < D3: sprite color (clut index)
	and.w	#0xF,d3
	add.w	d3,d3
	add.w	d3,d3
	move.l	a0,-(a7)
	move.l	d4,a0
	move.l	(a0,d3.w),d4
	bne.b	12f
	* bob is valid but wrong clut
	.ifndef	RELEASE
	lsr		#2,d3
	move.l	(a7),a0
	move.w	#0xFF0,_custom+color
	.endif
	jra		22f
12:
	move.l		bg_drawed_screen_ptr(pc),a1
	* D0 and D1 are already set
	move.l	d4,a0	| plane list (+ mask)
	tst.b	d6
	beq.b	13f
	* Y-flip: fetch mirrored planes
	* note that there is no safety: if it's mirrored
	* and mirror isn't declared when creating sprite, the engine
	* will fetch the next bob (pretty visible when testing!!)
	add.w	#(NB_BOBS_PLANES+1)*4+6,a0
	.ifndef RELEASE
	tst.l	(a0)
	bpl.b	13f
	* missing mirror
	move.w	#0x00F,_custom+color
	lsr		#2,d3
	sub.w	#(NB_BOBS_PLANES+1)*4+6,a0
	.endif
13:
	move.l	(NB_BOBS_PLANES*4+6,a0),d3	| mask plane is after bob data
	jeq		22f		| mask is zero: blank tile => skip
	move.l	d3,a3

	.ifne	SPRITE_Y_CORRECTION
	add.w	#SPRITE_Y_CORRECTION,d1
	.endif
	.ifne	SPRITE_X_CORRECTION
	add.w	#SPRITE_X_CORRECTION,d0
	.endif

	move.w	d7,-(a7)

	* normal or double w/h?
	move.w	(a0),d3	| height
	move.w	d3,(PREVIOUS_SPRITE_HEIGHT,a6)
	lea		double_size_flag_table,a5
	tst.b	(a5,d2.w)
	beq.b	16f
	* some explosions are double width/height
	moveq	#0,d2	| no y-clip
	clr.w	(PREVIOUS_Y_START,a6)
	lea		blit_planes_cookie_cut_32x(pc),a4
	bra.b	17f
16:
	add.w	(2,a0),d1	| add Y offset
	move.w	(2,a0),(PREVIOUS_Y_START,a6)
	
	moveq	#0,d2	| no y-clip
	lea		blit_planes_cookie_cut_16x(pc),a4
17:

	* check if bitplanes are zeroed
	* note: only checks 4 bitplanes
	* must be adapted if 5 bitplanes or more!
	.ifne	NB_BOBS_PLANES-4
	.error	"must adapt for nb bitplanes != 4"
	.endif
	st		d7		| default: all bitplanes are to be erased/restored
	tst.l		(6,a0)
	bne.b	503f
	bclr	#0,d7
502:
	tst.l		(4+6,a0)
	bne.b	503f
	bclr	#1,d7
503:
	tst.l		(8+6,a0)
	bne.b	504f
	bclr	#2,d7
504:
	tst.l		(12+6,a0)
	bne.b	505f
	bclr	#3,d7
505:
	move.b	d7,(PREVIOUS_ACTIVE_BITPLANE_MASK,a6)		| store bitplane redraw mask
	tst.b	d5
	bne.b	14f
20:
	addq.w	#6,a0		| skip header
	jsr		(a4)		| start the blit
21:
	move.w	(a7)+,d7
22:
	move.l	(a7)+,a0
211:
	addq	#CURRENT_SPRITE_SIZE,a0
	lea		(PREVIOUS_SPRITE_SIZE,a6),a6		| next previous sprite pos
	dbf		d7,1b
	
	.ifndef	RELEASE
	* write per-frames statistics in zero page
	move.l	lines_blitted,0xF0
	move.l	objects_blitted,0xF4
	.endif

	rts
	* rarer case: blit upside down
14:
	sub.w	(2,a0),d1	| sub Y offset that had been added
	add.w	(4,a0),d1   | add Y rev offset

	move.w	(4,a0),(PREVIOUS_Y_START,a6)

	lea		blit_planes_cookie_cut_16x_flipped(pc),a4
	bra.b	20b


lines_blitted:
	.word	0
lines_erased:
	.word	0
objects_blitted:
	.word	0
objects_erased:
	.word	0

* what: erases the 4 planes used for BOBs
* args:
* < A1: plane pointer
* < D0: X (rounded to smaller 8-multiple)
* < D1: Y
* < D3: bit mask to be able to erase planes or not
* < D4: height

restore_16x_background:
	movem.l	d2/a1/a5,-(a7)
	.ifndef	RELEASE
	add.w	d4,lines_erased
	addq.w	#1,objects_erased
	movem.w	d0/d1,-(a7)
	.endif
	tst.w	d1
	bmi.b	2f
	moveq	#0,d2
	move.l	bg_drawed_screen_ptr(pc),a1
	lea		_custom,a5
0:
	btst	d2,d3
	beq.b	1f
	movem.l	d0-d6/a0-a5,-(a7)
	moveq	#4,d2			| 32 bits blit

	bsr.b	clear_plane_any_blitter_internal
	movem.l	(a7)+,d0-d6/a0-a5
1:
	addq.w	#1,d2
	lea		(BG_SCREEN_PLANE_SIZE,a1),a1
	cmp.w	#NB_BOBS_PLANES,d2
	bne.b	0b
2:
	.ifndef	RELEASE
	movem.w	(a7)+,d0/d1
	.endif
	movem.l	(a7)+,d2/a1/a5
	rts

	
* what: erases the 4 planes used for BOBs
* args:
* < D0: X (rounded to smaller 8-multiple)
* < D1: Y
* < D4: real height
restore_32x_background:
	.ifndef	RELEASE
	movem.l	d0/d1,-(a7)
	add.w	d4,lines_erased
	add.w	d4,lines_erased
	addq.w	#1,objects_erased
	.endif
	tst.w	d1
	bmi.b	0f
	movem.l	d2/d3/d5-d7/a0-a5,-(a7)
	moveq	#6,d2			| 48 bits blit
	move.w	#NB_BOBS_PLANES,d3
	move.l	bg_drawed_screen_ptr(pc),a1
	lea		_custom,a5
	bsr.b	clear_planes_any_blitter_internal
	movem.l	(a7)+,d2/d3/d5-d7/a0-a5
0:
	.ifndef	RELEASE
	movem.l	(a7)+,d0/d1
	.endif
	rts
	
* < A5: custom
* < D0,D1: x,y
* < A1: plane pointer
* < D2: width in bytes (inc. 2 extra for shifting)
* < D4: blit height
* trashes D0-D6
* > A1: even address where blit was done
clear_plane_any_blitter_internal:
	moveq	#1,d3
* < A5: custom
* < D0,D1: x,y
* < A1: foreground plane pointer (often first plane!)
* < D2: width in bytes (inc. 2 extra for shifting)
* < D3: number of planes to clear
* < D4: blit height
* < D7: mask (disabled, -1 set at start)
* trashes D0-D6
clear_planes_any_blitter_internal:
    * pre-compute the maximum of shit here
	move.w	d1,d6
    beq.b   1f    | optim
	* check if y start + height > Y_MAX
	* (ignores case where y = 0, no risk)
	add.w	d4,d6
	sub.w	#Y_MAX,d6
	bmi.b	0f
	* y start + height > Y_MAX: clip height
	sub.w	d6,d4
	beq.b	10f
	bpl.b	0f
10:
	* null or negative height after clipping: out
	rts
0:
    lea mulNB_BYTES_PER_ROW_table(pc),a2
    add.w   d1,d1
    move.w  (a2,d1.w),d1
1:
    move.l  #0x01000000,d5   | minterm useD & rect clear (0xA) 
    move    d0,d6
    beq.b   2f
    MOVEQ #15,D6
    AND.W D0,D6
    and.w   #0x1F0,d0
    lsr.w   #3,d0
    add.w   d0,d1
    LSL.W #8,D6
    LSL.W #4,D6

    swap    d6
    or.l    d6,d5            | add shift
2:   
    add.w   d1,a1       | plane position (always even)

	move.w #NB_BYTES_PER_ROW,d0
    sub.w   d2,d0       | blit width

    lsl.w   #6,d4
    lsr.w   #1,d2
    add.w   d2,d4       | blit height

    * now just wait for blitter ready to write all registers
	WAIT_BLIT
    
	
	move.l d5,bltcon0(a5)	
    move.w  d0,bltdmod(a5)	|D modulo
	
	subq	#1,d3
	jeq		4f
	subq	#1,d3
3:
	CHECK_BLITTER_BOUNDS
	move.l a1,bltdpt(a5)	|destination top left corner
	move.w  d4,bltsize(a5)	|rectangle size, starts blit
	lea		(BG_SCREEN_PLANE_SIZE,a1),a1
	WAIT_BLIT
	dbf		d3,3b
4:
	CHECK_BLITTER_BOUNDS
	move.l a1,bltdpt(a5)	|destination top left corner
	move.w  d4,bltsize(a5)	|rectangle size, starts blit
	
    rts

* y-flipped version
blit_planes_cookie_cut_16x_flipped:
    lea _custom,A5
	move.w	d2,d5
	move.w	d3,d4
	neg.w	d4
	moveq	#NB_BOBS_PLANES,d3
    moveq  #4,d2       | 16 pixels + 2 shift bytes
    jra blit_planes_any_internal_cookie_cut

* what: blits 32x? data on one plane, cookie cut
* args:
* < A0: pointers on 16x? data
* < A1: plane  (40 rows)
* < A2: background (40 rows) to mix with cookie cut
* < A3: source mask for cookie cut (16x16)
* < D0: X
* < D1: Y
* < D2: source y-offset
* < D3: height of data
* trashes: D0-D1
blit_planes_cookie_cut_32x:
	.ifndef	RELEASE
	move.w	d0,last_x_blit
	move.w	d1,last_y_blit
	move.w	d3,last_blit_height
	add.w	d3,lines_blitted
	add.w	d3,lines_blitted
	addq.w	#1,objects_blitted

	.endif
	tst.w	d1
	bpl.b	0f
	rts
0:
    lea _custom,A5
	move.w	d2,d5
	move.w	d3,d4
	moveq	#NB_BOBS_PLANES,d3
    moveq	#6,d2       | 32 pixels + 2 shift bytes
	bra.b	blit_planes_any_internal_cookie_cut
	
* what: blits 16x? data on one plane, cookie cut
* args:
* < A0: pointers on 16x? data
* < A1: plane  (40 rows)
* < A2: background (40 rows) to mix with cookie cut
* < A3: source mask for cookie cut (16x16)
* < D0: X
* < D1: Y
* < D2: source y-offset
* < D3: height of data
* trashes: D0-D1
blit_planes_cookie_cut_16x:
	.ifndef	RELEASE
	move.w	d0,last_x_blit
	move.w	d1,last_y_blit
	move.w	d3,last_blit_height
	add.w	d3,lines_blitted
	addq.w	#1,objects_blitted
	.endif
	tst.w	d1
	bpl.b	0f
	rts
0:
    lea _custom,A5
	move.w	d2,d5
	move.w	d3,d4
	moveq	#NB_BOBS_PLANES,d3
    moveq  #4,d2       | 16 pixels + 2 shift bytes
* < A5: custom
* < D0.W,D1.W: x,y
* < A0: source (pointer on array of planes)
* < A1: destination fg plane, also background to mix with cookie cut fg plane
* < A3: source mask for cookie cut
* < D2: width in bytes (inc. 2 extra for shifting)
* < D3: number of planes
* < D4: height. If negative, source is copied with negative modulo (flip)
* < D5: y offset for source planes
* < D7: blit mask (not considered, optim, -1 all through the game)
* blit mask set
* returns: start of destination in A1 (computed from old A1+X,Y)
* trashes: a1
blit_planes_any_internal_cookie_cut:
    movem.l d0-d7/a2/a4,-(a7)
    * pre-compute the maximum of shit here
	tst.w	d4
	bpl.b	1f
	* inverted y blit
	
	sub.w	d4,d1	| pre-add height to d1
	subq.w	#1,d1	| minus one
1:
	tst	d1
    beq.b   2f    | optim
	cmp.w	#NB_LINES,d1
	jcc		8f			| too low, won't be drawn, may as well optimize
    lea		mulNB_BYTES_PER_ROW_table,a4
	.ifdef	NO68020
	add.w	d1,d1
    move.w  (a4,d1.w),d1	| y times 40
	.else
    move.w  (a4,d1.w*2),d1	| y times 40
	.endif
2:
	move.w	d5,-(a7)
	moveq	#0,d5
    move.w  #0x0fca,d5    | B+C-A->D cookie cut   
	swap	d5
	moveq	#0,d6		| make sure D6.L is zero!!
    move.w  d0,d6
    beq.b   4f
    lsr.w   #3,d0
	bclr	#0,d0
    and.w   #0xF,d6
	beq.b	3f				| if 0 shift, optimize a few instructions
    lsl.l   #8,d6
    lsl.l   #4,d6
    or.w    d6,d5            | add shift to mask (bltcon1)
    swap    d6
    clr.w   d6
    or.l    d6,d5            | add shift
3:   
    add.w   d0,d1
4:
    * make offset even. Blitter will ignore odd address
    * but a 68000 CPU doesn't and since we RETURN A1...
    bclr    #0,d1
    add.w   d1,a1       | plane position (D1 < 0x7FFF, 288*40=0x2D00)
	move.w	#NB_BYTES_PER_ROW,d0
	tst.w	d4
	bpl.b	5f
	neg.w	d0
	neg.w	d4    | make d4 positive again
5:

    sub.w   d2,d0       | blit width
    lsl.w   #6,d4
    lsr.w   #1,d2
    add.w   d2,d4       | blit height
    * always the same settings (ATM)

	* prepare d1
	moveq	#0,d1
	move.w	#0x0BCA,d1
	swap	d1
	or.l	d6,d1

    * now just wait for blitter ready to write all registers
	WAIT_BLIT
    
    * blitter registers set

	clr.w bltamod(a5)		|A modulo=bytes to skip between lines
	clr.w bltbmod(a5)		|B modulo=bytes to skip between lines
	move.l	d5,d7			| save cookie cut bltcon
	move.w	(a7)+,d5
	
    move.w  d0,bltcmod(a5)	|C modulo
    move.w  d0,bltdmod(a5)	|D modulo
					
	add.w	d5,a3			| apply to mask too
	subq	#1,d3
	beq.b	7f
	subq	#1,d3
6:
	jbsr	process_1_plane
	lea		(BG_SCREEN_PLANE_SIZE,a1),a1
	WAIT_BLIT
	dbf		d3,6b
7:
	jbsr	process_1_plane
8:   
    movem.l (a7)+,d0-d7/a2/a4
    rts
	
process_1_plane:
	move.l a3,bltapt(a5)	|  source graphic top left corner (mask)
	move.l (a0)+,d0
	jeq	63f    | do nothing ATM see if it works
	move.l	d0,a4
	add.w	d5,a4
	bra.b	61f
60:
	* source is 0: just apply mask (less bandwidth lost) and change bltcon
	move.l	d1,bltcon0(a5)	| sets con0 and con1: C-A->D cookie cut, B fixed
 	clr.w	bltbdat(a5)	|B word is zero
	bra.b	62f
61:
	* non-zero: set data source & bltcon
	move.l	d7,bltcon0(a5)	| sets con0 and con1: C-A+B->D cookie cut full
	move.l	a4,bltbpt(a5)	|source graphic top left corner
62:
	CHECK_BLITTER_BOUNDS
 	move.l	a1,bltcpt(a5)	|pristine background top (bottom) left corner
	move.l	a1,bltdpt(a5)	|destination top (bottom) left corner
	move.w  d4,bltsize(a5)	|rectangle size, starts blit
63:	
	rts

	
* < D0: sprite X
* < D1: sprite Y
* < D2: sprite code & flags
* < D3: sprite color (clut index, no flip information)
* > D6: allocated sprite index
alloc_sprite:
	* first pass: find a free sprite next to a sprite with
	* same clut
	lea		host_sprites(pc),a2
	moveq	#0,d6
0:
	cmp.b	(SPRITE_CLUT,a2),d3
	bne.b	10f
	* allocated (else would be -1/invalid) + same clut
	* check even/odd index
	btst	#0,d6
	beq.b	1f
	* odd: check if previous entry is free
	tst.b	(SPRITE_X-SPRITE_SIZEOF,a2)
	beq.b	8f
	tst.b	(SPRITE_Y-SPRITE_SIZEOF,a2)
	bne.b	10f
8:
	* previous entry is free, same clut: we can use that
	* entry, no color conflict
	lea		(-SPRITE_SIZEOF,a2),a2
9:
	move.b	d0,(a2)+		| X
	move.b	d1,(a2)+		| Y
	move.b	d2,(a2)+		| code
	move.b	d3,(a2)+		| clut (no flip information)
	rts						| done
1:
	* even: check if next entry is free
	tst.b	(SPRITE_X+SPRITE_SIZEOF,a2)
	beq.b	2f
	tst.b	(SPRITE_Y+SPRITE_SIZEOF,a2)
	bne.b	10f
2:
	* next entry is free, same clut: we can use that
	* entry, no color conflict
	lea		(SPRITE_SIZEOF,a2),a2
	bra.b	9b
10:
	* next entry
	addq.w	#SPRITE_SIZEOF,a2
	addq	#1,d6
	cmp.w	#NB_HOST_SPRITES,d6
	bne.b	0b
	* second pass if first pass failed (could not match
	* a pair with one occupied slot with compatible clut,
	* which happens when there are very few sprites
	* displayed): we have to find 2 consecutive free slots

	lea		host_sprites(pc),a2
	moveq	#0,d6
11:
	* we consider that a sprite is not allocated
	* if one of the coordinates is zero (real game
	* doesn't care and sets X to 255, and Y to 0 at times
	tst.b	(SPRITE_Y,a2)
	beq.b	12f
	tst.b	(SPRITE_X,a2)
	bne.b	20f
12:
	* not allocated: test odd sprite
	tst.b	(SPRITE_Y+SPRITE_SIZEOF,a2)
	jeq	9b
	tst.b	(SPRITE_X+SPRITE_SIZEOF,a2)
	jeq	9b		| ok, both slots are free, allocate the first one
20:
	* next sprite pair
	lea		(2*SPRITE_SIZEOF,a2),a2
	addq	#2,d6
	cmp.w	#NB_HOST_SPRITES,d6
	bne.b	11b
	
	* third pass: last chance/emergency: there ARE free slots
	* but maybe too many different cluts so we can't find a suitable slot.
	* In that case, pick the first free slot
	*
	lea		host_sprites(pc),a2
	moveq	#0,d6
21:
	tst.b	(SPRITE_X,a2)
	beq.b	9b		| ok, a slot is free, allocate it
	tst.b	(SPRITE_Y,a2)
	beq.b	9b		| ok, a slot is free, allocate it
30:
	* next sprite
	lea		(SPRITE_SIZEOF,a2),a2
	addq	#1,d6
	cmp.w	#NB_HOST_SPRITES,d6
	bne.b	21b
	* just cannot happen
	* if we reach that point there's a big problem, break if dev mode
	* hopefully if we save buffer in A1 we can reproduce the issue at will!
	.ifndef	RELEASE
	lea		sfr_sprite_code_8B80,a1
	lea			sprite_allocation_error,a0
	jbsr	osd_break
	.endif
	* in release mode, just discard this sprite, maybe we'll get away with it!
	rts
	


osd_sound_start:
	movem.l	d0-d2/a0-a1/a6,-(a7)
	and.w	#0xFF,d0
	

	move.w	d0,d2
	lsl.w	#3,d0
	lea		sound_table,a0

	move.w	(a0,d0.w),d1	| sound type
	beq.b	0f		| no sound
	lea		_custom,a6
	
	cmp.w	#1,d1
	bne.b	4f		| music module
	
	* override music block for some sounds
	cmp.w	#EXTRA_LIFE_SND,d2
	beq.b	10f
	cmp.w	#CREDIT_SND,d2
	beq.b	10f
	cmp.w	#ATTACK_SND,d2
	beq.b	10f
	
	* don't play if already playing
	* (music_tick value is not important for looped tunes
	* as long as it's not zero)
	tst.w	music_tick
	bne.b	1f
10:
	move.w	(2,a0,d0.w),d1
	move.l	(4,a0,d0.w),a0
	tst.w	d1
	beq.b	3f
	* looped sound

	lea		playing_sounds(pc),a1
	tst.b	(a1,d2.w)
	bne.b	1f				| loop already playing: skipped
	st		(a1,d2.w)
	jsr		_mt_loopfx
	bra.b	1f
3:
	jsr		_mt_playfx
1:
	movem.l	(a7)+,d0-d2/a0-a1/a6
	rts
0:

	bra.b	1b
	* music
4:
	* don't play if game not in play
	* could have been handled at generic galaga.68k level
	* but it's way simpler here. I suppose than the real game
	* just turns music volume off to get away with it
	*tst.b	game_playing_8817
	*beq.b	1b
	
	* play the proper module pattern
	* load up the countdown if loop
	move.w	(2,a0,d0.w),d1	| pattern number in .mod file
	* since it's not zero, next vbl tick will play the music
	cmp.b	music_track_start_number(pc),d1
	beq.b	1b		| same track, skip

    movem.l d0-a6,-(a7)
	bsr		osd_sound_stop
    lea _custom,a6
 	movem.l	d0/a0,-(a7)
    lea	galaga_tunes,a0
	move.b	d1,music_track_start_number
	move.w	d1,d0
    sub.l   a1,a1		| samples are in the module
    jsr _mt_init
	movem.l	(a7)+,d0/a0

    * set master volume a little less loud if needed
	move.b	(6,a0,d0.w),music_volume
	move.b	(7,a0,d0.w),music_loops
	move.w	(2,a0,d0.w),music_pattern	| pattern number in .mod file
	move.w	(4,a0,d0.w),d2

	move.w	d2,music_duration
	move.w	d2,music_tick

    moveq	#0,d0
	move.b	music_volume(pc),d0
    jsr	_mt_mastervol
	st.b	music_playing
    jsr _mt_start
    movem.l (a7)+,d0-a6
	
6:
	jra	1b

7:
	jra	1b

	
osd_loop_stop:
	movem.l	d0/a0/a6,-(a7)
	lea		_custom,a6
	move.w	#3,d0		| channel used by sound loops
	jbsr	_mt_stopfx
	lea		playing_sounds(pc),a0
	* those are no longer playing if they were playing
	clr.b	(CAPTURE_DOWN_SND,a0)
	clr.b	(CAPTURE_UP_SND,a0)
	movem.l	(a7)+,d0/a0/a6
	rts

osd_sound_stop:
	movem.l	d0/a0/a6,-(a7)
	lea		_custom,a6
	move.b	#-1,music_track_start_number
    clr.w   music_tick   | not playing anymore
	clr.b	music_playing
    jsr		_mt_end
	lea		playing_sounds(pc),a0
	move.w	#SND_COUNT/4-1,d0
0:
	clr.l	(a0)+
	dbf		d0,0b
	
	movem.l	(a7)+,d0/a0/a6
	rts
	


switch_screen_buffers:

	.ifne	OPT_ENABLE_DOUBLE_BUFFERING
	* let's switch screen buffers, background (chars)
	* toggle fg planes (double buffering)
	* also toggle previous sprite positions
	lea		bg_drawed_screen_ptr(pc),a0
	lea		bob_previous_positions_1(pc),a2
	lea		bob_previous_positions_2(pc),a3
	lea		bg_screen_data_1,a1
	lea		bg_screen_data_2,a5
	* also switch previous state memory
	cmp.l	(a0),a1
	bne.b	2f
	* screen data 1 is displayed screen
	* set it to drawn screen
	exg		a1,a5
	exg		a2,a3
2:
	move.l	a1,(a0)
	move.l	a5,bg_displayed_screen_ptr
	move.l	a3,bob_previous_displayed_sprites
	move.l	a2,bob_previous_drawed_sprites
	*jbsr		set_4_first_bitplanes
	jbsr	set_bitplanes
	.endif
	
	rts

	
store_system:
	tst.l	_resload
	beq.b	0f
	rts
0:
	* system copper
	
	move.l	4.W,a6
	move.w	AttnFlags(a6),d0
	btst	#AFB_68010,d0
	beq.b	1f
	lea	get_vbr,a5

	jsr		_LVOSupervisor(a6)
	move.l	d0,system_vbr
1:
	pea		2f(pc)	
2:
	move.l	(a7)+,d0
	cmp.l	#0x200000,d0
	bcs.b	3f				| will crawl if no fastmem
	move.w	AttnFlags(a6),d0
	btst	#AFB_68020,d0
	bne.b	1f
3:
	* no whdload, no 68020: assume slow
	* if running on PiStorm, well, too bad use whdload
	st.b	slow_machine
	st.b	half_fps
1:
	lea	_custom,a6
	move.w	intenar(a6),old_intena
	move.w	dmaconr(a6),old_dmacon
	lea		old_sysvectors,a0
	move.l	system_vbr(pc),a1
	move.l	(0x64,a1),(a0)+
	move.l	(0x68,a1),(a0)+
	move.l	(0x6c,a1),(a0)+
	move.l	(0x70,a1),(a0)+
	move.l	(0x74,a1),(a0)+
	move.l	(0x78,a1),(a0)+
	move.l	(0x7C,a1),(a0)+
	rts

restore_system:
	lea	_custom,a6
	jsr		_mt_remove_cia

	move.w	#0x4000,intena(a6)	| ints off
	lea		old_sysvectors,a0
	move.l	system_vbr(pc),a1
	move.l	(a0)+,(0x64,a1)
	move.l	(a0)+,(0x68,a1)
	move.l	(a0)+,(0x6c,a1)
	move.l	(a0)+,(0x70,a1)
	move.l	(a0)+,(0x74,a1)
	move.l	(a0)+,(0x78,a1)
	move.l	(a0)+,(0x7C,a1)


	bclr	#6,0xbfee01


	lea	_custom,a6
	move.w	old_intena,d0			| get old val
	and.w	#0x3fff,d0
	eor.w	#0x3fff,d0
	move.w	d0,intena(a6)		| clr bits
	eor.w	#0x3fff,d0
	or.w	#0xc000,d0		
	move.w	d0,intena(a6)		| set bits and main

	move.w	old_dmacon,d0			| get old val
	and.w	#0x3fff,d0
	eor.w	#0x3fff,d0

***		and.w	#0xfff0,d0		| preserve sound dma for now

	move.w	d0,dmacon(a6)		| clr bits



	eor.w	#0x3fff,d0
	or.w	#0xc000,d0		
	move.w	d0,dmacon(a6)		| set bits and main

	move.l	old_syscoplist,cop1lc(a6)
	move.l	_gfxbase,a6
	move.l	old_actiview,a1
	jsr	_LVOLoadView(a6)


	moveq	#0,d0
	rts

quit_to_os:
	tst.l	_resload
	bne.b	0f
	bsr		restore_system
	* set SR to 0 from here, so we return to OS with SR=0
	* (else it kills the system pretty quickly)
	* it works as quit_to_os is called from an interrupt
	move.w	#0,SR
	move.l	old_stack(pc),a7
	bsr		save_highscores
	moveq	#0,d0
	rts
0:
	pea	  TDREASON_OK
	move.l	_resload(pc),-(a7)
	addq.l	#resload_Abort,(a7)
	rts

platform_init:
	bsr		store_system
	

	lea		_custom,a5
	move.w	#0x7FFF,dmacon(a5)
	move.w	#0x7FFF,intena(a5)
	* set blitter parameters once and for all
    move.l  #-1,bltafwm(a5)
	
	* restrict borders: we don't see bobs on the borders!
	*         VVHH
    move.w #0x1C99,diwstrt(a5)
    move.w #0x3881-8,diwstop(a5)
    move.w #0x0038,ddfstrt(a5)
    move.w #0x00D0,ddfstop(a5)
	* using one extra bitplane for monoplanar chars (letters)
    move.w #0x200+(NB_PLAYFIELD_PLANES<<12)+BORDERBLANK,bplcon0(a5)
    move.w #BASE_BPLCON2_VALUE,bplcon2(a5)
	* AGA-compatible ECS default values
    move.w #0x0C00+BORDERBLANK<<5,bplcon3(a5)     | no AGA specificities, default ECS
    move.w #0x0011,bplcon4(a5)     | ECS default for sprite colors
    move.w #0,fmode(a5)			
    move.w #0,bplcon1(a5)
	move.w	#0,d0
    move.w d0,bpl1mod(a5)
    move.w d0,bpl2mod(a5)

	* read twice to make sure!
	move.w	0xdff07c,d0
	cmp.b	#0xF8,d0		|  AGA (Lisa) is $f8.
	bne.b	0f
	move.w	0xdff07c,d0
	cmp.b	#0xF8,d0		|  AGA (Lisa) is $f8.
	bne.b	0f

	* AGA version
    move.w #3,fmode(a5)			
	move.w	#-8,d0
    move.w d0,bpl1mod(a5)
    move.w d0,bpl2mod(a5)

0:



	* set other sprites to blank
	move.l		#blank_sprite,d0

	moveq	#NB_HOST_SPRITES-1+1,d1   | only 6 sprites are in the list
	lea		sprites,a1
0:
    move.w	d0,(6,a1)
	swap	d0
    move.w	d0,(2,a1)
	swap	d0
	addq.w	#8,a1
	dbf		d1,0b
	
	bsr		set_bitplanes
	
	
	* set copperlist
	move.l	#copperlist,cop1lc(a5)

	* wait 300 lines
	move.w	#100,d0
	bsr	beamdelay
	move.w	#100,d0
	bsr	beamdelay
	move.w	#100,d0
	bsr	beamdelay
	
    * init sprite, bitplane, whatever dma

    move.w #0x83E0,dmacon(a5)
    *move.w #0x20,dmacon(a5)

	* install keyboard and vblank/copper handler
	pea		level2_interrupt(pc)
	move.l	system_vbr(pc),a1
	move.l	(a7)+,(0x68,a1)
	pea		_vblank(pc)
	move.l	(a7)+,(0x6C,a1)
	pea		_nmi(pc)
	move.l	(a7)+,(0x7C,a1)

	* soundfx lib
	lea		_custom,a6
	lea		blank_sound,a0
	move.l	a0,(0xA0,a6)
	move.l	a0,(0xB0,a6)
	move.l	a0,(0xC0,a6)
	move.l	a0,(0xD0,a6)
	move.l	system_vbr(pc),a0
	moveq	#1,d0	| PAL
	jsr		_mt_install_cia

	.ifne	OPT_ENABLE_PROFILING
	* init profiling if enabled
	lea		0x180000,a0
	move.l	#0x20000,d0
	lea		0x100,a1
	bsr		init_fixed_address
	bsr		install_profiler_vbl_hook
	.endif

	
    rts
	
load_palette_in_copperlist:
	movem.l	d0-d1/a0-a1,-(a7)
	lea		palette(pc),a0
	move.w	#TOTAL_NB_COLORS*2,d0
	lea		colors,a1
	bsr		load_palette
	movem.l	(a7)+,d0-d1/a0-a1

	
	rts

	

playing_sounds:
	.skip	SND_COUNT

* < A0: palette
* < A1: copperlist
* < D0: number of colors to load	
load_palette:
	subq.w	#1,d0
	beq.b	2f
1:
	addq.w	#2,a1
	move.w	(a0)+,(a1)+
	dbf		d0,1b
2:
	rts
	

osd_is_vblank_interrupt_enabled:
	move.w	_custom+intenar,d0
	btst	#5,d0			| check vblank interrupt
	rts
	
* < d0: 0 disable interrupts, 1 enable interrupts
osd_interrupt_control:
	tst.b	interrupt_mode
	bne.b	0f				| no interrupt change from within an IRQ
	tst.b	d0
	beq.b	1f
* 60Hz VBLANK interrupt (also keyboard)
osd_enable_interrupts:
	move.w	#0xC038,_custom+intena
0:
	rts
	
1:
	move.w	#0x0030,_custom+intena
	rts



	


* < D4: sprite properties
*     Y code+attrs clut X
* > D0,D1: X,Y.B
* > D5: clut index
* > D6: sprite index + attributes
* 
decode_sprite_data:
	move.b	d4,d1	| sprite X (aka Y on amiga)
	lsr.l	#8,d4
	move.b	d4,d5	| clut index
	lsr.l	#8,d4
	move.b	d4,d6	| sprite index
	lsr.l	#8,d4	
	move.b	d4,d0	| sprite Y (aka X on amiga)
	rts

* d7=screen address (preserved), d0=tile (preserved)
* should preserve all registers

osd_w_videoram:
    .ifeq OPT_DISABLE_BG_LAYER
	movem.l	d0-d7/a0-a3,-(a7)
	

	
	sub.w	#SCREEN_ADDRESS,d7
	bcs.b	0f
	cmp.w	#0x400,d7
	bcs.b	1f
0:
	.ifndef		RELEASE

	* should not happen
	add.w	#SCREEN_ADDRESS,d7
	lea		write_videoram_out_of_range_error(pc),a0
	jbsr	osd_break
	nop	
	.endif
	bra.b	0f
	
1:
	lea		bg_videoram,a1
	add.w	d7,a1
	
	cmp.b	(a1),d0
	beq.b	0f		| already the proper value
3:

	move.b	d0,(a1)	| update logical grid

	st.b	d6		| both buffers
	
	jbsr		update_bg_tile
0:
	movem.l	(a7)+,d0-d7/a0-a3
    .endif | OPT_DISABLE_BG_LAYER
	rts

* d7=screen address (preserved), d0=tile (preserved)
* should preserve all registers

osd_w_colorram:
    .ifeq OPT_DISABLE_BG_LAYER
	movem.l	d0-d7/a0-a4,-(a7)
	
	
	sub.w	#SCREEN_ADDRESS+0x400,d7
	bcs.b	0f
	cmp.w	#0x400,d7
	bcs.b	1f
0:
	.ifndef		RELEASE

	* should not happen
	lea		write_colorram_out_of_range_error(pc),a0
	jbsr	osd_break
	nop	
	.endif
	bra.b	0f
	
1:
	lea		bg_colorram,a1
	add.w	d7,a1
*   we have to force the rewrite
*	cmp.b	(a1),d0
*	beq.b	0f		| already the proper value
*3:
*
	move.b	d0,(a1)	| update logical grid

	jbsr		update_bg_color
0:
	movem.l	(a7)+,d0-d7/a0-a4
    .endif | OPT_DISABLE_BG_LAYER
	rts

compute_tile_xy:
	cmp.w	#0x3C0,d7
	bcc.b	0f
	cmp.w	#0x40,d7
	bcs.b	2f
	
	move.w	d7,d3
	and.w	#0x1F,d3	| this is Y (tile)
	addq	#1,d3
	
	lsr.w	#5,d7		| this is X (tile)
	not.w	d7
	add.w	#0x21,d7
	bra.b	1f
	* two first rows are special
0:
	move.w	d7,d3
	lsr.w	#5,d3		| this is Y
	
	sub.w	#30,d3		| minus 2
	and.w	#0x1F,d7	| this is X
	neg.w	d7
	add.w	#32,d7
	bra.b	1f
	* two last rows as well
2:
	move.w	d7,d3
	lsr.w	#5,d3		| this is Y
	add.w	#33,d3
	and.w	#0x1F,d7	| this is X
	neg.w	d7
	add.w	#32,d7
1:
	rts
	
* d7: screen offset
* d0: tile color code
*

update_bg_color:
	and.w	#0x3F,d0	| mask up to 63
	bsr		compute_tile_xy
	*cmp.w	#(Y_MAX/8)-2,d3
	*jcc		0f				| don't change colors on last rows
	cmp.w	#MAX_ROW_X,d7
	bcc.b	0f				| above 28: ignore
	cmp.w	#2,d7
	bcs.b	0f				| below 2: ignore


	* D3 contains Y row
	lea		bg_color_table(pc),a0
	add.w	d3,d3
	add.w	d3,d3
	move.l	(a0,d3.w),a0
	lea		tile_cluts+2(pc),a1		| skip first color (black)
	lsl.w	#3,d0
	* set color on that row
	move.w	(4,a1,d0.w),(2,a0)
	move.w	(2,a1,d0.w),(6,a0)
	move.w	(a1,d0.w),(10,a0)
0:
	rts
	
* d7: screen offset
* d6: 0: update only drawed plane, 0xFF: both
* d0: tile code
*

update_bg_tile:
	and.w	#0xFF,d0	| mask up to 255

	bsr		compute_tile_xy
	cmp.w	#MAX_ROW_X,d7
	jcc	0f				| above 30: ignore
	cmp.w	#2,d7
	jcs	0f				| below 2: ignore


	lea		mulNB_BYTES_PER_ROW_table(pc),a0


	add.w	d3,d3
	move.w	(a0,d3.w),d3	| times 40
	lsl.w	#3,d3		| times 8
	moveq	#NB_PLAYFIELD_PLANES-1,d4		| 5 bitplanes
	move.w	#BG_SCREEN_PLANE_SIZE,d5
	
	* D3 = Y
	cmp.w	#264*NB_BYTES_PER_ROW,d3
	bcs.b	1100f
	sub.w	#3*NB_BYTES_PER_ROW,d3		| last rows are too low!
1100:

	* we update the drawed bitplanes and also the backbuffer
	* that we use to erase the sprites with
	tst.b	d6
	bne.b	1110f
	move.l	bg_drawed_screen_ptr(pc),a1
	jra		1111f
1110:
	lea		bg_screen_data_1,a1
	lea		bg_screen_data_2,a3
1111:	
	swap	d7
	clr		d7
	swap	d7
	add.w	d3,d7

	add.w	#BG_SCREEN_PLANE_SIZE*NB_BOBS_PLANES,d7  | last plane (5th here) first
	add.l	d7,a1	| long add required!
	.ifne	OPT_ENABLE_DOUBLE_BUFFERING
	add.l	d7,a3
	.endif

	* optimization when a well-known
	* empty character is passed (standard charset)
	cmp.b	#0x24,d0
	jeq	11f

	lea		character_table,a0
	tst.b	d0
	jmi		0f
	add.w	d0,d0
	add.w	d0,d0
	move.l	(a0,d0.w),d0
	jeq	2f
	move.l	d0,a0		| pointer on char plane list (reversed)
	
	tst.b	d6
	jne		4f

	* just copy (current buffer)

3:
	move.l	(a0)+,d0	| pointer on bitplane or 0 or -1
	bmi.b	0f			| -1 encountered, stop copying
	beq.b	31f			| 0 encountered: skip that plane (maybe later we'll need to write 0)
	* positive, non-null: it's a pointer on a bitplane
	move.l	d0,a4
	
	.set	offset,0
	.rept	8
	move.b	(a4)+,d0
	or.b	d0,(offset,a1)	
	.set	offset,offset+NB_BYTES_PER_ROW
	.endr
31:
	sub.w	d5,a1
	dbf		d4,3b
0:
	rts	
	
	
	* just copy (both buffers)
4:
	move.l	(a0)+,d0	| pointer on bitplane or 0 or -1
	bmi.b	0f			| -1 encountered, stop copying
	beq.b	5f			| 0 encountered: skip that plane (maybe later we'll need to write 0)
	* positive, non-null: it's a pointer on a bitplane
	move.l	d0,a4
	
	.set	offset,0
	.rept	8
	move.b	(a4)+,d0
	move.b	d0,(offset,a1)	
	.ifne	OPT_ENABLE_DOUBLE_BUFFERING
	move.b	d0,(offset,a3)
	.endif
	.set	offset,offset+NB_BYTES_PER_ROW
	.endr
5:
	sub.w	d5,a1
	.ifne	OPT_ENABLE_DOUBLE_BUFFERING
	sub.w	d5,a3
	.endif
	dbf		d4,4b
0:
	rts

	
	* clear tile
11:
	tst.b	d6
	jne		111f
110:
	.set	offset,0
	.rept	8
	clr.b	(offset,a1)
	.set	offset,offset+NB_BYTES_PER_ROW
	.endr
	sub.w	d5,a1
	dbf		d4,110b
	rts

111:
	.set	offset,0
	.rept	8
	clr.b	(offset,a1)
	.ifne	OPT_ENABLE_DOUBLE_BUFFERING
	clr.b	(offset,a3)
	.endif
	.set	offset,offset+NB_BYTES_PER_ROW
	.endr
	sub.w	d5,a1
	.ifne	OPT_ENABLE_DOUBLE_BUFFERING
	sub.w	d5,a3
	.endif
	dbf		d4,111b
2:
	rts

12:
	* clut/tile combo not declared as used
	**blitz
	rts

			
store_sprite_pos_16:
	move.l	a1,-(a7)
	lea		HW_SpriteYTable_16,a1
	bsr		store_sprite_pos
	move.l	(a7)+,a1
	rts
store_sprite_pos_32:
	move.l	a1,-(a7)
	lea		HW_SpriteYTable_32,a1
	bsr		store_sprite_pos
	move.l	(a7)+,a1
	rts
	
* < d0.w: x
* < d1.w: y
* < a1: sprite pos table (depending on height)
* > d0.L: control word
store_sprite_pos:
    move.l  a0,-(a7)

    lea	HW_SpriteXTable(pc),a0
	
	.ifdef	NO68020
    add.w	d0,d0
    add.w	d0,d0
    move.l	(a0,d0.w),d0
	move.w	d1,-(a7)
    add.w	d1,d1
    add.w	d1,d1
    or.l	(a1,d1.w),d0
	move.w	(a7)+,d1
	.else
    move.l	(a0,d0.w*4),d0
    or.l	(a1,d1.w*4),d0	
	.endc
    move.l  (a7)+,a0
    rts
	
HW_SpriteXTable:
	.set	reptn,0
	.rept 320
	.set	x,reptn+0x80
	.set reptn,reptn+1
    .byte  0,x>>1,0,x&1
  .endr

	.macro DEF_HW_SPRITE_Y_TABLE	height
HW_SpriteYTable_\height:
  .set	reptn,0
  .rept 288
	.set	ys,reptn+0x1c
	.set	ye,ys+\height
    .byte  ys&255, 0, ye&255, ((ys>>6)&4)+((ye>>7)&2)
	.set	reptn,reptn+1
  .endr
	.endm


	DEF_HW_SPRITE_Y_TABLE	0
	DEF_HW_SPRITE_Y_TABLE	8
	DEF_HW_SPRITE_Y_TABLE	16
	DEF_HW_SPRITE_Y_TABLE	32


set_4_first_bitplanes:
    moveq #NB_PLAYFIELD_PLANES-2,d1
	bra.b	0f

* set_bitplanes
* what: sets bitplanes in copperlist
* sets 6 bitplanes at start even if only 4 are used in the panel
* or it will just be big headaches to compute...
* a small amount of chipmem is wasted for the 2 bitplanes that aren't active
* in the first 48 lines but we're talking about 48*40*2 = 3840 bytes...
* maybe we can use that memory for something at some point.

set_bitplanes:
    moveq #NB_PLAYFIELD_PLANES-1,d1
0:
    move.l	bg_displayed_screen_ptr(pc),a0
	move.l	a0,d0
    lea	panel_bitplanes+2,a0
	moveq	#0,d2
	move.w	#BG_SCREEN_PLANE_SIZE,d2
1:
    swap d0
    move.w d0,(a0)
    swap d0
    move.w d0,(4,a0)    
    addq.w  #8,a0
    add.l d2,d0		| LONG!
    dbf d1,1b

    rts


	

osd_debug_hook:
	rts
	
osd_get_random:
* > D0: pseudo random value (8 bits, all other bits zeroed)
	movem.l	a0,-(a7)
	lea	seed(pc),a0
	move.l	(a0),d0
	* thanks meynaf
	mulu #0xa57b,d0
	addi.l #0xbb40e62d,d0
	rol.l #6,d0	
	move.l	d0,(a0) 
	movem.l	(a7)+,a0
	add.b	_custom+vposr,d0
	and.l	#0xFF,d0
	rts
seed:
	dc.l	0x12345678

	
* d7=screen address
osd_r_videoram:
	movem.l	a0/d7,-(a7)
	sub.w	#SCREEN_ADDRESS,d7
	bmi.b	0f
	cmp.w	#0x400,d7
	bcs.b	1f
0:
	.ifndef		RELEASE
	* should not happen
	lea		read_videoram_out_of_range_error(pc),a0
	jbsr	osd_break
	clr.b	d0
	move.b	D1,d1
	nop
	.endif
	bra.b	2f
1:
	lea		bg_videoram,a0
	move.b	(a0,d7.w),d0
2:
	movem.l	(a7)+,a0/d7
	rts

BIT_LEFT = 3
BIT_RIGHT = 1
BIT_FIRE = 4

* < *A0: number of credits
* < *A0+1: player 1 controls

osd_update_inputs:
	movem.l	a1/d0-d4,-(a7)
	lea		keyboard_table(pc),a1
	move.l	_joypad_state(pc),d1
	move.l	_previous_joypad_state(pc),d2
	st		d0		| active low
	* misc control keys

	tst.b	(5,a1)		| "5" key like in MAME
	beq.b	0f
	bset	#JPB_BTN_REVERSE,d1
0:
	tst.b	(1,a1)		| "1" key like in MAME
	beq.b	0f
	bset	#JPB_BTN_FORWARD,d1
0:
	tst.b	(2,a1)		| "2" key like in MAME
	beq.b	0f
	bset	#JPB_BTN_GRN,d1
0:	


	cmp.b	#3,b8_game_state_9201
	beq.b	2f
	btst	#JPB_BTN_RED,d1
	beq.b	2f
	btst	#JPB_BTN_RED,d2
	bne.b	2f
	* game not in play, accept insert coin with fire	
	bset	#JPB_BTN_REVERSE,d1		| add one credit
2:	
	btst	#JPB_BTN_UP,d1
	beq.b	1f
	btst	#JPB_BTN_UP,d2
	bne.b	1f
	bset	#JPB_BTN_FORWARD,d1		| start 1P game
	

1:
	btst	#JPB_BTN_FORWARD,d1
	beq.b	0f
	btst	#JPB_BTN_FORWARD,d2
	bne.b	0f
	clr		d3
	add.b	d3,d3	| clear X
	move.b	(a0),d3
	beq.b	0f
	moveq	#1,d4
	sbcd	d4,d3		| sub one credit: this starts 1P game
	move.b	d3,(a0)     | as game monitors previous credit count
0:
	* ATM 2P disabled
	.ifne	0
	btst	#JPB_BTN_GRN,d1
	beq.b	0f
	btst	#JPB_BTN_GRN,d2
	bne.b	0f
	clr		d3
	add.b	d3,d3	| clear X
	move.b	(a0),d3
	moveq	#2,d4
	cmp.b	d4,d3
	bcs.b	0f
	sbcd	d4,d3		| sub one credit: this starts 2P game
	move.b	d3,(a0)     | as game monitors previous credit count
0:
	.endif
	
	btst	#JPB_BTN_REVERSE,d1
	beq.b	0f
	btst	#JPB_BTN_REVERSE,d2
	bne.b	0f
	clr		d3
	add.b	d3,d3	| clear X
	move.b	(a0),d3
	moveq	#1,d4
	abcd	d4,d3		| add one credit
	move.b	d3,(a0)
	move.l	d0,-(a7)
	move.w	#CREDIT_SND,d0
	jbsr	osd_sound_start
	move.l	(a7)+,d0
0:
	tst.b	(0x4F,a1)		| "<-" key
	beq.b	0f
	bclr	#BIT_LEFT,d0
0:
	tst.b	(0x4E,a1)		| "->" key
	beq.b	0f
	bclr	#BIT_RIGHT,d0
0:
	tst.b	(0x63,a1)		| "ctrl" key
	beq.b	0f
	bset	#JPB_BTN_RED,d1		| previous inputs
	bra.b	1f
0:
	btst	#JPB_BTN_RED,d1
	beq.b	0f
1:
	btst	#JPB_BTN_RED,d2
	bne.b	0f			        | debounce
	bclr	#BIT_FIRE,d0
0:
	btst	#JPB_BTN_LEFT,d1
	beq.b	0f
	bclr	#BIT_LEFT,d0
0:
	btst	#JPB_BTN_RIGHT,d1
	beq.b	0f
	bclr	#BIT_RIGHT,d0
0:
	
	move.b	d0,(1,a0)
	
	move.l	d1,_previous_joypad_state
	
	movem.l	(a7)+,a1/d0-d4
	rts
	
	
	
osd_read_dsw_1:
	move.b	#3,d0

	rts

osd_read_dsw_2:
*    0x00  = 0 -> A (MEDIUM)
*    0x01  = 1 -> C (HARD)
*    0x02  = 2 -> D (HARDEST)
*    0x03  = 3 -> A (EASY)

	moveq	#3,d0
	rts
	
osd_read_dsw_3:
	moveq	#0,d0
	rts
	

	
osd_read_dsw_6:
	moveq	#0,d0
	rts



osd_read_nb_fighters:
	move.l	dip_switch_start_lives,d0
	move.l	a0,-(a7)
	lea		start_lives_table(pc),a0
	move.b	(a0,d0.w),d0
	move.l	(a7)+,a0
	rts
	
start_lives_table:
	.byte	3-1,2-1,4-1,5-1
	

		
osd_read_high_scores:
	movem.l	d0-d7/a0-a6,-(a7)
	move.l	a0,a4
	move.l	_resload(pc),d0
	beq.b	0f
	move.l	d0,a2
	bsr		get_hiscore_name
 	jsr		resload_GetFileSize(a2)		
	tst.l	d0
	beq.b	2f
	bsr		get_hiscore_name
	lea	b_best5_score_8a20,a1
	jsr		resload_LoadFile(a2)		
	bra.b	1f
0:
	tst.b	highscore_loaded
	beq.b	2f
	* from DOS: just copy buffer
	lea		high_score_buffer(pc),a1
	move.w	#SCORE_FILE_SIZE-1,d0
0:
    move.b    (a1)+,(a4)+
	dbf		d0,0b
1:
	* need to update screen 83ED-
	lea		b_best5_score1,a0
	move.w	#0x83F2-5,d7
	moveq	#5,d1
10:
	move.b	(a0)+,d0
	jbsr	osd_w_videoram
	addq.w	#1,d7
	dbf		d1,10b
2:
	movem.l	(a7)+,d0-d7/a0-a6
	rts
	
osd_write_high_scores:
	movem.l	d0-d7/a0-a6,-(a7)
	.ifdef	RELEASE
	tst.b	cheat_used		| don't save score if cheat on
	bne.b	1f
	.endif
	
	move.l	_resload(pc),d0
	beq.b	0f
	move.l	d0,a2
	move.l	#SCORE_FILE_SIZE,d0
	lea		b_best5_score_8a20,a1
	bsr		get_hiscore_name
	jsr		resload_SaveFile(a2)
	bra.b	1f
0:
	* from DOS: just copy buffer
	lea		high_score_buffer(pc),a1
	move.w	#SCORE_FILE_SIZE-1,d0
0:
	move.b	(a0)+,(a1)+
	dbf		d0,0b

	st.b	highscore_needs_saving
1:
	movem.l	(a7)+,d0-d7/a0-a6
	rts


level2_interrupt:
	bsr		handle_keyboard
	move.w	#8,_custom+intreq
	rte
	
handle_keyboard:
	movem.l	D0/A0/A5,-(a7)
	LEA	0x00BFD000,A5
	MOVEQ	#0x08,D0
	AND.B	0x1D01(A5),D0
	jeq		1f
	MOVE.B	0x1C01(A5),D0
	NOT.B	D0
	ROR.B	#1,D0		| raw key code here
  
	CLR.B	0x1C01(A5)
  
    lea keyboard_table(pc),a0
    bclr    #7,d0
    seq (a0,d0.w)       | updates keyboard table
    jne   2f     | we don't care about key release
	
    cmp.b   #0x19,d0	| "P" key
    bne.b   0f

    bsr	toggle_pause
0:
	cmp.b	#0x10,d0	| "Q" key (US)
	bne.b	0f
	* game over, no lives + kill mario
	nop
	*clr.b	mario_array_6200
	*move.b	#1,number_of_lives_remaining_6228
0:

	btst	#4,cheat_flags+3
	jeq		10f
	* cheat keys
	cmp.b	#0x50,d0	| F1 key
	bne.b	0f
	move.w	#0x0FF,_custom+color
	eor.b	#1,invincible_flag
	st.b	cheat_used
	
0:
	cmp.b	#0x51,d0	| F2 key
	bne.b	0f
	st.b	cheat_used
	* give double shot
	move.w	#0x0FF,_custom+color
	move.b	#1,ds_plyr_actv+_b_2ship

	
0:
	cmp.b	#0x52,d0	| F3 key
	bne.b	0f
	st.b	cheat_used
	* add 10000+ points
	movem.w	d0/d1,-(a7)
	move.b	#0x90,ds_bug_collsn_hit_mult_9290+1
	movem.w	(a7)+,d0/d1
0:
*	cmp.b	#0x53,d0	| F4 key
*	bne.b	0f
*	st.b	cheat_used
*	* no more enemies => goto next level
*	move.w	#0x0FF,_custom+color
*	clr.b	b_bugs_actv_nbr
*0:
0:
*	cmp.b	#0x54,d0	| F5 key
*	bne.b	0f
*	st.b	cheat_used
*	move.w	#0x0FF,_custom+color
*0:

10:
	.ifndef	RELEASE
	* cheat but not very rewarding as it kills all lives
	cmp.b	#0x57,d0	| F8 key
	bne.b	0f
	clr.b	ds_plyr_actv+_b_nships
	clr.b	invincible_flag
	move.w	#0x0FF,_custom+color
0:
	cmp.b	#0x58,d0	| F9 key crashes game (restarts whdload)
	bne.b	0f
	illegal
	.endif
0:

	cmp.b	_keyexit,d0	| "ESC" key or whdload quitkey
	bne.b	2f
	BSET	#0x06,0x1E01(A5)
	moveq	#2,d0
	bsr	beamdelay
	BCLR	#0x06,0x1E01(A5)	| acknowledge key
	bra		quit_to_os
2:
	BSET	#0x06,0x1E01(A5)
	moveq	#2,d0
	bsr	beamdelay
	BCLR	#0x06,0x1E01(A5)	| acknowledge key

1:
	movem.l	(a7)+,d0/a0/a5
	rts
	
toggle_pause:
	* pause only within game
*	tst.b	gameplay_allowed_6054
*	beq.b	0f
*	tst.b	check_scenery_disabled_61ED
*	bne.b	0f
*	tst.b	game_locked_6053
*	bne.b	0f
	eor.b   #1,pause_flag
0:
	rts
	
    
* < D0: numbers of vertical positions to wait
beamdelay:
0:
	move.w  d0,-(a7)
    move.b	0xdff006,d0	| VPOS
1:
	cmp.b	0xdff006,d0
	beq.s	1b
	move.w	(a7)+,d0
	dbf	d0,0b
	rts

	* add 16 to account for reverted Y blit
	MUL_TABLE	NB_BYTES_PER_ROW,288+16


	.align	4		| leave this long word alignment
program_args:	ds.l	64,0
program_args_end:
	.long	0		| add a longword else it overwrites the read args string in kick 1.3!
	.align	4
read_args_string:
	.byte	read_args_string_end-read_args_string
	.ascii	"INVINCIBLE/S,INFLIVES/S,PERFECT/S,"
	.ascii	"CHEATKEYS/S,STARTLIVES/K/N,STARTLEVEL/K/N"
read_args_string_end:
	.align	2


* 8 slots (indexed with the target sprite index, not
* the amiga sprite index) with
* - 4 bytes for the sprite actual address
* - 2 bytes amiga sprite index
* - 2 bytes??
hw_sprite_slots:
	ds.b	8*8
* 8 slots (indexed with the amiga sprite index)
amiga_sprite_slots:
	ds.b	8

	.ifndef	RELEASE
blitter_address_too_low_error:
	.asciz	"blitter address too low, a0=offset, a2=screen addr, D1=screen size"
blitter_address_too_high_error:
	.asciz	"blitter address too high, a0=offset, a2=screen addr, D1=screen size"
coordinates_out_of_range_error:
	.asciz	"coordinates out of range, offset in d0, base in a0"
sprite_allocation_error:
	.asciz	"sprite allocation error"
sprite_doesnt_exist_error:
	.asciz	"sprite doesn't exist"
read_videoram_out_of_range_error:
	.asciz	"read videoram out of range"
write_videoram_out_of_range_error:
	.asciz	"write videoram out of range"
write_colorram_out_of_range_error:
	.asciz	"write colorram out of range"
	.align	2

last_x_blit:
	.word	0
last_y_blit:
	.word	0
last_blit_height:
	.word	0
	.endif


old_intena:
	.long	0
old_dmacon:
	.long	0
old_sysvectors:
	ds.l	10
old_vbr:
	.long	0
old_syscoplist:
	.long	0
old_actiview:
	.long	0
old_stack:
	.long	0
slow_machine:
	.word	0
half_fps:
	.word	0
palette_number:
	.word	0
four_barrels_drawn:
	.byte	0
four_barrels_present:
	.byte	0
climbing_kong_present:
	.byte	0
skip_screen_update:
	.byte	0
	
	.align	2	
_tag:
		.long	WHDLTAG_CUSTOM1_GET
cheat_flags:
		.long	0
		.long	WHDLTAG_CUSTOM2_GET
		.long	0
		.long	WHDLTAG_CUSTOM3_GET
misc_options:
		.long	0
		.long	WHDLTAG_CUSTOM4_GET
start_level_option:
		.long	0
		.long	WHDLTAG_CUSTOM5_GET
dip_switch_start_lives:
		.long	0
	.long	0
dip_switches:
		.byte	0x0
		.byte	0

system_vbr:
	.long	0

	
temp_copper_buffer:
	ds.w	3
stars_copper_pointers_count:
	.word	0
enable_star_scroll:
	.word	0
stars_copper_row_pointers:
	ds.l	NB_LINES+32
	
high_score_buffer:
	ds.b	SCORE_FILE_SIZE

highscore_needs_saving:
	.byte	0
highscore_loaded:
	.byte	0
flip_flop:
	.byte	0
music_track_start_number:
	.byte	-1
	.align	2

host_sprites:
	ds.b	8*SPRITE_SIZEOF
keyboard_table:
	ds.b	0x100

interrupt_mode:
	.word	0
	
pause_flag:
	.word	0

	* sound variables
music_duration:
	.word	0
music_pattern:
	.word	0
music_tick:
	.word	0
intro_music_counter:
	.word	0
vbl_counter:
	.word	0
_resload:
	.long	0
_joypad_state:
	.long	0
_previous_joypad_state:
	.long	0
_gfxbase:
	.long	0
_dosbase:
	.long	0
delay_timer:
	.word	0
one_out_of_five:
	.word	0
bg_drawed_screen_ptr:
	.long	bg_screen_data_1
bg_displayed_screen_ptr:
	.ifne	OPT_ENABLE_DOUBLE_BUFFERING
	.long	bg_screen_data_2
	.else
	.long	bg_screen_data_1
	.endif


	.include	"sound_entries.68k"


	

previous_random:
	.long	0	
_keyexit:
	.byte	0x45	| ESC by default unless whdload overwrites it
music_loops:
	.byte	0
music_volume:
	.byte	0
music_playing:
	.byte	0
music_muted:
	.byte	0
dynamic_color_mode:
	.byte	0

cheat_used:
	.byte	0
dosname:
	.ascii	"dos.library"
	.byte	0
graphicsname:
	.ascii	"graphics.library"
	.byte	0
normal_hiscorename:
	.asciz	"galaga.high"
floppy_file:
	.ascii	"floppy"
	.byte	0
temp_filename_buffer:
	ds.b	255
_end_of_ng_code:
		
	.align 2

* 32 rows = 256 pixels
* table of the colors for fg tiles in the copperlist
	.set	row_offset,0
bg_color_table:
	.rept	28
	.long	color_row_0+row_offset
	* warning: this offset increase depends on what's in color_row_0
	* 16=4 colors to change, 32 bytes per star pattern * 8 patterns per row
	.set	row_offset,row_offset+copper_8x8_row_size
	.endr
	.long	color_row_28
	.long	color_row_29
	.set	row_offset,0
	.rept	4
	.long	color_row_29_plus+row_offset
	.set	row_offset,row_offset+copper_8x8_row_size
	.endr


	
bob_previous_positions_1:
	ds.b	NB_TARGET_SPRITES*PREVIOUS_SPRITE_SIZE
bob_previous_drawed_sprites:
	.long	bob_previous_positions_1
bob_previous_displayed_sprites:
	.ifeq	OPT_ENABLE_DOUBLE_BUFFERING
	.long	bob_previous_positions_1
	.else
	.long	bob_previous_positions_2	
bob_previous_positions_2:
	ds.b	NB_TARGET_SPRITES*PREVIOUS_SPRITE_SIZE	
	.endif
	
	
start_levels_whd:
	.byte	1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20
	.byte	30,40,50,60,70,80,90,100,200,255
	* everything above will go level 1
	.byte	1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1
	.byte	1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1
	.byte	1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1
	.align	2

	
* generated by assets/generate_star_colors.py, copied from galaxian port


stars_palette_rgb4:
	.word	0x0000,0x000d,0x000c,0x000f,0x00d0,0x00dd,0x00dc,0x00df
	.word	0x00c0,0x00cd,0x00cc,0x00cf,0x00f0,0x00fd,0x00fc,0x00ff
	.word	0x0d00,0x0d0d,0x0d0c,0x0d0f,0x0dd0,0x0ddd,0x0ddc,0x0ddf
	.word	0x0dc0,0x0dcd,0x0dcc,0x0dcf,0x0df0,0x0dfd,0x0dfc,0x0dff
	.word	0x0c00,0x0c0d,0x0c0c,0x0c0f,0x0cd0,0x0cdd,0x0cdc,0x0cdf
	.word	0x0cc0,0x0ccd,0x0ccc,0x0ccf,0x0cf0,0x0cfd,0x0cfc,0x0cff
	.word	0x0f00,0x0f0d,0x0f0c,0x0f0f,0x0fd0,0x0fdd,0x0fdc,0x0fdf
	.word	0x0fc0,0x0fcd,0x0fcc,0x0fcf,0x0ff0,0x0ffd,0x0ffc,0x0fff


palette:
	.include "palette.68k"

	* hardware sprites "individual" 4-color palettes
sprite_cluts:
	**.include "sprite_cluts.68k"
	* tiles "individual" 4-color palettes
tile_cluts:
	.include "tile_cluts.68k"
	
	* on amiga, this file is included in galaga.68k file
	* so the assembler can optimize by using PC-relative addressing
	* whenever possible (and it does)
	.ifndef	RELEASE
	* easier to debug game to have memory aligned on 0x10000
	.align	0x10000

	.ifne	OPT_ENABLE_LOGGING
	.section	.bss
	.ascii	"TILE"
tile_log_table:
	* 32 cluts, 1024 tiles
	* a lot of combinations aren't used (fortunately!)
	ds.w	0x10000
	.endif
	.endif
	.ascii	"CODE_END"


	.section	.datachip
	
.macro	DECL_BITPLANES	bpoff_start,nb_planes
	.set	bpoff,\bpoff_start
	.rept	\nb_planes
	dc.w  0xe0+bpoff,0
	dc.w  0xe2+bpoff,0
	.set	bpoff,bpoff+4
	.endr
	.endm

.macro	DECL_COLORS	offset,nb_colors
	.set	colidx,\offset
	.rept	\nb_colors
	dc.w	color+(colidx*2),0
	.set	colidx,colidx+1
	.endr
	.endm

	
blank_sound:
	ds.l	4
	
debug_copperlist:
	dc.w	color
debug_color:
	dc.w	0
	dc.l	-2
	
blank_sprite:
	.rept	32
	.long	0
	.endr
	
	.macro STAR_COPPER_ROW
    * we use sprite #7 (last) for the stars, multiplexing it
	.word	STAR_SPRITE_COLOR_REG,0xF00	   | 4
    .word    spr+sd_SIZEOF*STAR_SPRITE_INDEX+sd_pos,0   | 8
    .word    spr+sd_SIZEOF*STAR_SPRITE_INDEX+sd_ctl,0   | 12
	* sprite pattern
    .word    spr+sd_SIZEOF*STAR_SPRITE_INDEX+sd_dataB,0x0000	| 16
    .word    spr+sd_SIZEOF*STAR_SPRITE_INDEX+sd_dataa,0x8000	| 20
	.word	beampos,0xFFFE              | 24
    .word    spr+sd_SIZEOF*STAR_SPRITE_INDEX+sd_dataB,0	| 28
    .word    spr+sd_SIZEOF*STAR_SPRITE_INDEX+sd_dataa,0	| 32	
	
	.endm

start_color = color+32
default_color_1 = 0x0F00
default_color_2 = 0x0F0
default_color_3 = 0x0F

	* ATM sprite colors are out of copperlist
	
	* main copperlist
copperlist:
    *.word   0x1801,0xFFFE


panel_bitplanes:
	DECL_BITPLANES	0,NB_PLAYFIELD_PLANES
colors:
	DECL_COLORS	0,TOTAL_NB_COLORS
sprite_cols:
	DECL_COLORS	16,16
sprites:
    * #0
    .word    sprpt+0,0
    .word    sprpt+2,0
    * #1
    .word    sprpt+4,0
    .word    sprpt+6,0
    * #2
    .word    sprpt+8,0
    .word    sprpt+10,0
    * #3
    .word    sprpt+12,0
    .word    sprpt+14,0   
    * #4
    .word    sprpt+16,0
    .word    sprpt+18,0
    * #5
    .word    sprpt+20,0
    .word    sprpt+22,0
    * #6
    .word    sprpt+24,0
    .word    sprpt+26,0
	* 2 last sprites cannot be used
	
 	.set    beampos,0x1C01	| first displayed row
	.word	beampos,0xFFFE
color_row_0:
	.rept	28
	* set 4 colors for that 8-high row: 16 bytes
	.word	start_color,default_color_1
	.word	start_color+8,default_color_2
	.word	start_color+16,default_color_3   
	* set sprite slots for stars: 32*8 bytes
	.rept	8
	.set	beampos,beampos+0x100
	STAR_COPPER_ROW
	.endr
	.endr
color_row_28:
	.word	start_color,default_color_1 
	.word	start_color+8,default_color_2 
	.word	start_color+16,default_color_3     
	.rept	3
	.set	beampos,beampos+0x100
	STAR_COPPER_ROW
	.endr

	* pal limit
    .word  0xFFDF,0xFFFE       | PAL wait (should be 0xFFDF but probably fmode=3 changes it)
    .word  0x0401,0xFFFE

	.set    beampos,0x0401
    .word   beampos,0xFFFE	
	
color_row_29:
	.word	start_color,default_color_1
	.word	start_color+8,default_color_2  
	.word	start_color+16,default_color_3  
	.rept	8
	.set	beampos,beampos+0x100
	STAR_COPPER_ROW
	.endr
	
	.set    beampos,0x0c01
	
color_row_29_plus:
	.rept	4
	.word	start_color,default_color_1 
	.word	start_color+8,default_color_2
	.word	start_color+16,default_color_3
	.rept	8
	.set	beampos,beampos+0x100
	STAR_COPPER_ROW
	.endr
	.endr

    .word	 intreq,0x8010	| no bobs from now on, get more drawing time
	
    .long    -2					
	.ascii	"ENDCPLST"

	* aligning on 8 bytes so .align will work
	* in the next datachip sections
	.align	8
	
		.section .bsschip
bg_screen_data_1:
	ds.b	BG_SCREEN_SIZE
	ds.b	NB_BYTES_PER_ROW*16*NB_BOBS_PLANES
	.ifne  OPT_ENABLE_DOUBLE_BUFFERING
bg_screen_data_2:
	ds.b	BG_SCREEN_SIZE
	ds.b	NB_BYTES_PER_ROW*16*NB_BOBS_PLANES
	.endif
	.align	8

		