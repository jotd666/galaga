	* read register to var, little endian
	.macro	MOVE_TO_VAR	reg,var
	move.b	\reg,\var
	ror.w	#8,\reg
	move.b	\reg,\var+1
	ror.w	#8,\reg	
	.endm
	
	* read var to register, little endian
	.macro	MOVE_TO_REG	var,reg
	move.b	\var+1,\reg	
	ror.w	#8,\reg
	move.b	\var,\reg
	.endm
	
	.macro CLEAR_XC_FLAGS
	move.w	d7,-(a7)
	moveq	#0,d7
	roxl.b	#1,d7
	movem.w	(a7)+,d7
	.endm
	.macro SET_XC_FLAGS
	move.w	d7,-(a7)
	st	d7
	roxl.b	#1,d7
	movem.w	(a7)+,d7
	.endm
	.macro	INVERT_XC_FLAGS
	jcs	0f
	SET_XC_FLAGS
	bra.b	1f
0:
	CLEAR_XC_FLAGS
1:
	.endm
	.macro	SET_X_FROM_C
	jcc	0f
	SET_XC_FLAGS
	bra.b	1f
0:
	CLEAR_XC_FLAGS
1:
	.endm
	.macro	SET_C_FROM_X
	move.w	d7,-(a7)
	roxl.b	#1,d7
	roxr.b	#1,d7
	movem.w	(a7)+,d7
	.endm
	
	.macro	SET_C_FROM_X
	move.w	d7,-(a7)
	roxl.b	#1,d7
	roxr.b	#1,d7
	movem.w	(a7)+,d7
    .endm


	.macro	LOAD_D1_16_FROM_D1D2
	and.l	#0xFFFF,d1
	lsl.w	#8,d1
	move.b	d2,d1
	.endm
	
	.macro	LOAD_D3_16_FROM_D3D4
	and.l	#0xFFFF,d3
	lsl.w	#8,d3
	move.b	d4,d3
	.endm
	.macro	LOAD_D5_16_FROM_D5D6
	and.l	#0xFFFF,d5
	lsl.w	#8,d5
	move.b	d6,d5
	.endm
	.macro	LOAD_D1D2_FROM_D1_16
	move.b	d1,d2
	lsr.w	#8,d1
	.endm
	.macro	LOAD_D5D6_FROM_D5_16
	move.b	d5,d6
	lsr.w	#8,d5
	.endm
	.macro	LOAD_D3D4_FROM_D3_16
	move.b	d3,d4
	lsr.w	#8,d3
	.endm

	
* input file game_ctrl.s
*
* game_ctrl.s:
*  gg1-1.3p 'maincpu' (Z80)
*
*  Manage high-level game control.
*
*  j_Game_init_02d3:
*      One time entry from power-up routines.
*  g_main:
*      Initializes game state. Starts with Title Screen, or "Press Start"
*      screen if credit available.
*  plyr_respawn_splsh:
*      Sets up each new stage.
*  jp_045E_While_Game_Run:
*      Continous loop once the game is started, until gameover.
*
*  The possible modes of operation are (from the Bally Manual):
*    ATTRACT, READY-TO-PLAY, PLAY, HIGH SCORE INITIAL, and SELF-TEST."
*
*




*=============================================================================
* por_inits()
*  Description:
*   Once per poweron/reset (following hardware inits) do inits for screen and
*   etc. prior to invoking "main".
* IN:
*  ...
* OUT:
*  ...
*-----------------------------------------------------------------------------
j_Game_init_02d3:
	lea	ds_stk_cpu0_init,a7  | [ld   sp,#ds_stk_cpu0_init]

*  memset(ds4_game_tmrs,0,4)
	clr.b	d0                               	| [xor  a]
	lea	ds4_game_tmrs(pc),a0             	| [ld   hl,#ds4_game_tmrs + 0] memset(...,0,4)
	move.b	#4,d1                           	| [ld   b,#4]
	jbsr	rst_18                            	| [rst  0x18] memset((HL), A=fill, B=ct)

*  memset($9aa0,0,$20)
	lea	ds_9AA0(pc),a0                     	| [ld   hl,#ds_9AA0] memset(...,0,$20) ... count/enable registers for sound effects
	move.b	#0x20,d1                        	| [ld   b,#0x20]
	jbsr	rst_18                            	| [rst  0x18] memset((HL), A=fill, B=ct)

	*move.b	d0,0xA007                       	| [ld   (0xA007),a] 0 (not_flipped)
	move.b	d0,b_9215_flip_screen           	| [ld   (b_9215_flip_screen),a] 0 (not_flipped)
	move.b	d0,ds_99B9_star_ctrl+0          	| [ld   (ds_99B9_star_ctrl + 0),a] 0 ...1 when ship on screen

* memset($92ca,$ff,$10) ... bmbr_boss_slots[] is only 12 bytes, so this initialization would
* include b_CPU1_in_progress + b_CPU2_in_progress + 2 unused bytes
	subq.b	#1,d0                           	| [dec  a] = $FF
	lea	bmbr_boss_pool(pc),a0              	| [ld   hl,#bmbr_boss_pool] memset( ... , $FF, $10 )
	move.b	#0x10,d1                        	| [ld   b,#0x10]
	jbsr	rst_18                            	| [rst  0x18] memset((HL), A=fill, B=ct)

* galaga_interrupt_enable_1_w  seems to already be set, but we make sure anyway.
	move.b	#1,d0                           	| [ld   a,#1]
	move.b	d0,_sfr_6820                    	| [ld   (_sfr_6820),a] 1 ,,,enable IRQ1

* The test grid is now cleared from screen. Due to odd organization of tile ram
* it is done in 3 steps. 1 grid row is cleared from top and bottom (each grid
* row is 2 tile rows). Then, there is a utility function to clear the actual
* playfield area.

*  memset($83c0,$24,$40)
	move.w	#0x83C0,a0           	| $02F8: [ld   hl,#0x8000 + 0x03C0] clear top 2 tile rows ($40 bytes)
	move.b	#0x40,d1                        	| [ld   b,#0x40]
	move.b	#0x24,d0                        	| [ld   a,#0x24] "space" character
	jbsr	rst_18_video                            	| [rst  0x18] memset((HL), A=fill, B=ct)

*  memset($8000,$24,$40)
	move.w	#0x8000,a0                   	| [ld   h,#>0x8000] clear bottom 2 tile rows ($40 bytes)
	move.b	#0x40,d1                        	| [ld   b,#0x40]
	jbsr	rst_18_video                            	| [rst  0x18] memset((HL), A=fill, B=ct)

*  memset($8400,$03,$40)
	move.w	#0x8000,a0                 	| [ld   hl,#m_color_ram] $40 bytes (code 03)
	move.b	#0x40,d1                        	| [ld   b,#0x40]
	move.b	#0x03,d0                        	| [ld   a,#0x03]
	jbsr	rst_18_color                            	| [rst  0x18] memset((HL), A=fill, B=ct)

	jbsr	c_sctrl_playfld_clr               	| [call c_sctrl_playfld_clr] clear remainder of grid pattern from the playfield tiles (14x16)
* all tile ram is now wiped

* Sets up "Heroes" screen
	lea	b_best5_score(pc),a1               	| [ld   de,#b_best5_score] 1st score (100000's)
	move.b	#5,d0                           	| [ld   a,#5]
	clr.b	d1                               	| [ld   b,#0]
l_0317:
	lea	d_str20000(pc),a0                  	| [ld   hl,#d_str20000] "00002 " (20000 reversed)
	move.w	#0x0600,d1                        	| [ld   c,#0x06]
	jbsr	ldir                              	| [ldir]
 	subq.b	#1,d0                           	| [dec  a]
	jne	l_0317                             	| [jr   nz,l_0317]

	lea	d_strScore(pc),a0                  	| [ld   hl,#d_strScore] "SCORE" (reversed)
	move.b	#0x2A,d0                        	| [ld   a,#0x2A] period character '.'
	move.w	#0x05FF,d1                        	| [ld   b,#0x05]
												| [ld   c,#0xFF]
* de==8a3e
l_032A:
	jbsr	ldi                               	| [ldi]
	subq.w	#1,a0                           	| [dec  hl]
	move.b	d0,(a1)+                         	| [ld   (de),a]
												| [inc  e]
	jbsr	ldi                               	| [ldi]
	subq.b	#1,d1                           	| [...]
	jne	l_032A                             	| [djnz l_032A]

* initialize game state
	move.b	#0x01,d0                        	| [ld   a,#0x01]
	move.b	d0,b8_9201_game_state           	| [ld   (b8_9201_game_state),a] 1 == ATTRACT_MODE

	*lea	l_A005(pc),a0                      	| [ld   hl,#0xA005] star_ctrl_port_bit6 -> 0, then 1
	*clr.b	(a0)                             	| [ld   (hl),#0]
	*move.b	d0,(a0)                         	| [ld   (hl),a]

	jbsr	c_sctrl_sprite_ram_clr            	| [call c_sctrl_sprite_ram_clr]

* display 1UP HIGH SCORE 20000 (1 time only after boot)
	jbsr	c_textout_1uphighscore_onetime    	| [call c_textout_1uphighscore_onetime]

	jbsr	c_1230_init_taskman_structs       	| [call c_1230_init_taskman_structs]

* data structures for 12 objects
	jbsr	rst_28                            	| [rst  0x28] memset(mctl_mpool,0,$$14 * 12)

* Not sure here...
* this would have the effect of disabling/skipping the task at 0x1F (f_0977)
* which happens to relate to updating the credit count (although, there is no
* RST 38 to actually trigger the task from now until setting this to 0 below.)

* cpu0_task_activ[0x1E] = 0x20
	move.b	#0x20,d0                        	| [ld   a,#0x20]
	move.b	d0,ds_cpu0_task_actv+0x1E       	| [ld   (ds_cpu0_task_actv + 0x1E),a] $20

* credit_cnt = io_input[0]
	move.b	ds3_99B5_io_input+0x00,d0       	| [ld   a,(ds3_99B5_io_input + 0x00)] credit_count
	move.b	d0,b8_99B8_credit_cnt           	| [ld   (b8_99B8_credit_cnt),a] credit_cnt = io_input[credit_count]

* cpu0_task_activ[0x1E] = 0
	clr.b	d0                               	| [xor  a]
	move.b	d0,ds_cpu0_task_actv+0x1E       	| [ld   (ds_cpu0_task_actv + 0x1E),a] 0 ... just wrote $20 here see above
	move.b	d0,ds_cpu1_task_actv+0x00       	| [ld   (ds_cpu1_task_actv + 0x00),a] 0 ... CPU1:f_05BE (empty task)


*=============================================================================
* g_main()
*  Description:
*    Performs initialization, and does a one-time check for credits
*    (monitoring credit count and updating "GameState" is otherwise handled
*    by a 16mS task). If credits available at startup, it updates "GameState"
*    and skips directly to "Ready" state, otherwise it
*    stays in Attract mode state.
*
*    Resumes here following completion of a game.
* IN:
*  ...
* OUT:
*  ...
*-----------------------------------------------------------------------------
g_main:
	clr.b	d0                               	| [xor  a]
	*move.b	d0,0xA007                       	| [ld   (0xA007),a] 0 (not_flipped)
	move.b	d0,b_9215_flip_screen           	| [ld   (b_9215_flip_screen),a] 0 (not_flipped)

* disable f_1D76 - star control ... why? ... should be taken care of by init_taskman_structs ...below
* task_activ_tbl[0x12] = 0
	move.b	d0,ds_cpu0_task_actv+0x12       	| [ld   (ds_cpu0_task_actv + 0x12),a] 0 ... f_1D76

* The object-collision notification structures are cleared
* at every beginning of round (and demo), so I am guessing the intent here is to
* clear the globals that share the $80 byte block

* memset($9200,0,$80) ... object-collision notification  and other
	move.b	#0x80,d1                        	| [ld   b,#0x80]
	lea	ds_9200(pc),a0                     	| [ld   hl,#ds_9200] memset(...,0,$80)
	jbsr	rst_18                            	| [rst  0x18] memset((HL), A=fill, B=ct)

* star_ctrl_param=6
	move.b	#6,d0                           	| [ld   a,#6]
	move.b	d0,ds_99B9_star_ctrl+0x05       	| [ld   (ds_99B9_star_ctrl + 0x05),a] 6

* array of object movement structures etc.
	jbsr	rst_28                            	| [rst  0x28] memset(mctl_mpool,0,$$14 * 12)
	jbsr	c_sctrl_sprite_ram_clr            	| [call c_sctrl_sprite_ram_clr] clear sprite mem etc.
	jbsr	c_1230_init_taskman_structs       	| [call c_1230_init_taskman_structs]

* allow attract-mode festivities to be skipped if credit available
* if ( credit_cnt == 0 )  game_state = ATTRACT_MODE
	                               	| 
	move.b	#1,d0                           	| [ld   a,#1] 1 == ATTRACT_MODE
	tst.b	b8_99B8_credit_cnt           	| [ld   a,(b8_99B8_credit_cnt)]+[and  a]
	jeq	l_0380                             	| [jr   z,l_0380]
* else  game_state = READY_TO_PLAY_MODE
	move.b	#2,d0                           	| [ld   a,#2] 2 == READY_TO_PLAY_MODE
l_0380:
	move.b	d0,b8_9201_game_state           	| [ld   (b8_9201_game_state),a] = (credit_cnt==0 ? ATTRACT : READY) ... (m/c start, game_state init)

* if ( credit_cnt == 0 ) ...
	tst.b	b8_99B8_credit_cnt
	jne	l_game_state_ready                 	| [jr   nz,l_game_state_ready]

* ... do attract mode stuff
	clr.b	d0                               	| [xor  a]
	move.b	d0,ds_9200_glbls+0x03           	| [ld   (ds_9200_glbls + 0x03),a] demo_idx = 0

* task_activ_tbl[F_ATTRMODECTRL] = 1
	addq.b	#1,d0                           	| [inc  a]
	move.b	d0,ds_cpu0_task_actv+0x02       	| [ld   (ds_cpu0_task_actv + 0x02),a] 1 ... f_17B2 (attract-mode control)

* while (game_state == ATTRACT_MODE) { ; }
l_038D_while:
	move.b	b8_9201_game_state,d0           	| [ld   a,(b8_9201_game_state)] while (ATTRACT_MODE)
	subq.b	#1,d0                           	| [dec  a]
	jeq	l_038D_while                       	| [jr   z,l_038D_while]

* GameState == Ready ... reinitialize everthing
	jbsr	c_1230_init_taskman_structs       	| [call c_1230_init_taskman_structs]
	jbsr	c_sctrl_playfld_clr               	| [call c_sctrl_playfld_clr]
	jbsr	rst_28                            	| [rst  0x28] memset(mctl_mpool,0,$$14 * 12)
	jbsr	c_sctrl_sprite_ram_clr            	| [call c_sctrl_sprite_ram_clr]

* game_state == READY

l_game_state_ready:
	clr.b	d0                               	| [xor  a]
	move.b	d0,ds_9200_glbls+0x0B           	| [ld   (ds_9200_glbls + 0x0B),a] 0 ... glbl_enemy_enbl: cleared in case demo was running
	move.b	#0x13,d2                        	| [ld   c,#0x13] C = string_out_pe_index
	jbsr	rst_30                            	| [rst  0x30] string_out_pe "(c) 1981 NAMCO LTD"
	move.b	#1,d2                           	| [ld   c,#1] C = string_out_pe_index
	jbsr	rst_30                            	| [rst  0x30] string_out_pe "PUSH START BUTTON"

	lea	d_attrmode_sptiles_ships(pc),a0    	| [ld   hl,#d_attrmode_sptiles_ships]
	move.l	a0,p_attrmode_sptiles           	| [ld   (p_attrmode_sptiles),hl] &_attrmode_sptiles[0] ... parameter to _sprite_tiles_displ()

* if ( 0xFF == mchn_cfg_bonus[0] ) goto l_While_Ready
	move.b	w_mchn_cfg_bonus+0,d0           	| [ld   a,(w_mchn_cfg_bonus + 0)]
	cmp.b	#0xFF,d0                         	| [cp   #0xFF]
	jeq	j_0003D8_wrdy                      	| [jr   z,j_0003D8_wrdy]

	move.b	d0,d4                           	| [ld   e,a] E=bonus score digit
	move.b	#0x1B,d2                        	| [ld   c,#0x1B] C=string_out_pe_index
	jbsr	c_game_bonus_info_show_line       	| [call c_game_bonus_info_show_line]

* if ( 0xFF == mchn_cfg_bonus[1] ) goto l_While_Ready
	move.b	w_mchn_cfg_bonus+1,d0           	| [ld   a,(w_mchn_cfg_bonus + 1)]
	cmp.b	#0xFF,d0                         	| [cp   #0xFF]
	jeq	j_0003D8_wrdy                      	| [jr   z,j_0003D8_wrdy]

	and.b	#0x7F,d0                         	| [and  #0x7F]
	move.b	d0,d4                           	| [ld   e,a] E=bonus score digit
	move.b	#0x1C,d2                        	| [ld   c,#0x1C] C=string_out_pe_index
	jbsr	c_game_bonus_info_show_line       	| [call c_game_bonus_info_show_line] bugs from demo mode have disappeared!

* if bit 7 is set, the third bonus award does not apply
	move.b	w_mchn_cfg_bonus+1,d0           	| [ld   a,(w_mchn_cfg_bonus + 1)]
	btst.b	#7,d0                           	| [bit  7,a]
	jne	j_0003D8_wrdy                      	| [jr   nz,j_0003D8_wrdy]
	and.b	#0x7F,d0                         	| [and  #0x7F]
	move.b	d0,d4                           	| [ld   e,a] E=bonus score digit
	move.b	#0x1D,d2                        	| [ld   c,#0x1D] C=string_out_pe_index
	jbsr	c_game_bonus_info_show_line       	| [call c_game_bonus_info_show_line]

* while (game_state == READY_TO_PLAY_MODE)
j_0003D8_wrdy:
l_0003D8:
	move.b	b8_9201_game_state,d0           	| [ld   a,(b8_9201_game_state)] while (READY)
	cmp.b	#2,d0                            	| [cp   #2] READY_TO_PLAY_MODE
	jeq	l_0003D8                           	| [jr   z,l_0003D8]

* /****  start button was hit ******************/

	**move.b	d0,b_9AA0+0x17                  	| [ld   (b_9AA0 + 0x17),a] sound_mgr_reset: non-zero causes re-initialization of sound mgr process

* clear sprite mem etc.
	jbsr	c_sctrl_playfld_clr               	| [call c_sctrl_playfld_clr]
	jbsr	c_sctrl_sprite_ram_clr            	| [call c_sctrl_sprite_ram_clr]

* stars paused
	*lea	l_A005(pc),a0                      	| [ld   hl,#0xA005] star_ctrl_port_bit6 -> 0, then 1
	*clr.b	(a0)                             	| [ld   (hl),#0]
	*move.b	#1,(a0)                         	| [ld   (hl),#1]

* Not sure about the intent of clearing $A0 bytes.. player data and resv data are only $80 bytes.
* The structure at 98B0 is $30 bytes so it would not all be cleared (only $10 bytes)
*  memset( player_data, 0, $a0 )
	lea	ds_plyr_data(pc),a0                	| [ld   hl,#ds_plyr_data] memset( ..., 0, $a0 )
	clr.b	d0                               	| [xor  a]
	move.b	#0xA0,d1                        	| [ld   b,#0xA0]
	jbsr	rst_18                            	| [rst  0x18] memset((HL), A=fill, B=ct)

*ld hl, ds_plyr_actv +_b_stgctr   ; HELP_ME_DEBUG
*ld (hl), #6

	*move.b	d0,b_9AA0+0x17                  	| [ld   (b_9AA0 + 0x17),a] 0 ... do not reset sound mgr process?

	*move.b	d0,ds_99B9_star_ctrl+0x00       	| [ld   (ds_99B9_star_ctrl + 0x00),a] 0 ... star ctrl stop (1 when ship on screen)

	*addq.b	#1,d0                           	| [inc  a]
	*move.b	d0,b_9AA0+0x0B                  	| [ld   (b_9AA0 + 0x0B),a] 1 ... sound-fx count/enable registers, start of game theme

	move.b	d0,ds_cpu0_task_actv+0x12       	| [ld   (ds_cpu0_task_actv + 0x12),a] 1 ... f_1D76, star ctrl
	move.b	d0,ds_cpu0_task_resrv+0x12      	| [ld   (ds_cpu0_task_resrv + 0x12),a] 1 ... f_1D76, star ctrl

* do one-time inits
	jbsr	gctl_game_init                    	| [call gctl_game_init] setup number of lives and show player score(s) '00'
	jbsr	c_game_or_demo_init               	| [call c_game_or_demo_init]

	move.b	#4,d2                           	| [ld   c,#4] C=string_out_pe_index
	jbsr	rst_30                            	| [rst  0x30] string_out_pe "PLAYER 1" (always starts with P1 no matter what!)

* busy loop -leaves "Player 1" text showing while some of the opening theme music plays out
* game_tmr_3 = 8;
	lea	ds4_game_tmrs+3(pc),a0             	| [ld   hl,#ds4_game_tmrs + 3] = 8 ... while ! 0
	move.b	#8,(a0)                         	| [ld   (hl),#8]
l_0414_while_tmr_3:
	move.b	(a0),d0                         	| [ld   a,(hl)]
	                               	| [and  a]
	jne	l_0414_while_tmr_3                 	| [jr   nz,l_0414_while_tmr_3]

* memset($9290,$10,0)
	lea	ds_bug_collsn_hit_mult(pc),a0      	| [ld   hl,#ds_bug_collsn_hit_mult] memset(...,$10,0)
	move.b	#0x10,d1                        	| [ld   b,#0x10]
	jbsr	rst_18                            	| [rst  0x18] memset((HL), A=fill, B=ct)

* memset($98B0,$30,0)
	move.b	#0x30,d1                        	| [ld   b,#0x30]
	lea	ds_susp_plyr_obj_data(pc),a0       	| [ld   hl,#ds_susp_plyr_obj_data] memset(...,$30,0)
	jbsr	rst_18                            	| [rst  0x18] memset((HL), A=fill, B=ct)

* settext($0b, $83b0)
	lea	0x8000+0x03B0(pc),a0           	| [ld   hl,#0x8000 + 0x03B0]
	move.b	#0x0B,d2                        	| [ld   c,#0x0B] index into string table
	jbsr	c_string_out                      	| [call c_string_out] erase PLAYER 1 text

	move.b	#1,d0                           	| [ld   a,#1]
	move.b	d0,ds_plyr_susp+_b_plyr_nbr     	| [ld   (ds_plyr_susp +_b_plyr_nbr),a] 1==plyr2

	move.b	w_mchn_cfg_bonus,d0             	| [ld   a,(w_mchn_cfg_bonus)]
	move.b	d0,ds_plyr_actv+_b_mcfg_bonus   	| [ld   (ds_plyr_actv +_b_mcfg_bonus),a]
	move.b	d0,ds_plyr_susp+_b_mcfg_bonus   	| [ld   (ds_plyr_susp +_b_mcfg_bonus),a]

	jra	plyr_respawn_splsh                 	| [jp   plyr_respawn_splsh] does not return, jp's to _game_runner

* end

*=============================================================================
* c_game_bonus_info_show_line()
*  Description:
*   coinup... displays each line of "1st BONUS, 2ND BONUS, AND FOR EVERY".
*   Successive calls to this are made depending upon machine config, e.g.
*  'XXX BONUS FOR XXXXXX PTS'
*  'AND FOR EVERY XXXXXX PTS'
* IN:
*  C = string_out_pe_index
*  E = first digit of score i.e. X of Xxxxx.
* OUT:
*  ...
*-----------------------------------------------------------------------------
c_game_bonus_info_show_line:

	jbsr	rst_30                            	| [rst  0x30] string_out_pe ('XXX BONUS FOR   ', 'AND FOR EVERY   ' )

* set next position to append 'X0000 PTS'
	exg	a1,a0                              	| [ex   de,hl] get position of final character from string_out (digit now in L)
	                        	| [ld   a,e]
	add.w	#0x40,a1                         	| [add  a,#0x40] Offset position by 2 characters to the left.
	                        	| [ld   e,a]

	clr.b	d5                               	| [ld   h,#0]
	jbsr	c_text_out_i_to_d_0A53                 	| [call c_text_out_i_to_d_0A53] HL contains number to display, returns updated destination in DE

	exg	a1,a0                              	| [ex   de,hl]
	move.b	#0x1E,d2                        	| [ld   c,#0x1E]
	jbsr	c_string_out                      	| [call c_string_out] DE=dest, C=string_out_pe_index

	jbsr	c_sprite_tiles_displ              	| [call c_sprite_tiles_displ]

	rts                                    	| [ret]


*=============================================================================
*  attributes for ship-sprites in bonus info screen ... 4-bytes each:
*  0: offset/index of object to use
*  1: color/code
*      ccode<3:6>==code
*      ccode<0:2,7>==color
*  2: X coordinate
*  3: Y coordinate
*
d_attrmode_sptiles_ships:
	.byte 0x00, 0x81, 0x19, 0x56
	.byte 0x02, 0x81, 0x19, 0x62
	.byte 0x04, 0x81, 0x19, 0x6E


*=============================================================================
* gctl_game_runner()
*  Description:
*   background super-loop following game-start
* IN:
*  ...
* OUT:
*  ...
*-----------------------------------------------------------------------------
gctl_game_runner:
l_045E_while:
	jbsr	gctl_supv_score                   	| [call gctl_supv_score]
	jbsr	gctl_supv_stage                   	| [call gctl_supv_stage]
	jra	l_045E_while                       	| [jr   l_045E_while]


*=============================================================================
* _plyr_init()
*  Description:
*   One-time setup for new game cycle.
*   Reset score displays etc. for 1 player and/or 2 player.
* IN:
*  ...
* OUT:
*  ...
*
*-----------------------------------------------------------------------------
gctl_game_init:
*  get nbr of fighters from machine config
	move.b	b_mchn_cfg_nships,d0            	| [ld   a,(b_mchn_cfg_nships)]
	move.b	d0,ds_plyr_actv+_b_nships       	| [ld   (ds_plyr_actv +_b_nships),a] mchn_cfg_nships
	move.b	d0,ds_plyr_susp+_b_nships       	| [ld   (ds_plyr_susp +_b_nships),a] mchn_cfg_nships

*  tiles drawn right to left ... top row layout:
*     2 bytes                           	|| 2 bytes (not visible)
*    ----------------------------------------------------
*    .3DF     .3DD                              .3C2  .3C0     <- Row 0
*    .3FF     .3FD                              .3E2  .3E0     <- Row 1

* Two 0's + 4 spaces + 1 non-visible space on the left
	lea	0x8000+0x03E0+0x18(pc),a1      	| [ld   de,#0x8000 + 0x03E0 + 0x18] player 1 score, rightmost of "00"
	lea	d_0495(pc),a0                      	| [ld   hl,#d_0495] "00"
	jbsr	gctl_init_puts                    	| [call gctl_init_puts]

	lea	0x8000+0x03E0+0x03(pc),a1      	| [ld   de,#0x8000 + 0x03E0 + 0x03] player 2 score (rightmost column is .3C2)
	lea	d_0495(pc),a0                      	| [ld   hl,#d_0495] "00"

* if ( two_plyr_game )  _putc ... draw 2 0's and 5 spaces in plyr 2 score
	move.b	b8_99B3_two_plyr_game,d0        	| [ld   a,(b8_99B3_two_plyr_game)]
	                               	| [and  a]
	jne	gctl_init_puts                     	| [jr   nz,gctl_init_puts]
* else  hl+=2  ... advance src pointer past "00", draw 7 spaces and erase player 2 score
	addq.w	#2,a0                           	| [inc  hl] * 2

*=============================================================================
* _score_init
*  Description:
*   we saved 4 bytes of code space by factoring out the part that copies 7
*   characters. Then we wasted about 50 uSec by repeating the erase 2UP!
* IN:
*  HL: src tbl pointer ... either 0495 or 0497
*  DE: dest pointer (offset)
* OUT:
*
*-----------------------------------------------------------------------------
gctl_init_puts:

* erase score
	move.w	#7,d1                           	| [ld   c,#7] doesn't initialize B but maybe it should!
	jbsr	ldir                              	| [ldir]

* erase "2UP" ...start at '_' of '2UP_'  (gets re-drawn momentarily)
	lea	d_0495+2(pc),a0                    	| [ld   hl,#d_0495 + 2]
	lea	0x8000+0x03C0+3(pc),a1         	| [ld   de,#0x8000 + 0x03C0 + 3] rightmost column is .3C2
	move.w	#4,d1                           	| [ld   c,#4]
	jbsr	ldir                              	| [ldir]

	rts                                    	| [ret]

*=============================================================================
d_0495:
* "00" characters for initial score display
	.byte 0x00,0x00
* "space" characters
	.byte 0x24,0x24,0x24,0x24,0x24,0x24,0x24


*=============================================================================
* gctl_stg_restart_hdlr()
*  Description:
*   Starting a new round or re-starting a round due to one of the following events:
*   - single ship destroyed
*   - second ship of duo destroyed
*   - ship captured
*   - cleared the level.
* IN:
*  ...
* OUT:
*  ...
*-----------------------------------------------------------------------------
gctl_stg_restart_hdlr:

* return is by jp ... pop the push'd return address of call c_080B_monitor_stage_start_
	move.l	(sp)+,a0                        	| [pop  hl]

	lea	ds4_game_tmrs+3(pc),a0             	| [ld   hl,#ds4_game_tmrs + 3] = 4 (set a time to wait while ship exploding)
	move.b	#4,(a0)                         	| [ld   (hl),#4]

* wait for ship explosion or bug explosion or for a landing captured ship
l_04A4_wait:

*  if ( captured_ship_landing_task_en ) ...
	move.b	ds_cpu0_task_actv+0x1D,d0       	| [ld   a,(ds_cpu0_task_actv + 0x1D)] f_2000 (destroyed boss that captured ship)
	                               	| [and  a]
	jeq	l_04C1_while                       	| [jr   z,l_04C1_while]
*  ... then ...
*      ship in play is destroyed, but the "landing" ship remains in play.
	clr.b	d0                               	| [xor  a]
	move.b	d0,ds_9200_glbls+0x13           	| [ld   (ds_9200_glbls + 0x13),a] 0 ... restart stage flag
	addq.b	#1,d0                           	| [inc  a]
	move.b	d0,ds_cpu1_task_actv+0x05       	| [ld   (ds_cpu1_task_actv + 0x05),a] 1  (f_05EE: fighter collision detection task)

*    if ( num_bugs > 0 ) return
	move.b	b_bugs_actv_nbr,d0              	| [ld   a,(b_bugs_actv_nbr)]
	                               	| [and  a]
	jne	gctl_game_runner                   	| [jp   nz,gctl_game_runner] continue round w/ second (docked) ship... return to Game Runner Loop

*      bug_ct == 0... last bug destroyed by collision w active ship
*      ... wait for captured ship to land before starting new stage

l_04B9_while:
* while ( task active )
	move.b	ds_cpu0_task_actv+0x1D,d0       	| [ld   a,(ds_cpu0_task_actv + 0x1D)] f_2000 (destroyed boss that captured ship)
	                               	| [and  a]
	jne	l_04B9_while                       	| [jr   nz,l_04B9_while]

	jra	l_04DC_break                       	| [jr   l_04DC_break]

l_04C1_while:
*  if ( timer_3 > 0 )
	move.b	(a0),d0                         	| [ld   a,(hl)] hl==_game_tmr_3? waiting on 4 count delay time for explosion
	                               	| [and  a]
	jne	l_04A4_wait                        	| [jr   nz,l_04A4_wait]

	jbsr	gctl_supv_score                   	| [call gctl_supv_score]

* plyr_state_actv.b_nbugs = b_bugs_actv_nbr
	move.b	b_bugs_actv_nbr,d0              	| [ld   a,(b_bugs_actv_nbr)]
	move.b	d0,ds_plyr_actv+_b_enmy_ct_actv 	| [ld   (ds_plyr_actv +_b_enmy_ct_actv),a]

* check for "not (normal) end of stage conditions":

* if ( restart stage flag               	|| bugs_actv_nbr>0 )
	move.b	d0,d2                           	| [ld   c,a] remaining enemies, could be 0 if fighter hit last one
	move.b	ds_9200_glbls+0x13,d0           	| [ld   a,(ds_9200_glbls + 0x13)] restart stage flag (could not be here if nbr_bugs > 0 && flag==0 )
	or.b	d2,d0                             	| [or   c]
	jne	gctl_plyr_terminate                	| [jr   nz,gctl_plyr_terminate]

	move.b	ds_plyr_actv+_b_not_chllg_stg,d0	| [ld   a,(ds_plyr_actv +_b_not_chllg_stg)] 0 if challenge stage
	                               	| [and  a]
	jeq	gctl_chllng_stg_end                	| [jp   z,gctl_chllng_stg_end] jp's back to 04DC_

l_04DC_break:

* end of stage ... "normal"
	jbsr	stg_init_splash                   	| [call stg_init_splash]
	jra	plyr_respawn_rdy                   	| [jp   plyr_respawn_rdy]


*=============================================================================
* gctl_plyr_terminate()
*  Description:
*   Handle terminated player
*   Bramch off to GameOver or TerminateActivePlayer and change player.
* IN:
*  ...
* OUT:
*  ...
*-----------------------------------------------------------------------------
gctl_plyr_terminate:
* if ( active_plyr_state.num_resv_ships-- == 0 )
	lea	ds_plyr_actv+_b_nships(pc),a0      	| [ld   hl,#ds_plyr_actv +_b_nships]
	move.b	(a0),d0                         	| [ld   a,(hl)]
	subq.b	#1,(a0)                         	| [dec  (hl)]
	tst.b	d0                               	| [and  a]
	jne	j_0579_terminate                   	| [jp   nz,j_0579_terminate] active ship terminated but not game over
*  if  ( two_plyr_game ) ...
	move.b	b8_99B3_two_plyr_game,d0        	| [ld   a,(b8_99B3_two_plyr_game)]
	                               	| [and  a]
	jeq	l_04FD_end_of_game                 	| [jr   z,l_04FD_end_of_game]
*  then ... adjust message text for two player game-over
	lea	0x8000+0x0240+0x0E(pc),a0      	| [ld   hl,#0x8000 + 0x0240 + 0x0E]
	move.b	ds_plyr_actv+_b_plyr_nbr,d0     	| [ld   a,(ds_plyr_actv +_b_plyr_nbr)] 0==plyr1, 1==plyr2
	addq.b	#4,d0                           	| [add  a,#4]
	move.b	d0,d2                           	| [ld   c,a] string index
	jbsr	c_string_out                      	| [call c_string_out] "PLAYER X" (for "PLAYER X GAME OVER")

l_04FD_end_of_game:
	move.b	#0x02,d2                        	| [ld   c,#0x02] string index
	jbsr	rst_30                            	| [rst  0x30] string_out_pe "GAME OVER"

	jbsr	c_tdelay_3                        	| [call c_tdelay_3]
	jbsr	c_tdelay_3                        	| [call c_tdelay_3]

*  while (0 != task_actv_tbl_0[0x18]){;} ... block if tractor beam completing
	lea	ds_cpu0_task_actv+0x18(pc),a0      	| [ld   hl,#ds_cpu0_task_actv + 0x18] f_2222 (Boss starts tractor beam) wait for task inactive
l_0509_while:
	move.b	(a0),d0                         	| [ld   a,(hl)]
	                               	| [and  a]
	jne	l_0509_while                       	| [jr   nz,l_0509_while]

	jbsr	rst_28                            	| [rst  0x28] memset(mctl_mpool,0,$$14 * 12)

	jbsr	c_sctrl_sprite_ram_clr            	| [call c_sctrl_sprite_ram_clr]
	jbsr	c_sctrl_playfld_clr               	| [call c_sctrl_playfld_clr]

	move.b	#0x15,d2                        	| [ld   c,#0x15] string index
	jbsr	rst_30                            	| [rst  0x30] string_out_pe ("-RESULTS-")
	move.b	#0x16,d2                        	| [ld   c,#0x16] string index
	jbsr	rst_30                            	| [rst  0x30] string_out_pe ("SHOTS FIRED")

	lea	0x8000+0x0120+0x12,a1      	| [ld   de,#0x8000 + 0x0120 + 0x12]
	move.w	ds_plyr_actv+_w_shot_ct(pc),d5  	| [ld   hl,(ds_plyr_actv +_w_shot_ct)] puts game shots fired count
	jbsr	c_text_out_i_to_d_0A53                 	| [call c_text_out_i_to_d_0A53] puts game shots fired count

	move.b	#0x18,d2                        	| [ld   c,#0x18] string index
	jbsr	rst_30                            	| [rst  0x30] string_out_pe ("NUMBER OF HITS")

	lea	0x8000+0x0120+0x15,a1      	| [ld   de,#0x8000 + 0x0120 + 0x15]
	move.w	ds_plyr_actv+_w_hit_ct,d5   	| [ld   hl,(ds_plyr_actv +_w_hit_ct)] puts game number of hits
	jbsr	c_text_out_i_to_d_0A53                 	| [call c_text_out_i_to_d_0A53] puts game number of hits

	move.b	#0x19,d2                        	| [ld   c,#0x19] string index
	jbsr	rst_30                            	| [rst  0x30] string_out_pe ("HIT-MISS RATIO")

	jbsr	c_puts_hitmiss_ratio_0A72         	| [call c_puts_hitmiss_ratio_0A72]

	exg	a1,a0                              	| [ex   de,hl] HL becomes c_string_out<IN:position in tile RAM>
	move.b	#0x1A,d2                        	| [ld   c,#0x1A] string index
	jbsr	c_string_out                      	| [call c_string_out] "%" after hit-miss number

       * wait for the timer
	lea	ds4_game_tmrs+2(pc),a0             	| [ld   hl,#ds4_game_tmrs + 2]
	move.b	#0x0E,(a0)                      	| [ld   (hl),#0x0E]
l_0540_while:
	move.b	(a0),d0                         	| [ld   a,(hl)]
	                               	| [and  a]
	jne	l_0540_while                       	| [jr   nz,l_0540_while]

	jbsr	c_sctrl_playfld_clr               	| [call c_sctrl_playfld_clr]
	jbsr	c_top5_dlg_proc                   	| [call c_top5_dlg_proc] returns immediately if not in top-5

	clr.b	d0                               	| [xor  a]
	move.b	d0,b_9AA0+0x10                  	| [ld   (b_9AA0 + 0x10),a] 0 ... sound-fx count/enable registers, hi-score dialog?

* while (_fx[0x0C]                      	|| _fx[0x16]) ... (finished when both 0)
	lea	b_9AA0+0x0C(pc),a0                 	| [ld   hl,#b_9AA0 + 0x0C] sound-fx count/enable registers, hi-score dialog
	lea	b_9AA0+0x16(pc),a1                 	| [ld   de,#b_9AA0 + 0x16] sound-fx count/enable registers, hi-score dialog
l_0554_while:
	move.b	(a1),d0                         	| [ld   a,(de)] sound_fx[0x16] ... probably 0
	move.b	(a0),d1                         	| [ld   b,(hl)] sound_fx[0x0C] ... probably still running
	or.b	d1,d0                             	| [or   b]
	jeq	l_0562                             	| [jr   z,l_0562]
* if (0 != _fx[0x0C]) then _fx[0x0C] = 1 ... snd[$0C] used as timer, enable snd[$16] when 0 is reached
	addq.b	#1,d1                           	| [inc  b]
	subq.b	#1,d1                           	| [dec  b]
	jeq	l_055F                             	| [jr   z,l_055F]
	move.b	#1,(a0)                         	| [ld   (hl),#1]
l_055F:
* On halt, processor wakes at maskable or nonmaskable interrupt providing
* something like a busy-wait with sleep(n) where n is the interrupt period.
halt                                       ; hi-score, finished name entry (wait for music to stop)
	jra	l_0554_while                       	| [jr   l_0554_while]

l_0562:
	jbsr	c_sctrl_playfld_clr               	| [call c_sctrl_playfld_clr] clear screen at end of game

* done game over stuff for active player, so if 1P game or
* plyr_susp.resv_fghtrs exhausted then halt

* if ( !two_plyr_game                   	|| -1 == plyr_susp.resv_fghtrs ) then halt
	move.b	b8_99B3_two_plyr_game,d0        	| [ld   a,(b8_99B3_two_plyr_game)]
	                               	| [and  a]
	jeq	g_halt                             	| [jp   z,g_halt] jp   g_main
	move.b	ds_plyr_susp+_b_nships,d0       	| [ld   a,(ds_plyr_susp +_b_nships)] -1 if no resv ships remain
	addq.b	#1,d0                           	| [inc  a]
	jeq	g_halt                             	| [jp   z,g_halt] jp   g_main

* else if ( stage_rst_flag != 1 ) ... _plyr_chg()
*   indicates fighter-capture event
	move.b	ds_9200_glbls+0x13,d0           	| [ld   a,(ds_9200_glbls + 0x13)] restart stage flag
	subq.b	#1,d0                           	| [dec  a]
	jne	j_058E_plyr_chg                    	| [jr   nz,j_058E_plyr_chg]

j_0579_terminate:
* if ( !two_plyr_game ) {
	move.b	b8_99B3_two_plyr_game,d0        	| [ld   a,(b8_99B3_two_plyr_game)]
	                               	| [and  a]
	jeq	plyr_respawn_1up                   	| [jp   z,plyr_respawn_1up] plyr_respawn_1P < plyr_respawn_wait < fghtr_rdy < game_runner

* } else if ( plyr_susp.resv_fghtrs == -1	|| stage_rst_flag != 0 )
	move.b	ds_plyr_susp+_b_nships,d0       	| [ld   a,(ds_plyr_susp +_b_nships)] -1 when .resv_fghtrs exhausted
	addq.b	#1,d0                           	| [inc  a]
	jeq	plyr_respawn_plyrup                	| [jp   z,plyr_respawn_plyrup] allow actv plyr respawn if susp plyr out of ships
* note: stage_rst_flag == 0 would also test true but that would make no sense here
	move.b	ds_9200_glbls+0x13,d0           	| [ld   a,(ds_9200_glbls + 0x13)] restart_stage
	subq.b	#1,d0                           	| [dec  a]
	jne	plyr_respawn_plyrup                	| [jp   nz,plyr_respawn_plyrup] allows active plyr to respawn on capture ship event
* }
* else { do player change }


*=============================================================================

j_058E_plyr_chg:
* if ( nr of bugs == 0 ) {{
	move.b	b_bugs_actv_nbr,d0              	| [ld   a,(b_bugs_actv_nbr)]
	                               	| [and  a]
	jeq	l_059A_prep                        	| [jr   z,l_059A_prep]
* }} else {{
*    while ( nbr_flying_bugs > 0 ) {
l_0594:
	move.b	b_bugs_flying_nbr,d0            	| [ld   a,(b_bugs_flying_nbr)] check if !=0 (ship destroyed, wait for bugs return to nest)
	                               	| [and  a]
	jne	l_0594                             	| [jr   nz,l_0594]
*    }
* }}

* set up for active player nest to retreat
l_059A_prep:
	clr.b	d0                               	| [xor  a]
	move.b	d0,b8_99B4_bugnest_onoff_scrn_tmr	| [ld   (b8_99B4_bugnest_onoff_scrn_tmr),a] 0 ( timer/counter while nest retreating)
	addq.b	#1,d0                           	| [inc  a]
	lea	ds_cpu0_task_actv+0x0E(pc),a0      	| [ld   hl,#ds_cpu0_task_actv + 0x0E] 1 ... f_1D32
	move.b	d0,(a0)                         	| [ld   (hl),a]

* wait for formation to exit ... completion of f_1D32 (status actv_task_tbl[$0E])
l_05A3_while:
	move.b	(a0),d0                         	| [ld   a,(hl)]
	                               	| [and  a]
	jne	l_05A3_while                       	| [jr   nz,l_05A3_while]

* exchange player data
	move.b	b_9AA0+0x00,d0                  	| [ld   a,(b_9AA0 + 0x00)] plyr_actv.b_sndflag
	move.b	d0,ds_plyr_actv+_b_sndflag      	| [ld   (ds_plyr_actv +_b_sndflag),a] _fx[0] ... enable for pulsing_sound
	move.b	ds4_game_tmrs+2,d0              	| [ld   a,(ds4_game_tmrs + 2)]
	move.b	d0,ds_plyr_actv+_b_plyr_swap_tmr	| [ld   (ds_plyr_actv +_b_plyr_swap_tmr),a] game_tmr[2]
	jbsr	c_player_active_switch            	| [call c_player_active_switch]
	jbsr	c_2C00                            	| [call c_2C00] new stage setup
	move.b	ds_plyr_actv+_b_plyr_swap_tmr,d0	| [ld   a,(ds_plyr_actv +_b_plyr_swap_tmr)] game_tmr[2]
	move.b	d0,ds4_game_tmrs+2              	| [ld   (ds4_game_tmrs + 2),a] actv_plyr_state[0x1F]
	move.b	ds_plyr_actv+_b_sndflag,d0      	| [ld   a,(ds_plyr_actv +_b_sndflag)] _fx[0] ... enable for pulsing_sound
	move.b	d0,b_9AA0+0x00                  	| [ld   (b_9AA0 + 0x00),a] enable for pulsing_sound
	jbsr	draw_resv_ships                   	| [call draw_resv_ships]

* if ( _enmy_ct_actv != 0 ) ...
	move.b	ds_plyr_actv+_b_enmy_ct_actv,d0 	| [ld   a,(ds_plyr_actv +_b_enmy_ct_actv)]
	                               	| [and  a]
	jeq	l_05D1                             	| [jr   z,l_05D1]
* ... then ... player was previously destroyed by collision with last enemy in the round
	jbsr	c_25A2                            	| [call c_25A2] gctl_stg_new_atk_wavs_init()

* setting up a new screen (changing players)
l_05D1:
*  screen_is_flipped = (cab_type==Table & Plyr2up )
	move.b	ds_plyr_actv+_b_plyr_nbr,d0     	| [ld   a,(ds_plyr_actv +_b_plyr_nbr)] 0==plyr1, 1==plyr2
	move.b	d0,d2                           	| [ld   c,a]
	move.b	b_mchn_cfg_cab_type,d0          	| [ld   a,(b_mchn_cfg_cab_type)] 0==UPRIGHT, 1==TABLE
	and.b	d2,d0                            	| [and  c]
	*move.b	d0,0xA007                       	| [ld   (0xA007),a] sfr_flip_screen
	move.b	d0,b_9215_flip_screen           	| [ld   (b_9215_flip_screen),a]

* gctl_stg_fmtn_hpos_init
	move.b	#0x3F,d0                        	| [ld   a,#0x3F]
	jbsr	c_12C3                            	| [call c_12C3] A==$3F ... set MOB coordinates, player changeover

* set Cy to disable sound clicks for level tokens on player change (value of A is irrelevant)
	SET_XC_FLAGS                           	| [scf]
	scs	d7                              	| [ex   af,af']
	jbsr	c_new_level_tokens                	| [call c_new_level_tokens] Cy' == 1, A == don't care

* if ( _enmy_ct_actv == 0 )  ... then _stg_init ... player was previously destroyed by collision with last enemy in the round
	move.b	ds_plyr_actv+_b_enmy_ct_actv,d0 	| [ld   a,(ds_plyr_actv +_b_enmy_ct_actv)]
	                               	| [and  a]
	jeq	plyr_respawn_splsh                 	| [jr   z,plyr_respawn_splsh] _plyr_startup > _new_stg_ <-  _plyr_startup

* else ...
	move.b	#3,d2                           	| [ld   c,#3] C=string_out_pe_index
	jbsr	rst_30                            	| [rst  0x30] string_out_pe "READY"

* set wait-time for bug nest retreat. The count is masked with $7F in f_1D32, so I
* don't see why it starts at $80 here instead of 0. Shouldn't make any difference tho'...
	move.b	#0x80,d0                        	| [ld   a,#0x80]
	move.b	d0,b8_99B4_bugnest_onoff_scrn_tmr	| [ld   (b8_99B4_bugnest_onoff_scrn_tmr),a] $80

* wait for bug nest to reappear.
	lea	ds_cpu0_task_actv+0x0E(pc),a0      	| [ld   hl,#ds_cpu0_task_actv + 0x0E] 1 ... f_1D32
	move.b	#1,d0                           	| [ld   a,#1]
	move.b	d0,(a0)                         	| [ld   (hl),a]

* while ( cpu0_task_actv[$0E] ) ... wait for the task to timeout
l_05FD:
	move.b	(a0),d0                         	| [ld   a,(hl)]
	                               	| [and  a]
	jne	l_05FD                             	| [jr   nz,l_05FD]

	jra	plyr_respawn_plyrup                	| [jp   plyr_respawn_plyrup] reloaded suspended plyr, bug nest reloaded... ready!


*=============================================================================
* "respawn" for 1 player game.
* If fighter terminated by last enemy of the stage, then init new stage.
* Only reference is from _terminate() so it should be "inlined" there.
plyr_respawn_1up:
* if (0 == plyr_state_actv.b_nbugs) ...
	move.b	ds_plyr_actv+_b_enmy_ct_actv,d0 	| [ld   a,(ds_plyr_actv +_b_enmy_ct_actv)]
	                               	| [and  a]
	jne	gctl_plyr_respawn_wait             	| [jr   nz,gctl_plyr_respawn_wait]
* ... then ...
	jbsr	stg_init_splash                   	| [call stg_init_splash] new stage setup, shows "STAGE X"

	jra	gctl_plyr_respawn_wait             	| [jr   gctl_plyr_respawn_wait]


*=============================================================================
* Player respawn with stage setup (i.e. when plyr.enemys = 0, i.e. player
* change, or at start of new game loop.
* If on a new game, PLAYER 1 text has been erased.
plyr_respawn_splsh:
	jbsr	stg_init_splash                   	| [call stg_init_splash] shows "STAGE X" and does setup

       * plyr_respawn_plyrup()

*-----------------------------------------------------------------------------
* Setup a new player... every time the player is changed on a 2P game or once
* at first fighter of new 1P game. Player X text shown, stage restart.
plyr_respawn_plyrup:
	move.b	ds_plyr_actv+_b_plyr_nbr,d0     	| [ld   a,(ds_plyr_actv +_b_plyr_nbr)] 0==plyr1, 1==plyr2
	addq.b	#4,d0                           	| [add  a,#4] P1 text is index 4, P2 is index 5
	move.b	d0,d2                           	| [ld   c,a] index into string table
	lea	0x8000+0x0260+0x0E(pc),a0      	| [ld   hl,#0x8000 + 0x0260 + 0x0E] not position encoded, this one is 1C left and 2R up
	jbsr	c_string_out                      	| [call c_string_out] puts PLAYER X ("1" or "2") .

*-----------------------------------------------------------------------------
* _fghtr_rdy + wait ... 1 player skips previous stuff
gctl_plyr_respawn_wait:
	jbsr	c_player_respawn                  	| [call c_player_respawn] "credit X" is wiped and reserve ships appear on lower left of screen

* ds4_game_tmrs[2] was set to 120 by new_stg_game_or_demo

* if tmr > $5A then reset to $78
	move.b	ds4_game_tmrs+2,d0              	| [ld   a,(ds4_game_tmrs + 2)]
	add.b	#0x1E,d0                         	| [add  a,#0x1E]
	cmp.b	#0x78,d0                         	| [cp   #0x78]
	jcs	l_062C                             	| [jr   c,l_062C]
	move.b	#0x78,d0                        	| [ld   a,#0x78]
l_062C:
	move.b	d0,ds4_game_tmrs+2              	| [ld   (ds4_game_tmrs + 2),a] $78

* new ship appears on screen and stars start moving ... should about take care of the music
	jbsr	c_tdelay_3                        	| [call c_tdelay_3]

*-----------------------------------------------------------------------------
* new round starting or round re-starting after active player switch.
plyr_respawn_rdy:
	move.b	#1,d0                           	| [ld   a,#1]
	move.b	d0,ds_cpu0_task_actv+0x15       	| [ld   (ds_cpu0_task_actv + 0x15),a] 1 ... f_1F04 (fire button input)
	move.b	d0,ds_cpu1_task_actv+0x05       	| [ld   (ds_cpu1_task_actv + 0x05),a] 1 ... cpu1:f_05EE (hit-detection)
	move.b	d0,ds_plyr_actv+_b_atk_wv_enbl  	| [ld   (ds_plyr_actv +_b_atk_wv_enbl),a] 1  (0 when respawning player ship)

	move.b	#0x0B,d2                        	| [ld   c,#0x0B] index into string table
	lea	0x8000+0x03B0(pc),a0           	| [ld   hl,#0x8000 + 0x03B0]
	jbsr	c_string_out                      	| [call c_string_out] erase "READY" or "STAGE X"

	move.b	#0x0B,d2                        	| [ld   c,#0x0B] index into string table
	lea	0x8000+0x03A0+0x0E(pc),a0      	| [ld   hl,#0x8000 + 0x03A0 + 0x0E]
	jbsr	c_string_out                      	| [call c_string_out] erase "PLAYER 1"

	jra	gctl_game_runner                   	| [jp   gctl_game_runner] resume background super loop


*=============================================================================
* gctl_chllng_stg_end()
*  Description:
*    Handle challenge stage book-keeping prior to doing the "normal"
*    new_stage_setup.
*    Entry and Exit are both by jp.
* IN:
*  ...
* OUT:
*  ...
*-----------------------------------------------------------------------------
gctl_chllng_stg_end:

	move.b	b_bug_flyng_hits_p_round,d0     	| [ld   a,(b_bug_flyng_hits_p_round)]
	move.b	d0,d4                           	| [ld   e,a]

	lea	b_9AA0+0x0E(pc),a0                 	| [ld   hl,#b_9AA0 + 0x0E] sound-fx count/enable registers, default melody for challenge stage
	cmp.b	#40,d0                           	| [cp   #40] nbr of bugs in challenge round
	jne	l_065E                             	| [jr   nz,l_065E]
	lea	b_9AA0+0x14(pc),a0                 	| [ld   hl,#b_9AA0 + 0x14] sound effect count/enable registers, "perfect!" melody, challenge stg
l_065E:
	move.b	#1,(a0)                         	| [ld   (hl),#1]

	jbsr	c_tdelay_3                        	| [call c_tdelay_3]

	move.b	#0x08,d2                        	| [ld   c,#0x08]
	jbsr	rst_30                            	| [rst  0x30] string_out_pe ("NUMBER OF HITS")

	jbsr	c_tdelay_3                        	| [call c_tdelay_3]

* DE = adjusted offset into tile ram on return
	move.b	d4,d6                           	| [ld   l,e] E==nbr of flying bugs hit this round
	clr.b	d5                               	| [ld   h,#0]
	lea	0x8000+0x0100+0x10(pc),a1      	| [ld   de,#0x8000 + 0x0100 + 0x10]
	jbsr	c_text_out_i_to_d_0A53                 	| [call c_text_out_i_to_d_0A53] HL contains number to display (number of hits)

	jbsr	c_tdelay_3                        	| [call c_tdelay_3]

* if (0x40 != b_bug_flyng_hits_p_round) ...
	move.b	b_bug_flyng_hits_p_round,d0     	| [ld   a,(b_bug_flyng_hits_p_round)] if 40
	cmp.b	#40,d0                           	| [cp   #40]
	jeq	l_0699_special_bonus               	| [jr   z,l_0699_special_bonus]
* then ...
	move.b	#9,d2                           	| [ld   c,#9]
	jbsr	rst_30                            	| [rst  0x30] string_out_pe ("BONUS")

	jbsr	c_tdelay_3                        	| [call c_tdelay_3]

	exg	a1,a0                              	| [ex   de,hl] DE = HL

* if (0 != b_bug_flyng_hits_p_round) ...
	move.b	b_bug_flyng_hits_p_round,d0     	| [ld   a,(b_bug_flyng_hits_p_round)] if !0
	                               	| [and  a]
	jeq	l_0693_put_ones                    	| [jr   z,l_0693_put_ones]
* then ...
	move.b	d0,d6                           	| [ld   l,a]
	clr.b	d5                               	| [ld   h,#0]
	jbsr	c_text_out_i_to_d_0A53                 	| [call c_text_out_i_to_d_0A53] HL contains number to display (1000's,100's place of bonus pts awarded)
	clr.b	d0                               	| [xor  a]
	jbsr	write_videoram_a1					| [ld   (de),a] putc(0) ... 10's place of bonus pts awarded
	sub.w	#0x20,a1                            	| [rst  0x20] DE-=$20
	clr.b	d0                               	| [xor  a]

l_0693_put_ones:
	jbsr	write_videoram_a1                         	| [ld   (de),a] putc(0) ... 1's place of bonus pts awarded
	move.b	b_bug_flyng_hits_p_round,d0     	| [ld   a,(b_bug_flyng_hits_p_round)]
	jra	l_06BA                             	| [jr   l_06BA]

l_0699_special_bonus:
* blink the "PERFECT !" text
	move.b	#7,d1                           	| [ld   b,#7]
l_069B_while_b:
l_069B_while_fcnt:
	move.b	ds3_92A0_frame_cts+0,d0         	| [ld   a,(ds3_92A0_frame_cts + 0)]
	and.b	#0x0F,d0                         	| [and  #0x0F]
	jne	l_069B_while_fcnt                  	| [jr   nz,l_069B_while_fcnt]

	move.b	#0x0B,d2                        	| [ld   c,#0x0B] index into string table (27 spaces)
	btst.b	#0,d1                           	| [bit  0,b]
	jeq	l_06A9                             	| [jr   z,l_06A9]
	addq.b	#1,d2                           	| [inc  c] C = 0x0C; // index into string table "PERFECT !"
l_06A9:
	movem.w	d1/d2,-(sp)                    	| [push bc]
	jbsr	rst_30                            	| [rst  0x30] string_out_pe ( C == $0B or C == $0C ... "PERFECT !" or spaces)

	movem.w	(sp)+,d1/d2                    	| [pop  bc]

l_06AC_while_fcnt:
	move.b	ds3_92A0_frame_cts+0,d0         	| [ld   a,(ds3_92A0_frame_cts + 0)]
	and.b	#0x0F,d0                         	| [and  #0x0F]
	jeq	l_06AC_while_fcnt                  	| [jr   z,l_06AC_while_fcnt]

	subq.b	#1,d1                           	| [...]
	jne	l_069B_while_b                     	| [djnz l_069B_while_b]

	move.b	#0x0D,d2                        	| [ld   c,#0x0D] index into string table
	jbsr	rst_30                            	| [rst  0x30] string_out_pe ("SPECIAL BONUS 10000 PTS")

	move.b	#100,d0                         	| [ld   a,#100] 100 * 10 ... special bonus (d_scoreman_inc_lut[0] == $10)
l_06BA:
	lea	ds_bug_collsn_hit_mult+0x0F(pc),a0 	| [ld   hl,#ds_bug_collsn_hit_mult + 0x0F] challenge bonus score += 10000
	add.b	(a0),d0                          	| [add  a,(hl)]
	move.b	d0,(a0)                         	| [ld   (hl),a]
	jbsr	gctl_supv_score                   	| [call gctl_supv_score] add bonus to player score
	jbsr	c_tdelay_3                        	| [call c_tdelay_3]
	jbsr	c_tdelay_3                        	| [call c_tdelay_3]

	lea	0x8000+0x03A0+0x10(pc),a0      	| [ld   hl,#0x8000 + 0x03A0 + 0x10]
	move.b	#0x0B,d2                        	| [ld   c,#0x0B] index into string table
	jbsr	c_string_out                      	| [call c_string_out] erase "Number of hits XX" (line below Perfect)

	lea	0x8000+0x03A0+0x13(pc),a0      	| [ld   hl,#0x8000 + 0x03A0 + 0x13]
	move.b	#0x0B,d2                        	| [ld   c,#0x0B] index into string table
	jbsr	c_string_out                      	| [call c_string_out] erase "Special Bonus 10000 Pts" (or Bonus xxxx)

	move.b	#0x0B,d2                        	| [ld   c,#0x0B] index into string table
	jbsr	rst_30                            	| [rst  0x30] string_out_pe (erase "PERFECT !")

	jra	l_04DC_break                       	| [jp   l_04DC_break]


*=============================================================================
* g_halt()
*  Description:
*    Restarts machine when one (or both) players exhausted supply of fighters.
*    Resumes at g_main.
* IN:
*  ...
* OUT:
*  ...
*-----------------------------------------------------------------------------
g_halt:
	illegal		 | halt                                       ; screen is now cleared at end of game
	di

l_06E0_while_wait_io_ackrdy:
	*move.b	0x7100,d0                       	| [ld   a,(0x7100)] read IO status
	cmp.b	#0x10,d0                         	| [cp   #0x10] if (IO_ACKRDY) ... "command executed"
	jne	l_06E0_while_wait_io_ackrdy        	| [jr   nz,l_06E0_while_wait_io_ackrdy]

	lea	d_0725(pc),a0                      	| [ld   hl,#d_0725] set data src ($02,$02,$02)
	lea	l_7000(pc),a1                      	| [ld   de,#0x7000] IO data xfer (write)
	move.b	#0x00,d1                        	| [ld   bc,#0x0003] 3
	move.b	#0x03,d2                        	| [ld   bc,#0x0003] 3
	jbsr	exx                               	| [exx]

	move.b	#0x61,d0                        	| [ld   a,#0x61] Reset IO chip? (not in Mame36 - check newer).
	*move.b	d0,0x7100                       	| [ld   (0x7100),a] IO cmd ($61 -> disable IO chip?)
	illegal		 |  halt                                       ; stops until interrupt

* allow blinking of Player2 text to be inhibited on the intro screen when the
* game recycles (Player1 text shown anyway)
	clr.b	d0                               	| [xor  a]
	jbsr	c_093C                            	| [call c_093C] A == 0 ... blinking off

ei

*  memset($9AA0,0,$20)
	clr.b	d0                               	| [xor  a]
	move.b	#0x20,d1                        	| [ld   b,#0x20]
	lea	ds_9AA0(pc),a0                     	| [ld   hl,#ds_9AA0] count/enable registers for sound effects, $20 bytes cleared
	jbsr	rst_18                            	| [rst  0x18] memset((HL), A=fill, B=ct)

	lea	0x8000+0x03E0+0x19(pc),a1      	| [ld   de,#0x8000 + 0x03E0 + 0x19] 83f9 is 10's place score digit, below P of '1UP'
	jbsr	c_mach_info_add_score             	| [call c_mach_info_add_score]
	lea	0x8000+0x03E0+0x04(pc),a1      	| [ld   de,#0x8000 + 0x03E0 + 0x04] 83e4 is 10's place score digit, below P of '2UP'
	jbsr	c_mach_info_add_score             	| [call c_mach_info_add_score]

*  Update total plays (up to 9999 bcd)
*  total_plays_bcd = (two_plyr_game==1) + 1  ... 0 for 1P, 1 for 2P
	move.b	b8_99B3_two_plyr_game,d0        	| [ld   a,(b8_99B3_two_plyr_game)]
	addq.b	#1,d0                           	| [inc  a]
	lea	b16_99E0_ttl_plays_bcd+1(pc),a0    	| [ld   hl,#b16_99E0_ttl_plays_bcd + 1] get lsb (1s,10s place)
	add.b	(a0),d0                          	| [add  a,(hl)]
daa
	move.b	d0,(a0)                         	| [ld   (hl),a]
	jcc	g_main                             	| [jp   nc,g_main] finished update total_plays_bcd
      ^^^^^^ TODO: review cpu flags (move.b,jcc)
	subq.w	#1,a0                           	| [dec  hl] w_total_plays_bcd (get msb ...100s,1000s place)
	move.b	(a0),d0                         	| [ld   a,(hl)]
	addq.b	#0x01,d0                        	| [add  a,#0x01]
daa
	move.b	d0,(a0)                         	| [ld   (hl),a]
	jra	g_main                             	| [jp   g_main] from g_halt

*=============================================================================
* const data for g_halt()
d_0725:
	.byte 0x02,0x02,0x02

*=============================================================================
* gctl_supv_score()
*  Description:
*
* IN:
*  ...
* OUT:
*  ...
*-----------------------------------------------------------------------------
gctl_supv_score:
*  if ( activ_plyr_state.plyr_1or2 == plyr1 )
	                               	| [and  a]
*    tmp = $f9
	move.b	#0xF9,d0                        	| [ld   a,#0xF9] offset to 10's place from _tile_ram + 0x0300 (plyr 1)
	tst.b	ds_plyr_actv+_b_plyr_nbr     	| [ld   a,(ds_plyr_actv +_b_plyr_nbr)] 0==plyr1, 1==plyr2
	jeq	l_0732                             	| [jr   z,l_0732]
*  else tmp = $E4
	move.b	#0xE4,d0                        	| [ld   a,#0xE4] offset to 10's place from _tile_ram + 0x0300 (plyr 2)

l_0732:
ld   ixl,a                                 ; parameter to c_scoreman_incr_add (tile ram offset)

	move.b	#0x10,d1                        	| [ld   b,#0x10] sizeof scoreman_inc_lut[]
	lea	ds_bug_collsn_hit_mult+0x00(pc),a0 	| [ld   hl,#ds_bug_collsn_hit_mult + 0x00]
l_0739_while_B:
	exg	a1,a0                              	| [ex   de,hl] DE := &bug_collsn[hl]
	lea	d_scoreman_inc_lut-1(pc),a0        	| [ld   hl,#d_scoreman_inc_lut - 1] effective start index is $10 - 1
	move.b	d1,d0                           	| [ld   a,b]
	jbsr	rst_10                            	| [rst  0x10] HL += A
	move.b	(a0),d2                         	| [ld   c,(hl)] scoreman_inc_lut[B-1]
* bug_collsn[hl] * scoreman_inc_lut[B-1]
l_0740:
	exg	a1,a0                              	| [ex   de,hl]
	move.b	(a0),d0                         	| [ld   a,(hl)] bug_collsn[hl]
	                               	| [and  a]
	jeq	l_0762                             	| [jr   z,l_0762] while ( 0 != bug_collsn[HL] )

	subq.b	#1,(a0)                         	| [dec  (hl)] bug_collsn[HL] decrement accumulated hit count
	exg	a1,a0                              	| [ex   de,hl] DE := &bug_collsn[0x00]

	move.w	0x8000+0x0300(pc),a0        	| [ld   h,#>(0x8000 + 0x0300)] tile rows 32-35:  $83C0 - 83FF
                  ^^^^^^ TODO: review move.w into address register
	move.b	#ixl,d0                         	| [ld   a,ixl] offset to 10's place in tile ram
	move.b	d0,d6                           	| [ld   l,a]
	move.b	d2,d0                           	| [ld   a,c] scoreman_inc_lut[B-1]
	and.b	#0x0F,d0                         	| [and  #0x0F]
	jbsr	c_scoreman_incr_add               	| [call c_scoreman_incr_add] add to 10's

	move.b	#ixl,d0                         	| [ld   a,ixl] increment offset to 10's place in tile ram
	addq.b	#1,d0                           	| [inc  a]
	move.b	d0,d6                           	| [ld   l,a]
	move.b	d2,d0                           	| [ld   a,c] scoreman_inc_lut[B-1]
	rol.b	#4,d0                            	| [rlca] upper nibble of "score increment" * 4
	and.b	#0x0F,d0                         	| [and  #0x0F]
	jbsr	c_scoreman_incr_add               	| [call c_scoreman_incr_add] add to 100's
	jra	l_0740                             	| [jr   l_0740]

l_0762:
	addq.w	#1,a0                           	| [inc  l] index of bug_collsn[]
            ^^^^ TODO check inc register d6 or a0 (above!!)
	subq.b	#1,d1                           	| [...]
	jne	l_0739_while_B                     	| [djnz l_0739_while_B]


	move.b	#ixl,d0                         	| [ld   a,ixl]
	addq.b	#4,d0                           	| [add  a,#4]
	move.b	d0,d4                           	| [ld   e,a]
	lea	0x8000+0x03E0+0x12(pc),a0      	| [ld   hl,#0x8000 + 0x03E0 + 0x12] 100000's digit of HIGH SCORE (83ED-83F2)
	move.w	0x8000+0x0300(pc),a1        	| [ld   d,#>(0x8000 + 0x0300)]
                  ^^^^^^ TODO: review move.w into address register

	move.b	#6,d1                           	| [ld   b,#6]
l_0771:
	move.b	(a1),d0                         	| [ld   a,(de)]
	sub.b	(a0),d0                          	| [sub  (hl)]
	add.b	#9,d0                            	| [add  a,#9]
	cmp.b	#0xE5,d0                         	| [cp   #0xE5]
	jcc	l_0788                             	| [jr   nc,l_0788]
	sub.b	#0x0A,d0                         	| [sub  #0x0A]
	cmp.b	#9,d0                            	| [cp   #9]
	jcs	l_0788                             	| [jr   c,l_0788]
	addq.b	#1,d0                           	| [inc  a]
	jne	l_078E                             	| [jr   nz,l_078E]
	subq.w	#1,a0                           	| [dec  l]
	subq.w	#1,a1                           	| [dec  e]
	subq.b	#1,d1                           	| [...]
	jne	l_0771                             	| [djnz l_0771]
* else ... break
	jra	l_078E                             	| [jr   l_078E]

l_0788:
	move.b	(a1),d0                         	| [ld   a,(de)] hi score
	move.b	d0,(a0)                         	| [ld   (hl),a]
	subq.w	#1,a0                           	| [dec  l]
	subq.w	#1,a1                           	| [dec  e]
	subq.b	#1,d1                           	| [...]
	jne	l_0788                             	| [djnz l_0788]

l_078E:
	move.b	#ixl,d0                         	| [ld   a,ixl]
	addq.b	#4,d0                           	| [add  a,#4]
	move.b	d0,d6                           	| [ld   l,a] 
	^^^ problem!
	move.b	(a0),d0                         	| [ld   a,(hl)]
	cmp.b	#0x24,d0                         	| [cp   #0x24]
	jne	l_0799                             	| [jr   nz,l_0799]
	clr.b	d0                               	| [xor  a]
l_0799:
	and.b	#0x3F,d0                         	| [and  #0x3F]
	rol.b	#1,d0                            	| [rlca]
	move.b	d0,d2                           	| [ld   c,a]
	rol.b	#2,d0                            	| [rlca] * 2
	add.b	d2,d0                            	| [add  a,c]
	move.b	d0,d2                           	| [ld   c,a]
	subq.w	#1,a0                           	| [dec  l]
	move.b	(a0),d0                         	| [ld   a,(hl)]
	cmp.b	#0x24,d0                         	| [cp   #0x24]
	jne	l_07A8                             	| [jr   nz,l_07A8]
	clr.b	d0                               	| [xor  a]
l_07A8:
	add.b	d2,d0                            	| [add  a,c]
	lea	ds_plyr_actv+_b_mcfg_bonus(pc),a0  	| [ld   hl,#ds_plyr_actv +_b_mcfg_bonus] &actv_plyr_state[0x1E] ... load at game start from $9980
	cmp.b	(a0),d0                          	| [cp   (hl)]
	beq.b	0f                               	| [...]
	rts                                    	| [ret  nz] [...]
0:
	move.b	w_mchn_cfg_bonus+0x01,d0        	| [ld   a,(w_mchn_cfg_bonus + 0x01)] looks like a bonus may be awarded.
	move.b	d0,d1                           	| [ld   b,a]
	and.b	#0x7F,d0                         	| [and  #0x7F]
	move.b	d0,d2                           	| [ld   c,a]
	move.b	(a0),d0                         	| [ld   a,(hl)] &actv_plyr_state[0x1E]
	cmp.b	d2,d0                            	| [cp   c]
	jcc	l_07BC                             	| [jr   nc,l_07BC]
	move.b	d2,d0                           	| [ld   a,c]
	jra	l_07BD                             	| [jr   l_07BD]

l_07BC:
	add.b	d1,d0                            	| [add  a,b] actv_plyr_state[0x1E] += mchn_cfg_bonus[1]
l_07BD:
	move.b	d0,(a0)                         	| [ld   (hl),a]
	move.b	d0,b_9AA0+0x0A                  	| [ld   (b_9AA0 + 0x0A),a] sound-fx count/enable registers, bonus ship awarded sound (set non-zero)
	lea	ds_plyr_actv+_b_nships(pc),a0      	| [ld   hl,#ds_plyr_actv +_b_nships]
	addq.b	#1,(a0)                         	| [inc  (hl)]
	jbsr	draw_resv_ships                   	| [call draw_resv_ships] new spare ship added
	lea	b16_99EA_bonus_ct_bcd+1(pc),a0     	| [ld   hl,#b16_99EA_bonus_ct_bcd + 1]
	move.b	(a0),d0                         	| [ld   a,(hl)]
	addq.b	#1,d0                           	| [add  a,#1]
daa
	move.b	d0,(a0)                         	| [ld   (hl),a]
	bcs.b	0f                               	| [...]
      ^^^^^^ TODO: review cpu flags (move.b,bcs.b)
	rts                                    	| [ret  nc] [...]
0:
			                           	| [dec  l]
	move.b	-(a0),d0                         	| [ld   a,(hl)]
	addq.b	#1,d0                           	| [add  a,#1]
daa
	move.b	d0,(a0)                         	| [ld   (hl),a]
	rts                                    	| [ret]
* end call $0728

*=============================================================================
* c_scoreman_incr_add()
*  Description:
*   Handle score increment (score manager)
*   Score is not stored other than in character ram, so this function is
*   specific to the layout of decimal digits in the character map.
* IN:
*  A == scoreman_inc_lut[B-1]
*  HL== destination address ... _tile_ram + 0x0300
* OUT:
*
* PRESERVES:
*  HL
*-----------------------------------------------------------------------------
c_scoreman_incr_add:
	tst.b	d0                               	| [and  a]
	bne.b	0f                               	| [...]
	rts                                    	| [ret  z] [...]
0:

	add.b	(a0),d0                          	| [add  a,(hl)] a += _tile_ram[hl]
	cmp.b	#0x24,d0                         	| [cp   #0x24] $23=='Z', $24==' '
	jcs	l_07E1                             	| [jr   c,l_07E1]
	sub.b	#0x24,d0                         	| [sub  #0x24] when is jr not taken?

l_07E1:
	cmp.b	#0x0A,d0                         	| [cp   #0x0A] $0A='A'
	jcc	l_07E7                             	| [jr   nc,l_07E7]
	move.b	d0,(a0)                         	| [ld   (hl),a]
	rts                                    	| [ret]

l_07E7:
	sub.b	#0x0A,d0                         	| [sub  #0x0A]

l_07E9_while_1:
	move.b	d0,(a0)+                         	| [ld   (hl),a] 0x8000[hl] = a

	                           	| [inc  l]
	move.b	(a0),d0                         	| [ld   a,(hl)] a = 0x8000[hl + 1]
	cmp.b	#0x24,d0                         	| [cp   #0x24] $24==' '
	jne	l_07F1                             	| [jr   nz,l_07F1]
	clr.b	d0                               	| [xor  a]

l_07F1:
	cmp.b	#0x09,d0                         	| [cp   #0x09]
	jeq	l_07F8_while                       	| [jr   z,l_07F8_while]

	addq.b	#1,d0                           	| [inc  a]
	move.b	d0,(a0)                         	| [ld   (hl),a] 0x8000[hl] = a
	rts                                    	| [ret] end call 07d8

l_07F8_while:
	clr.b	d0                               	| [xor  a]
	jra	l_07E9_while_1                     	| [jr   l_07E9_while_1]

*=============================================================================
* Base-factors of points awareded for enemy hits, applied to multiples
* reported via _bug_collsn[]. Values are BCD-encoded, and ordered by object
* color group, i.e. as per _bug_collsn.
* Indexing is reversed, probably to take advantage of djnz.
* Index $00 is a base factor of 10 for challenge-stage bonuses to which a
* variable bonus-multiplier is applied (_bug_collsn[$0F]).
d_scoreman_inc_lut:
	.byte 0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00
	.byte 0x50,0x08,0x08,0x08,0x05,0x08,0x15,0x00

*=============================================================================
* gctl_supv_stage()
*  Description:
*   from _0461 game runner inf loop.
*   Checks for conditions indicating start of new stage or restart of
*   stage-in-progress.
*   0 bugs remaining indicates that a new-stage start is in order. (also 9008?)
*   Otherwise, the "restart_stage_flag" may indicate that the players active
*   ship has been terminated or captured requiring a stage re-start.
* IN:
*  ...
* OUT:
*  ...
*-----------------------------------------------------------------------------
gctl_supv_stage:

*  if ( num_bugs == 0  &&  !f_2916 active ) ...
	move.b	ds_cpu0_task_actv+0x08,d0       	| [ld   a,(ds_cpu0_task_actv + 0x08)] f_2916 (supervises attack waves)
	move.b	d0,d1                           	| [ld   b,a]
	move.b	b_bugs_actv_nbr,d0              	| [ld   a,(b_bugs_actv_nbr)]
	or.b	d1,d0                             	| [or   b]
	jne	l_081B                             	| [jr   nz,l_081B]
* then ...
	move.b	d0,b_9AA0+0x00                  	| [ld   (b_9AA0 + 0x00),a] 0 ... sound-fx count/enable registers, pulsing formation sound effect

	jra	gctl_stg_restart_hdlr              	| [jp   gctl_stg_restart_hdlr] cleared the round ... num_bugs_on_screen ==0|| !f_2916_active

l_081B:
* else if ( rst_stage_flag ) ...
	move.b	ds_9200_glbls+0x13,d0           	| [ld   a,(ds_9200_glbls + 0x13)] restart stage flag
	                               	| [and  a]
	bne.b	0f                               	| [...]
	rts                                    	| [ret  z] not the end of the stage, and not restart_stage event [...]
0:
* then ...
	clr.b	d0                               	| [xor  a]
	move.b	d0,ds_plyr_actv+_b_atk_wv_enbl  	| [ld   (ds_plyr_actv +_b_atk_wv_enbl),a] 0 ... restart_stage_flag has been set

	jra	gctl_stg_restart_hdlr              	| [jp   gctl_stg_restart_hdlr] restart_stage_flag has been set


*=============================================================================
* f_0827()
*  Description:
*   empty task
* IN:
*  ...
* OUT:
*  ...
*-----------------------------------------------------------------------------
f_0827:
	rts                                    	| [ret]

*=============================================================================
* f_0828()
*  Description:
*   Copies from sprite "buffer" to sprite RAM...
*   works in conjunction with CPU-sub1:_05BF to update sprite RAM
* IN:
*  ...
* OUT:
*  ...
*-----------------------------------------------------------------------------
f_0828:
	move.b	#1,d0                           	| [ld   a,#1]
	move.b	d0,b_CPU1_in_progress           	| [ld   (b_CPU1_in_progress),a] 1
	lea	mrw_sprite_code+0x40(pc),a0        	| [ld   hl,#mrw_sprite_code + 0x40]
	lea	sfr_sprite_code+0x40(pc),a1        	| [ld   de,#sfr_sprite_code + 0x40]
	move.b	#0x00,d1                        	| [ld   bc,#0x0040] 64
	move.b	#0x40,d2                        	| [ld   bc,#0x0040] 64
	jbsr	ldir                              	| [ldir]
     ^^^^ TODO: review special instruction inputs
	lea	mrw_sprite_posn+0x40(pc),a0        	| [ld   hl,#mrw_sprite_posn + 0x40]
	lea	sfr_sprite_posn+0x40(pc),a1        	| [ld   de,#sfr_sprite_posn + 0x40]
	move.b	#0x40,d2                        	| [ld   c,#0x40]
	jbsr	ldir                              	| [ldir]
     ^^^^ TODO: review special instruction inputs
	lea	mrw_sprite_ctrl+0x40(pc),a0        	| [ld   hl,#mrw_sprite_ctrl + 0x40]
	lea	sfr_sprite_ctrl+0x40(pc),a1        	| [ld   de,#sfr_sprite_ctrl + 0x40]
	move.b	#0x40,d2                        	| [ld   c,#0x40]
	jbsr	ldir                              	| [ldir]
     ^^^^ TODO: review special instruction inputs
	clr.b	d0                               	| [xor  a]
	move.b	d0,b_CPU1_in_progress           	| [ld   (b_CPU1_in_progress),a] 0
l_0850:
	move.b	b_CPU2_in_progress,d0           	| [ld   a,(b_CPU2_in_progress)] check status of other CPU... while (b_CPU2_in_progress) == $01 ...
	subq.b	#1,d0                           	| [dec  a]
	jeq	l_0850                             	| [jr   z,l_0850] wait
	rts                                    	| [ret]
* end task $0828

*=============================================================================
* f_0857()
*  Description:
*    triggers various parts of gameplay based on parameters
* IN:
*  ...
* OUT:
*  ...
*-----------------------------------------------------------------------------
f_0857:
	move.b	ds4_game_tmrs+2,d0              	| [ld   a,(ds4_game_tmrs + 2)]
	move.b	d0,d1                           	| [ld   b,a] parameter to c_08AD
	cmp.b	#0x3C,d0                         	| [cp   #0x3C]
	jcc	l_0865                             	| [jr   nc,l_0865]
* increases allowable max_bombers after a time
	move.b	ds_new_stage_parms+0x05,d0      	| [ld   a,(ds_new_stage_parms + 0x05)]
	move.b	d0,ds_new_stage_parms+0x04      	| [ld   (ds_new_stage_parms + 0x04),a] new_stage_parms[4] = new_stage_parms[5] ... max bombers

* set bomb drop enable flags
l_0865:
	move.b	b_bugs_actv_nbr,d0              	| [ld   a,(b_bugs_actv_nbr)]
	move.b	d0,d2                           	| [ld   c,a] parameter to c_08BE
	move.b	ds_new_stage_parms+0x00,d0      	| [ld   a,(ds_new_stage_parms + 0x00)] set bomb drop enable flags
	lea	d_0909+0*4(pc),a0                  	| [ld   hl,#d_0909 + 0 * 4]
	jbsr	c_08BE                            	| [call c_08BE] A==new_stage_parms[0], HL==d_0909, C==num_bugs_on_scrn
	move.b	d0,b_92C0+0x08                  	| [ld   (b_92C0 + 0x08),a] = c_08BE() ... bomb drop enable flags

* flag indicates number of flying aliens is less than new_stage_parm[7]
* if flag is set by sub-CPU tasking kernel ...
	move.b	b_92A0+0x0A,d0                  	| [ld   a,(b_92A0 + 0x0A)] continuous bombing when flag set
	                               	| [and  a]
	jeq	l_0888                             	| [jr   z,l_0888]

* then ... set default start values for bomber launch timers in continuous bombing state
* this will also happen momentarily at start of round until bugs_actv_nbr exceeds ds_new_stage_parms[0x07]
	lea	b_92C0+0x04(pc),a0                 	| [ld   hl,#b_92C0 + 0x04] memset( b_92C0_4, 2, 3 )
	move.b	#2,d0                           	| [ld   a,#2]
	move.b	#3,d1                           	| [ld   b,#3]
	jbsr	rst_18                            	| [rst  0x18] memset((HL), A=fill, B=ct)

	clr.b	d0                               	| [xor  a]
	move.b	d0,b_9AA0+0x00                  	| [ld   (b_9AA0 + 0x00),a] 0 ... sound-fx count/enable registers, kill pulsing sound effect (free-fly)
	rts                                    	| [ret]

l_0888:
* ... else after bugs_actv_nbr exceeds parameter_7 until continous bombing begins
	move.b	ds_new_stage_parms+0x01,d0      	| [ld   a,(ds_new_stage_parms + 0x01)]
	lea	d_0909+8*4(pc),a0                  	| [ld   hl,#d_0909 + 8 * 4] offset the data pointer
	jbsr	c_08BE                            	| [call c_08BE] A==new_stage_parms[1], HL==d_0929, C==num_bugs_on_scrn
	move.b	d0,b_92C0+0x04                  	| [ld   (b_92C0 + 0x04),a] c_08BE() ... boss alien default bomber timer

	move.b	ds_new_stage_parms+0x02,d0      	| [ld   a,(ds_new_stage_parms + 0x02)]
	lea	d_08CD(pc),a0                      	| [ld   hl,#d_08CD]
	jbsr	c_08AD                            	| [call c_08AD] A==new_stage_parms[2], HL==d_08CD
	move.b	d0,b_92C0+0x05                  	| [ld   (b_92C0 + 0x05),a] c_08AD() ... red alien default bomber timer

	move.b	ds_new_stage_parms+0x03,d0      	| [ld   a,(ds_new_stage_parms + 0x03)]
	lea	d_08EB(pc),a0                      	| [ld   hl,#d_08EB]
	jbsr	c_08AD                            	| [call c_08AD] A==new_stage_parms[3], HL==d_08EB
	move.b	d0,b_92C0+0x06                  	| [ld   (b_92C0 + 0x06),a] c_08AD() ... yellow alien default bomber timer

	rts                                    	| [ret]

*=============================================================================
* c_08AD()
*  Description:
*  for f_0857
* IN:
*  A == ds_new_stage_parms[2] or [3]
*  B == ds4_game_tmrs[2]
*  HL == d_08CD or d_08EB
* OUT:
*  A == (hl)
*-----------------------------------------------------------------------------
c_08AD:
* HL += 3 * A ... index into groups of 3 bytes
	move.b	d0,d4                           	| [ld   e,a]
	asl.b	#1,d0                            	| [sla  a]
	add.b	d4,d0                            	| [add  a,e]
	jbsr	rst_10                            	| [rst  0x10] HL += A

	move.b	d1,d0                           	| [ld   a,b] ds4_game_tmrs[2] from f_0857
	cmp.b	#0x28,d0                         	| [cp   #0x28]
	jcc	l_08B8                             	| [jr   nc,l_08B8]
	addq.w	#1,a0                           	| [inc  hl]
l_08B8:
	tst.b	d0                               	| [and  a]
	jne	l_08BC                             	| [jr   nz,l_08BC]
	addq.w	#1,a0                           	| [inc  hl]
l_08BC:
	move.b	(a0),d0                         	| [ld   a,(hl)]
	rts                                    	| [ret]
* end 'call _08AD'

*=============================================================================
* c_08BE()
*  Description:
*   for f_0857
* IN:
*  A==ds_new_stage_parms + 0x00 or ds_new_stage_parms + 0x01
*  C==bugs_actv_nbr
*  HL== pointer _0909, _0929
* OUT:
*  A==(hl)
*-----------------------------------------------------------------------------
c_08BE:
* A used as index into sets of 4
* 16-bit division not needed here, but slightly more efficient to load the
* dividend into upper byte of HL and take quotient from H
* the quotient is ranged 0-4, so in the case the A max out at 7 and number
* of creatures is 40, the selected byte would be at $0929, so d_0909 and
* d_0929 should be one contiguous table.
	asl.b	#1,d0                            	| [sla  a]
	jbsr	rst_08                            	| [rst  0x08] HL += 2A
	exg	a1,a0                              	| [ex   de,hl]
	move.b	d2,d5                           	| [ld   h,c]
	move.b	#0x0A,d0                        	| [ld   a,#0x0A]
	jbsr	c_divmod                          	| [call c_divmod] HL=HL/10
	exg	a1,a0                              	| [ex   de,hl] 8-bit quotient into d ...
	move.b	d3,d0                           	| [ld   a,d] ... quotient into a
	jbsr	rst_10                            	| [rst  0x10] HL += A
	move.b	(a0),d0                         	| [ld   a,(hl)]
	rts                                    	| [ret]

*=============================================================================
* sets of 3 bytes indexed by stage parameters 2 and 3 (max value 9)
d_08CD:
	.byte 0x09,0x07,0x05
	.byte 0x08,0x06,0x04
	.byte 0x07,0x05,0x04
	.byte 0x06,0x04,0x03
	.byte 0x05,0x03,0x03
	.byte 0x04,0x03,0x03
	.byte 0x04,0x02,0x02
	.byte 0x03,0x03,0x02
	.byte 0x03,0x02,0x02
	.byte 0x02,0x02,0x02
d_08EB:
	.byte 0x06,0x05,0x04
	.byte 0x05,0x04,0x03
	.byte 0x05,0x03,0x03
	.byte 0x04,0x03,0x02
	.byte 0x04,0x02,0x02
	.byte 0x03,0x03,0x02
	.byte 0x03,0x02,0x01
	.byte 0x02,0x02,0x01
	.byte 0x02,0x01,0x01
	.byte 0x01,0x01,0x01

* sets of 4 bytes indexed by stage parameters 0 and 1 (max value 7)
d_0909:
	.byte 0x03,0x03,0x01,0x01
	.byte 0x03,0x03,0x03,0x01
	.byte 0x07,0x03,0x03,0x01
	.byte 0x07,0x03,0x03,0x03
	.byte 0x07,0x07,0x03,0x03
	.byte 0x0F,0x07,0x03,0x03
	.byte 0x0F,0x07,0x07,0x03
	.byte 0x0F,0x07,0x07,0x07
*d_0929:
	.byte 0x06,0x0A,0x0F,0x0F
	.byte 0x04,0x08,0x0D,0x0D
	.byte 0x04,0x06,0x0A,0x0A

*=============================================================================
* f_0935()
*  Description:
*    handle "blink" of Player1/Player2 texts.
*    Toggles the "UP" text on multiples of 16 frame counts.
*    With frame counter being about 60hz, we should get a blink of
*    about twice per second.
* IN:
*  ...
* OUT:
*  ...
*-----------------------------------------------------------------------------
f_0935:
*  A = ds3_92A0_frame_cts[0] / 16
	move.b	ds3_92A0_frame_cts+0,d0         	| [ld   a,(ds3_92A0_frame_cts + 0)]
	rol.b	#4,d0                            	| [rlca] * 4

*=============================================================================
* gctl_1up2up_displ()
*  Description:
*   Blink 1UP/2UP
* IN:
*   A==0 ... called by game_halt()
*   A==frame_cnts/16 ...continued from f_0935()
* OUT:
*  ...
*-----------------------------------------------------------------------------
c_093C:
	move.b	d0,d2                           	| [ld   c,a] stash counter in C

* if ( game_state != IN_GAME_MODE )  return
	move.b	b8_9201_game_state,d0           	| [ld   a,(b8_9201_game_state)] if ( ! IN_GAME )
	cmp.b	#3,d0                            	| [cp   #3]
	beq.b	0f                               	| [...]
	rts                                    	| [ret  nz] [...]
0:

* B = ds_plyr_actv.p1or2
* (9820[] has not cleared yet so plyr_state.p1or2 may be invalid at first game start after powerup.)
	move.b	ds_plyr_actv+_b_plyr_nbr,d0     	| [ld   a,(ds_plyr_actv +_b_plyr_nbr)] 0==plyr1, 1==plyr2
	move.b	d0,d1                           	| [ld   b,a] stash it in B

* do 1UP
	not.b	d0                               	| [cpl] toggle to 1 if 1UP

	and.b	d2,d0                            	| [and  c] C == 1 if wipe
	lea	str_1UP(pc),a0                     	| [ld   hl,#str_1UP]
	lea	0x8000+0x03C0+0x19(pc),a1      	| [ld   de,#0x8000 + 0x03C0 + 0x19] 'P' of 1UP
	jbsr	c_095F                            	| [call c_095F] wipe if A != 0

* if ( two_plyr_game ) then ...
	move.b	b8_99B3_two_plyr_game,d0        	| [ld   a,(b8_99B3_two_plyr_game)]
	                               	| [and  a]
	bne.b	0f                               	| [...]
	rts                                    	| [ret  z] [...]
0:

* ... do 2UP
	move.b	d1,d0                           	| [ld   a,b] 1 if 2UP
	and.b	d2,d0                            	| [and  c] C == 1 if wipe
	lea	str_2UP(pc),a0                     	| [ld   hl,#str_2UP]
	lea	0x8000+0x03C0+0x04(pc),a1      	| [ld   de,#0x8000 + 0x03C0 + 0x04] 'P' of 2UP
*       call c_095F

*=============================================================================
* c_095F()
*  Description:
*   draw 3 characters
* IN:
*  A==1 ...  wipe text
*  A==0 ...  show text at HL
*  HL == src pointer, xUP text
*  DL == dest pointer
* OUT:
* PRESERVES:
*  BC
*-----------------------------------------------------------------------------
c_095F:
	movem.w	d1/d2,-(sp)                    	| [push bc]

	and.b	#0x01,d0                         	| [and  #0x01]
	jeq	l_0967                             	| [jr   z,l_0967]
	lea	str_0974(pc),a0                    	| [ld   hl,#str_0974] wipe
l_0967:
	                        	| [ld   bc,#0x0003] 3
	move.w	#0x03,d1                        	| [ld   bc,#0x0003] 3
	jbsr	ldir                              	| [ldir]


	movem.w	(sp)+,d1/d2                    	| [pop  bc]
	rts                                    	| [ret]

*=============================================================================
str_1UP:
	.byte 0x19,0x1E,0x01                          | "PU1"
str_2UP:
	.byte 0x19,0x1E,0x02                          | "PU2"
str_0974:
	.byte 0x24,0x24,0x24                         | "spaces"

*=============================================================================
* f_0977()
*  Description:
*   Polls the test switch, updates game-time counter, updates credit count.
*   Handles coinage and changes in game-state.
*
*    If credit > 0, change _game_state to Push_start ($02)
*     (causes 38d loop to transition out of the Attract Mode, if it's not already in PUSH_START mode)
*
*    Check Service Switch - in "credit mode", the 51xx is apparently programmed
*      to set io_buffer[0]=$bb to indicate "Self-Test switch ON position" .
*      So, ignore the credit count and jump back to the init.
*      Bally manual states that "may begin a Self-Test at any time by sliding the
*      ... switch to the "ON" position...the game will react as follow: ... there is
*     an explosion sound...upside down test display which lasts for about 1/2 second"
*    However MAME may not handle this correctly - after the jump to Machine_init, the
*    system hangs up on the info screen, all that is shown is "RAM OK". (This is
*    true even if the switch is turned off again prior to that point).
*
*    Note mapping of character cells on bottom (and top) rows differs from
*    that of the rest of the screen;
*      801D-<<<<<<<<<<<<<<<<<<<<<<<<<<<<-8002
*      803d-<CREDIT __<<<<<<<<<<<<<<<<<<-8022
*
*    99E6-9 implements a count in seconds of total accumulated game-playing time.
*    counter (low digit increments 1/60th of second)
*
*    Credits available count (from HW IO) is transferred to the IO input
*    buffer (in BCD) in the NMI, and represent actual credits awarded (not
*    coin-in count). The HW count is decremented by the HW. The game logic
*    then must keep its own count to compare to the HW to determine if the
*    HW count has been added or decremented and thus determine game-start
*    condition and number of player credits debited from the HW count.
* IN:
*  ...
* OUT:
*  ...
*-----------------------------------------------------------------------------
f_0977:
* if ( io_input[0] == $bb )
	move.b	ds3_99B5_io_input+0x00,d0       	| [ld   a,(ds3_99B5_io_input + 0x00)] check for bb ... Service Switch On indication in credit mode
	cmp.b	#0xBB,d0                         	| [cp   #0xBB]
	jeq	jp_RAM_test                        	| [jp   z,jp_RAM_test]

* if ( game_state != IN_GAME_MODE )  // goto update freeplay_or_credit
	move.b	b8_9201_game_state,d0           	| [ld   a,(b8_9201_game_state)] if ( IN_GAME )
	cmp.b	#3,d0                            	| [cp   #3] game_state==IN_GAME
	jne	l_099F_update_freeplay_or_credit   	| [jr   nz,l_099F_update_freeplay_or_credit]

* else // update timer
	lea	b32_99E6_gametime_secs_bcd+3(pc),a0	| [ld   hl,#b32_99E6_gametime_secs_bcd + 3] least-sig. digit increments 1/60th of second
	move.b	(a0),d0                         	| [ld   a,(hl)]
	addq.b	#1,d0                           	| [add  a,#1]
daa
       * if ( ct == $60 ) ct=0
	cmp.b	#0x60,d0                         	| [cp   #0x60] if A==60, Cy is not set...
	jne	l_0992_update_counter              	| [jr   nz,l_0992_update_counter]
	clr.b	d0                               	| [xor  a]

      * update 4 bytes of the timer (BCD count 0 - 99.99.99.60)
l_0992_update_counter:
	move.b	#4,d1                           	| [ld   b,#4]

	INVERT_XC_FLAGS                        	| [ccf] ... compliment Cy (provides Cy into 1's place if A==60...
l_0995:
	move.b	d0,(a0)                         	| [ld   (hl),a] Update 60'ths digit.
	                           	| [dec  l]
 	move.b	-(a0),d0                         	| [ld   a,(hl)] note, last iteration, reads from 99e5, but then exits the loop.
adc  a,#0                                  ; ...carry into 1's, 10's, or 100's place.
daa
	subq.b	#1,d1                           	| [...]
	jne	l_0995                             	| [djnz l_0995]

	jra	l_09E1_update_game_state           	| [jr  l_09E1_update_game_state] skip display of "CREDIT" when in Game Mode

l_099F_update_freeplay_or_credit:

	move.b	b8_99B8_credit_cnt,d0           	| [ld   a,(b8_99B8_credit_cnt)] if free-play == $A0  i.e. > 99 (BCD)
	cmp.b	#0xA0,d0                         	| [cp   #0xA0]

	lea	0x8000+0x0000+0x3C(pc),a1      	| [ld   de,#0x8000 + 0x0000 + 0x3C] dest of "C" of "CREDIT"

* if (credit_cnt == 0xA0 )  // goto puts_freeplay ...  i.e. > 99 (BCD)
	jeq	l_09D9_puts_freeplay               	| [jr   z,l_09D9_puts_freeplay] skip credits status

* else if (credit_cnt < 0xA0 )  // do credit update display
	move.b	ds3_99B5_io_input+0x00,d0       	| [ld   a,(ds3_99B5_io_input + 0x00)] io_input[credit_count]

       * puts "credit"
	lea	str_09CA+6-1(pc),a0                	| [ld   hl,#str_09CA + 6 - 1] source of 'C' in reversed string
	move.b	#0x00,d1                        	| [ld   bc,#0x0006] strlen(strCredit) 6
	move.b	#0x06,d2                        	| [ld   bc,#0x0006] strlen(strCredit) 6
lddr
       * leave the "space" following the 'T'
	subq.b	#1,d4                           	| [dec  e] de-- advances one cell to the right (note: bottom row, so not de-20!)

       * if bcd_credit_ct > 9, then rotate "10's" nibble into lower nibble and display it.
	move.b	d0,d2                           	| [ld   c,a] save temp hw credit count
	rol.b	#4,d0                            	| [rlca] * 4
	and.b	#0x0F,d0                         	| [and  #0x0F] only upper digit of BCD credit cnt
	jeq	l_09C0_putc_ones_place_digit       	| [jr   z,l_09C0_putc_ones_place_digit]

	move.b	d0,(a1)                         	| [ld   (de),a] putc 10's place digit.
	subq.b	#1,d4                           	| [dec  e] next character position to the right ... 1's place digit

l_09C0_putc_ones_place_digit:
	move.b	d2,d0                           	| [ld   a,c] reload saved hw count
	and.b	#0x0F,d0                         	| [and  #0x0F] only lower digit of BCD credit cnt
	move.b	d0,(a1)                         	| [ld   (de),a] putc 1's place digit.
       * one more space to be sure two cells are covered.
	subq.b	#1,d4                           	| [dec  e]
	move.b	#0x24,d0                        	| [ld   a,#0x24]
	move.b	d0,(a1)                         	| [ld   (de),a]

	jra	l_09E1_update_game_state           	| [jr   l_09E1_update_game_state]

*=============================================================================

str_09CA:
* "CREDIT" (reversed)
	.byte 0x1D,0x12,0x0D,0x0E,0x1B,0x0C
str_09D0:
* "FREE PLAY" (reversed)
	.byte 0x22,0x0A,0x15,0x19,0x24,0x0E,0x0E,0x1B,0x0F


l_09D9_puts_freeplay:
	lea	str_09D0+9-1(pc),a0                	| [ld   hl,#str_09D0 + 9 - 1] load src (last byte) of string "FREE PLAY"
	move.b	#0x00,d1                        	| [ld   bc,#0x0009] 9
	move.b	#0x09,d2                        	| [ld   bc,#0x0009] 9
lddr

l_09E1_update_game_state:

* if ( game_state == GAME_ENDED ) return
	move.b	b8_9201_game_state,d0           	| [ld   a,(b8_9201_game_state)] if Game Ended
	                               	| [and  a]
	bne.b	0f                               	| [...]
	rts                                    	| [ret  z] 0==GAME_ENDED [...]
0:

* else if ( game_state == ATTRACT_MODE && io_input[credit_count] > 0 )
	subq.b	#1,d0                           	| [dec  a] ATTRACT_MODE - 1 ==0
	jne	l_09FF_check_credits_used          	| [jr   nz,l_09FF_check_credits_used] if (!ATTRACT_MODE)

	move.b	ds3_99B5_io_input+0x00,d0       	| [ld   a,(ds3_99B5_io_input + 0x00)] io_input[credit_count]
	                               	| [and  a]
	jeq	l_09FF_check_credits_used          	| [jr   z,l_09FF_check_credits_used] if io_credit_count == 0

* then {
*   game_state = READY_TO_PLAY_MODE
	move.b	#2,d0                           	| [ld   a,#2]
	move.b	d0,b8_9201_game_state           	| [ld   (b8_9201_game_state),a] READY_TO_PLAY ...push start to begin!

       * memset($9AA0,0,8)
	clr.b	d0                               	| [xor  a]
	lea	ds_9AA0+0x00(pc),a0                	| [ld   hl,#ds_9AA0 + 0x00] clear sound-fx count/enable registers (9AA0...9AA7)
	move.b	#8,d1                           	| [ld   b,#8]
	jbsr	rst_18                            	| [rst  0x18] memset((HL), A=fill, B=ct)
       * memset($9AA0+8+1,0,15)
	addq.b	#1,d6                           	| [inc  l] hl = $9AA0+9, sound-fx cnt/enable regs, 15 bytes, skipped 9AA0[8] (coin-in)
	move.b	#0x0F,d1                        	| [ld   b,#0x0F]
	jbsr	rst_18                            	| [rst  0x18] memset((HL), A=fill, B=ct)
* }

l_09FF_check_credits_used:

* A = credits_counted - io_input[credit_count]  ... credits_used
* if ( A == 0 )  return
	move.b	ds3_99B5_io_input+0x00,d0       	| [ld   a,(ds3_99B5_io_input + 0x00)] io_input[credit_count] ... in BCD!
	move.b	d0,d2                           	| [ld   c,a]
	move.b	b8_99B8_credit_cnt,d0           	| [ld   a,(b8_99B8_credit_cnt)] BCD
	move.b	d0,d1                           	| [ld   b,a] stash the previous credit count
	sub.b	d2,d0                            	| [sub  c]
	bne.b	0f                               	| [...]
	rts                                    	| [ret  z] return if no change of game state [...]
0:

* else  if (io_input[credit_count] > credit_cnt)  goto _update_credit_ct ...
	jcs	l_0A1A_update_credit_ct            	| [jr   c,l_0A1A_update_credit_ct] Cy is set (credit_hw > credit_ct)

* else  ... if (io_input[credit_count] < credit_cnt) {

*   two_plyr_game = credits_used - 1
daa                                        ; A == credits_used ... corrected for arithmentic with BCD operands
	subq.b	#1,d0                           	| [dec  a]
	move.b	d0,b8_99B3_two_plyr_game        	| [ld   (b8_99B3_two_plyr_game),a] 0 for 1P, 1 for 2P

*   credit_cnt = io_input[credit_count]
	move.b	d2,d0                           	| [ld   a,c]
	move.b	d0,b8_99B8_credit_cnt           	| [ld   (b8_99B8_credit_cnt),a] io_input[credit_count]

*   game_state = IN_GAME_MODE
	move.b	#3,d0                           	| [ld   a,#3]
	move.b	d0,b8_9201_game_state           	| [ld   (b8_9201_game_state),a] 3 (IN_GAME)

	rts                                    	| [ret]
* }

* ...  credits_countd_hw > credit_count_sw
l_0A1A_update_credit_ct:
* credit_cnt = io_input[credit_count]
	move.b	d2,d0                           	| [ld   a,c] C==credits_countd_hw (from above)
	move.b	d0,b8_99B8_credit_cnt           	| [ld   (b8_99B8_credit_cnt),a] credits_countd_hw

* no coin_in sound for free-play
* if ( credit_cnt == $A0 )  return
	cmp.b	#0xA0,d0                         	| [cp   #0xA0]
	bne.b	0f                               	| [...]
	rts                                    	| [ret  z] [...]
0:
* else ... set global credit count for sound-manager
	sub.b	d1,d0                            	| [sub  b] B==credit_ct_previous (from above)
daa
	move.b	d0,b_9A70+0x09                  	| [ld   (b_9A70 + 0x09),a] sndmgr, count of credits-in since last update (triggering coin-in sound)
	rts                                    	| [ret]


*=============================================================================
* c_mach_info_add_score()
*  Description:
*   Add player score(s) to total at end of game (called once for each player).
* IN:
*  DE = ptr to 10's place digit of score in tile RAM.
* OUT:
*  ...
*-----------------------------------------------------------------------------
c_mach_info_add_score:
*  first part packs the 5 digits of the score into BCD using 4 bytes (ones omitted)
	lea	ds_9100_tmp+0x03(pc),a0            	| [ld   hl,#ds_9100_tmp + 0x03] 3 bytes, workspace for converting score to BCD (temporary)
	move.b	#5,d1                           	| [ld   b,#5]
l_0A2C:
	move.b	(a1)+,d0                         	| [ld   a,(de)]
	                           	| [inc  e]
*  if ( char != $24 ) goto 0a33  // if space, then a:=0
	cmp.b	#0x24,d0                         	| [cp   #0x24] space character
	jne	l_0A33                             	| [jr   nz,l_0A33]
	clr.b	d0                               	| [xor  a]
l_0A33:
	jbsr	rrd                               	| [rrd]
     ^^^^ TODO: review special instruction inputs
	btst.b	#0,d1                           	| [bit  0,b]
	jne	l_0A3A                             	| [jr   nz,l_0A3A]
	subq.w	#1,a0                           	| [dec  l]
l_0A3A:
	subq.b	#1,d1                           	| [...]
	jne	l_0A2C                             	| [djnz l_0A2C]

	clr.b	d0                               	| [xor  a]
	jbsr	rrd                               	| [rrd] one more rrd to fix the last digit
     ^^^^ TODO: review special instruction inputs
	subq.w	#1,a0                           	| [dec  l]
	clr.b	(a0)                             	| [ld   (hl),#0] *9100:=0 (score is now "00054321")
	move.b	#3,d6                           	| [ld   l,#3] HL:=9103
	^^^^ TODO adjust
	lea	b32_99E2_sum_score_bcd+3(pc),a1    	| [ld   de,#b32_99E2_sum_score_bcd + 3]
	move.b	#0x04,d1                        	| [ld   b,#0x04]
	tst.b	d0                               	| [and  a] clear the carry flag?
l_0A4A:
	move.b	(a1),d0                         	| [ld   a,(de)]
adc  a,(hl)
daa
	move.b	d0,(a1)                         	| [ld   (de),a]
	subq.w	#1,a1                           	| [dec  e]
	subq.w	#1,a0                           	| [dec  l]
	subq.b	#1,d1                           	| [...]
	jne	l_0A4A                             	| [djnz l_0A4A]

	rts                                    	| [ret]

*=============================================================================
* c_text_out_i_to_d_0A53()
*  Description:
*   Display an integer value as decimal.
* IN:
*   D5: input value (max $FFFF)
*   A1.W: points to destination.
* OUT:
*   A1.W: points to (destination - count * 0x40)
*-----------------------------------------------------------------------------
c_text_out_i_to_d_0A53:
	move.b	#1,d1                           	| [ld   b,#1] there is at least 1 digit ... (but maybe more)
l_0A55:
	LOAD_D5D6_FROM_D5_16
* check HL > 10 ... but we can only cp 8 bits in A, so we have to break HL into 2 bytes.
* while ( ( H > 0 )  ...
	subq.b	#1,d5                           	| [dec  h]
	addq.b	#1,d5                           	| [inc  h]
	jne	l_0A5E                             	| [jr   nz,l_0A5E]
* ...                                   	|| ( L > $0A ) )
	move.b	d6,d0                           	| [ld   a,l]
	cmp.b	#0x0A,d0                         	| [cp   #0x0A] CY is set if A < $0A

	jcs	l_0A68                             	| [jr   c,l_0A68]

* do: Convert next digit to the "left" (next higher power of 10).
l_0A5E:
	move.b	#0x0A,d0                        	| [ld   a,#0x0A]
	jbsr	c_divmod                          	| [call c_divmod] A=HL%10 (gets a "printable" decimal digit)
	move.w	d0,-(sp)                        	| [push af] converted digit returned in A and stacked.
	addq.b	#1,d1                           	| [inc  b] count of digits in converted decimal number.
	jra	l_0A55                             	| [jr   l_0A55]

* while ( b > 0 ) ... show digits from left to right
l_0A67:
	move.w	(sp)+,d0                        	| [pop  af]

l_0A68:
* display the value in A as a single decimal digit .. each DE-=$20 advances 1 character to the right
	jbsr	c_0A6E                            	| [call c_0A6E]
	subq.b	#1,d1                           	| [...]
	jne	l_0A67                             	| [djnz l_0A67]

	rts                                    	| [ret]

c_0A6E:
	jbsr	osd_w_videoram	             	| [ld   (de),a]
	sub.w	#0x20,d7
	rts
	
	                      	| [jp   rst_DEminus20] it will 'ret' from the jp.
* end 0a53

*=============================================================================
* hit_ratio()
*  Description:
*   Calculate and display hit/shot ratio.
* IN:
*  ...
* OUT:
*  DE == resultant pointer to screen ram to be used by caller
*-----------------------------------------------------------------------------
c_puts_hitmiss_ratio_0A72:

	move.w	ds_plyr_actv+_w_hit_ct(pc),d6   	| [ld   hl,(ds_plyr_actv +_w_hit_ct)]

* if ( shots fired  == 0 )
	move.w	ds_plyr_actv+_w_shot_ct(pc),d3  	| [ld   de,(ds_plyr_actv +_w_shot_ct)]
											| [ld   a,d]
												| [or   e]
	jne	l_0A82                             	| [jr   nz,l_0A82]
* then
								| [ld   de,#0x0000] uhh...isn't DE already 0? 0
	jra	l_0AD3                             	| [jr   l_0AD3]
* else
*   determine ratio: first, use left-shifts to up-scale the dividend and divisor
l_0A82:
l_0A82_while:
* while !(0x80 & d) && !(0x80 & h) de <<= 1, hl <<= 1
	btst.b	#15,d3                           	| [bit  7,d]
	jne	l_0A90                             	| [jr   nz,l_0A90]
	btst.b	#15,d6                           	| [bit  7,h]
	jne	l_0A90                             	| [jr   nz,l_0A90]
	add.w	d6,d6                            	| [add  hl,hl]
	exg	d3,d6                              	| [ex   de,hl]
	add.w	d6,d6                            	| [add  hl,hl]
	exg	d3,d6                              	| [ex   de,hl]
	jra	l_0A82_while                       	| [jr   l_0A82_while]

* do the actual division with resultant quotient scaled up by factor of 0x0100 to keep precision
l_0A90:
* HL = hl_adjusted_hits / (de_adjusted_shots / 0x0100)
	move.b	d3,d0                           	| [ld   a,d] divisor in A
	jbsr	c_divmod                          	| [call c_divmod] HL=HL/A (preserves DE)

	move.l	a0,-(sp)                        	| [push hl]

* HL = modulus / (de_adjusted_shots / 0x0100)
	move.b	d0,d5                           	| [ld   h,a] result of HL%A
	clr.b	d6                               	| [ld   l,#0]
	move.b	d3,d0                           	| [ld   a,d] divisor in A
	jbsr	c_divmod                          	| [call c_divmod] HL=HL/A (preserves DE)

* SP points to lsb of 1st quotient (msb)
	exg	(sp),a0                            	| [ex   (sp),hl] restore msw (1st quotient) into HL, lsw (2nd quotient) to (SP), (SP+1)
	lea	b16_99B0_tmp(pc),a1                	| [ld   de,#b16_99B0_tmp] pointer to hit-miss ratio calc.
	move.b	#4,d1                           	| [ld   b,#4] loop counter to calculate percentage to 2 decimal places
	move.b	d5,d0                           	| [ld   a,h] msb of msw (first quotient), only low 4 bits significant (would be 0 or 1)
	clr.b	d5                               	| [ld   h,#0] done with this byte
l_0AA5_while:
	exg	a1,a0                              	| [ex   de,hl] pointer->HL, lsb of HL+A -> DE
* 4-bit leftward rotation of the 12-bit number whose 4 most signigifcant bits
* are the 4 least significant bits of A, and its 8 least significant bits are at (HL)
	jbsr	rld                               	| [rld] rld (hl) ... 1st product msb + sum msb in A
     ^^^^ TODO: review special instruction inputs
* advance the byte pointer when b==3 (case of b==1 not significant)
	btst.b	#0,d1                           	| [bit  0,b]
	jeq	l_0AAD                             	| [jr   z,l_0AAD]
	addq.w	#1,a0                           	| [inc  l]
l_0AAD:
	exg	a1,a0                              	| [ex   de,hl] lsb of HL+A -> HL, pointer to DE
	jbsr	c_0B06                            	| [call c_0B06] HL *= 10 ... MSB->A
	scs	d7                              	| [ex   af,af'] stash 1st product msb
         ^^^ TODO review: wrong if carry is needed or D7 used in between!

	exg	(sp),a0                            	| [ex   (sp),hl] 2nd product to HL, 1st product to (SP)
	jbsr	c_0B06                            	| [call c_0B06] HL *= 10 ... MSB->A
	exg	(sp),a0                            	| [ex   (sp),hl] 1st product to HL, 2nd product to (SP)
	jbsr	rst_10                            	| [rst  0x10] HL += A ... 1st product + 2nd product (msb)
	scs	d7                              	| [ex   af,af'] 1st product msb -> A, stash sum lsb
         ^^^ TODO review: wrong if carry is needed or D7 used in between!
	add.b	d5,d0                            	| [add  a,h] 1st product msb + sum msb
	clr.b	d5                               	| [ld   h,#0] done with this byte
	subq.b	#1,d1                           	| [...]
	jne	l_0AA5_while                       	| [djnz l_0AA5_while]

	move.l	(sp)+,a1                        	| [pop  de] restore SP
	movem.w	(sp)+,d3/d4                    	| [pop  de] restore SP

* if (A >= 5)
	cmp.b	#5,d0                            	| [cp   #5]
	jcs	l_0AD7                             	| [jr   c,l_0AD7]
* then
	move.w	b16_99B0_tmp(pc),a1             	| [ld   de,(b16_99B0_tmp)] temp register for hit-miss ratio calc.
                  ^^^^^^ TODO: review move.w into address register
	move.b	d3,d0                           	| [ld   a,d] msb (99B1) ... but its really LSB
	addq.b	#1,d0                           	| [add  a,#1]
daa
	move.b	d0,d3                           	| [ld   d,a]
*  if
	jcc	l_0AD3                             	| [jr   nc,l_0AD3]
      ^^^^^^ TODO: review cpu flags (move.b,jcc)
*  then
	move.b	d4,d0                           	| [ld   a,e]
	addq.b	#1,d0                           	| [add  a,#1]
daa
	move.b	d0,d4                           	| [ld   e,a]
*  fi

l_0AD3:
	move.b	a1,b16_99B0_tmp                 	| [ld   (b16_99B0_tmp),de] tmp computed hit-miss ratio (BCD)
* setup for display of computed ratio
l_0AD7:
	move.b	#4,d1                           	| [ld   b,#4]
	clr.b	d2                               	| [ld   c,#0] use <:1> as flag
	lea	b16_99B0_tmp(pc),a0                	| [ld   hl,#b16_99B0_tmp] &hitratio.b0 (BCD)
	lea	0x8000+0x0120+0x18(pc),a1      	| [ld   de,#0x8000 + 0x0120 + 0x18]

* loop to putc 4 characters (XXX.X)
l_0AE1_while:
* if ( b==1 ) then ...
	subq.b	#1,d1                           	| [dec  b]
	jne	l_0AE8                             	| [jr   nz,l_0AE8]
* ... show dot character left of to 10ths place
	move.b	#0x2A,d0                        	| [ld   a,#0x2A] '.' (dot) character.
	move.b	d0,(a1)                         	| [ld   (de),a]
	jbsr	rst_20                            	| [rst  0x20] DE-=$20 (next column)

l_0AE8:
	addq.b	#1,d1                           	| [inc  b] restore B from test at l_0AE1

	clr.b	d0                               	| [xor  a] clear A before rotating H<7:4> into it
	jbsr	rld                               	| [rld] rld (hl) ... (HL<7:4>) to A<3:0> ... HL used as pointer
     ^^^^ TODO: review special instruction inputs

* if (b == 3                            	|| b==1) advance pointer to .b1  ... b==1 irrelevant
	btst.b	#0,d1                           	| [bit  0,b] even count of b
	jeq	l_0AF1                             	| [jr   z,l_0AF1]
	addq.w	#1,a0                           	| [inc  l] HL++
 
l_0AF1:
* line up the shots/hits/ratio on the left - once we have A!=0, latch the
* state and keep going
* if ( A != 0 )
	tst.b	d0                               	| [and  a]
	jne	l_0AF8                             	| [jr   nz,l_0AF8]
*                                       	|| (0 != C & 0x01) ...
	btst.b	#0,d2                           	| [bit  0,c] check flag
	jeq	l_0AFC                             	| [jr   z,l_0AFC]
* ... then
l_0AF8:
	bset.b	#0,d2                           	| [set  0,c] set flag
	move.b	d0,(a1)                         	| [ld   (de),a]
	jbsr	rst_20                            	| [rst  0x20] DE-=$20 (next column)

l_0AFC:
* b==3 is first digit left of decimal (10's place) so it has to start here regardless
* if ( B != 3 )
	move.b	d1,d0                           	| [ld   a,b]
	cmp.b	#3,d0                            	| [cp   #3]
	jne	l_0B03                             	| [jr   nz,l_0B03]
* else
	bset.b	#0,d2                           	| [set  0,c]
l_0B03:
	subq.b	#1,d1                           	| [...]
	jne	l_0AE1_while                       	| [djnz l_0AE1_while]

	rts                                    	| [ret]

*=============================================================================
* c_0B06()
*  Description:
*   multiply by 10
* IN:
*   HL = 16-bit factor
*   A  = 8-bit factor
* OUT:
*   HL = (HL * $0A) & 0x00FF
*    A = (HL * $0A) >> 8 ... MSB
*
*-----------------------------------------------------------------------------
c_0B06:
	move.b	#0x0A,d0                        	| [ld   a,#0x0A]
	jbsr	c_104E_mul_16_8                   	| [call c_104E_mul_16_8] HL = HL * A
	move.b	d5,d0                           	| [ld   a,h]
	clr.b	d5                               	| [ld   h,#0x00] %256
	rts                                    	| [ret]


_l_0B0F:
*          1000  c_1000

*
* input file gg1-2.s
*
* gg1-2.s
*  gg1-2.3m, 'maincpu' (Z80)
*
*  Utility functions, player and stage setup, text display.
*
*
.module borg

.include "sfrs.inc"
.include "structs.inc"
.include "gg1-2.dep"

*.area ROM (ABS,OVR)
*       .org 0x0FFF
*       .db 0x93                                   ; checksum
*       .org 0x1000
.area CSEG10


*=============================================================================
* c_1000()
*  Description:
*   for c_25A2
*   R register used as a randomizer?
* IN:
*  ...
* OUT:
*   A==random value
* PRESERVES:
*   HL
*-----------------------------------------------------------------------------
c_1000:

	move.l	a0,-(sp)                        	| [push hl]
	move.b	#r,d0                           	| [ld   a,r]
	move.b	d0,d5                           	| [ld   h,a]
	move.b	ds3_92A0_frame_cts+0,d0         	| [ld   a,(ds3_92A0_frame_cts + 0)]
	add.b	d5,d0                            	| [add  a,h]
	move.b	d0,d6                           	| [ld   l,a]
	lea	db_obj_home_posn_rc(pc),a0         	| [ld   h,#>db_obj_home_posn_rc]
	and.w	#0xFF,d6
	add.w	d6,a0
	      ^^^^ TODO: review XX value
	move.b	(a0),d0                         	| [ld   a,(hl)]
	move.b	d0,d5                           	| [ld   h,a]
	move.b	#r,d0                           	| [ld   a,r]
	add.b	d5,d0                            	| [add  a,h]
	move.l	(sp)+,a0                        	| [pop  hl]
	rts                                    	| [ret]

*=============================================================================
* dead_code
*  Description:
*   Assuming this is dead code. There are no references to this anywhere as
*   either code or data.
*-----------------------------------------------------------------------------
* _1012
	movem.w	d1/d2,-(sp)                    	| [push bc]
	movem.w	d3/d4,-(sp)                    	| [push de]
	move.l	a1,-(sp)                        	| [push de]
	move.b	d4,d0                           	| [ld   a,e]
	sub.b	d6,d0                            	| [sub  l]
	clr.b	d1                               	| [ld   b,#0]
	jcc	l_101E                             	| [jr   nc,l_101E]
      ^^^^^^ TODO: review cpu flags (clr.b,jcc)
	bset.b	#0,d1                           	| [set  0,b]
	neg.b	d0                               	| [neg]
l_101E:
	move.b	d0,d2                           	| [ld   c,a]
	move.b	d3,d0                           	| [ld   a,d]
	sub.b	d5,d0                            	| [sub  h]
	jcc	l_102D                             	| [jr   nc,l_102D]
	move.b	d0,d3                           	| [ld   d,a]
	move.b	d1,d0                           	| [ld   a,b]
	eor.b	#0x01,d0                         	| [xor  #0x01]
	or.b	#0x02,d0                          	| [or   #0x02]
	move.b	d0,d1                           	| [ld   b,a]
	move.b	d3,d0                           	| [ld   a,d]
	neg.b	d0                               	| [neg]
l_102D:
	cmp.b	d2,d0                            	| [cp   c]
	move.w	d0,-(sp)                        	| [push af]
	roxl.b	#1,d0                           	| [rla]
      ^^^^^^ TODO: review cpu X flag
	eor.b	d1,d0                            	| [xor  b]
	roxr.b	#1,d0                           	| [rra]
      ^^^^^^ TODO: review cpu X flag

	bcs.b	0f
	clr.b	d7
	bra.b	1f
0:
	st.b	d7
1:
	cmp.b	#1,d7                            	| [ccf]
	roxl.b	#1,d1                           	| [rl   b]
      ^^^^^^ TODO: review cpu X flag, cmp doesn't affect it!
	move.w	(sp)+,d0                        	| [pop  af]
	jcc	l_103B                             	| [jr   nc,l_103B]
      ^^^^^^ TODO: review cpu flags (move.w,jcc)
	move.b	d2,d3                           	| [ld   d,c]
	move.b	d0,d2                           	| [ld   c,a]
	move.b	d3,d0                           	| [ld   a,d]
l_103B:
	move.b	d2,d5                           	| [ld   h,c]
	clr.b	d6                               	| [ld   l,#0]
	jbsr	c_divmod                          	| [call c_divmod] HL=HL/D
	move.b	d5,d0                           	| [ld   a,h]
	eor.b	d1,d0                            	| [xor  b]
	and.b	#0x01,d0                         	| [and  #0x01]
	jeq	l_104A                             	| [jr   z,l_104A]
	move.b	d6,d0                           	| [ld   a,l]
	not.b	d0                               	| [cpl]
	move.b	d0,d6                           	| [ld   l,a]
l_104A:
	move.b	d1,d5                           	| [ld   h,b]
	move.l	(sp)+,a1                        	| [pop  de]
	movem.w	(sp)+,d3/d4                    	| [pop  de]

	movem.w	(sp)+,d1/d2                    	| [pop  bc]
	rts                                    	| [ret]

*=============================================================================
* c_104E_mul_16_8()
*  Description:
*   HL := b16 * b8
* IN:
*   HL==16 bit factor
*   A==8 bit factor
* OUT:
*   HL=16 bit product
* SAVES:
*   DE
*-----------------------------------------------------------------------------
c_104E_mul_16_8:
	movem.w	d3/d4,-(sp)                    	| [push de]
	move.l	a1,-(sp)                        	| [push de]
	exg	a1,a0                              	| [ex   de,hl]
	move.w	#0x0000,d5                      	| [ld   hl,#0x0000] 0
l_1053:
	lsr.b	#1,d0                            	| [srl  a]
	jcc	l_1058                             	| [jr   nc,l_1058]
	add.w	d3,a0                            	| [add  hl,de]
  ^^^^ TODO: review d3 computation above
l_1058:
	asl.b	#1,d4                            	| [sla  e]
	roxl.b	#1,d3                           	| [rl   d]
	tst.b	d0                               	| [and  a]
	jne	l_1053                             	| [jr   nz,l_1053]
	move.l	(sp)+,a1                        	| [pop  de]
	movem.w	(sp)+,d3/d4                    	| [pop  de]
	rts                                    	| [ret]

*=============================================================================
* c_1061()
*  Description:
*   Integer division and modulus operation. NOTE input value is NOT preserved.
*   HL = HL / A
*    A = HL % A
*   Uses ADC to sort of left-rotate the Dividend bitwise, linking through Cy
*   Flag into A and from A through Cy back into HL.
* IN:
*  D0 = Divisor
*  D5/D6 = Dividend
* OUT:
*  D5/D6 = Quotient
*  D0 =  Modulus
* PRESERVES: BC, DE
*-----------------------------------------------------------------------------
c_divmod:
	LOAD_D5_16_FROM_D5D6
	* completely rewritten using 68000 divu for faster op & bugfree code :)
	divu	d0,d5
	swap	d5
	move.w	d5,d0
	swap	d5
	LOAD_D5D6_FROM_D5_16
	rts
	

l_1074:                                           ; handle overflow out of A
	sub.b	d2,d0                            	| [sub  c]
	SET_XC_FLAGS                           	| [scf] need to explicitly set Cy so overflow of A will be summed with result in HL
	jra	l_106E                             	| [jp   l_106E]

*=============================================================================
* c_1079()
*  Description:
*   Called once for each of boss + 1 or 2 wingmen.
* IN:
*   HL == &b_8800[n] ... bits 0:6 ... loaded at l_1B8B from boss_wing_slots[n + 0]
*         if bit-7 set then negate rotation angle to (ix)0x0C
*         (creature originating on right side)
*   DE == pointer to object data (in cpu-sub1 code space)
* OUT:
*  ...
*-----------------------------------------------------------------------------
c_1079:
	move.b	d6,d0                           	| [ld   a,l]

	and.b	#0x80,d0                         	| [and  #0x80] if set then negate rotation angle to (ix)0x0C
	addq.b	#1,d0                           	| [inc  a] set bit-0, .b13<0> makes object slot active
	scs	d7                              	| [ex   af,af']
         ^^^ TODO review: wrong if carry is needed or D7 used in between!

	bclr.b	#7,d6                           	| [res  7,l]
	jra	j_108A                             	| [jp   j_108A]

*=============================================================================
* c_1083()
*  Description:
*   Diving movement of red alien, yellow alien, clone-attacker, and rogue fighter.
* IN:
*   HL == &b_8800[n]
*   DE == pointer to object data (in cpu-sub1 code space)
* OUT:
*  ...
*-----------------------------------------------------------------------------
c_1083:
* set A:bit-7 if L:bit-1 != 0 ... creature originating on right side
	move.b	d6,d0                           	| [ld   a,l]

	ror.b	#2,d0                            	| [rrca] * 2

	and.b	#0x80,d0                         	| [and  #0x80] if set then negate rotation angle to (ix)0x0C
	addq.b	#1,d0                           	| [inc  a] set bit-0, .b13<0> makes object slot active
	scs	d7                              	| [ex   af,af']
         ^^^ TODO review: wrong if carry is needed or D7 used in between!

*=============================================================================
* j_108A()
*  Description:
*   Setup motion for diving attackers.
* IN:
*   HL == &b_8800[n]
*   DE == pointer to table in cpu-sub1 code space
*   A' ==
*        bit-0: set by c_1083 and c_1079
*        bit-7: flag set for negative rotation angle
* OUT:
*
*-----------------------------------------------------------------------------
j_108A:
	movem.w	d3/d4,-(sp)                    	| [push de]
	move.l	a1,-(sp)                        	| [push de]

* find an available data structure or quit
	move.w	#0x0014,d3                      	| [ld   de,#0x0014] size of 1 data structure 20
	move.b	#0x0C,d1                        	| [ld   b,#0x0C] number of structures in array
	lea	ds_bug_motion_que(pc),a2           	| [ld   ix,#ds_bug_motion_que]
l_1094:
	btst.b	#0,(0x13,a2)                    	| [bit  0,0x13(ix)] check for activated state
	jeq	l_10A0_got_one                     	| [jr   z,l_10A0_got_one]
	add.w	d3,a2                            	| [add  ix,de]
  ^^^^ TODO: review d3 computation above
	subq.b	#1,d1                           	| [...]
	jne	l_1094                             	| [djnz l_1094]

	move.l	(sp)+,a1                        	| [pop  de]
	movem.w	(sp)+,d3/d4                    	| [pop  de]
	rts                                    	| [ret]

l_10A0_got_one:
	move.l	(sp)+,a1                        	| [pop  de] pointer to table
	movem.w	(sp)+,d3/d4                    	| [pop  de] pointer to table

	move.b	d4,(0x08,a2)                    	| [ld   0x08(ix),e] data pointer lsb
	move.b	d3,(0x09,a2)                    	| [ld   0x09(ix),d] data pointer msb
	move.b	#1,(0x0D,a2)                    	| [ld   0x0D(ix),#1] expiration counter
	move.b	<0x0100,(0x04,a2)               	| [ld   0x04(ix),#<0x0100] msb, 0x0100 (90 degrees)
	move.b	#0x0100,(0x05,a2)               	| [ld   0x05(ix),#>0x0100] lsb
	move.b	d6,d2                           	| [ld   c,l] stash index to obj_status[], sprite etc.
	move.b	d2,(0x10,a2)                    	| [ld   0x10(ix),c] index of object, sprite etc.

	scs	d7                              	| [ex   af,af']
         ^^^ TODO review: wrong if carry is needed or D7 used in between!
	move.b	d0,d3                           	| [ld   d,a] function parameter from A' to 0x13(ix)

	move.b	#9,(a0)+                         	| [ld   (hl),#9] obj_status[l].state ... disposition = diving attack
	move.b	#ixl,d0                         	| [ld   a,ixl]
	                           	| [inc  l]
	move.b	d0,(a0)                         	| [ld   (hl),a] obj_status[L].idx ... index into flying que

	move.b	b_9215_flip_screen,d0           	| [ld   a,(b_9215_flip_screen)]
	move.b	d0,d4                           	| [ld   e,a]

* insert sprite Y coord into pool structure
	move.b	d2,d6                           	| [ld   l,c] restore index to obj_status[], sprite etc. (dec l just as good, no?)
	lea	ds_sprite_posn(pc),a0              	| [ld   h,#>ds_sprite_posn]
	and.w	#0xFF,d6
	add.w	d6,a0
	      ^^^^ TODO: review XX value
	move.b	(a0)+,d2                         	| [ld   c,(hl)] sprite_x
	                           	| [inc  l]
	move.b	(a0),d1                         	| [ld   b,(hl)] sprite_y<7:0>
	lea	ds_sprite_ctrl(pc),a0              	| [ld   h,#>ds_sprite_ctrl]
	and.w	#0xFF,d6
	add.w	d6,a0
	      ^^^^ TODO: review XX value
	move.b	(a0),d0                         	| [ld   a,(hl)] sprite_y<8>
	ror.b	#1,d0                            	| [rrca] sY<8> into Cy
	roxr.b	#1,d1                           	| [rr   b] sY<8> from Cy to b<7> and sY<0> to Cy
      ^^^^^^ TODO: review cpu X flag

	btst.b	#0,d4                           	| [bit  0,e] test flipped screen
	jne	l_10DC                             	| [jr   nz,l_10DC]
* not flipped screen
* 160 - sprite_y + 1 ... backwards math since sY<8:1> already loaded in B, and this is only for flipped screen
	scs	d7                              	| [ex   af,af'] stash Cy ... sY<:0>
         ^^^ TODO review: wrong if carry is needed or D7 used in between!
	move.b	d1,d0                           	| [ld   a,b]
	add.b	<(-0x0160>>1),d0                 	| [add  a,#<(-0x0160 >> 1)] adjust addend for scale factor 2
	neg.b	d0                               	| [neg]
	move.b	d0,d1                           	| [ld   b,a]
	scs	d7                              	| [ex   af,af'] un-stash Cy
         ^^^ TODO review: wrong if carry is needed or D7 used in between!

	bcs.b	0f
	clr.b	d7
	bra.b	1f
0:
	st.b	d7
1:
	cmp.b	#1,d7                            	| [ccf] sY<:0> = Cy ^ 1

* insert sprite X coord into pool structure
l_10DC:
* resacale sY<8:0> to fixed-point 9.7
	move.b	d1,(0x01,a2)                    	| [ld   0x01(ix),b] sY<8:1> ... fixed point 9.7
* sY<:0> from Cy into A<7> ... fixed point 9.7 (LSB)
	roxr.b	#1,d0                           	| [rra]
      ^^^^^^ TODO: review cpu X flag
	and.b	#0x80,d0                         	| [and  #0x80]
	move.b	d0,(0x00,a2)                    	| [ld   0x00(ix),a] sY<0> ... fixed point 9.7

	move.b	d2,d0                           	| [ld   a,c] sprite_x
	btst.b	#0,d4                           	| [bit  0,e] test flipped screen
	jeq	l_10ED                             	| [jr   z,l_10ED]
* flipped screen
	add.b	#0x0D,d0                         	| [add  a,#0x0D] if flipped screen
	not.b	d0                               	| [cpl]

l_10ED:
	lsr.b	#1,d0                            	| [srl  a]
	move.b	d0,(0x03,a2)                    	| [ld   0x03(ix),a] sX<8:1>
	roxr.b	#1,d0                           	| [rra] Cy into A<8:>
      ^^^^^^ TODO: review cpu X flag
	and.b	#0x80,d0                         	| [and  #0x80]
	move.b	d0,(0x02,a2)                    	| [ld   0x02(ix),a] sX<:0> ... now scaled fixed point 9.7
	move.b	d3,(0x13,a2)                    	| [ld   0x13(ix),d] function argument (A') sets bit-0 and bit-7
	move.b	#0x1E,(0x0E,a2)                 	| [ld   0x0E(ix),#0x1E] bomb drop counter

* if (flying_bug_attck_condtn)  bug_motion_que[n].b0F = bomb_drop_enbl_flags
	move.b	ds_9200_glbls+0x0B,d0           	| [ld   a,(ds_9200_glbls + 0x0B)] if ( !0 ), load  b_92C0[0x08] ... bomb drop enable flags
	                               	| [and  a]
	jeq	l_1108                             	| [jr   z,l_1108]
	move.b	b_92C0+0x08,d0                  	| [ld   a,(b_92C0 + 0x08)] bomb drop enable flags
* else bug_motion_que[n].b0F = 0
l_1108:
	move.b	d0,(0x0F,a2)                    	| [ld   0x0F(ix),a] 0 or b_92C0[$08] ... bomb drop enable flags

	rts                                    	| [ret]

*=============================================================================
* c_player_active_switch()
*  Description:
*   End a player's turn and/or prep for next player.
*   Called when bug nest has already retreated.
*   Never on single player game and not at and of player 2's final ship.
* IN:
*  ...
* OUT:
*  ...
*-----------------------------------------------------------------------------
c_player_active_switch:
*  active_plyr_task_tbl[0] = reserve_plyr_task_tbl[0] = $1F
	move.b	#0x1F,d0                        	| [ld   a,#0x1F]
	move.b	d0,ds_cpu0_task_actv+0          	| [ld   (ds_cpu0_task_actv + 0),a] $1F
	move.b	d0,ds_cpu0_task_resrv+0         	| [ld   (ds_cpu0_task_resrv + 0),a] $1F

* swap active player and waiting player state data structures
	lea	ds_plyr_actv(pc),a0                	| [ld   hl,#ds_plyr_actv] $40 bytes
	lea	ds_plyr_susp(pc),a1                	| [ld   de,#ds_plyr_susp] $40 bytes
	move.b	#0x40,d1                        	| [ld   b,#0x40]
l_111C:
	move.b	(a0),d2                         	| [ld   c,(hl)]
	move.b	(a1),d0                         	| [ld   a,(de)]
	move.b	d0,(a0)+                         	| [ld   (hl),a]
	move.b	d2,d0                           	| [ld   a,c]
	move.b	d0,(a1)+                         	| [ld   (de),a]
	                           	| [inc  l]
	                           	| [inc  e]
	subq.b	#1,d1                           	| [...]
	jne	l_111C                             	| [djnz l_111C]

* swap active player and waiting player game object data
	lea	b_8800(pc),a0                      	| [ld   hl,#b_8800] $30 bytes to 98B0
	lea	ds_susp_plyr_obj_data(pc),a1       	| [ld   de,#ds_susp_plyr_obj_data]
	move.b	#0x30,d1                        	| [ld   b,#0x30]
l_112D:
	move.b	(a0),d0                         	| [ld   a,(hl)] &sprt_mctl_objs[n]
	move.b	d0,d2                           	| [ld   c,a]
	lea	ds_sprite_code(pc),a0              	| [ld   h,#>ds_sprite_code]
	and.w	#0xFF,d6
	add.w	d6,a0
	      ^^^^ TODO: review XX value
	move.b	(a0),d0                         	| [ld   a,(hl)]
	and.b	#0x7F,d0                         	| [and  #0x7F]
	subq.b	#1,d2                           	| [dec  c]
	jne	l_1142                             	| [jr   nz,l_1142] starts at $80?
	and.b	#0x78,d0                         	| [and  #0x78] sprite[n].cclr.code
	move.b	d0,d2                           	| [ld   c,a]
	addq.w	#1,a0                           	| [inc  l]
	move.b	(a0),d0                         	| [ld   a,(hl)] sprite[n].cclr.colr
	subq.w	#1,a0                           	| [dec  l]
	and.b	#0x07,d0                         	| [and  #0x07]
	or.b	d2,d0                             	| [or   c]
	or.b	#0x80,d0                          	| [or   #0x80]
l_1142:
	exg	a1,a0                              	| [ex   de,hl] hl := &susp_plyr_obj_data[n]
	move.b	(a0),d2                         	| [ld   c,(hl)] hl==98b0, de==8b00
	move.b	d0,(a0)                         	| [ld   (hl),a]
	exg	a1,a0                              	| [ex   de,hl] hl := sprite[n].cclr.code
	btst.b	#7,d2                           	| [bit  7,c]
	jeq	l_115A                             	| [jr   z,l_115A]
	move.b	d2,d0                           	| [ld   a,c] 114a, player 2->plyr 1
	and.b	#0x78,d0                         	| [and  #0x78]
	addq.b	#6,d0                           	| [add  a,#6]
	move.b	d0,(a0)+                         	| [ld   (hl),a]
	                           	| [inc  l]
	move.b	d2,d0                           	| [ld   a,c]
	and.b	#0x07,d0                         	| [and  #0x07]
	move.b	d0,(a0)                         	| [ld   (hl),a]
	subq.w	#1,a0                           	| [dec  l]
 	move.b	#1,d0                           	| [ld   a,#1]
	jra	l_1161                             	| [jr   l_1161]

l_115A:
	move.b	d2,(a0)                         	| [ld   (hl),c] hl==8b00
	lea	ds_sprite_posn(pc),a0              	| [ld   h,#>ds_sprite_posn]
	and.w	#0xFF,d6
	add.w	d6,a0
	      ^^^^ TODO: review XX value
	clr.b	(a0)                             	| [ld   (hl),#0] hl==9300
	move.b	#0x80,d0                        	| [ld   a,#0x80]

l_1161:
	lea	b_8800(pc),a0                      	| [ld   h,#>b_8800]
	and.w	#0xFF,d6
	add.w	d6,a0
	      ^^^^ TODO: review XX value
	move.b	d0,(a0)                         	| [ld   (hl),a]
	addq.w	#1,a1                           	| [inc  de] de==98b0
	addq.w	#2,a0                           	| [inc  l]
	subq.b	#1,d1                           	| [...]
	jne	l_112D                             	| [djnz l_112D]

	lea	ds_cpu0_task_actv(pc),a0           	| [ld   hl,#ds_cpu0_task_actv] cp $20 bytes to reserve task tbl
	lea	ds_cpu0_task_resrv(pc),a1          	| [ld   de,#ds_cpu0_task_resrv] cp $20 bytes from active task tbl
	move.b	#0x20,d1                        	| [ld   b,#0x20]
l_1171:
	move.b	(a0),d2                         	| [ld   c,(hl)]
	move.b	(a1),d0                         	| [ld   a,(de)]
	move.b	d0,(a0)+                         	| [ld   (hl),a]
	move.b	d2,d0                           	| [ld   a,c]
	move.b	d0,(a1)+                         	| [ld   (de),a]
	                          	| [inc  l]
	                           	| [inc  e]
 	subq.b	#1,d1                           	| [...]
	jne	l_1171                             	| [djnz l_1171]

	clr.b	d0                               	| [xor  a]
	move.b	d0,ds_cpu0_task_actv+0          	| [ld   (ds_cpu0_task_actv + 0),a] 0
	rts                                    	| [ret]

*=============================================================================
* gctl_stg_tokens()
*  Description:
*   new stage setup (c_new_stage_, plyr_changeover)
* IN:
*  A': non-zero if sound-clicks for stage tokens (passed to sound manager)
*  Cy': set if inhibit sound-clicks for stage tokens
*
* OUT:
*  ...
*-----------------------------------------------------------------------------
c_new_level_tokens:
*  memset($8002,$24,$12)
	lea	0x8000+2,a0                	| [ld   hl,#0x8000 + 2] second row from bottom at right
	move.b	#0x12,d1                        	| [ld   b,#0x12]
	move.b	#0x24,d0                        	| [ld   a,#0x24]
	jbsr	rst_18_video                            	| [rst  0x18] memset((HL), A=fill, B=ct)
*  memset($8022,$24,$12)                          ; bottom row at right
	move.b	#0x22,d6                        	| [ld   l,#0x22]
	move.b	#0x12,d1                        	| [ld   b,#0x12]
	jbsr	rst_18_video                            	| [rst  0x18] memset((HL), A=fill, B=ct)

	move.b	ds_plyr_actv+_b_stgctr,d0       	| [ld   a,(ds_plyr_actv +_b_stgctr)] c_new_level_tokens
	clr.b	d1                               	| [ld   b,#0] tmp_quotient 50
	lea	0x8000+1,a0                	| [ld   hl,#0x8000 + 1] offset into tile ram


* stage_ctr/50 and stage_ctr%50 (by brute force!)

*  while ( tmp_stage_ctr >= 50 ) {
l_1194_while:
	cmp.b	#50,d0                           	| [cp   #50]
	jcs	l_119F                             	| [jr   c,l_119F]
	sub.b	#50,d0                           	| [sub  #50] tmp_modulus
	addq.b	#1,d1                           	| [inc  b] tmp_quotient
* offset tileram ptr 2 columns to the left... *50 icons are 2 tiles wide
	addq.w	#2,a0                           	| [inc  l]
	jra	l_1194_while                       	| [jr   l_1194_while]

l_119F:
	exg	a1,a0                              	| [ex   de,hl] stash the tileram offset in DE
	move.b	d0,d6                           	| [ld   l,a] stage_ctr % 50

	clr.b	d5                               	| [ld   h,#0]
	move.b	#10,d0                          	| [ld   a,#10]
	jbsr	c_divmod                          	| [call c_divmod] HL = HL / 10
	move.b	d0,d5                           	| [ld   h,a] A = HL % 10 ... (still have L==HL/10)


	movem.w	d5/d6,-(sp)                        	| [push hl] stack the quotient and mod10 result
	exg	a1,a0                              	| [ex   de,hl]

* now HL == tile_ram address  and  DE == div10 and mod10 result

* offset base pointer in HL by the nbr of tile columns needed:

* if ( A >= 5 )  { C = A = A - 4 }  ... if mod10 > 5 then only 1 tile for the 5, plus nbr of 1's
	cmp.b	#5,d0                            	| [cp   #5]
	jcs	l_11B1_add_total                   	| [jr   c,l_11B1_add_total]
	subq.b	#4,d0                           	| [sub  #4]

l_11B1_add_total:
	move.b	d0,d2                           	| [ld   c,a] nbr of columns for 5's and 1's (not including 50's)

* Add up the total additional columns needed for 10, 10, 20, 30, 40 in A.
* 'bit 0' catches the odd div10 result and sets A=2. Noteing the 40 needs 4 columns,
* the div10 result does the right thing for 0, 20, and 40.
	move.b	d4,d0                           	| [ld   a,e] div10result
	btst.b	#0,d0                           	| [bit  0,a] even or odd
	jeq	l_11B9                             	| [jr   z,l_11B9]
	move.b	#2,d0                           	| [ld   a,#2]
l_11B9:
	add.b	d2,d0                            	| [add  a,c] nbr of additional tile columns
	jbsr	rst_10                            	| [rst  0x10] HL += A

* B == count of 50's markers, if any
	addq.b	#1,d1                           	| [inc  b] pre-increment for djnz ... B is at least 1

l_11BC_loop:
	subq.b	#1,d1                           	| [...]
	jne	l_11DC_show_50s_tokens             	| [djnz l_11DC_show_50s_tokens]

	movem.w	(sp)+,d1/d2                    	| [pop  bc] pop the quotient and mod10 result
	move.b	d2,d0                           	| [ld   a,c] div10 result
	jbsr	c_11E3_show_tokens_1              	| [call c_11E3_show_tokens_1]

* if ( mod10result < 5 )
	move.b	d1,d0                           	| [ld   a,b] mod10 result
	cmp.b	#5,d0                            	| [cp   #5]
	jcs	l_11D0_do_1s_tokens                	| [jr   c,l_11D0_do_1s_tokens]
* else
	move.b	#0x36+2,d3                      	| [ld   d,#0x36 + 2] tile nbr of top of '5' token ... bottom tile of token is next tile nbr
	jbsr	c_build_token_1                   	| [call c_build_token_1] show the 5 token

* do 1's ... mod10result -= 5
	move.b	d1,d0                           	| [ld   a,b]
	subq.b	#5,d0                           	| [sub  #5]

l_11D0_do_1s_tokens:
	move.b	d0,d1                           	| [ld   b,a] nbr of 1's tokens
	addq.b	#1,d1                           	| [inc  b] pre-increment for djnz

l_11D2_show_1s_loop:
	subq.b	#1,d1                           	| [...]
	jne	l_11D5_while                       	| [djnz l_11D5_while]
	rts                                    	| [ret]

l_11D5_while:
	move.b	#0x36,d3                        	| [ld   d,#0x36] tile nbr of top of '1' token ... bottom tile of token is next tile nbr
	jbsr	c_build_token_1                   	| [call c_build_token_1] show the token
	jra	l_11D2_show_1s_loop                	| [jr   l_11D2_show_1s_loop]

l_11DC_show_50s_tokens:
	move.b	#4,d0                           	| [ld   a,#4]
	jbsr	c_11E9                            	| [call c_11E9] show the token
	jra	l_11BC_loop                        	| [jr   l_11BC_loop]


*=============================================================================
* c_11E3_show_tokens_1()
*  Description:
*   Setup c_11E9 to display the 10's tokens.
* IN:
*   A = count of 10's tiles to show, i.e. stage % 50 / 10
* OUT:
*  ...
*-----------------------------------------------------------------------------
c_11E3_show_tokens_1:

* branch off depending on div10result ... do nothing for 0
	tst.b	d0                               	| [and  a] A==div10 result
	bne.b	0f                               	| [...]
	rts                                    	| [ret  z] [...]
0:
* handle 40's separately
	cmp.b	#4,d0                            	| [cp   #4]
	jeq	l_11F0_do_40s                      	| [jr   z,l_11F0_do_40s]

c_11E9:
* get offset of of start of tiles for 10, 20, and 30 ... div10result * 4
	rol.b	#2,d0                            	| [rlca] * 2
	add.b	#0x36,d0                         	| [add  a,#0x36] base offset of icon tiles
	move.b	d0,d3                           	| [ld   d,a]
	jra	l_11FA_show_10s_20s_30s_50s        	| [jr   l_11FA_show_10s_20s_30s_50s]

l_11F0_do_40s:
	move.b	#0x36+4*3,d3                    	| [ld   d,#0x36 + 4 * 3] offset to 30's tiles group
	jbsr	c_build_token_1                   	| [call c_build_token_1]
	jbsr	c_build_token_2                   	| [call c_build_token_2]

	move.b	#0x36+4,d3                      	| [ld   d,#0x36 + 4] offset to 10's tiles group

l_11FA_show_10s_20s_30s_50s:
	jbsr	c_build_token_1                   	| [call c_build_token_1]
	jbsr	c_build_token_2                   	| [call c_build_token_2]

	rts                                    	| [ret]

*=============================================================================
* c_build_token()
*  Description:
*   wrapper for c_build_token_2 that handles timing and sound-effect
* IN:
*   D = offset of start of tile group for the token to display
*   HL = base address in tileram
* OUT:
*   HL -= 1
*-----------------------------------------------------------------------------
c_build_token_1:

* check sound_disable_flag
	scs	d7                              	| [ex   af,af']
         ^^^ TODO review: wrong if carry is needed or D7 used in between!
	jcs	l_1215_restore_A_and_continue      	| [jr   c,l_1215_restore_A_and_continue]
* put it back
	scs	d7                              	| [ex   af,af']
         ^^^ TODO review: wrong if carry is needed or D7 used in between!
* set the delay count 8 ... preserve frame count
	move.b	ds3_92A0_frame_cts+0,d0         	| [ld   a,(ds3_92A0_frame_cts + 0)]
	add.b	#8,d0                            	| [add  a,#8]
	move.b	d0,d4                           	| [ld   e,a]
l_120B:
	move.b	ds3_92A0_frame_cts+0,d0         	| [ld   a,(ds3_92A0_frame_cts + 0)]
	sub.b	d4,d0                            	| [sub  e]
	jne	l_120B                             	| [jr   nz,l_120B]

* actv_plyr_state[0x05]==0 for challenge stage ... 0 count/enable for stage tokens clicks
	scs	d7                              	| [ex   af,af']
         ^^^ TODO review: wrong if carry is needed or D7 used in between!
	move.b	d0,b_9AA0+0x15                  	| [ld   (b_9AA0 + 0x15),a] 2 ... sound-fx count/enable registers, clicks for stage tokens

l_1215_restore_A_and_continue:
	scs	d7                              	| [ex   af,af']
         ^^^ TODO review: wrong if carry is needed or D7 used in between!

*=============================================================================
* c_build_token_2()
*  Description:
*   Display 2 tiles comprising a stage token icon.
*
*   Each call to this displays a top and bottom tile. 4 tile tokens require
*   this function to be called twice. HL is decremented in order to leave the
*   pointer at the next column to the left.
*   Use color table 1 for 1's, 5's and 50's.
*   These are situated in the tile order such that the $0C mask leaves the 8,
*   thereby setting the Z flag.
*   Use color table 2 for the others.
*   This is a bit roundabout and slightly confusing, here is a table of the
*   tile numbers to help visualize it:
*
*    1's   36 37         38 & 0C = 08
*    5's   38 39         3A & 0C = 08
*    10's  3A 3B 3C 3D   3C & 0C = 0C  ... 3E & 0C = 0C
*    20's  3E 3F 40 41   40 & 0C = 00  ... 42 & 0C = 00
*    30's  42 43 44 45   44 & 0C = 00  ... 46 & 0C = 00
*    50's  46 47 48 49   48 & 0C = 08  ... 5A & 0C = 08
*
* IN:
*   D = offset of start of tile group for the token to display
*   HL = base address in tileram
* OUT:
*   HL -= 1
*
*-----------------------------------------------------------------------------
c_build_token_2:
	move.b	d3,(a0)                         	| [ld   (hl),d]
	addq.b	#1,d3                           	| [inc  d] next tile
	bset.b	#5,d6                           	| [set  5,l] +=32 ... advance one row down
	move.b	d3,(a0)                         	| [ld   (hl),d]

	addq.b	#1,d3                           	| [inc  d]
	bset.b	#2,d5                           	| [set  2,h] +=$0400 ... colorram

* if ( D & $0C  > 8 ) { A = 2  else A = 1 }
	move.b	d3,d0                           	| [ld   a,d]
	and.b	#0x0C,d0                         	| [and  #0x0C]
	cmp.b	#8,d0                            	| [cp   #8]
	move.b	#1,d0                           	| [ld   a,#1]
	jeq	l_1228                             	| [jr   z,l_1228]
      ^^^^^^ TODO: review cpu flags (move.b,jeq)
	addq.b	#1,d0                           	| [inc  a]

* set the color codes, resetting the bits and updating HL as we go
l_1228:
	move.b	d0,(a0)                         	| [ld   (hl),a]
	bclr.b	#5,d6                           	| [res  5,l]
	^^^ TILERAM TODO
	move.b	d0,(a0)                         	| [ld   (hl),a]
	bclr.b	#2,d5                           	| [res  2,h]
	subq.w	#1,a0                           	| [dec  l] offset tileram pointer 1 column to the right

	rts                                    	| [ret]

*=============================================================================
* c_1230_init_taskman_structs()
*  Description:
*   Initialize active player and reserve player kernel tables from defaults:
*   - At reset
*   - Immediately following end of "demo game (just prior to "heroes" shown)
*   - After "results" or "HIGH SCORE INITIAL"
*   - New game (credit==0 -> credit==1)
* IN:
*  ...
* OUT:
*  ...
*-----------------------------------------------------------------------------
c_1230_init_taskman_structs:
* memcpy(_task_activ, task_enable_tbl_def, 0x20)
	lea	task_enable_tbl_def(pc),a0         	| [ld   hl,#task_enable_tbl_def]
	lea	ds_cpu0_task_actv(pc),a1           	| [ld   de,#ds_cpu0_task_actv] $20 bytes copied from task_enable_tbl_def
	move.b	#0x00,d1                        	| [ld   bc,#0x0020] 32
	move.b	#0x20,d2                        	| [ld   bc,#0x0020] 32
	movem.w	d1/d2,-(sp)                    	| [push bc]

	move.l	a0,-(sp)                        	| [push hl]
	jbsr	ldir                              	| [ldir]
     ^^^^ TODO: review special instruction inputs

* memcpy(_task_resrv, task_enable_tbl_def, 0x20);
*  for ( de = 98e0, hl = 1249; bc++ ; bc < 0$20 ) de[bc] = hl[bc];
	move.l	(sp)+,a0                        	| [pop  hl]

	movem.w	(sp)+,d1/d2                    	| [pop  bc]
	lea	ds_cpu0_task_resrv(pc),a1          	| [ld   de,#ds_cpu0_task_resrv] $20 bytes copied from task_enable_tbl_def
	jbsr	ldir                              	| [ldir]
     ^^^^ TODO: review special instruction inputs

* kill the idle task at [0]
*  task_tbl_9000[0] = 0
	clr.b	d0                               	| [xor  a]
	move.b	d0,ds_cpu0_task_actv            	| [ld   (ds_cpu0_task_actv),a] 0

	rts                                    	| [ret]


*=============================================================================
* kernel task-enable table defaults

task_enable_tbl_def:

	.byte  0x1F | f_0827
	.byte  0x01 | f_0828  | Copies from sprite "buffer" to sprite RAM
	.byte  0x00 | f_17B2
	.byte  0x00 | f_1700  | Ship-update in training/demo mode.
	.byte  0x00 | f_1A80
	.byte  0x01 | f_0857  | triggers various parts of gameplay based on parameters
	.byte  0x00 | f_0827
	.byte  0x00 | f_0827

	.byte  0x00 | f_2916
	.byte  0x00 | f_1DE6
	.byte  0x00 | f_2A90
	.byte  0x00 | f_1DB3
	.byte  0x01 | f_23DD  | Updates each object in the table at 8800
	.byte  0x01 | f_1EA4  | Bomb position updater
	.byte  0x00 | f_1D32
	.byte  0x01 | f_0935  | handle "blink" of Player1/Player2 texts

	.byte  0x00 | f_1B65
	.byte  0x00 | f_19B2
	.byte  0x00 | f_1D76  | star control
	.byte  0x00 | f_0827
	.byte  0x00 | f_1F85
	.byte  0x00 | f_1F04
	.byte  0x00 | f_0827
	.byte  0x01 | f_1DD2  | Updates array of 4 timers

	.byte  0x00 | f_2222
	.byte  0x00 | f_21CB
	.byte  0x00 | f_0827
	.byte  0x00 | f_0827
	.byte  0x00 | f_20F2
	.byte  0x00 | f_2000
	.byte  0x00 | f_0827
	.byte  0x0A | f_0977  | Handles coinage and changes in game-state

*=============================================================================
* g_mssl_init()
*  Description:
*   For game or "demo-mode" (f_17B2) setup
*   Initialize "missile" objects (bombs and/or rockets).
*   One-time init for codes, colors and tiles.
* IN:
*  ...
* OUT:
*  ...
*-----------------------------------------------------------------------------
c_game_or_demo_init:
	lea	ds_sprite_code+0x64(pc),a0         	| [ld   hl,#ds_sprite_code + 0x64] rocket object
	lea	l_0900+0x0030(pc),a1               	| [ld   de,#0x0900 + 0x0030] temp store two 8-bit values ... $30 is a rocket
	clr.b	d2                               	| [ld   c,#0]
	move.b	#10,d1                          	| [ld   b,#10]

l_1273_while:
	move.b	d4,(a0)                         	| [ld   (hl),e] e.g. (8B64):=$30
	lea	ds_sprite_posn(pc),a0              	| [ld   h,#>ds_sprite_posn]
	and.w	#0xFF,d6
	add.w	d6,a0
	      ^^^^ TODO: review XX value
	clr.b	(a0)                             	| [ld   (hl),#0]
	lea	ds_sprite_ctrl(pc),a0              	| [ld   h,#>ds_sprite_ctrl]
	and.w	#0xFF,d6
	add.w	d6,a0
	      ^^^^ TODO: review XX value
	move.b	d2,(a0)                         	| [ld   (hl),c]
	lea	ds_sprite_code(pc),a0              	| [ld   h,#>ds_sprite_code]
	and.w	#0xFF,d6
	add.w	d6,a0
	      ^^^^ TODO: review XX value
	addq.w	#1,a0                           	| [inc  l]
 	move.b	d3,(a0)+                         	| [ld   (hl),d] e.g. (8B65):=$09

                          	| [inc  l]
* if ( B == 9 )
	move.b	d1,d0                           	| [ld   a,b]
	cmp.b	#9,d0                            	| [cp   #9]
	jne	l_1289                             	| [jr   nz,l_1289]
	move.b	#1,d2                           	| [ld   c,#1]
	move.b	#0x0B,d3                        	| [ld   d,#0x0B] bomb color code

l_1289:
	subq.b	#1,d1                           	| [...]
	jne	l_1273_while                       	| [djnz l_1273_while] B--

	rts                                    	| [ret]

*=============================================================================
* sprite_tiles_display()
*  Description:
*   Display sprite tiles in specific arrangements loaded from table data.
*   This is for demo or game-start (bonus-info ) screen but not gameplay.
* IN:
*  _attrmode_sptiles: ptr to sprite tiles data
* OUT:
*  _attrmode_sptiles: advanced to next data group
*-----------------------------------------------------------------------------
c_sprite_tiles_displ:
	lea	ds_sprite_code(pc),a0              	| [ld   h,#>ds_sprite_code]
	and.w	#0xFF,d6
	add.w	d6,a0
	      ^^^^ TODO: review XX value

* L = p_sptiles_displ[idx*4 + 0] ... index/offset of object to use
	move.w	p_attrmode_sptiles(pc),a1       	| [ld   de,(p_attrmode_sptiles)] load the persistent pointer (not always needed)
                  ^^^^^^ TODO: review move.w into address register
	move.b	(a1),d0                         	| [ld   a,(de)] _attrmode_sptiles[ E + 0 ]
	move.b	d0,d6                           	| [ld   l,a]

* C = p_sptiles_displ[E+1] ... color/code
	addq.w	#1,a1                           	| [inc  de] _attrmode_sptiles[DE].b01  ... color/code
	move.b	(a1),d0                         	| [ld   a,(de)]
	move.b	d0,d2                           	| [ld   c,a]

* sprite_code<3:6>
* tile 0+6 in each set of 8 is the "upright" orientation (wings spread for bug)
	and.b	#0x78,d0                         	| [and  #0x78]
	addq.b	#6,d0                           	| [add  a,#6]
	move.b	d0,(a0)                         	| [ld   (hl),a] sprite_code_base[ object + 0 ] ... sprite tile code

* advance pointer, i.e. sprite_code_base[ index + 1 ] ... color code
	addq.w	#1,a0                           	| [inc  l]
            ^^^^ TODO check inc register d6 or a0

* get color bits from original color/code value
	move.b	d2,d0                           	| [ld   a,c]
	and.b	#0x07,d0                         	| [and  #0x07]

* Apparently bit-7 of the color/code provides color bit-3
*     if (C & 0x80)  A                  	|= 0x08
	btst.b	#7,d2                           	| [bit  7,c]
	jeq	l_12A6                             	| [jr   z,l_12A6]
	or.b	#0x08,d0                          	| [or   #0x08]
l_12A6:
	move.b	d0,(a0)                         	| [ld   (hl),a] sprite_code_base

	addq.w	#1,a1                           	| [inc  de] &table[ n + 2 ]  ... L/R offset

	subq.w	#1,a0                           	| [dec  l] object_data[ n + 0 ] ... object state
            ^^^^ TODO check dec register d6 or a0
	lea	b_8800(pc),a0                      	| [ld   h,#>b_8800]
	and.w	#0xFF,d6
	add.w	d6,a0
	      ^^^^ TODO: review XX value
	move.b	#1,(a0)                         	| [ld   (hl),#1] disposition = ACTIVE

	lea	ds_sprite_posn(pc),a0              	| [ld   h,#>ds_sprite_posn]
	and.w	#0xFF,d6
	add.w	d6,a0
	      ^^^^ TODO: review XX value
	move.b	(a1),d0                         	| [ld   a,(de)] L/R offset
	move.b	d0,(a0)                         	| [ld   (hl),a] sprite_posn.X

* Y coordinate: the table value is actually sprite.posn.Y<8..1> and the sla
* causes the Cy flag to pick up sprite.posn<8> ...
	addq.w	#1,a1                           	| [inc  de] &table[ n + 3 ]  ... T/B offset
	addq.w	#1,a0                           	| [inc  l] sprite_posn.Y<0..7>
	move.b	(a1),d0                         	| [ld   a,(de)]
	asl.b	#1,d0                            	| [sla  a]
	move.b	d0,(a0)                         	| [ld   (hl),a] sprite_posn.Y

* and sprite.posn<8> is handled here, i.e. ctrl[n + 1]<0>
	clr.b	d0                               	| [ld   a,#0] set the sprite with no additional control attributes
	roxl.b	#1,d0                           	| [rla]
      ^^^^^^ TODO: review cpu X flag
	lea	ds_sprite_ctrl(pc),a0              	| [ld   h,#>ds_sprite_ctrl]
	and.w	#0xFF,d6
	add.w	d6,a0
	      ^^^^ TODO: review XX value
	move.b	d0,(a0)                         	| [ld   (hl),a]

* advance the pointer
	addq.w	#1,a1                           	| [inc  de] e.g., DE:=$1960
	move.b	a1,p_attrmode_sptiles           	| [ld   (p_attrmode_sptiles),de] += 1

	rts                                    	| [ret]

*=============================================================================
* gctl_stg_fmtn_hpos_init()
*  Description:
*   plyr_changeover or new_stg_setup, also for start of demo "stage"....after
*   the rank icons are shown and the text is shown i.e. "game over" or "stage x"
* IN:
*   A == offset ... 0 on new-screen, $3F on player changeover
* OUT:
*  ...
*-----------------------------------------------------------------------------
c_12C3:
ld   ixl,a
	move.b	b_9215_flip_screen,d0           	| [ld   a,(b_9215_flip_screen)]
	move.b	d0,d2                           	| [ld   c,a]

* init formation location tracking structure: relative (offset) initialize to 0
* and origin coordinate bits<8:1> from data (copy of origin coordinate from
* CPU0 data as it would be outside of address space of CPU1)
	lea	ds_hpos_loc_t(pc),a0               	| [ld   hl,#ds_hpos_loc_t] init home_posn_loc[]
	lea	db_fmtn_hpos_orig(pc),a1           	| [ld   de,#db_fmtn_hpos_orig]
	move.b	#16,d1                          	| [ld   b,#16] table size
l_12D1:
	clr.b	(a0)+                             	| [ld   (hl),#0] fmtn_hpos.offs[]
	                           	| [inc  l]
 	move.b	(a1)+,d0                         	| [ld   a,(de)]
	                           	| [inc  de]
	move.b	d0,(a0)+                         	| [ld   (hl),a] pair.b1 i.e. ds_hpos_loc_orig ... copy data for reference in CPU1
	                           	| [inc  l]
	subq.b	#1,d1                           	| [...]
	jne	l_12D1                             	| [djnz l_12D1]

* X coordinates at origin (10 bytes) to even offsets, adjusted for flip-screen.
	lea	ds_hpos_spcoords(pc),a0            	| [ld   hl,#ds_hpos_spcoords] init origin x-coords (10 columns)
	lea	db_fmtn_hpos_orig(pc),a1           	| [ld   de,#db_fmtn_hpos_orig]
	move.b	#10,d1                          	| [ld   b,#10]
l_12E2:
	move.b	(a1),d0                         	| [ld   a,(de)] home_posn_ini[B]
	addq.w	#1,a1                           	| [inc  de]

	btst.b	#0,d2                           	| [bit  0,c] test if flip_screen
	jeq	l_12EB                             	| [jr   z,l_12EB]
	add.b	#0x0D,d0                         	| [add  a,#0x0D] flipped
	not.b	d0                               	| [cpl]

l_12EB:
	move.b	d0,(a0)                         	| [ld   (hl),a] store lsb
	addq.w	#2,a0                           	| [inc  l]
	subq.b	#1,d1                           	| [...]
	jne	l_12E2                             	| [djnz l_12E2]

* Y coordinates at origin (6 bytes) to even offsets. Offset argument (in ixl)
* is added and result adjusted for flip-screen. Only bits <8:1> are stored.
* For non-inverted screen, equivalent of "$0160 - n" is implemented.
	move.b	#6,d1                           	| [ld   b,#6]
l_12F2:
	move.b	(a1),d0                         	| [ld   a,(de)] db_fmtn_hpos_orig[B]
	add.b	ixl,d0                           	| [add  a,ixl]
	addq.w	#1,a1                           	| [inc  de]

	btst.b	#0,d2                           	| [bit  0,c] test if flip_screen
	jne	l_12FD                             	| [jr   nz,l_12FD]
	add.b	#0x4F,d0                         	| [add  a,#0x4F] add offset
	not.b	d0                               	| [cpl] negate

l_12FD:
	asl.b	#1,d0                            	| [sla  a] Cy now contains bit-8
	move.b	d0,(a0)+                         	| [ld   (hl),a]
	                           	| [inc  l]
	clr.b	d0                               	| [ld   a,#0]
	roxl.b	#1,d0                           	| [rla] bit-8 from Cy into bit-0 of MSB
      ^^^^^^ TODO: review cpu X flag
	move.b	d0,(a0)+                         	| [ld   (hl),a]
	                           	| [inc  l]
	subq.b	#1,d1                           	| [...]
	jne	l_12F2                             	| [djnz l_12F2]

	move.b	b_9215_flip_screen,d0           	| [ld   a,(b_9215_flip_screen)]
	move.b	d0,ds_9200_glbls+0x0F           	| [ld   (ds_9200_glbls + 0x0F),a] = _flip_screen (nest direction... 1:left, 0:right)
	rts                                    	| [ret]

*=============================================================================
* Initial pixel coordinates of cylon attackers are copied to odd-offsets of home_posn_loc[].
*
*                                       	|<-------------- COLUMNS ------------------------>|<---------- ROWS ----------->|
*
*     00   02   04   06   08   0A   0C   0E   10   12   14   16   18   1A   1C   1E
*
*-----------------------------------------------------------------------------
db_fmtn_hpos_orig:
	.byte 0x31,0x41,0x51,0x61,0x71,0x81,0x91,0xA1,0xB1,0xC1, 0x92,0x8A,0x82,0x7C,0x76,0x70

*=============================================================================
* c_tdelay_3()
*  Description:
*   used in game_ctrl
*   delay 3 count on .5 second timer used various places (in game_ctrl)
* IN:
*  ...
* OUT:
*  ...
* PRESERVES:
*  HL
*-----------------------------------------------------------------------------
c_tdelay_3:

	move.l	a0,-(sp)                        	| [push hl]
*  game_tmrs[3] = 3
	lea	ds4_game_tmrs+3(pc),a0             	| [ld   hl,#ds4_game_tmrs + 3] =3 ... while ! 0
	move.b	#3,(a0)                         	| [ld   (hl),#3]
*  while ( game_tmrs[3] != 0 ) {}
l_1325:
	move.b	(a0),d0                         	| [ld   a,(hl)]
	                               	| [and  a]
	jne	l_1325                             	| [jr   nz,l_1325]

	move.l	(sp)+,a0                        	| [pop  hl]
	rts                                    	| [ret]


*=============================================================================
* c_player_respawn()
*  Description:
*    Single player, shows "player 1", then overwrite w/ "stage 1" and show "player 1" above
*
*                                       	|       PLAYER 1
*               PLAYER 1                	|       STAGE 1
*
*                                    PLAYER 1
*                                    STAGE 1     (S @ 8270)
*
*                                    PLAYER 1
*                                    READY       (R @ 8270)
*
*    Get READY to start a new ship, after destroying or capturing the one in play.
*    ("Player X" text already is shown).
*    Format is different one plyr vs two.
*    One Plyr:
*     Updates "Ready" game message text (except for on new stage...
*     ..."STAGE X" already shown in that position).
*    Two Plyr:
*      Next players nest has already descended onto screen w/ "PLAYER X" text shown.
*     "Ready" is already shown from somewhere else (05f1).
*
*    Removes one ship from reserve. (p_136c)
*    (used in game_ctrl)
* IN:
*  ...
* OUT:
*  ...
*-----------------------------------------------------------------------------
c_player_respawn:
	move.b	#1,d0                           	| [ld   a,#1]
	move.b	d0,ds_cpu0_task_actv+0x14       	| [ld   (ds_cpu0_task_actv + 0x14),a] 1  (f_1F85 ... control stick input)

* check if "STAGE X" text shown and if so skip showing "READY"
*  if ( *(8270) ) == ' ' ) ...
	move.b	0x8000+0x0260+0x10,d0       	| [ld   a,(0x8000 + 0x0260 + 0x10)]
	cmp.b	#0x24,d0                         	| [cp   #0x24]
	jne	l_133A                             	| [jr   nz,l_133A]
* ... else
	move.b	#3,d2                           	| [ld   c,#3] string_out_pe  index
	jbsr	rst_30                            	| [rst  0x30] string_out_pe "READY" (at 8270)
l_133A:

*=============================================================================
* c_133A()
*  Description:
*   Demo mode (f_17B2) ...
*   ...while (bug/bee flys home) ...ship hit, waiting for flying bug to re-nest
*   Label provided for code reuse (jr from c_player_respawn)
* IN:
*  ...
* OUT:
*  ...
*-----------------------------------------------------------------------------
c_133A:

l_133A_while:
	move.b	b_bugs_flying_nbr,d0            	| [ld   a,(b_bugs_flying_nbr)]
	                               	| [and  a]
	jne	l_133A_while                       	| [jr   nz,l_133A_while] wait for all bugs to stop flying

	jbsr	draw_resv_ships                   	| [call draw_resv_ships] updates reserve ships in lower left corner (wipes CREDIT X)

* put the ship out there
	lea	l_0900+0x0006(pc),a0               	| [ld   hl,#0x0900 + 0x0006] two bytes, code 6, color 9
	move.b	a0,ds_sprite_code+0x62          	| [ld   (ds_sprite_code + 0x62),hl] = $0906 ... ship-1 code 6, color 9 (load 16-bits)
	lea	ds_sprite_posn+0x62(pc),a0         	| [ld   hl,#ds_sprite_posn + 0x62] ship (1) position

*  if ( !_flip_screen )  A = $29,  C = 1
	move.b	b_9215_flip_screen,d0           	| [ld   a,(b_9215_flip_screen)]
	and.b	#1,d0                            	| [and  #1]
	move.b	#0x29,d0                        	| [ld   a,#0x29]
	move.b	#1,d2                           	| [ld   c,#1]
	jeq	l_135A                             	| [jr   z,l_135A]
      ^^^^^^ TODO: review cpu flags (move.b,jeq)
*  else  A = $37,  C = 0
	add.b	#0x0E,d0                         	| [add  a,#0x0E] screen is flipped in demo?????
	subq.b	#1,d2                           	| [dec  c]
l_135A:
	move.b	#0x7A,(a0)+                      	| [ld   (hl),#0x7A] SPRPOSN.0[$62] ... sx
	                           	| [inc  l]
	move.b	d0,(a0)                         	| [ld   (hl),a] SPRPOSN.1[$62] ... sy<0:7>
	lea	ds_sprite_ctrl(pc),a0              	| [ld   h,#>ds_sprite_ctrl]
	and.w	#0xFF,d6
	add.w	d6,a0
	      ^^^^ TODO: review XX value
	move.b	d2,(a0)                         	| [ld   (hl),c] SPRCTRL.1[n]:0 ... sy<8>
	subq.w	#1,a0                           	| [dec  l]
 	clr.b	d0                               	| [xor  a]
	move.b	d0,(a0)                         	| [ld   (hl),a] 0 ... SPRCTRL.0[n] (no flip/double attribute)

	move.b	d0,ds_9200_glbls+0x13           	| [ld   (ds_9200_glbls + 0x13),a] 0 ... stage restart flag
	addq.b	#1,d0                           	| [inc  a]
	move.b	d0,ds_99B9_star_ctrl+0          	| [ld   (ds_99B9_star_ctrl + 0),a] 1 ... when ship on screen

	rts                                    	| [ret]

*=============================================================================
* fghtr_resv_draw()
*  Description:
*   Draws up to 6 reserve ships in the status area of the screen, calling
*   the subroutine 4 times to build the ship icons from 4 tiles.
* IN:
*  ...
* OUT:
*  ...
*-----------------------------------------------------------------------------
draw_resv_ships:
	move.b	ds_plyr_actv+_b_nships,d0       	| [ld   a,(ds_plyr_actv +_b_nships)]
	not.b	d0                               	| [cpl]
	addq.b	#6,d0                           	| [add  a,#6] max nr of icons
	move.b	d0,d4                           	| [ld   e,a]
	move.b	#0x49,d3                        	| [ld   d,#0x49] $4A,$4B,$4C,$4D ... / \ [ ]
	lea	0x8000+0x0000+0x1D(pc),a0      	| [ld   hl,#0x8000 + 0x0000 + 0x1D]
	jbsr	draw_resv_ship_tile               	| [call draw_resv_ship_tile]
	subq.w	#1,a0                           	| [dec  l] advance 1 column right
            ^^^^ TODO check dec register d6 or a0
	jbsr	draw_resv_ship_tile               	| [call draw_resv_ship_tile]
	bset.b	#5,d6                           	| [set  5,l] +=32 (down 1 row)
	addq.w	#1,a0                           	| [inc  l] 1 column to the left
            ^^^^ TODO check inc register d6 or a0
	jbsr	draw_resv_ship_tile               	| [call draw_resv_ship_tile]
	subq.w	#1,a0                           	| [dec  l] advance 1 column right
            ^^^^ TODO check dec register d6 or a0
*       call draw_resv_ship_tile

*=============================================================================
* draw_resv_ship_tile()
*  Description:
*   Each ship is composed of 4 tiles. This is called once for each tile.
*   Each tile is replicated at the correct screem offset, allowing up to 6
*   reserve ship indicators to be shown. Unused locations are filled with
*   the "space" character tile.
* IN:
*   HL: offset in tile ram
*    D: tile character
*    E: nr of reserve ships
* OUT:
*    D: tile character (increment)
* PRESERVES:
*    HL: current offset in tile ram
*
*-----------------------------------------------------------------------------
draw_resv_ship_tile:

	move.l	a0,-(sp)                        	| [push hl]
	addq.b	#1,d3                           	| [inc  d]
	move.b	d3,d1                           	| [ld   b,d]
	move.b	#6-1,d0                         	| [ld   a,#6 - 1] max nr of resv ship icon
l_138B:
	cmp.b	d4,d0                            	| [cp   e]
	jne	l_1390                             	| [jr   nz,l_1390]
	move.b	#0x24,d1                        	| [ld   b,#0x24] space character tile
l_1390:
	move.b	d1,(a0)                         	| [ld   (hl),b]
	subq.w	#2,a0                           	| [dec  l]
            ^^^^ TODO check dec register d6 or a0 * 2
	subq.b	#1,d0                           	| [dec  a]
	jne	l_138B                             	| [jr   nz,l_138B]

	move.l	(sp)+,a0                        	| [pop  hl]
	rts                                    	| [ret]

*=============================================================================
* c_string_out()
*  Description:
*    Copy a series of characters to tile-ram (see d_cstring_tbl).
*    Converts characters strings from ASCII to corresponding character tiles.
*    Machine character set:
*     $00 - $09 : decimal digit characters.
*     $0A - $23 : A-Z
*     $24       : <space>
*    String length is variant - the termination token is $2F (ascii "/").
*    Can be called two ways:
*    CALL:
*      Destination position address is passed in HL and swapped into DE.
*    RST $30:
*      RST $30 sets the CY flag and JPs to string_out_pe.
*      The string pointer is then offset (-2) i.e. sizeof(ptr) to get
*      the destination position address, which winds up in DE.
*      With the position address in DE, the rest of the routine is the same.
*  IN:
*    HL: position in tile RAM.
*    C: index into table of string pointers (d_cstring_tbl)
*    CY: "set" if jumped to j_string_out_pe_13b5
*  OUT:
*    HL contains final string character display position.
*
*    PRESERVES :   DE
*-----------------------------------------------------------------------------
c_string_out:
	tst.b	d0                               	| [and  a] clear CY flag.
	scs		d7                              	| [ex   af,af'] save CY flag.

j_string_out_pe_13b5:
	movem.w	d3/d4,-(sp)                    	| [push de] preserves DE
	move.l	a1,-(sp)                        	| [push de] preserves DE
	exg	a1,a0                              	| [ex   de,hl] DE := position in tile RAM

* Get address of string pointer using index in C ...
* p_sptr = ( ptr_tbl - sizeof(ptr) ) + sizeof(ptr) * index
	move.b	d2,d0                           	| [ld   a,c] C = index into table string pointers (d_cstring_tbl)
	lea	d_cstring_tbl-2(pc),a0             	| [ld   hl,#d_cstring_tbl - 2] index is ordered from 1 !!
	jbsr	rst_08                            	| [rst  0x08] HL += 2A

* De-reference the string pointer
* sptr = *(p_sptr)
	move.b	(a0)+,d0                         	| [ld   a,(hl)] lsb
	                           	| [inc  hl]
	move.b	(a0),d5                         	| [ld   h,(hl)] msb
	move.b	d0,d6                           	| [ld   l,a] lsb
	LOAD_D5_16_FROM_D5D6
	
* Restore flags and check CY
	tst.b	d7                              	| [ex   af,af']
* if ( CY ) ...
	jcc	l_13AE                             	| [jr   nc,l_13AE]
* ... do PE stuff: get position into DE ... HL-=2, DE:=*(HL)
	subq.w	#2,a0                           	| [dec  hl] * 2
	move.b	(a0)+,d4                         	| [ld   e,(hl)] LSB
	                           	| [inc  hl]
	move.b	(a0)+,d3                         	| [ld   d,(hl)] MSB
	                           	| [inc  hl] HL now pointing to "color".

* now DE == position, so the rest is the same...
l_13AE:
	move.b	(a0),d2                         	| [ld   c,(hl)] C := color byte ($00 == "cyan")
	addq.w	#1,a0                           	| [inc  hl] ptr++ (first byte of "text")
	exg	a1,a0                              	| [ex   de,hl] position address in HL, src address in DE
l_13B1:
* if ( TERMINATION ) then exit
	move.b	(a1),d0                         	| [ld   a,(de)]
	cmp.b	#0x2F,d0                         	| [cp   #0x2F] string terminator
	jeq	l_13D4_out                         	| [jr   z,l_13D4_out]
       *
* only a <space> character ($20) should be < $30
	sub.b	#0x30,d0                         	| [sub  #0x30] e.g. ASCII "0" ... ($30 - $30 ) = 0, "1" ... ($31 - $30 ) = 1 ... etc.
	jcc	l_13BE                             	| [jr   nc,l_13BE]
	move.b	#0x24,d0                        	| [ld   a,#0x24] generate a <space> character.
	jra	l_13C4_putc                        	| [jr   l_13C4_putc]
l_13BE:
* if ( A >= $11 )
	cmp.b	#0x11,d0                         	| [cp   #0x11] e.g. ASCII "A" ... ($41 - $30) = $11
	jcs	l_13C4_putc                        	| [jr   c,l_13C4_putc]
* then A-=7
	subq.b	#7,d0                           	| [sub  #7] e.g. ASCII "A" ... ($41 - $30 - $07) = $0A
       *
l_13C4_putc:
	move.b	d0,(a0)                         	| [ld   (hl),a] display the character

	bset.b	#2,d5                           	| [set  2,h] H|= $04  (HL:+=$0400)  offset HL into color RAM $8400-$87FF
	move.b	d2,(a0)                         	| [ld   (hl),c] color code in C
	bclr.b	#2,d5                           	| [res  2,h] HL:-=$0400

	addq.w	#1,a1                           	| [inc  de] psrc++

* HL-=$20 (advance destination position one tile to the "right")
	move.b	d6,d0                           	| [ld   a,l]
	sub.b	#0x20,d0                         	| [sub  #0x20]
	move.b	d0,d6                           	| [ld   l,a]
	jcc	l_13B1                             	| [jr   nc,l_13B1]
      ^^^^^^ TODO: review cpu flags (move.b,jcc)
	subq.b	#1,d5                           	| [dec  h]
       *
	jra	l_13B1                             	| [jr   l_13B1]
l_13D4_out:
	move.l	(sp)+,a1                        	| [pop  de]
	movem.w	(sp)+,d3/d4                    	| [pop  de]
	rts                                    	| [ret]

*=============================================================================
* strings for c_string_out
d_cstring_tbl:
  * 0x00
	.long s_1414,s_1429,s_1436,s_1441,s_144B,s_1457,s_1461,s_1476,s_1488,s_1493
  * 0x0A
	.long s_14A7,s_14C6,s_14D3,s_14EE,s_14F8,s_1507,s_1514,s_1521,s_1525,s_153A
  * 0x14
	.long s_1545,s_1552,s_1569,s_1577,s_1590,s_15A7,s_15AD,s_15C1,s_15D5,s_15E7


* "Declare Effective Address" macro (idfk)
* Generates offsets in Playfield Tile RAM from given row/column ordinates. _R
* and _C are 0 based, and this is reflected in the additional "-1" term. The
* coordinate system applies only to the "Playfield" area and is independent of
* the top two rows and bottom two rows of tiles.
* (See tile RAM & color RAM layout ascii art diagram in mrw.s).
.macro  _dea  _R _C
	.long    0x8000 + $$40 + ( $$1C - _C - 1 ) * $$20 + _R
.endm


* Terminated strings (2f). First byte is color-code (1-byte ), unless the string is
* position-encoded, in which case the address word will precede string label.

* $01
_dea 11 6                                 ; 02EB
s_1414:
	.byte 0x00
.ascii "PUSH START BUTTON/"

* $02
_dea 16 10                                ; 0270
s_1429:
	.byte 0x00
.ascii "GAME OVER/"

* $03
_dea 16 10                                ; 0270
s_1436:
	.byte 0x00
.ascii "READY !/"                         ; '!' displays as <space>

* $04
_dea 16 11                                ; 0250
s_1441:
	.byte 0x00
.ascii "PLAYER 1/"

* $05
s_144B:
	.byte 0x00
.ascii "PLAYER 2/"

* %06
_dea 16 10                                ; 0270
s_1457:
	.byte 0x00
.ascii "STAGE /"

* $07
_dea 16 5                                 ; 0310
s_1461:
	.byte 0x00
.ascii "CHALLENGING STAGE/"

* $08
_dea 16 5                                 ; 0310
s_1476:
	.byte 0x00
.ascii "NUMBER OF HITS/"

* $09
_dea 19 8                                 ; 02B3
s_1488:
	.byte 0x00
.ascii "BONUS  /"

* $0A
_dea 17 6                                 ; 02F1
s_1493:
	.byte 0x04
.ascii "FIGHTER CAPTURED/"

* $0B
_dea 13 0                                 ; 03AD
s_14A7:
	.byte 0x00
.ascii "                           /"     ; 27 spaces

* $0C
_dea 13 10                                ; 026D
s_14C6:
	.byte 0x04
.ascii "PERFECT c/"

* $0D
_dea 19 2                                 ; 0373
s_14D3:
	.byte 0x05
.ascii "SPECIAL BONUS 10000 PTS/"

* $0E
_dea 2 11                                 ; 0242
s_14EE:
	.byte 0x00
.ascii "GALAGA/"

* $0F
_dea 5 8                                  ; 02A5
s_14F8:
	.byte 0x00
.ascii "]] SCORE ]]/"

* $10
_dea 8 12                                 ; 0228
s_1507:
	.byte 0x00
.ascii "50    100/"

* $11
_dea 10 12                                ; 022A
s_1514:
	.byte 0x00
.ascii "80    160/"

* $12
_dea 11 12                                ; 022B
s_1521:
	.byte 0x00
.ascii "/"

* $13
_dea 27 6                                 ; 02FB
s_1525:
	.byte 0x03                                  | "(C) 1981 NAMCO LTD."
.ascii "e 1981 NAMCO LTDa/"

* $14
_dea 30 11                                ; 025E
s_153A:
	.byte 0x04                                  | "NAMCO" (in styled font)
	.byte 0x66,0x67,0x68,0x69,0x6A,0x6B,0x6C,0x2F

* $15
_dea 15 9                                 ; 028F
s_1545:
	.byte 0x04
.ascii "]RESULTS]/"

* $16
_dea 18 4                                 ; 0332
s_1552:
	.byte 0x05
.ascii "SHOTS FIRED          /"

* $17
s_1569:
	.byte 0x05
.ascii "  MISSILES/"

* $18
_dea 21 4                                 ; 0335
s_1577:
	.byte 0x05
.ascii "NUMBER OF HITS       /"

* $19
_dea 24 4                                 ; 0338
s_1590:
	.byte 0x03
.ascii "HIT]MISS RATIO       /"

* $1A
s_15A7:
	.byte 0x03
.ascii "$`/"                              ; '`' displays as "%" ("$" displays as <space>)

* $1B
_dea 15 4                                 ; 032F
s_15AD:
	.byte 0x05
.ascii "1ST BONUS FOR   /"

* $1C
_dea 18 4                                 ; 0332
s_15C1:
	.byte 0x05
.ascii "2ND BONUS FOR   /"

* $1D
_dea 21 4                                 ; 0335
s_15D5:
	.byte 0x05
.ascii "AND FOR EVERY   /"

* $1E
s_15E7:
	.byte 0x05
.ascii "0000 PTS/"


_l_15f1: ; end area
*           00001700  f_1700

*
* input file gg1-2_fx.s
*
* gg1-2_fx.s:
*  gg1-2.3m, 'maincpu' (Z80)
*
*  step function execution from gg1-2
*  ship movement, control inputs, flying bugs, flying bombs
*
*
.module ga0
*.area ROM (ABS,OVR)

.include "sfrs.inc"
.include "structs.inc"
.include "gg1-2_fx.dep"

*       .org  0x1700
.area CSEG17


*=============================================================================
* f_1700()
*  Description:
*   Fighter control, only called in training/demo mode.
* IN:
*  ...
* OUT:
*  ...
*-----------------------------------------------------------------------------
f_1700:
* labels for "case" blocks in _1713
* switch( *_demo_fghtrvctrs >> 5) & 0x07 )
	move.w	pdb_demo_fghtrvctrs(pc),a1      	| [ld   de,(pdb_demo_fghtrvctrs)] cases for switch
                  ^^^^^^ TODO: review move.w into address register
	move.b	(a1),d0                         	| [ld   a,(de)]
	rol.b	#3,d0                            	| [rlca] * 3
	and.b	#0x07,d0                         	| [and  #0x07]
	lea	d_1713(pc),a0                      	| [ld   hl,#d_1713] &table
	jbsr	rst_08                            	| [rst  0x08] HL += 2A
	move.b	(a0),d0                         	| [ld   a,(hl)]
	addq.w	#1,a0                           	| [inc  hl]
	move.b	(a0),d5                         	| [ld   h,(hl)]
	move.b	d0,d6                           	| [ld   l,a]
	jra	(a0)                               	| [jp   (hl)]
d_1713:
	.long case_1766
	.long case_1766
	.long case_171F
	.long case_1766
	.long case_1734
	.long case_172D

* boss+wingmen nearly to fighter
case_171F:  ; 0x02
	move.b	ds3_92A0_frame_cts+0,d0         	| [ld   a,(ds3_92A0_frame_cts + 0)]
	and.b	#0x0F,d0                         	| [and  #0x0F]
	beq.b	0f                               	| [...]
	rts                                    	| [ret  nz] [...]
0:

	lea	ds_9200_glbls+0x07(pc),a0          	| [ld   hl,#ds_9200_glbls + 0x07] timer, training mode, far-right boss turned blue
	subq.b	#1,(a0)                         	| [dec  (hl)]
	beq.b	0f                               	| [...]
	rts                                    	| [ret  nz] [...]
0:
	jra	case_1766                          	| [jp   case_1766] training mode, far-right boss exploding

* appearance of first enemy formation in Demo
case_172D:  ; 0x05
	jbsr	c_1F0F                            	| [call c_1F0F] init sprite objects for rockets
	move.w	pdb_demo_fghtrvctrs(pc),a1      	| [ld   de,(pdb_demo_fghtrvctrs)] trampled DE so reload it
                  ^^^^^^ TODO: review move.w into address register

* drives the simulated inputs to the fighter in training mode
case_1734:  ; 0x04
	move.b	(a1),d0                         	| [ld   a,(de)] *pdb_demo_fghtrvctrs

	lea	ds_plyr_actv+_b_2ship(pc),a0       	| [ld   hl,#ds_plyr_actv +_b_2ship]
	move.b	(a0),d4                         	| [ld   e,(hl)] setup E for c_1F92

	btst.b	#0,d0                           	| [bit  0,a]
	jne	l_1741                             	| [jr   nz,l_1741]
	and.b	#0x0A,d0                         	| [and  #0x0A]
	jra	l_1755                             	| [jr   l_1755]

l_1741:
	move.b	ds_9200_glbls+0x09,d0           	| [ld   a,(ds_9200_glbls + 0x09)] object/index of targeted alien
	move.b	d0,d6                           	| [ld   l,a]
	lea	ds_sprite_posn(pc),a0              	| [ld   h,#>ds_sprite_posn]
	and.w	#0xFF,d6
	add.w	d6,a0
	      ^^^^ TODO: review XX value

	move.b	ds_sprite_posn+0x62,d0          	| [ld   a,(ds_sprite_posn + 0x62)] ship (1) position
	sub.b	(a0),d0                          	| [sub  (hl)]
	move.b	#0x0A,d0                        	| [ld   a,#0x0A]
	jeq	l_1755                             	| [jr   z,l_1755]
      ^^^^^^ TODO: review cpu flags (move.b,jeq)
	move.b	#0x08,d0                        	| [ld   a,#0x08] right
	jcs	l_1755                             	| [jr   c,l_1755]
      ^^^^^^ TODO: review cpu flags (move.b,jcs)
	move.b	#2,d0                           	| [ld   a,#2] left
l_1755:
	jbsr	c_1F92                            	| [call c_1F92]
	move.b	ds3_92A0_frame_cts+0,d0         	| [ld   a,(ds3_92A0_frame_cts + 0)]
	and.b	#0x03,d0                         	| [and  #0x03]
	beq.b	0f                               	| [...]
	rts                                    	| [ret  nz] [...]
0:
	lea	ds_9200_glbls+0x07(pc),a0          	| [ld   hl,#ds_9200_glbls + 0x07] timer, training mode, far-right boss exploding
	subq.b	#1,(a0)                         	| [dec  (hl)]
	beq.b	0f                               	| [...]
	rts                                    	| [ret  nz] [...]
0:
	jbsr	c_1F0F                            	| [call c_1F0F] init sprite objects for rockets ...training mode, ship about to shoot?

case_1766:  ; 0x00, 0x01, 0x03
	move.w	pdb_demo_fghtrvctrs(pc),a1      	| [ld   de,(pdb_demo_fghtrvctrs)]
                  ^^^^^^ TODO: review move.w into address register
	move.b	(a1),d0                         	| [ld   a,(de)]
	and.b	#0xC0,d0                         	| [and  #0xC0] 0x80 fires shot ... 0xC0 is end of sequence
	cmp.b	#0x80,d0                         	| [cp   #0x80]
	jne	l_1772                             	| [jr   nz,l_1772]
	addq.w	#1,a1                           	| [inc  de] firing shot ... advance to next token
l_1772:
	addq.w	#1,a1                           	| [inc  de]

	move.b	(a1),d0                         	| [ld   a,(de)]
	move.b	a1,pdb_demo_fghtrvctrs          	| [ld   (pdb_demo_fghtrvctrs),de] += 1
* A = (*_demo_fghtrvctrs >> 5) & 0x07;
	rol.b	#3,d0                            	| [rlca] * 3
	and.b	#0x07,d0                         	| [and  #0x07]
* switch(...)
	lea	d_1786(pc),a0                      	| [ld   hl,#d_1786]
	jbsr	rst_08                            	| [rst  0x08] HL += 2A (pointer from index)
	move.b	(a0),d0                         	| [ld   a,(hl)]
	addq.w	#1,a0                           	| [inc  hl]
	move.b	(a0),d5                         	| [ld   h,(hl)]
	move.b	d0,d6                           	| [ld   l,a]
	jra	(a0)                               	| [jp   (hl)] 1784

d_1786:
	.long case_1794  | 0
	.long case_1794  | 1 -> $2x
	.long case_17A1  | 2 -> $4x
	.long case_17A8  | 3
	.long case_17AE  | 4 -> $8x
	.long case_17AE  | 5
	.long case_179C  | 6 -> $Cx

* load index/position of target alien
case_1794:
* ds_9200_glbls[0x09] = *_demo_fghtrvctrs << 1 & 0x7E
	move.b	(a1),d0                         	| [ld   a,(de)]
	rol.b	#1,d0                            	| [rlca] rotate bits<6:1> into place
	and.b	#0x7E,d0                         	| [and  #0x7E] mask out Cy rlca'd into <:0>
	move.b	d0,ds_9200_glbls+0x09           	| [ld   (ds_9200_glbls + 0x09),a] index/position of of target alien
	rts                                    	| [ret]

* $C0: last token, shot-and-hit far-left boss in training mode (second hit)
case_179C:
	clr.b	d0                               	| [xor  a]
	move.b	d0,ds_cpu0_task_actv+0x03       	| [ld   (ds_cpu0_task_actv + 0x03),a] 0 ... f_1700() end of fighter control sequence
	rts                                    	| [ret]

* $4x: shoot-and-hit far-right or far-left boss (once) in training mode
case_17A1:
	move.b	(a1),d0                         	| [ld   a,(de)]
	and.b	#0x1F,d0                         	| [and  #0x1F]
l_17A4:
	move.b	d0,ds_9200_glbls+0x07           	| [ld   (ds_9200_glbls + 0x07),a] demo timer
	rts                                    	| [ret]

* when?
case_17A8:
	move.b	(a1),d0                         	| [ld   a,(de)]
	and.b	#0x1F,d0                         	| [and  #0x1F]
	move.b	d0,d2                           	| [ld   c,a]
	jbsr	rst_30                            	| [rst  0x30] string_out_pe
	rts                                    	| [ret]

* $8x: prior to each fighter shot in training mode?
case_17AE:
	addq.w	#1,a1                           	| [inc  de]
	move.b	(a1),d0                         	| [ld   a,(de)]
	jra	l_17A4                             	| [jr   l_17A4]

*=============================================================================
* f_17B2()
*  Description:
*   Manage attract mode, control sequence for training and demo screens.
*   The state progression is always the same, ordered by the state-index
*   (switch variable).
*
* IN:
*  ...
* OUT:
*  ...
*-----------------------------------------------------------------------------
f_17B2:
* if ( game_state != ATTRACT_MODE ) return
	move.b	b8_9201_game_state,d0           	| [ld   a,(b8_9201_game_state)]
	subq.b	#1,d0                           	| [dec  a]
	beq.b	0f                               	| [...]
	rts                                    	| [ret  nz] [...]
0:

* switch( demo_idx )
	move.b	ds_9200_glbls+0x03,d0           	| [ld   a,(ds_9200_glbls + 0x03)] demo state variable (jp to "switch-case")
	lea	d_17C3_jptbl(pc),a0                	| [ld   hl,#d_17C3_jptbl] table_base
	jbsr	rst_08                            	| [rst  0x08] HL += 2A
	move.b	(a0),d4                         	| [ld   e,(hl)]
	addq.w	#1,a0                           	| [inc  hl]
	move.b	(a0),d3                         	| [ld   d,(hl)]
	exg	a1,a0                              	| [ex   de,hl]
	jra	(a0)                               	| [jp   (hl)]

d_17C3_jptbl:
	.long case_1940   | 0x00 . clear tile and sprite ram
	.long case_1948   | 0x01   setup info-screen: sprite tbl index, text index, preload tmr[2]==2
	.long case_1984   | 0x02   tmr[2]=2,  sequence info-text and sprite tiles indices 1 sec intervals
	.long case_18D9   | 0x03   task[F_demo_fghter_ctrl]==1  init 7 aliens for training mode
	.long case_18D1   | 0x04 ~ wait for task[F_demo_fghter_ctrl]==0 training-mode runs before advance state
	.long case_18AC   | 0x05   synchronize copyright text with completion of explosion of last boss
	.long case_1940   | 0x06 . clear tile and sprite ram
	.long case_17F5   | 0x07   delay ~1 sec before puts("GAME OVER")
	.long case_1852   | 0x08   init demo   task[F_demo_fghter_ctrl]==1
	.long case_18D1   | 0x09 ~ wait for task[F_demo_fghter_ctrl]==0 demo-mode runs before advance state
	.long case_1808   | 0x0A   task[F_demo_fghter_ctrl]==1
	.long case_18D1   | 0x0B ~ wait for task[F_demo_fghter_ctrl]==0 boss-capture before advance state
	.long case_1840   | 0x0C   end of Demo - init taskman, disable flying_bug_ctrl(), global enemy ct 0,
	.long case_1940   | 0x0D . clear tile and sprite ram
	.long case_17E1   | 0x0E   end of Demo ... delay, then show GALACTIC HERO screen

* 0E: end of Demo ...  delay, then show GALACTIC HERO screen
case_17E1:
* if ( game_timers[3] == 0 ) then l_17EC
	move.b	ds4_game_tmrs+3,d0              	| [ld   a,(ds4_game_tmrs + 3)] if 0, display hi-score tbl
	                               	| [and  a]
	jeq	l_17EC                             	| [jr   z,l_17EC]
* else if ( game_timers[3] == 1 )  advance state
	subq.b	#1,d0                           	| [dec  a]
	jeq	l_attmode_state_step               	| [jp   z,l_attmode_state_step]
* else break
	rts                                    	| [ret]
l_17EC:
	jbsr	c_mach_hiscore_show               	| [call c_mach_hiscore_show]
	move.b	#0x0A,d0                        	| [ld   a,#0x0A]
	move.b	d0,ds4_game_tmrs+3              	| [ld   (ds4_game_tmrs + 3),a] $0A ... after displ hi-score tbl
	rts                                    	| [ret]

* 07: just cleared screen from training mode, delay ~1 sec before puts("game over")
case_17F5:
* if ( ( ds3_92A0_frame_cts[0] & 0x1F ) == 0x1F )
	move.b	ds3_92A0_frame_cts+0,d0         	| [ld   a,(ds3_92A0_frame_cts + 0)]
	and.b	#0x1F,d0                         	| [and  #0x1F]
	cmp.b	#0x1F,d0                         	| [cp   #0x1F]
	beq.b	0f                               	| [...]
	rts                                    	| [ret  nz] [...]
0:
* then ...
	move.b	#1,d0                           	| [ld   a,#1]
	move.b	d0,ds_cpu0_task_actv+0x05       	| [ld   (ds_cpu0_task_actv + 0x05),a] 1 ... f_0857
	move.b	#2,d2                           	| [ld   c,#2] index of string
	jbsr	rst_30                            	| [rst  0x30] string_out_pe ("GAME OVER")
	jra	l_attmode_state_step               	| [jp   l_attmode_state_step]

* 10: enable fighter control demo
case_1808:
	jbsr	c_133A                            	| [call c_133A]

	lea	d_181F(pc),a0                      	| [ld   hl,#d_181F]
	move.b	a0,pdb_demo_fghtrvctrs          	| [ld   (pdb_demo_fghtrvctrs),hl] &d_181F[0]

	move.b	#1,d0                           	| [ld   a,#1]
	move.b	d0,ds_cpu0_task_actv+0x03       	| [ld   (ds_cpu0_task_actv + 0x03),a] 1  (f_1700 ... fighter control in training/demo mode)
	move.b	d0,ds_cpu0_task_actv+0x15       	| [ld   (ds_cpu0_task_actv + 0x15),a] 1  (f_1F04 ... fire button input))
	move.b	d0,ds_cpu1_task_actv+0x05       	| [ld   (ds_cpu1_task_actv + 0x05),a] 1  (cpu1:f_05EE ... fighter collision detection)
	jra	l_attmode_state_step               	| [jp   l_attmode_state_step]

* demo fighter vectors demo level after capture
d_181F:
	.byte 0x08,0x18,0x8A,0x08,0x88,0x06,0x81,0x28,0x81,0x05,0x54,0x1A,0x88,0x12,0x81,0x0F
	.byte 0xA2,0x16,0xAA,0x14,0x88,0x18,0x88,0x10,0x43,0x82,0x10,0x88,0x06,0xA2,0x20,0x56,0xC0

* 12: end of Demo, fighter has been erased but remaining enemies may not have been erased yet
case_1840:
	jbsr	rst_28                            	| [rst  0x28] memset(mctl_mpool,0,$$14 * 12)
	jbsr	c_1230_init_taskman_structs       	| [call c_1230_init_taskman_structs]

	clr.b	d0                               	| [xor  a]
	move.b	d0,ds_cpu0_task_actv+0x10       	| [ld   (ds_cpu0_task_actv + 0x10),a] 0 (f_1B65 ... manage bomber attack )
	move.b	d0,ds_9200_glbls+0x0B           	| [ld   (ds_9200_glbls + 0x0B),a] 0 ... glbl_enemy_enbl, end of demo

* have to re-set enable bit for this flag after init_structs
	addq.b	#1,d0                           	| [inc  a]
	move.b	d0,ds_cpu0_task_actv+0x02       	| [ld   (ds_cpu0_task_actv + 0x02),a] 1 ... f_17B2 (attract-mode control)

	jra	l_attmode_state_step               	| [jp   l_attmode_state_step]

* 08: init demo (following training mode) ... "GAME OVER" showing
case_1852:
	clr.b	d0                               	| [xor  a]
	move.b	d0,ds_plyr_actv+_b_bmbr_boss_cflag	| [ld   (ds_plyr_actv +_b_bmbr_boss_cflag),a] 0 ... enable capture-mode selection
	addq.b	#1,d0                           	| [inc  a]
	move.b	d0,b_9AA0+0x17                  	| [ld   (b_9AA0 + 0x17),a] 1 ... sound_mgr_reset: non-zero causes re-initialization of sound mgr
	move.b	d0,ds_plyr_actv+_b_stgctr       	| [ld   (ds_plyr_actv +_b_stgctr),a] 1
	move.b	d0,ds_cpu0_task_actv+0x03       	| [ld   (ds_cpu0_task_actv + 0x03),a] 1  (f_1700 ... fighter control in training/demo mode)
	move.b	d0,ds_cpu0_task_actv+0x15       	| [ld   (ds_cpu0_task_actv + 0x15),a] 1  (f_1F04 ... fire button input)
	move.b	d0,ds_plyr_actv+_b_not_chllg_stg	| [ld   (ds_plyr_actv +_b_not_chllg_stg),a] 1  (0 if challenge stage ...see new_stg_game_only)

	lea	d_1887(pc),a0                      	| [ld   hl,#d_1887]
	move.b	a0,pdb_demo_fghtrvctrs          	| [ld   (pdb_demo_fghtrvctrs),hl] &d_1887[0]
	jbsr	stg_init_env                      	| [call stg_init_env]
	jbsr	c_133A                            	| [call c_133A] apparently erases some stuff from screen?

	move.b	#1,d0                           	| [ld   a,#1]
	move.b	d0,ds_9200_glbls+0x0B           	| [ld   (ds_9200_glbls + 0x0B),a] 1 ... glbl_enemy_enbl, one time init for demo
	move.b	d0,ds_plyr_actv+_b_atk_wv_enbl  	| [ld   (ds_plyr_actv +_b_atk_wv_enbl),a] 1 ... 0 when respawning player ship
	move.b	d0,ds_plyr_actv+_b_bmbr_boss_wingm	| [ld   (ds_plyr_actv +_b_bmbr_boss_wingm),a] 1 ... for demo, force the bomber-boss into wingman-mode
	addq.b	#1,d0                           	| [inc  a]
	move.b	d0,ds_new_stage_parms+0x04      	| [ld   (ds_new_stage_parms + 0x04),a] 2 ... max_bombers (demo)
	move.b	d0,ds_new_stage_parms+0x05      	| [ld   (ds_new_stage_parms + 0x05),a] 2 ... increases max bombers in certain conditions (demo)
	jra	l_attmode_state_step               	| [jp   l_attmode_state_step]

* demo fighter vectors demo level before capture
d_1887:
	.byte 0x02,0x8A,0x04,0x82,0x07,0xAA,0x28,0x88,0x10,0xAA,0x38,0x82,0x12,0xAA,0x20,0x88
	.byte 0x14,0xAA,0x20,0x82,0x06,0xA8,0x0E,0xA2,0x17,0x88,0x12,0xA2,0x14,0x18,0x88,0x1B
	.byte 0x81,0x2A,0x5F,0x4C,0xC0

* 05: synchronize copyright text with completion of explosion of last boss
case_18AC:
* tmr[2] always 0 at transition to this case (was reloaded at last of 5 texts in case_1984)
* if (0 == tmr[2])  collsn_notif && tmr[2]=9 && break
	move.b	ds4_game_tmrs+2,d0              	| [ld   a,(ds4_game_tmrs + 2)] always 0 here at entry to case_18AC
	                               	| [and  a]
	jeq	l_18BB                             	| [jr   z,l_18BB]
* else  if (1 == tmr[2])  state++ ; break
	subq.b	#1,d0                           	| [dec  a]
	jeq	l_attmode_state_step               	| [jp   z,l_attmode_state_step]
* else  if (6 == tmr)  copyright_info ; break
	cmp.b	#5,d0                            	| [cp   #5]
	jeq	l_18C6                             	| [jr   z,l_18C6]
* else  break
	rts                                    	| [ret]

l_18BB:
* tmr == 0 ... put 4.5 seconds on the clock (but transitions to next case at tmr==1, so delay actually 4 secs)
	move.b	#0x34,d0                        	| [ld   a,#0x34]
	move.b	d0,b_9200_obj_collsn_notif+0x34 	| [ld   (b_9200_obj_collsn_notif + 0x34),a] $34
	move.b	#9,d0                           	| [ld   a,#9]
	move.b	d0,ds4_game_tmrs+2              	| [ld   (ds4_game_tmrs + 2),a] 9
	rts                                    	| [ret]
l_18C6:
* tmr == 5, explosion complete ... '150' score on display
	clr.b	d0                               	| [xor  a]
	move.b	d0,ds_sprite_posn+0x62          	| [ld   (ds_sprite_posn + 0x62),a] 0 ... fighter (1) is removed from screen
	move.b	#0x13,d2                        	| [ld   c,#0x13]
	jbsr	rst_30                            	| [rst  0x30] string_out_pe ("(C) 1981 NAMCO LTD.")
	move.b	#0x14,d2                        	| [ld   c,#0x14]
	jbsr	rst_30                            	| [rst  0x30] string_out_pe ("NAMCO" - 6 tiles)
	rts                                    	| [ret]

* 04, 09, 11: wait for fighter control task to disable itself
case_18D1:
* if (0 == task_actv_tbl_0[0x03])  attmode_state_step()
	move.b	ds_cpu0_task_actv+0x03,d0       	| [ld   a,(ds_cpu0_task_actv + 0x03)] wait for task[f_1700 fighter ctrl ]==0 before advance state
	                               	| [and  a]
	jeq	l_attmode_state_step               	| [jp   z,l_attmode_state_step]
	rts                                    	| [ret]

* 03: one time init for 7 enemies in training mode
case_18D9:
	move.b	#7,d1                           	| [ld   b,#7] 4 bosses + 3 moths
l_18DB_while:
	jbsr	c_sprite_tiles_displ              	| [call c_sprite_tiles_displ] updates offset of pointer to _attrmode_sptiles[0]
	subq.b	#1,d1                           	| [...]
	jne	l_18DB_while                       	| [djnz l_18DB_while]

	clr.b	d0                               	| [xor  a]
	move.b	d0,ds_plyr_actv+_b_nships       	| [ld   (ds_plyr_actv +_b_nships),a] 0
	move.b	d0,ds_cpu0_task_actv+0x05       	| [ld   (ds_cpu0_task_actv + 0x05),a] 0 ... f_0857 uses tmr[2]
	jbsr	c_133A                            	| [call c_133A] fghtr_onscreen()

* set inits and override defaults of bomber timers (note f_0857 disabled above)
	lea	l_FF0D(pc),a0                      	| [ld   hl,#0xFF0D]
       * tmrs_init[0x06] = 0xFF
	move.b	a0,b_92C0+0x05                  	| [ld   (b_92C0 + 0x05),hl] demo ... timrs[0x06] = $FF
	move.b	a0,b_92C0+0x04                  	| [ld   (b_92C0 + 0x04),hl] demo ... timrs
       * tmrs[0x02] = 0xFF
	move.b	a0,b_92C0+0x01                  	| [ld   (b_92C0 + 0x01),hl] demo ... timrs_ini[0x06] = $FF
	move.b	a0,b_92C0+0x00                  	| [ld   (b_92C0 + 0x00),hl] demo ... timrs_ini

	lea	d_1928(pc),a0                      	| [ld   hl,#d_1928] demo fighter vectors
	move.b	a0,pdb_demo_fghtrvctrs          	| [ld   (pdb_demo_fghtrvctrs),hl] &d_1928[0] ... demo fighter vectors

* memset($92ca,$00,$10)
	clr.b	d0                               	| [xor  a]
	move.b	#0x10,d1                        	| [ld   b,#0x10]
	lea	bmbr_boss_pool(pc),a0              	| [ld   hl,#bmbr_boss_pool] memset( ... , 0, $10 )
	jbsr	rst_18                            	| [rst  0x18] memset((HL), A=fill, B=ct)

	move.b	d0,ds_plyr_actv+_b_2ship        	| [ld   (ds_plyr_actv +_b_2ship),a] 0: not double fighter
	move.b	d0,ds_9200_glbls+0x0B           	| [ld   (ds_9200_glbls + 0x0B),a] 0: glbl_enemy_enbl (demo)
	addq.b	#1,d0                           	| [inc  a]
	move.b	d0,ds_plyr_actv+_b_bmbr_boss_cflag	| [ld   (ds_plyr_actv +_b_bmbr_boss_cflag),a] 1 ... force bomber-boss wingman for training mode
	move.b	d0,ds_cpu0_task_actv+0x10       	| [ld   (ds_cpu0_task_actv + 0x10),a] 1: f_1B65 ... manage bomber attack
	move.b	d0,ds_cpu0_task_actv+0x0B       	| [ld   (ds_cpu0_task_actv + 0x0B),a] 1: f_1DB3 ... check enemy status at 9200
	move.b	d0,ds_cpu0_task_actv+0x03       	| [ld   (ds_cpu0_task_actv + 0x03),a] 1: f_1700 ... fighter control in training/demo mode

	move.b	_sfr_dsw4,d0                    	| [ld   a,(_sfr_dsw4)] DSWA ... SOUND IN ATTRACT MODE: _fx[0x17]
	ror.b	#1,d0                            	| [rrca]
	and.b	#0x01,d0                         	| [and  #0x01]
	move.b	d0,b_9AA0+0x17                  	| [ld   (b_9AA0 + 0x17),a] from DSWA "sound in attract mode" ... 0 == enable CPU-sub2 process

	jbsr	c_game_or_demo_init               	| [call c_game_or_demo_init]

	jra	l_attmode_state_step               	| [jp   l_attmode_state_step]

* demo fighter vectors training mode
d_1928:
	.byte 0x08,0x1B,0x81,0x3D,0x81,0x0A,0x42,0x19,0x81,0x28,0x81,0x08
	.byte 0x18,0x81,0x2E,0x81,0x03,0x1A,0x81,0x11,0x81,0x05,0x42,0xC0

* 00, 06, 13: clear tile and sprite ram
case_1940:
	jbsr	c_sctrl_playfld_clr               	| [call c_sctrl_playfld_clr]
	jbsr	c_sctrl_sprite_ram_clr            	| [call c_sctrl_sprite_ram_clr]
	jra	l_attmode_state_step               	| [jr   l_attmode_state_step]

* 01: setup info-screen: sprite tbl index, text index, timer[2]
case_1948:
	lea	d_attrmode_sptiles(pc),a0          	| [ld   hl,#d_attrmode_sptiles] setup index into sprite data table
	move.b	a0,p_attrmode_sptiles           	| [ld   (p_attrmode_sptiles),hl] parameter to _sprite_tiles_displ

	clr.b	d0                               	| [xor  a]
	move.b	d0,ds_9200_glbls+0x05           	| [ld   (ds_9200_glbls + 0x05),a] 0 ... demo_scrn_txt_indx
	move.b	d0,w_bug_flying_hit_cnt         	| [ld   (w_bug_flying_hit_cnt),a] 0

	move.b	#2,d0                           	| [ld   a,#2]
	move.b	d0,ds4_game_tmrs+2              	| [ld   (ds4_game_tmrs + 2),a] 2 (1 sec)
	jra	l_attmode_state_step               	| [jr   l_attmode_state_step]

* parameters for sprite tiles used in attract mode, 4-bytes each:
*  0: offset/index of object to use
*  1: color/code
*      ccode<3:6>==code
*      ccode<0:2,7>==color
*  2: X coordinate
*  3: Y coordinate
*
d_attrmode_sptiles:
	.byte 0x08,0x1B,0x44,0x3A  | code $18 (bee)
	.byte 0x0A,0x12,0x44,0x42  | code $10 (moth)
	.byte 0x0C,0x08,0x7C,0x50  | code $08 (boss)
*d_attrmode_sptiles_7 ; label not needed, residual value of the pointer is used
	.byte 0x34,0x08,0x34,0x5C  | code $08
	.byte 0x30,0x08,0x64,0x5C  | code $08
	.byte 0x32,0x08,0x94,0x5C  | code $08
	.byte 0x4A,0x12,0xA4,0x64  | code $10
	.byte 0x36,0x08,0xC4,0x5C  | code $08
	.byte 0x58,0x12,0xB4,0x64  | code $10
	.byte 0x52,0x12,0xD4,0x64  | code $10

* 02: info-screen sequencer, advance text and sprite tiles indices
case_1984:
*  if ( 0 == game_tmrs[2] ) ... (2 on the clock from case_1948)
	move.b	ds4_game_tmrs+2,d0              	| [ld   a,(ds4_game_tmrs + 2)]
	                               	| [and  a]
	beq.b	0f                               	| [...]
	rts                                    	| [ret  nz] [...]
0:
* then ...
* . game_tmrs[2] = 2; // 1 second
	move.b	#2,d0                           	| [ld   a,#2]
	move.b	d0,ds4_game_tmrs+2              	| [ld   (ds4_game_tmrs + 2),a] info-screen: 2counts (1 second) between text

* . if (index == 5) then  state++ ; break
	move.b	ds_9200_glbls+0x05,d0           	| [ld   a,(ds_9200_glbls + 0x05)] if 5 ... demo_scrn_txt_indx
	cmp.b	#5,d0                            	| [cp   #5]
	jeq	l_attmode_state_step               	| [jr   z,l_attmode_state_step]
* . else
* .. txt_index++ ; show text
	addq.b	#1,d0                           	| [inc  a]
	move.b	d0,ds_9200_glbls+0x05           	| [ld   (ds_9200_glbls + 0x05),a] demo_scrn_txt_indx++
	add.b	#0x0D,d0                         	| [add  a,#0x0D] s_14EE - d_cstring_tbl - 1
	move.b	d0,d2                           	| [ld   c,a] C = 0x0D + A ... string index
	jbsr	rst_30                            	| [rst  0x30] string_out_pe ("GALAGA", "--SCORE--", etc)

* .. [index >= 3] && sprite_tiles_displ() && break
	move.b	ds_9200_glbls+0x05,d0           	| [ld   a,(ds_9200_glbls + 0x05)] [demo_scrn_txt_indx >= 3] ... sprite tile display
	cmp.b	#3,d0                            	| [cp   #3]
	bcc.b	0f                               	| [...]
	rts                                    	| [ret  c] [...]
0:
	jbsr	c_sprite_tiles_displ              	| [call c_sprite_tiles_displ] advances pointer to sptiles_3[]

	rts                                    	| [ret]

l_attmode_state_step:
* .demo_idx++
	lea	ds_9200_glbls+0x03(pc),a0          	| [ld   hl,#ds_9200_glbls + 0x03] advance state variable
	addq.b	#1,(a0)                         	| [inc  (hl)]
* if ( .demo_idx == 0x0F )  then demo_idx = 0
	move.b	(a0),d0                         	| [ld   a,(hl)]
	cmp.b	#0x0F,d0                         	| [cp   #0x0F]
	beq.b	0f                               	| [...]
	rts                                    	| [ret  nz] [...]
0:
	clr.b	(a0)                             	| [ld   (hl),#0]

	rts                                    	| [ret]

*=============================================================================
* f_19B2()
*  Description:
*   Manage ship movement during capturing phase. There are two segments - in
*   the first, the  ship movement simply tracks that of the capturing boss.
*   Second, once the boss reaches position in the collective, the ship is
*   moved vertically an additional 24 steps toward the top of the screen so
*   that the final position is above the boss.
*   Enabled by f_2222 tractor beam task when it terminates with the ship captured.
*   When first called 928E==1 (show text flag), which will show the text and
*   clear the flag.
*   Noticed that once the ship is positioned in the collective, it may
*   experience an additional small horizontal offset once its position begins
*   to be managed by the collective positioning manager.
* IN:
*  ...
* OUT:
*  ...
*-----------------------------------------------------------------------------
f_19B2:
*  if ( flag  != 0 )  goto show_text
	move.b	ds5_928A_captr_status+0x04,d0   	| [ld   a,(ds5_928A_captr_status + 0x04)] == 1 when boss connects with ship (2318)
	                               	| [and  a]
	jne	l_19D2_fighter_captured            	| [jr   nz,l_19D2_fighter_captured]

*  else if ( game_tmrs[1]               	| 0 == 0 )  goto erase_text
*   ... with A already 0, we use OR to check Z flag for zero count... which efficently loads our count to A at the same time!
	lea	ds4_game_tmrs+1(pc),a0             	| [ld   hl,#ds4_game_tmrs + 1]
	or.b	(a0),d0                           	| [or   (hl)]
	jeq	l_1A01_erase_text                  	| [jr   z,l_1A01_erase_text]

*  else if ( game_tmrs[1] != 4 ) goto 19c7
	cmp.b	#4,d0                            	| [cp   #4]
	jne	l_19C7                             	| [jr   nz,l_19C7]

*  timer--   .....decrement timer at 4. ... why? the count is set to 6 (19D7)
	subq.b	#1,d0                           	| [dec  a]
	move.b	d0,(a0)                         	| [ld   (hl),a]
	move.b	d0,b_9AA0+0x09                  	| [ld   (b_9AA0 + 0x09),a] game_tmrs[1] ... sound-fx count/enable registers
l_19C7:
	move.b	ds_plyr_actv+_b_cboss_slot,d0   	| [ld   a,(ds_plyr_actv +_b_cboss_slot)] bug_flite_que[ plyr.cboss_slot ].b0D = 4
	add.b	#0x0D,d0                         	| [add  a,#0x0D]
	move.b	d0,d6                           	| [ld   l,a]
	lea	ds_bug_motion_que(pc),a0           	| [ld   h,#>ds_bug_motion_que] bug_flite_que[ plyr.cboss_slot ].b0D = 4
	and.w	#0xFF,d6
	add.w	d6,a0
	      ^^^^ TODO: review XX value
	move.b	#4,(a0)                         	| [ld   (hl),#4]
	rts                                    	| [ret]

l_19D2_fighter_captured:
* sets up a captured-fighter as an enemy object
	move.b	#0x0A,d2                        	| [ld   c,#0x0A] index of string
	jbsr	rst_30                            	| [rst  0x30] string_out_pe "FIGHTER CAPTURED"
	move.b	#6,d0                           	| [ld   a,#6] set time of countdown
	move.b	d0,ds4_game_tmrs+1              	| [ld   (ds4_game_tmrs + 1),a] 6 ...time to show fighter-captured-text
	lea	ds_sprite_posn+0x62(pc),a0         	| [ld   hl,#ds_sprite_posn + 0x62] ship (1) position
	move.b	ds_plyr_actv+_b_bmbr_boss_cobj,d0	| [ld   a,(ds_plyr_actv +_b_bmbr_boss_cobj)]
	and.b	#7,d0                            	| [and  #7] captured ships are in same order as bosses, from 8800-8807
	move.b	d0,d4                           	| [ld   e,a]
	move.b	d5,d3                           	| [ld   d,h]
	move.b	(a0),d0                         	| [ld   a,(hl)] get column of ship object e.g. ... A := *(9362)
	move.b	d0,(a1)                         	| [ld   (de),a] get column of captured ship object e.g. (DE == 9302)
	clr.b	(a0)                             	| [ld   (hl),#0]
* set row offset of captured ship object
	addq.w	#1,a0                           	| [inc  l]
	addq.w	#1,a1                           	| [inc  e]
	move.b	(a0),d0                         	| [ld   a,(hl)]
	move.b	d0,(a1)                         	| [ld   (de),a]
* odd byte of sprite ctrl...
	lea	ds_sprite_ctrl(pc),a0              	| [ld   h,#>ds_sprite_ctrl]
	and.w	#0xFF,d6
	add.w	d6,a0
	      ^^^^ TODO: review XX value
	move.b	d5,d3                           	| [ld   d,h]
	move.b	(a0),d0                         	| [ld   a,(hl)]
	move.b	d0,(a1)                         	| [ld   (de),a]

	lea	ds_sprite_code(pc),a0              	| [ld   h,#>ds_sprite_code]
	and.w	#0xFF,d6
	add.w	d6,a0
	      ^^^^ TODO: review XX value
	move.b	d4,d6                           	| [ld   l,e]
	move.b	#7,(a0)                         	| [ld   (hl),#7] sprite code 7 is the vertical ship "wing closed" used for captured ship
	subq.w	#1,a0                           	| [dec  l]
	move.b	#7,(a0)                         	| [ld   (hl),#7] sprite color ... red
	clr.b	d0                               	| [xor  a]
	move.b	d0,ds5_928A_captr_status+0x01   	| [ld   (ds5_928A_captr_status + 0x01),a] 0
	move.b	d0,ds5_928A_captr_status+0x04   	| [ld   (ds5_928A_captr_status + 0x04),a] 0 .... erase fighter-captured text
	rts                                    	| [ret]

l_1A01_erase_text:
* check if text has been cleared yet?
*  if ( *82d1 == $24 ) goto $1a10
	move.b	0x8000+0x02C0+0x11,d0       	| [ld   a,(0x8000 + 0x02C0 + 0x11)] 'I' of fighter captured
	cmp.b	#0x24,d0                         	| [cp   #0x24]
	jeq	l_1A10                             	| [jr   z,l_1A10]
*  clear "fighter captured" text
	move.b	#0x0B,d2                        	| [ld   c,#0x0B] index into string table
	lea	0x8000+0x03A0+0x11(pc),a0      	| [ld   hl,#0x8000 + 0x03A0 + 0x11] "leftmost" column of row where "fighter captured" is displayed
	jbsr	c_string_out                      	| [call c_string_out] erase fighter capture text
l_1A10:
	move.b	ds_plyr_actv+_b_bmbr_boss_cobj,d0	| [ld   a,(ds_plyr_actv +_b_bmbr_boss_cobj)]
	move.b	d0,d6                           	| [ld   l,a]
	and.b	#0x07,d0                         	| [and  #0x07] ships are in same order as bosses, from 8800-8807
	move.b	d0,d4                           	| [ld   e,a]
	lea	b_8800(pc),a0                      	| [ld   h,#>b_8800]
	and.w	#0xFF,d6
	add.w	d6,a0
	      ^^^^ TODO: review XX value
	move.b	b_9215_flip_screen,d0           	| [ld   a,(b_9215_flip_screen)]
	move.b	d0,d2                           	| [ld   c,a]
	move.b	(a0),d0                         	| [ld   a,(hl)] e.g. HL==8832
	cmp.b	#0x09,d0                         	| [cp   #0x09] check if object status "flying"
	jne	l_1A3F_join_ship_to_group          	| [jr   nz,l_1A3F_join_ship_to_group] status changes to 2 (rotating) when boss reaches home positn
	lea	ds_sprite_posn(pc),a0              	| [ld   h,#>ds_sprite_posn]
	and.w	#0xFF,d6
	add.w	d6,a0
	      ^^^^ TODO: review XX value
	move.b	d5,d3                           	| [ld   d,h] DE == captd ship sprite posn
	move.b	(a0)+,d0                         	| [ld   a,(hl)] HL == boss posn, horizontal
	move.b	d0,(a1)+                         	| [ld   (de),a]
	                           	| [inc  l]
                           	| [inc  e]
	move.b	#0x10,d0                        	| [ld   a,#0x10] offset captured-ship vertically from flying boss
*  if ( !flip_screen ) goto 1a31
	btst.b	#0,d2                           	| [bit  0,c] C == _flip_screen
	jeq	l_1A31                             	| [jr   z,l_1A31]
	neg.b	d0                               	| [neg] offset negated for inverted screen.
l_1A31:
	move.b	d0,d1                           	| [ld   b,a] A == vertical offset of ship from boss
	add.b	(a0),d0                          	| [add  a,(hl)] HL == boss in sprite posn regs (odds...vertical posn)
	move.b	d0,(a1)                         	| [ld   (de),a] ... DE == boss_posn + $10
	roxr.b	#1,d0                           	| [rra]
      ^^^^^^ TODO: review cpu X flag
	eor.b	d1,d0                            	| [xor  b]
	rol.b	#1,d0                            	| [rlca]
	and.b	#0x01,d0                         	| [and  #0x01]
	lea	ds_sprite_ctrl(pc),a0              	| [ld   h,#>ds_sprite_ctrl] .b1
	and.w	#0xFF,d6
	add.w	d6,a0
	      ^^^^ TODO: review XX value
	move.b	d5,d3                           	| [ld   d,h]
	move.b	(a0),d7
	eor.b	d7,d0                            	| [xor  (hl)]
	move.b	d0,(a1)                         	| [ld   (de),a] update ship sprite ctrl (e.g. 9B03)
	rts                                    	| [ret]

* ...boss status e.g. 8830[n] == $02  (rotating into position)
l_1A3F_join_ship_to_group:
* if ( couonter > 0 ) goto 1A4B
	lea	ds5_928A_captr_status+0x01(pc),a0  	| [ld   hl,#ds5_928A_captr_status + 0x01] counter while captured ship is joined with the collective
	move.b	(a0),d0                         	| [ld   a,(hl)] a=0
	                               	| [and  a]
	jne	l_1A4B_test_positioning_timer      	| [jr   nz,l_1A4B_test_positioning_timer]
* else initialize_ship_sprite
	lea	ds_sprite_code(pc),a1              	| [ld   d,#>ds_sprite_code]
	and.w	#0xFF,d4
	add.w	d4,a1
	      ^^^^ TODO: review XX value
	move.b	#6,d0                           	| [ld   a,#6] ship sprite code
	move.b	d0,(a1)                         	| [ld   (de),a]
l_1A4B_test_positioning_timer:
	addq.b	#1,(a0)                         	| [inc  (hl)] *( ds5_928A_captr_status + 1 )++
	cmp.b	#0x24,d0                         	| [cp   #0x24]
	jeq	l_1A6A_ship_in_position            	| [jr   z,l_1A6A_ship_in_position]

* set position increment +1 for inverted screen, otherwise -1
	move.b	#1,d1                           	| [ld   b,#1]
	btst.b	#0,d2                           	| [bit  0,c] C == flip_screen
	jne	l_1A58                             	| [jr   nz,l_1A58]
	subq.b	#2,d1                           	| [dec  b] * 2
l_1A58:
	move.b	d4,d6                           	| [ld   l,e]
	addq.b	#1,d6                           	| [inc  l] set vertical position (odd-byte)
	lea	ds_sprite_posn(pc),a0              	| [ld   h,#>ds_sprite_posn]
	and.w	#0xFF,d6
	add.w	d6,a0
	      ^^^^ TODO: review XX value
	move.b	d1,d0                           	| [ld   a,b]
	add.b	(a0),d0                          	| [add  a,(hl)]
	move.b	d0,(a0)                         	| [ld   (hl),a]
	roxr.b	#1,d0                           	| [rra]
      ^^^^^^ TODO: review cpu X flag
	eor.b	d1,d0                            	| [xor  b]
	rol.b	#1,d0                            	| [rlca]
	bcs.b	0f                               	| [...]
	rts                                    	| [ret  nc] [...]
0:
	lea	ds_sprite_ctrl(pc),a0              	| [ld   h,#>ds_sprite_ctrl]
	and.w	#0xFF,d6
	add.w	d6,a0
	      ^^^^ TODO: review XX value
	move.b	(a0),d0                         	| [ld   a,(hl)]
	eor.b	#0x01,d0                         	| [xor  #0x01]
	move.b	d0,(a0)                         	| [ld   (hl),a]
	rts                                    	| [ret]

l_1A6A_ship_in_position:
	clr.b	d0                               	| [xor  a]
	move.b	d0,ds_cpu0_task_actv+0x11       	| [ld   (ds_cpu0_task_actv + 0x11),a] 0: this task
	move.b	d0,b_9AA0+0x09                  	| [ld   (b_9AA0 + 0x09),a] 0: sound-fx count/enable registers
	lea	b_8800(pc),a1                      	| [ld   d,#>b_8800]
	and.w	#0xFF,d4
	add.w	d4,a1
	      ^^^^ TODO: review XX value
	addq.b	#1,d0                           	| [inc  a]
	move.b	d0,(a1)                         	| [ld   (de),a] 1: b_8800[n] (stand-by position)
	move.b	d0,ds_plyr_actv+_b_bmbr_boss_cobj	| [ld   (ds_plyr_actv +_b_bmbr_boss_cobj),a] 1: invalidate the capture boss object (e.g. was $32)
	move.b	d0,ds_99B9_star_ctrl+0x00       	| [ld   (ds_99B9_star_ctrl + 0x00),a] 1: when fighter on screen
	addq.b	#1,d0                           	| [inc  a]
	move.b	d0,ds_9200_glbls+0x13           	| [ld   (ds_9200_glbls + 0x13),a] 2: restart-stage flag (fighter captured)
	rts                                    	| [ret]

*=============================================================================
* f_1A80()
*  Description:
*   "clone-attack" manager.
*   Not active until stage-4 or higher because the parameter is 0.
* IN:
*  ...
* OUT:
*  ...
*-----------------------------------------------------------------------------
f_1A80:
* check parameter for condition to enable the bonus-bee feature.
* if ( num_bugs > num_bugs_for_bonus_bee ) then return
	move.b	ds_new_stage_parms+0x0A,d0      	| [ld   a,(ds_new_stage_parms + 0x0A)] bonus-bee when bug count reaches this
	move.b	d0,d2                           	| [ld   c,a]
	move.b	b_bugs_actv_nbr,d0              	| [ld   a,(b_bugs_actv_nbr)]
	cmp.b	d2,d0                            	| [cp   c]
	bcs.b	0f                               	| [...]
	rts                                    	| [ret  nc] [...]
0:

* if ( activated_one_already ) goto 1AD5
	move.b	ds_plyr_actv+_b_bbee_tmr,d0     	| [ld   a,(ds_plyr_actv +_b_bbee_tmr)]
	                               	| [and  a]
	jne	l_1AD5_in_one_already              	| [jr   nz,l_1AD5_in_one_already]
* else ... find_available
	lea	b_8800+0x07(pc),a0                 	| [ld   hl,#b_8800 + 0x07] first object of bee group (minus 1)
	move.b	#20*256+0xFF_msb,d1             	| [ld   bc,#20 * 256 + 0xFF] 20 of these pests (we don't care about C) None
	move.b	#20*256+0xFF_lsb,d2             	| [ld   bc,#20 * 256 + 0xFF] 20 of these pests (we don't care about C) None
	move.b	#1,d0                           	| [ld   a,#1] 1 == resting
l_1A97:
	addq.w	#1,a0                           	| [inc  l] increment to next even offset
	jbsr	cpi                               	| [cpi] A-(HL), HL <- HL+1, BC <- BC-1
     ^^^^ TODO: review special instruction inputs
	jeq	l_1AAB_found_one                   	| [jr   z,l_1AAB_found_one]
	subq.b	#1,d1                           	| [...]
	jne	l_1A97                             	| [djnz l_1A97]

* iterate through moth group and find one that is resting
	lea	b_8800+0x40-1(pc),a0               	| [ld   hl,#b_8800 + 0x40 - 1] offset into moth group
	move.b	#0x10,d1                        	| [ld   b,#0x10] 16 of the vermin
l_1AA3:
	addq.w	#1,a0                           	| [inc  l] increment to next even offset
	jbsr	cpi                               	| [cpi]
     ^^^^ TODO: review special instruction inputs
	jeq	l_1AAB_found_one                   	| [jr   z,l_1AAB_found_one]
	subq.b	#1,d1                           	| [...]
	jne	l_1AA3                             	| [djnz l_1AA3]

	rts                                    	| [ret]

l_1AAB_found_one:
	move.b	#0xC0,d0                        	| [ld   a,#0xC0]
	move.b	d0,ds_plyr_actv+_b_bbee_tmr     	| [ld   (ds_plyr_actv +_b_bbee_tmr),a] $C0 ... delay count until bonus-bee launch
	subq.w	#1,a0                           	| [dec  l]
 	move.b	d6,d4                           	| [ld   e,l]
	lea	ds_sprite_code(pc),a1              	| [ld   d,#>ds_sprite_code]
	and.w	#0xFF,d4
	add.w	d4,a1
	      ^^^^ TODO: review XX value
	addq.w	#1,a1                           	| [inc  e]
            ^^^^ TODO check inc register d4 or a1
	move.b	(a1),d0                         	| [ld   a,(de)]
	subq.w	#1,a1                           	| [dec  e]
            ^^^^ TODO check dec register d4 or a1
	move.b	d0,d2                           	| [ld   c,a]
	move.b	ds_plyr_actv+_b_stgctr,d0       	| [ld   a,(ds_plyr_actv +_b_stgctr)] "Bonus-bee" manager
	lsr.b	#2,d0                            	| [srl  a] * 2
	move.b	d0,d6                           	| [ld   l,a]
	clr.b	d5                               	| [ld   h,#0]
	move.b	#3,d0                           	| [ld   a,#3]
	jbsr	c_divmod                          	| [call c_divmod] HL=HL/3
	addq.b	#4,d0                           	| [add  a,#4]
	lea	ds_plyr_actv+_b_bbee_obj(pc),a0    	| [ld   hl,#ds_plyr_actv +_b_bbee_obj]
	move.b	d4,(a0)+                         	| [ld   (hl),e]
	                           	| [inc  l]
	move.b	d2,(a0)+                         	| [ld   (hl),c]
	                           	| [inc  l]
	move.b	d0,(a0)                         	| [ld   (hl),a]
	move.b	d0,b_9AA0+0x12                  	| [ld   (b_9AA0 + 0x12),a] sound-fx count/enable registers, bonus-bee sound
	rts                                    	| [ret]

l_1AD5_in_one_already:
	addq.b	#1,d0                           	| [inc  a] A == delay count until bonus-bee launch
	jeq	l_1AF4_ready_go                    	| [jr   z,l_1AF4_ready_go]
	move.b	d0,ds_plyr_actv+_b_bbee_tmr     	| [ld   (ds_plyr_actv +_b_bbee_tmr),a] A<0 (delay count until bonus-bee launch)
	scs	d7                              	| [ex   af,af'] stash the counter
         ^^^ TODO review: wrong if carry is needed or D7 used in between!
	lea	ds_plyr_actv+_b_bbee_obj(pc),a0    	| [ld   hl,#ds_plyr_actv +_b_bbee_obj]
	move.b	(a0),d4                         	| [ld   e,(hl)]
	lea	b_8800(pc),a1                      	| [ld   d,#>b_8800]
	and.w	#0xFF,d4
	add.w	d4,a1
	      ^^^^ TODO: review XX value
	move.b	(a1),d0                         	| [ld   a,(de)]
* if ( object_status != 1 ) exit  ... (killed the little fucker before he could launch)
	subq.b	#1,d0                           	| [dec  a]
	jne	l_1B54_getout                      	| [jp   nz,l_1B54_getout]
* else
	lea	ds_sprite_code(pc),a1              	| [ld   d,#>ds_sprite_code]
	and.w	#0xFF,d4
	add.w	d4,a1
	      ^^^^ TODO: review XX value
	addq.w	#1,a0                           	| [inc  l] HL:=982E   ... color 'A'
            ^^^^ TODO check inc register d6 or a0
	scs	d7                              	| [ex   af,af'] recover the counter
         ^^^ TODO review: wrong if carry is needed or D7 used in between!
	btst.b	#4,d0                           	| [bit  4,a] check for %$10 (alternate color every 1/4 second)
	jeq	l_1AF0_alternating_colors          	| [jr   z,l_1AF0_alternating_colors]
	addq.w	#1,a0                           	| [inc  l] HL:=982F   ... color 'B'
            ^^^^ TODO check inc register d6 or a0
l_1AF0_alternating_colors:
	move.b	(a0),d0                         	| [ld   a,(hl)]
	addq.w	#1,a1                           	| [inc  e] point to color register (odd-byte offset)
	move.b	d0,(a1)                         	| [ld   (de),a]
	rts                                    	| [ret]

l_1AF4_ready_go:
	move.b	ds_cpu0_task_actv+0x15,d0       	| [ld   a,(ds_cpu0_task_actv + 0x15)] f_1F04: fire button input ...  a "bonus-bee" has started
	                               	| [and  a]
	jne	l_1B00                             	| [jr   nz,l_1B00]
	move.b	#0xE0,d0                        	| [ld   a,#0xE0]
	move.b	d0,ds_plyr_actv+_b_bbee_tmr     	| [ld   (ds_plyr_actv +_b_bbee_tmr),a] $E0
	rts                                    	| [ret]

l_1B00:
	move.b	ds_plyr_actv+_b_bbee_obj,d0     	| [ld   a,(ds_plyr_actv +_b_bbee_obj)]
	move.b	d0,d6                           	| [ld   l,a]
	lea	b_8800(pc),a0                      	| [ld   h,#>b_8800]
	and.w	#0xFF,d6
	add.w	d6,a0
	      ^^^^ TODO: review XX value
	move.b	(a0),d0                         	| [ld   a,(hl)]
	subq.b	#1,d0                           	| [dec  a]
	jne	l_1B54_getout                      	| [jr   nz,l_1B54_getout] make sure he's not dead
	lea	b_9200_obj_collsn_notif(pc),a0     	| [ld   h,#>b_9200_obj_collsn_notif]
	and.w	#0xFF,d6
	add.w	d6,a0
	      ^^^^ TODO: review XX value
	move.b	(a0),d0                         	| [ld   a,(hl)]
	btst.b	#7,d0                           	| [bit  7,a]
	jne	l_1B54_getout                      	| [jr   nz,l_1B54_getout] make sure he's not dead
	move.b	ds_plyr_actv+_b_bbee_clr_b,d0   	| [ld   a,(ds_plyr_actv +_b_bbee_clr_b)]
	subq.b	#4,d0                           	| [sub  #4] convert color 4,5,or 6 to index from 0
	lea	d_1B59(pc),a0                      	| [ld   hl,#d_1B59]
	jbsr	rst_08                            	| [rst  0x08] HL += 2A
	lea	ds3_99B0_X3attackcfg(pc),a1        	| [ld   de,#ds3_99B0_X3attackcfg] setup X3 attacker, write 3 bytes...
                                                  * [0]:=3
                                                  * [1] [2] word loaded from 1B59[ 2 * ( actv_plyr_state + 0x0F ) ]
	move.b	#3,d0                           	| [ld   a,#3]
	move.b	d0,(a1)+                         	| [ld   (de),a] (99B0):=3
	                           	| [inc  e]
	jbsr	ldi                               	| [ldi]
     ^^^^ TODO: review special instruction inputs
	jbsr	ldi                               	| [ldi]
     ^^^^ TODO: review special instruction inputs
* setup vector argument to c_1083
	move.b	ds_plyr_actv+_b_bbee_clr_b,d0   	| [ld   a,(ds_plyr_actv +_b_bbee_clr_b)]
	subq.b	#4,d0                           	| [sub  #4] convert color 4,5,or 6 to index from 0
	and.b	#0x0F,d0                         	| [and  #0x0F] hmmmm.... we didn't do this before.. oh well
	move.b	d0,d2                           	| [ld   c,a]
	lea	d_1B5F(pc),a0                      	| [ld   hl,#d_1B5F] setup to load pointers into DE
	jbsr	rst_08                            	| [rst  0x08] HL += 2A
	move.b	(a0),d4                         	| [ld   e,(hl)]
	addq.w	#1,a0                           	| [inc  hl]
	move.b	(a0),d3                         	| [ld   d,(hl)]
* setup HL pointer to object in sprite code registers
	lea	ds_sprite_code(pc),a0              	| [ld   h,#>ds_sprite_code]
	and.w	#0xFF,d6
	add.w	d6,a0
	      ^^^^ TODO: review XX value
	move.b	ds_plyr_actv+_b_bbee_obj,d0     	| [ld   a,(ds_plyr_actv +_b_bbee_obj)]
	move.b	d0,d6                           	| [ld   l,a]

	move.b	d2,d0                           	| [ld   a,c] grab "color B" again
	rol.b	#3,d0                            	| [rlca] * 3
	add.b	#0x56,d0                         	| [add  a,#0x56]
	move.b	(a0),d2                         	| [ld   c,(hl)]
	move.b	d0,(a0)                         	| [ld   (hl),a]
	move.b	d2,d0                           	| [ld   a,c] grab "color B" again
	and.b	#0xF8,d0                         	| [and  #0xF8] ?
	move.b	d0,d2                           	| [ld   c,a]
	move.b	ds_plyr_actv+_b_bbee_clr_a,d0   	| [ld   a,(ds_plyr_actv +_b_bbee_clr_a)]
	and.b	#0x07,d0                         	| [and  #0x07]
	or.b	d2,d0                             	| [or   c]
	move.b	d0,ds_plyr_actv+_b_bbee_clr_a   	| [ld   (ds_plyr_actv +_b_bbee_clr_a),a]
	lea	b_8800(pc),a0                      	| [ld   h,#>b_8800]
	and.w	#0xFF,d6
	add.w	d6,a0
	      ^^^^ TODO: review XX value
	jbsr	c_1083                            	| [call c_1083] bomber setup, clone-attack mgr
l_1B54_getout:
	clr.b	d0                               	| [xor  a]
	move.b	d0,ds_cpu0_task_actv+0x04       	| [ld   (ds_cpu0_task_actv + 0x04),a] 0: f_1A80 ... this task

	rts                                    	| [ret]

*=============================================================================
* bonus-bee configuration parameters
d_1B59:
	.byte 0x1E,0xBD
	.byte 0x0A,0xB8
	.byte 0x14,0xBC
d_1B5F:
	.long db_04EA
	.long db_0473
	.long db_04AB

*=============================================================================
* f_1B65()
*  Description:
*   Manage bomber attacks, enabled during demo in fighter-movement phase, as
*   well as in training mode. Disabled at start of each round until all
*   enemies are in home position, then enabled for the duration of the round.
* IN:
*  ...
* OUT:
*  ...
*-----------------------------------------------------------------------------
f_1B65:
* if ( flag == zero ) skip the condition check
	move.b	ds_9200_glbls+0x0B,d0           	| [ld   a,(ds_9200_glbls + 0x0B)] glbl_enemy_enbl
	                               	| [and  a]
	jeq	l_1B75                             	| [jr   z,l_1B75]

* if ((0 == ds_cpu0_task_actv[0x15])    	|| (0 != ds_cpu0_task_actv + 0x1D))  return
	move.b	ds_cpu0_task_actv+0x15,d0       	| [ld   a,(ds_cpu0_task_actv + 0x15)] f_1F04 (fire button input)
	move.b	d0,d2                           	| [ld   c,a]
	move.b	ds_cpu0_task_actv+0x1D,d0       	| [ld   a,(ds_cpu0_task_actv + 0x1D)] f_2000 (destroyed capture-boss)
	not.b	d0                               	| [cpl]
	and.b	d2,d0                            	| [and  c]
	bne.b	0f                               	| [...]
	rts                                    	| [ret  z] [...]
0:

* check the queue for boss+wing mission ... parameters are queue'd by case boss launcher
l_1B75:
	move.b	#4,d1                           	| [ld   b,#4]
	lea	bmbr_boss_pool(pc),a0              	| [ld   hl,#bmbr_boss_pool] check 4 groups of 3 bytes
l_1B7A:
	move.b	(a0),d0                         	| [ld   a,(hl)] .b0: valid object index if slot active, otherwise $FF
	addq.b	#1,d0                           	| [inc  a] 0 if boss_wing_slots[n*4].b0 == $ff
	jne	l_1B8B                             	| [jr   nz,l_1B8B] if slot active, go launch it
	addq.w	#3,a0                           	| [inc  l]
	subq.b	#1,d1                           	| [...]
	jne	l_1B7A                             	| [djnz l_1B7A]

       * insert a 1/4 sec delay before trying next bomber
	move.b	ds3_92A0_frame_cts+0,d0         	| [ld   a,(ds3_92A0_frame_cts + 0)]
	and.b	#0x0F,d0                         	| [and  #0x0F]
	jeq	l_1BA8                             	| [jr   z,l_1BA8]
	rts                                    	| [ret]

* launching element of boss+wing mission
* A == bmbr_boss_pool[L].obj_idx + 1
l_1B8B:
	move.b	#0xFF,(a0)                      	| [ld   (hl),#0xFF] bmbr_boss_pool[ n * 3 + 0 ] = $ff
	subq.b	#1,d0                           	| [dec  a] undo increment of boss_wing_slots[n].idx
	lea	b_8800(pc),a1                      	| [ld   d,#>b_8800]
	and.w	#0xFF,d4
	add.w	d4,a1
	      ^^^^ TODO: review XX value
	move.b	d0,d4                           	| [ld   e,a] e.g. E=$30 (boss)   8834 (boss already has a captured ship)
	bclr.b	#7,d4                           	| [res  7,e] bit-7 was used to indicate negated rotation angle to (ix)0x0C

* stash A ... object/index from boss_wing_slots[n] (with bit-7 possibly set for negating rotation angle)
	scs	d7                              	| [ex   af,af']
         ^^^ TODO review: wrong if carry is needed or D7 used in between!

* if (STAND_BY != obj_status[E].state) return ... disposition resting/inactivez
	move.b	(a1),d0                         	| [ld   a,(de)] 92CA[].b0
	subq.b	#1,d0                           	| [dec  a]
	beq.b	0f                               	| [...]
	rts                                    	| [ret  nz] exit if not available (demo) [...]
0:

* pointer to object data (in cpu-sub1 code space)
	addq.w	#1,a0                           	| [inc  l]
            ^^^^ TODO check inc register d6 or a0
	move.b	(a0)+,d4                         	| [ld   e,(hl)] e.g. 92CA[].b1, lsb of pointer to data
	                           	| [inc  l]
	move.b	(a0),d3                         	| [ld   d,(hl)] e.g. 92CA[].b2, msb of pointer to data

* reload A
	scs	d7                              	| [ex   af,af']
         ^^^ TODO review: wrong if carry is needed or D7 used in between!
	move.b	d0,d6                           	| [ld   l,a] byte-0 of boss_wing_slots[n*3] ... object index/offset
	lea	b_8800(pc),a0                      	| [ld   h,#>b_8800] e.g. b_8800[$30]
	and.w	#0xFF,d6
	add.w	d6,a0
	      ^^^^ TODO: review XX value
	jbsr	c_1079                            	| [call c_1079] DE, HL, and bit-7 of HL for negation of rotation angle if set

	move.b	#1,d0                           	| [ld   a,#1]
	move.b	d0,b_9AA0+0x13                  	| [ld   (b_9AA0 + 0x13),a] 1 ... sound-fx count/enable registers, bug dive attack sound
	rts                                    	| [ret]

l_1BA8:
* check each bomber type for ready status i.e. yellow, red, boss
	lea	b_92C0+0x00(pc),a0                 	| [ld   hl,#b_92C0 + 0x00] 3 bytes, 1 byte for each slot, enumerates selection of red, yellow, or boss
	move.b	#3,d1                           	| [ld   b,#3]
l_1BAD:
	subq.b	#1,(a0)                         	| [dec  (hl)] check if this one timed out
	jeq	l_1BB4                             	| [jr   z,l_1BB4] b used below argument to "switch" to select type of alien launched?
	addq.w	#1,a0                           	| [inc  l]
	subq.b	#1,d1                           	| [...]
	jne	l_1BAD                             	| [djnz l_1BAD]

	rts                                    	| [ret] none are ready

l_1BB4:
* if (bugs_flying_nbr >= max_flying_bugs_this_rnd) then ...
	move.b	ds_new_stage_parms+0x04,d0      	| [ld   a,(ds_new_stage_parms + 0x04)] max_bombers
	move.b	d0,d2                           	| [ld   c,a]

	move.b	b_bugs_flying_nbr,d0            	| [ld   a,(b_bugs_flying_nbr)]
	cmp.b	d2,d0                            	| [cp   c]
	jcs	l_1BC0                             	| [jr   c,l_1BC0]
* maximum nbr of bugs already flying set slot-counter back to 1 since it can't be processed right now
	addq.b	#1,(a0)                         	| [inc  (hl)]
	rts                                    	| [ret]

* else ... launch another bombing excursion
l_1BC0:
* b_92C0_0[n] =  b_92C0_0[n + 4] ... set next timeout for this bomber type
	bset.b	#2,d6                           	| [set  2,l] offset += 4
	move.b	(a0),d0                         	| [ld   a,(hl)] $92C0[n+4]
	bclr.b	#2,d6                           	| [res  2,l]
	move.b	d0,(a0)                         	| [ld   (hl),a]

	move.b	d1,d0                           	| [ld   a,b] ... b from loop l_1bad above decremented from 3
	subq.b	#1,d0                           	| [dec  a] offset for 0 based indexing of "switch"

* switch(A)
	lea	d_1BD1(pc),a0                      	| [ld   hl,#d_1BD1]
	jbsr	rst_08                            	| [rst  0x08] HL += 2A
	move.b	(a0),d0                         	| [ld   a,(hl)]
	addq.w	#1,a0                           	| [inc  hl]
	move.b	(a0),d5                         	| [ld   h,(hl)]
	move.b	d0,d6                           	| [ld   l,a]
	jra	(a0)                               	| [jp   (hl)]
d_1BD1:
* jp table in order of bomber launch timers
	.long case_bmbr_yellow
	.long case_bmbr_red
	.long case_bmbr_boss

* set bee launch params
case_bmbr_yellow:
	move.b	#20,d1                          	| [ld   b,#20] number of yellow aliens
	lea	b_8800+0x08(pc),a0                 	| [ld   hl,#b_8800 + 0x08] $08-$2E
	lea	db_flv_atk_yllw(pc),a1             	| [ld   de,#db_flv_atk_yllw]

* this section common to both bee and moth launcher, check for next one, skip if already active
l_1BDF:
	move.b	ds_plyr_actv+_b_bbee_obj,d0     	| [ld   a,(ds_plyr_actv +_b_bbee_obj)] load bonus-bee parameter
	move.b	d0,d2                           	| [ld   c,a] stash A
l_1BE3_while:
* if ( disposition == STAND_BY ) && ...
	move.b	(a0),d0                         	| [ld   a,(hl)] obj_status[L].state
	subq.b	#1,d0                           	| [dec  a]
	jne	l_1BEB_next                        	| [jr   nz,l_1BEB_next]
* ... ( L != bonus_bee_index ) then l_1BF0_found_one
	move.b	d2,d0                           	| [ld   a,c] unstash A ... offset_to_bonus_bee
	cmp.b	d6,d0                            	| [cp   l]
	jne	l_1BF0_found_one                   	| [jr   nz,l_1BF0_found_one]
l_1BEB_next:
	addq.w	#2,a0                           	| [inc  l]
            ^^^^ TODO check inc register d6 or a0 * 2
	subq.b	#1,d1                           	| [...]
	jne	l_1BE3_while                       	| [djnz l_1BE3_while]

	rts                                    	| [ret]

l_1BF0_found_one:
	move.b	d0,b_9AA0+0x13                  	| [ld   (b_9AA0 + 0x13),a] from C, !0 ... sound-fx count/enable registers, bug dive attack sound
	jbsr	c_1083                            	| [call c_1083] bomber setup, red or yellow alien
	rts                                    	| [ret]

* set red moth launch params
case_bmbr_red:
	move.b	#16,d1                          	| [ld   b,#16] number of red aliens
	lea	b_8800+0x40(pc),a0                 	| [ld   hl,#b_8800 + 0x40] red moths $40-$5E
	lea	db_flv_atk_red(pc),a1              	| [ld   de,#db_flv_atk_red]
	jra	l_1BDF                             	| [jr   l_1BDF] common to red and yellow alien

* boss launcher... only enable capture-mode for every other one ( %2 )
case_bmbr_boss:
* if (boss is diving/capturing ) then goto 1C30
	move.b	ds_plyr_actv+_b_bmbr_boss_cflag,d0	| [ld   a,(ds_plyr_actv +_b_bmbr_boss_cflag)] 1 if capture-mode is active / capture-mode selection suppressed
	                               	| [and  a]
	jne	l_1C30                             	| [jr   nz,l_1C30]
* if ( plyr.cboss_enable_toggle % 2 ) then goto 1C30
	lea	ds_plyr_actv+_b_bmbr_boss_wingm(pc),a0	| [ld   hl,#ds_plyr_actv +_b_bmbr_boss_wingm] toggle bomber boss wingman-enable
	addq.b	#1,(a0)                         	| [inc  (hl)]
	btst.b	#0,(a0)                         	| [bit  0,(hl)]
	jne	l_1C30                             	| [jr   nz,l_1C30]

* capture-mode select: for each boss, first one that status==standby beomes capture-boss
ld   ixl,2
	lea	db_0454(pc),a3                     	| [ld   iy,#db_0454]
	lea	b_8800+0x30(pc),a1                 	| [ld   de,#b_8800 + 0x30] bosses start at $30 ... object/index of bomber to _1CAE
	move.b	#0x04,d1                        	| [ld   b,#0x04] there are 4 of these evil creatures

l_1C1B_while:
	move.b	(a1),d0                         	| [ld   a,(de)] sprt_mctl_objs[de].state
	subq.b	#1,d0                           	| [dec  a] if disposition STAND_BY,  1->0
	jeq	l_1C24_is_standby                  	| [jr   z,l_1C24_is_standby]
	addq.w	#2,a1                           	| [inc  e] status bytes, evens ... i.e. 8830, 32, etc.
	subq.b	#1,d1                           	| [...]
	jne	l_1C1B_while                       	| [djnz l_1C1B_while]

	rts                                    	| [ret]

l_1C24_is_standby:
	move.b	#1,d0                           	| [ld   a,#1]
	move.b	d0,ds_plyr_actv+_b_bmbr_boss_cflag	| [ld   (ds_plyr_actv +_b_bmbr_boss_cflag),a] 1 ... force next bomber-boss to wingman mode (suppress capture-boss select)
	move.b	d4,d0                           	| [ld   a,e]
	move.b	d0,ds_plyr_actv+_b_bmbr_boss_cobj	| [ld   (ds_plyr_actv +_b_bmbr_boss_cobj),a] object/index of bomber to _1CAE ... bosses start at $30
	jra	j_1CAE                             	| [jp   j_1CAE] _boss_activate(e, ixl, b, iy) ... C?

* alredy in capture-mode, or capture-mode select is suppressed this time ... look for a wingman
* get red alien index, check if already flagged by plyr_state.clone_attkr_en
l_1C30:
* escort object/IDs order in data right->left so bit will shift out left->right
	lea	d_1D2C_wingmen(pc),a0              	| [ld   hl,#d_1D2C_wingmen]
	lea	b_8800(pc),a1                      	| [ld   d,#>b_8800]
	and.w	#0xFF,d4
	add.w	d4,a1
	      ^^^^ TODO: review XX value
	move.b	#6*256+0_msb,d1                 	| [ld   bc,#6 * 256 + 0] check 6 objects (B) and clear C None
	move.b	#6*256+0_lsb,d2                 	| [ld   bc,#6 * 256 + 0] check 6 objects (B) and clear C None
l_1C38_while:
	move.b	(a0),d4                         	| [ld   e,(hl)]
	addq.w	#1,a0                           	| [inc  hl]
* if "special attacker" skip test object_status STAND_BY
	move.b	ds_plyr_actv+_b_bbee_obj,d0     	| [ld   a,(ds_plyr_actv +_b_bbee_obj)] check if wingman is already special-bomber
	cmp.b	d4,d0                            	| [cp   e]
	jeq	l_1C44                             	| [jr   z,l_1C44]
* test if object_status = STAND_BY
	move.b	(a1),d0                         	| [ld   a,(de)]
	subq.b	#2,d0                           	| [dec  a] one byte opcode ... * 2
l_1C44:
	roxl.b	#1,d2                           	| [rl   c] shifts in a bit from Cy if object status was 1 (00 - 01 = FF)
	subq.b	#1,d1                           	| [...]
	jne	l_1C38_while                       	| [djnz l_1C38_while]

ld   ixl,#0                                ; flag for 1st and 2nd loop?
	move.b	#4,d1                           	| [ld   b,#4]
ld   ixh,c                                 ; stash C ... bits set for each boss available in standby state

* first pass: look for 2 adjoining escorts available occuring in 3 adjacent spaces
l_1C4F_while:
	move.b	d2,d0                           	| [ld   a,c]
	and.b	#0x07,d0                         	| [and  #0x07]
* if (a==3                              	|| a==5|| a==6) ...
	cmp.b	#4,d0                            	| [cp   #4] (a ! 4) ...
	jeq	l_1C5B                             	| [jr   z,l_1C5B]
	cmp.b	#3,d0                            	| [cp   #3] && (a>=3)
       * d == #>b_8800, e don't care
	bcs.b	0f                               	| [...]
	jbsr	c_1C8D                            	| [call nc,c_1C8D] _boss_activate(0xFF, 0, b, 0xFFFF)
0:
l_1C5B:
	roxr.b	#1,d2                           	| [rr   c]
      ^^^^^^ TODO: review cpu X flag
	subq.b	#1,d1                           	| [...]
	jne	l_1C4F_while                       	| [djnz l_1C4F_while]

* second pass: look for 1 available escort
	addq.b	#1,ixl                          	| [inc  ixl] 1
	move.b	#ixh,d2                         	| [ld   c,ixh] restore previous C
	move.b	#4,d1                           	| [ld   b,#4]

l_1C65_while:
	move.b	d2,d0                           	| [ld   a,c]
	and.b	#0x07,d0                         	| [and  #0x07]
	beq.b	0f                               	| [...]
	jbsr	c_1C8D                            	| [call nz,c_1C8D] _boss_activate(0xFF, 1, b, 0xFFFF)
0:
	roxr.b	#1,d2                           	| [rr   c]
      ^^^^^^ TODO: review cpu X flag
	subq.b	#1,d1                           	| [...]
	jne	l_1C65_while                       	| [djnz l_1C65_while]

* third pass: take any available boss
	addq.b	#1,ixl                          	| [inc  ixl] 2
	lea	b_8800+0x30(pc),a1                 	| [ld   de,#b_8800 + 0x30] boss objects are 30 34 36 32
	move.b	#4,d1                           	| [ld   b,#4]
l_1C76_while:
	move.b	(a1),d0                         	| [ld   a,(de)]
	subq.b	#1,d0                           	| [dec  a]
	jeq	j_1CA0                             	| [jr   z,j_1CA0] _boss_activate(e, 2, b, 0xFFFF) ... status==STANDBY, skip index selection
	addq.w	#2,a1                           	| [inc  e]
	subq.b	#1,d1                           	| [...]
	jne	l_1C76_while                       	| [djnz l_1C76_while]

* last pass: no boss available ... check for available rogue fighter (objects 00, 02, 04, 06)
	lea	b_8800(pc),a0                      	| [ld   hl,#b_8800]
	move.b	#4,d1                           	| [ld   b,#4]
l_1C83_while:
	move.b	(a0),d0                         	| [ld   a,(hl)]
	subq.b	#1,d0                           	| [dec  a]
	jeq	l_1D25                             	| [jp   z,l_1D25]
	addq.w	#2,a0                           	| [inc  l]
	subq.b	#1,d1                           	| [...]
	jne	l_1C83_while                       	| [djnz l_1C83_while]

	rts                                    	| [ret]

*=============================================================================
* bmbr_boss_activate()
*  Description:
*   select bomber-boss object/index, select movement control vector
* IN:
*  B: 4,3,2,1 to select object/index of bomber
*  C: flags for escorts available (pass-thru)
*  D: pre-loaded with msb of pointer to objects array (for convenience as it was just used a few instructions ago)
*  E: object/index of bomber-boss candidate (from const array) if jp 1CA0 taken
*  IXL: 0 -> 2 escorts, 1 -> 1 escort (2 is for capture-boss so it doesn't apply)
* OUT:
*  ...
*-----------------------------------------------------------------------------
c_1C8D:
* convert ordinal in B (i.e. 4,3,2,1) to object/index in home-position order (left to right)
* the ordinal (B) will be used later to index d_escort_ids[] which are ordered
* right->left, i.e. ordinal 4 indexes to an ID located leftmost and so on.
*  4 -> 4 -> 0 -> 0
*  3 -> 2 -> 2 -> 4
*  2 -> 3 -> 3 -> 6
*  1 -> 1 -> 1 -> 2
	move.b	d1,d0                           	| [ld   a,b]
	btst.b	#1,d0                           	| [bit  1,a]
	jeq	l_1C94                             	| [jr   z,l_1C94]
	eor.b	#0x01,d0                         	| [xor  #0x01]
l_1C94:
	and.b	#0x03,d0                         	| [and  #0x03]
	asl.b	#1,d0                            	| [sla  a]
	add.b	#0x30,d0                         	| [add  a,#0x30] boss objects are 30 34 36 32
	move.b	d0,d4                           	| [ld   e,a] object/index of bomber to _1CAE
	move.b	(a1),d0                         	| [ld   a,(de)] d == #>b_8800
	cmp.b	#0x01,d0                         	| [cp   #0x01] check for ready/available status
	beq.b	0f                               	| [...]
	rts                                    	| [ret  nz] [...]
0:

	move.l	(sp)+,a0                        	| [pop  hl] will return to task manager eventually

j_1CA0:
	lea	db_flv_0411(pc),a3                 	| [ld   iy,#db_flv_0411]
	move.b	ds_9200_glbls+0x0B,d0           	| [ld   a,(ds_9200_glbls + 0x0B)] enemy enable, select data ptr boss launch: if (0), iy=$00F1, else iy=$0411
	                               	| [and  a]
	jne	l_1CAE                             	| [jr   nz,l_1CAE]
	lea	db_flv_00f1(pc),a3                 	| [ld   iy,#db_flv_00f1] training-mode

l_1CAE:

*-----------------------------------------------------------------------------
* setup bomber-boss, _boss_pool[0], bonus scoring, etc.
* if capture boss (jp $1CAE), paremeters same as above except:
* IN:
*    b, c: not used when escort selection skipped (ixl == 2)
*    ixl:  2==solo/capture boss is valid and will skip escort selection ...
*            ... in addition to 0 -> 2 escorts, 1 -> 1 escort
*-----------------------------------------------------------------------------
j_1CAE:

* objects 32 & 36 are on right side (bit-1 set): set flag in bit-7 to indicate negative rotation
	move.b	d4,d0                           	| [ld   a,e] object/index of bomber
	ror.b	#2,d0                            	| [rrca] * 2
	move.b	d4,d0                           	| [ld   a,e]
	roxl.b	#1,d0                           	| [rla] Cy into bit-0
      ^^^^^^ TODO: review cpu X flag
	ror.b	#1,d0                            	| [rrca] flag in Cy and in bit-7
	move.b	d0,bmbr_boss_pool+0             	| [ld   (bmbr_boss_pool + 0),a] object/index of bomber boss
	scs	d7                              	| [ex   af,af'] stash Cy for rotation flag
         ^^^ TODO review: wrong if carry is needed or D7 used in between!
	move.b	a3,bmbr_boss_pool+1             	| [ld   (bmbr_boss_pool + 1),iy] flight vector of bomber boss

	addq.b	#1,d1                           	| [inc  b] `dec b` in c_1D03

* plyr_actv.bmbr_boss_scode[]
	move.b	d4,d0                           	| [ld   a,e] object/index of bomber
	and.b	#0x07,d0                         	| [and  #0x07]
	lea	ds_plyr_actv+_ds_bmbr_boss_scode(pc),a0	| [ld   hl,#ds_plyr_actv +_ds_bmbr_boss_scode]
	jbsr	rst_10                            	| [rst  0x10] HL += A
* d_1CFD[ixl]
	move.b	#ixl,d0                         	| [ld   a,ixl]
	exg	a1,a0                              	| [ex   de,hl] stash hl (&plyr_actv.code)
	lea	d_1CFD(pc),a0                      	| [ld   hl,#d_1CFD]
	jbsr	rst_08                            	| [rst  0x08] HL += 2A
	move.b	(a0)+,d0                         	| [ld   a,(hl)]
	move.b	d0,(a1)+                         	| [ld   (de),a] plyr_actv._bonus_codescore[E] = d_1CFD[2*A]
	                           	| [inc  hl]
	                           	| [inc  e]
	move.b	(a0),d0                         	| [ld   a,(hl)]
	move.b	d0,(a1)                         	| [ld   (de),a]

* if (2 == ixl) then skip launching wingmen ... capture-boss situation
	move.b	#ixl,d0                         	| [ld   a,ixl]
	cmp.b	#2,d0                            	| [cp   #2]
	jeq	l_1CE3                             	| [jr   z,l_1CE3]

	lea	bmbr_boss_pool+1*3+0(pc),a1        	| [ld   de,#bmbr_boss_pool + 1 * 3 + 0] 4 groups of 3 bytes
* if (1 == ixl) ... setup 1 escort, else setup 2 escorts
	subq.b	#1,d0                           	| [dec  a]
	jeq	l_1CE0                             	| [jr   z,l_1CE0]
	jbsr	c_1D03                            	| [call c_1D03] DE==&boss_pool[1] ... boss dives with wingman
l_1CE0:
	jbsr	c_1D03                            	| [call c_1D03] DE==&boss_pool[2] ... boss dives with wingman

* if rogue fighter for this boss !STAND_BY then return
l_1CE3:
	move.b	bmbr_boss_pool+0*3+0,d0         	| [ld   a,(bmbr_boss_pool + 0 * 3 + 0)] obj/index (setup from function arguments above)
	and.b	#0x07,d0                         	| [and  #0x07] object/index of captured fighter i.e. 00 04 06 02
	move.b	d0,d6                           	| [ld   l,a]
* check for 0
	lea	b_8800(pc),a0                      	| [ld   h,#>b_8800]
	and.w	#0xFF,d6
	add.w	d6,a0
	      ^^^^ TODO: review XX value
	move.b	(a0),d0                         	| [ld   a,(hl)]
	subq.b	#1,d0                           	| [dec  a]
	beq.b	0f                               	| [...]
	rts                                    	| [ret  nz] return to task manager [...]
0:

	move.b	d6,d2                           	| [ld   c,l] object/index of rogue-fighter e.g. $00, $02, $04, $06

* find available slot (don't know how many are occupied by wingmen?)
	lea	bmbr_boss_pool+0*3+0(pc),a0        	| [ld   hl,#bmbr_boss_pool + 0 * 3 + 0] reset pointer, search for obj_idx==$FF
l_1CF2_while:
	addq.w	#3,a0                           	| [inc  l]
	move.b	(a0),d0                         	| [ld   a,(hl)]
	addq.b	#1,d0                           	| [inc  a]
	jne	l_1CF2_while                       	| [jr   nz,l_1CF2_while]

* setup A and Cy' parameters (HL, IY already loaded)
*  HL == &_boss_pool[n] ... n = { 3, 6, 9 }
*  IY == pointer to flight vector data
	scs	d7                              	| [ex   af,af'] unstash rotation flag
         ^^^ TODO review: wrong if carry is needed or D7 used in between!
	move.b	d2,d0                           	| [ld   a,c] object/index of captured ship
	jra	l_1D16                             	| [jr   l_1D16] ... jp past setup section of function

*=============================================================================
* data for c_1C8D:
* ixl selects bonus-score to override in ds_plyr_actv._ds_array8[]
* .b0 ... add to bug_collsn[$0F] (adjusted scoring increment)
* .b1 -> obj_collsn_notif[L] ... sprite code + 0x80
d_1CFD:
	.byte 16 - 3, 0x80 + 0x3A  | 1600
	.byte  8 - 3, 0x80 + 0x37  | 800
	.byte  4 - 3, 0x80 + 0x35  | 400 (default)

*=============================================================================
* c_1D03()
*  Description:
*   bmbr_boss_escort_sel
*   ...boss takes a sortie with one or two wingmen attached.
* IN:
*  B
*  C: flags for escorts available
*  DE: &_boss_pool[n]
*  IY: pointer to flight vector data
*  Cy': rotation flag, to be OR'd into pool_slot[n].idx<7>
* OUT:
*  B: index of next escort to be selected from const array
*  C: flags for escorts available
*-----------------------------------------------------------------------------
c_1D03:
	ror.b	#1,d2                            	| [rrc  c]
	jcs	l_1D0D                             	| [jr   c,l_1D0D]
	subq.b	#1,d1                           	| [dec  b] after boss docked home with ship
	ror.b	#1,d2                            	| [rrc  c]
	jcs	l_1D0D                             	| [jr   c,l_1D0D]
	subq.b	#1,d1                           	| [dec  b]
l_1D0D:
	move.b	d1,d0                           	| [ld   a,b]
	subq.b	#1,d1                           	| [dec  b]
	lea	d_1D2C_wingmen(pc),a0              	| [ld   hl,#d_1D2C_wingmen]
	jbsr	rst_10                            	| [rst  0x10] HL += A

* setup parameters (IY, pointer to flight vector data, already loaded)
	scs	d7                              	| [ex   af,af'] unstash rotation flag
         ^^^ TODO review: wrong if carry is needed or D7 used in between!
	move.b	(a0),d0                         	| [ld   a,(hl)] d_escorts[a] ... object/index
	exg	a1,a0                              	| [ex   de,hl] &boss_wing_slots[n] to HL

*=============================================================================
* skipping the setup section (rogue fighter)
* IN:
*  A  - object/index of red bomber wingman, captured ship etc.
*  HL - index to bmbr_boss_pool[]
*  IY - pointer to flight vector data
*  Cy - rotation flag
* OUT:
*  DE: &_boss_pool[n] ... pointer advanced in case of second call
*-----------------------------------------------------------------------------
l_1D16:
* load boss_wing_slots[n + 0], rotation flag from Cy to bit-7 of object/index
	roxl.b	#1,d0                           	| [rla] object/index
      ^^^^^^ TODO: review cpu X flag
	ror.b	#1,d0                            	| [rrca] rotate out of a<0> thru Cy into a<7>
	move.b	d0,(a0)                         	| [ld   (hl),a] &boss_wing_slots[n + 0]

* re-stash Cy (rotation flag)
	scs	d7                              	| [ex   af,af']
         ^^^ TODO review: wrong if carry is needed or D7 used in between!

	addq.w	#1,a0                           	| [inc  l]
            ^^^^ TODO check inc register d6 or a0
	move.b	#iyl,d0                         	| [ld   a,iyl]
	move.b	d0,(a0)+                         	| [ld   (hl),a]
	                           	| [inc  l]
	move.b	#iyh,d0                         	| [ld   a,iyh]
	move.b	d0,(a0)+                         	| [ld   (hl),a]
	                           	| [inc  l]
	exg	a1,a0                              	| [ex   de,hl] &boss_wing_slots[n] ... update pointer in DE for second subroutine call
	rts                                    	| [ret]

*=============================================================================
* Movement of captured rogue ship... out of section at l_1C83
*-----------------------------------------------------------------------------
l_1D25:
	lea	db_fltv_rogefgter(pc),a1           	| [ld   de,#db_fltv_rogefgter]
	jbsr	c_1083                            	| [call c_1083] rogue fighter
	rts                                    	| [ret]

*=============================================================================
* 6 escort aliens (right to left under the 4 bosses )
d_1D2C_wingmen:
	.byte 0x4A,0x52,0x5A,0x58,0x50,0x48

*=============================================================================
* f_1D32()
*  Description:
*   Moves bug nest on and off the screen at player changeover.
* IN:
*  ...
* OUT:
*  ...
*-----------------------------------------------------------------------------
f_1D32:
	lea	b8_99B4_bugnest_onoff_scrn_tmr(pc),a0	| [ld   hl,#b8_99B4_bugnest_onoff_scrn_tmr] increment timer
	move.b	(a0),d0                         	| [ld   a,(hl)]
	and.b	#0x7F,d0                         	| [and  #0x7F]
	sub.b	#0x7E,d0                         	| [sub  #0x7E] 126 (frames?)
	jeq	l_1D72                             	| [jr   z,l_1D72] A==0 ...

	move.b	(a0),d2                         	| [ld   c,(hl)]
	addq.b	#1,(a0)                         	| [inc  (hl)] update timer

	move.b	b_9215_flip_screen,d0           	| [ld   a,(b_9215_flip_screen)]

* rotate _scrn_tmr<7> into Cy for testing
	rol.b	#1,d2                            	| [rlc  c]
	eor.b	d2,d0                            	| [xor  c]
	ror.b	#1,d0                            	| [rrca]

	move.b	#1,d0                           	| [ld   a,#1] offset is +1
	jcs	l_1D4B                             	| [jr   c,l_1D4B]
      ^^^^^^ TODO: review cpu flags (move.b,jcs)
	neg.b	d0                               	| [neg] offset is -1

l_1D4B:
	move.b	d0,d2                           	| [ld   c,a]
	lea	ds_hpos_spcoords+(10*2(pc),a0      	| [ld   hl,#ds_hpos_spcoords + (10 * 2)] + byte offset to row coordinates

	move.b	#6,d1                           	| [ld   b,#6] 6 row coordinates to update
l_1D51:
	move.b	(a0),d0                         	| [ld   a,(hl)]
	add.b	d2,d0                            	| [add  a,c] + or - 1
	move.b	d0,(a0)                         	| [ld   (hl),a] _sprite_coords[ n ] ... LSB
	roxr.b	#1,d0                           	| [rra]
      ^^^^^^ TODO: review cpu X flag
	eor.b	d2,d0                            	| [xor  c]
	addq.w	#1,a0                           	| [inc  l]
            ^^^^ TODO check inc register d6 or a0
	rol.b	#1,d0                            	| [rlca]
	jcc	l_1D5E                             	| [jr   nc,l_1D5E]
	move.b	(a0),d0                         	| [ld   a,(hl)]
	eor.b	#0x01,d0                         	| [xor  #0x01]
	move.b	d0,(a0)                         	| [ld   (hl),a] add carry (if any) into MSB
l_1D5E:
	addq.w	#1,a0                           	| [inc  l]
            ^^^^ TODO check inc register d6 or a0
	subq.b	#1,d1                           	| [...]
	jne	l_1D51                             	| [djnz l_1D51]

* call MOB manager to get everything updated (each call updates half the mob)
* The call expects the frame count in A, but here it is overkill because the
* subroutine is only using bits 0-3 ("A % 4") and updates half of the objects
* on each odd count.
	move.b	ds3_92A0_frame_cts+0,d0         	| [ld   a,(ds3_92A0_frame_cts + 0)]
	and.b	#0xFC,d0                         	| [and  #0xFC] force A%4 == 0
	addq.b	#1,d0                           	| [inc  a] force A%4 == 1
	move.w	d0,-(sp)                        	| [push af]
	jbsr	c_23E0                            	| [call c_23E0]
	move.w	(sp)+,d0                        	| [pop  af]
	addq.b	#2,d0                           	| [add  a,#2] force A%4 = 3
	jbsr	c_23E0                            	| [call c_23E0]

	rts                                    	| [ret]

l_1D72:
	move.b	d0,ds_cpu0_task_actv+0x0E       	| [ld   (ds_cpu0_task_actv + 0x0E),a] f_1D32
	rts                                    	| [ret]

*=============================================================================
* f_1D76()
*  Description:
*   handles changes in star control status?
* IN:
*  ...
* OUT:
*  ...
*-----------------------------------------------------------------------------
f_1D76:
	move.b	b_9215_flip_screen,d0           	| [ld   a,(b_9215_flip_screen)]
	move.b	d0,d1                           	| [ld   b,a]
	lea	ds_99B9_star_ctrl+0x00(pc),a0      	| [ld   hl,#ds_99B9_star_ctrl + 0x00] 1 when ship on screen
	move.b	(a0)+,d0                         	| [ld   a,(hl)]
	=                           	| [inc  l]
	tst.b	d0                               	| [and  a]
	jeq	l_1DA8                             	| [jr   z,l_1DA8]

	move.b	(a0),d0                         	| [ld   a,(hl)] 99BA
	                               	| [and  a]
	move.b	#0xFD,d0                        	| [ld   a,#0xFD]
	jne	l_1D9B                             	| [jr   nz,l_1D9B] if ( *(99BA) != 0 )
      ^^^^^^ TODO: review cpu flags (move.b,jne)
	addq.w	#1,a0                           	| [inc  l]
            ^^^^ TODO check inc register d6 or a0
	move.b	(a0)+,d0                         	| [ld   a,(hl)] 99BB
	                           	| [inc  l]
	cmp.b	(a0),d0                          	| [cp   (hl)] 99BC
	jeq	l_1D8F                             	| [jr   z,l_1D8F]
	addq.b	#1,(a0)                         	| [inc  (hl)]
l_1D8F:
	move.b	(a0)+,d0                         	| [ld   a,(hl)]
	                           	| [inc  l]
	add.b	(a0),d0                          	| [add  a,(hl)] 99BD
	move.b	d0,d2                           	| [ld   c,a]
	and.b	#0x3F,d0                         	| [and  #0x3F]
	move.b	d0,(a0)                         	| [ld   (hl),a]
	move.b	d2,d0                           	| [ld   a,c]
	rol.b	#2,d0                            	| [rlca] * 2
	and.b	#0x03,d0                         	| [and  #0x03]
l_1D9B:
	btst.b	#0,d1                           	| [bit  0,b] 9215_flip_screen
	jne	l_1DA1                             	| [jr   nz,l_1DA1]
	neg.b	d0                               	| [neg] twos complement
l_1DA1:
	subq.b	#1,d0                           	| [dec  a]
	and.b	#0x07,d0                         	| [and  #0x07]
l_1DA4:
	move.b	d0,ds_99B9_star_ctrl+0x05       	| [ld   (ds_99B9_star_ctrl + 0x05),a]
	rts                                    	| [ret]

l_1DA8:
	clr.b	d0                               	| [xor  a]
	move.b	d0,(a0)                         	| [ld   (hl),a] 0 ... 99BA?
	addq.w	#2,a0                           	| [inc  l]
 	move.b	d0,(a0)+                         	| [ld   (hl),a] 0 ... 99BC?
	                           	| [inc  l]
	move.b	d0,(a0)                         	| [ld   (hl),a] 0 ... 99BD?
	move.b	#7,d0                           	| [ld   a,#7] stops stars
	jra	l_1DA4                             	| [jr   l_1DA4] set star ctrl state

*=============================================================================
* f_1DB3() ... 0x0B
*  Description:
*   Update enemy status.
*
*   only disabled when default task config is
*   re-loaded from ROM (c_1230_init_taskman_structs) just prior to the Top5
*   screen shown in attract-mode.
*
*   memory structure of enemy army:
*
*                         00 04 06 02            ; captured ships
*                         30 34 36 32
*                   40 48 50 58 5A 52 4A 42
*                   44 4C 54 5C 5E 56 4E 46
*                08 10 18 20 28 2A 22 1A 12 0A
*                0C 14 1C 24 2C 2E 26 1E 16 0E
*
* IN:
*   obj_collsn_notif[L] set by cpu1:_rocket_hit_detection to $81.
*   detect and reset bit-7. $01 remains
*
* OUT:
* _obj_status.b0: "activity" byte (see d_23FF_jp_tbl for codes)
* _obj_status.b1: ($40...$45 if exploding)
*
*  mrw_sprite.cclr[ L ].color set to $0A for explosion
*  obj_collsn_notif[L]  == $01
*
*-----------------------------------------------------------------------------
f_1DB3:
	lea	b_9200_obj_collsn_notif(pc),a0     	| [ld   hl,#b_9200_obj_collsn_notif] $30 bytes ... test bit-7
	move.b	#0x30,d1                        	| [ld   b,#0x30]
l_1DB8:
	btst.b	#7,(a0)                         	| [bit  7,(hl)] bit-7 set ($81) by cpu1 (l_07DB) if the orc has been hit
	jne	l_1DC1_make_him_dead               	| [jr   nz,l_1DC1_make_him_dead]
	addq.b	#1,d6                           	| [inc  l]
l_1DBD:
	addq.b	#1,d6                           	| [inc  l]
	subq.b	#1,d1                           	| [...]
	jne	l_1DB8                             	| [djnz l_1DB8]

	rts                                    	| [ret]

l_1DC1_make_him_dead:
	bclr.b	#7,(a0)                         	| [res  7,(hl)] b_9200_obj_collsn_notif[n] for rckt_hit_hdlr
	lea	b_8800(pc),a0                      	| [ld   h,#>b_8800] disposition = 4 (dying/exploding)
	and.w	#0xFF,d6
	add.w	d6,a0
	      ^^^^ TODO: review XX value
	move.b	#4,(a0)                         	| [ld   (hl),#4]
* use obj_status[].mctl_q_index for explosion counter (que object should already have been released at l_081E_hdl_flyng_bug
	addq.w	#1,a0                           	| [inc  l]
	move.b	#0x40,(a0)                      	| [ld   (hl),#0x40] start value for the explosion (40...45)
	lea	ds_sprite_code(pc),a0              	| [ld   h,#>ds_sprite_code]
	and.w	#0xFF,d6
	add.w	d6,a0
	      ^^^^ TODO: review XX value
	move.b	#0x0A,(a0)                      	| [ld   (hl),#0x0A] update color for inactive/dead sprite
	lea	b_9200_obj_collsn_notif(pc),a0     	| [ld   h,#>b_9200_obj_collsn_notif] reload ptr
	and.w	#0xFF,d6
	add.w	d6,a0
	      ^^^^ TODO: review XX value
	jra	l_1DBD                             	| [jr   l_1DBD]
* end 1DB3

*=============================================================================
* f_1DD2()
*  Description:
*   Updates array of 4 timers at 2Hz rate.
* IN:
*  ...
* OUT:
*  ...
*-----------------------------------------------------------------------------
f_1DD2:
*  if ( frame_cts[2] & 0x01 ) return ... divides the 4 Hz timer by 2 ... why not just use frame_cts[1]
	move.b	ds3_92A0_frame_cts+2,d0         	| [ld   a,(ds3_92A0_frame_cts + 2)] [2]: 4 Hz timer
	and.b	#0x01,d0                         	| [and  #0x01]
	beq.b	0f                               	| [...]
	rts                                    	| [ret  nz] [...]
0:

	lea	ds4_game_tmrs+0(pc),a0             	| [ld   hl,#ds4_game_tmrs + 0] decrement each of the 4 game timers
	move.b	#4,d1                           	| [ld   b,#4]
*  for ( b = 0 ; b < 4 ; b++ ) {
*    if ( game_tmrs[b] > 0 )   game_tmrs[b]--
l_1DDD:
	move.b	(a0),d0                         	| [ld   a,(hl)]
	                               	| [and  a]
	jeq	l_1DE2                             	| [jr   z,l_1DE2]
	subq.b	#1,(a0)                         	| [dec  (hl)]
l_1DE2:
	addq.w	#1,a0                           	| [inc  l]
	subq.b	#1,d1                           	| [...]
	jne	l_1DDD                             	| [djnz l_1DDD]
*  }
	rts                                    	| [ret]

*=============================================================================
* f_1DE6()
*  Description:
*   Provides pulsating movement of the collective.
*   Enabled by f_2A90 once the initial formation waves have completed.
* IN:
*  ...
* OUT:
*  ...
*-----------------------------------------------------------------------------
f_1DE6:
*  if ( frame_count % 4 != 0 ) return
	move.b	ds3_92A0_frame_cts+0,d0         	| [ld  a,(ds3_92A0_frame_cts + 0)] frame_ct%4 ... ... (provides 15Hz timer)
	and.b	#0x03,d0                         	| [and  #0x03]
	beq.b	0f                               	| [...]
	rts                                    	| [ret  nz] [...]
0:

	lea	ds_9200_glbls+0x0F(pc),a0          	| [ld   hl,#ds_9200_glbls + 0x0F] nest_direction counter for expand/contract motion.
	move.b	(a0),d0                         	| [ld   a,(hl)]
	move.b	d0,d4                           	| [ld   e,a] PREVIOUS_nest_direction counter

	move.b	#-1,d3                          	| [ld   d,#-1]
	btst.b	#7,d0                           	| [bit  7,a]
	jne	l_1DFC_contracting                 	| [jr   nz,l_1DFC_contracting]
* expanding
	addq.b	#2,d3                           	| [inc  d] * 2
	addq.b	#1,(a0)                         	| [inc  (hl)] nest_direction = 1
	jra	l_1DFD                             	| [jr   l_1DFD]
l_1DFC_contracting:
	subq.b	#1,(a0)                         	| [dec  (hl)] nest_direction = -1

l_1DFD:
	cmp.b	#0x1F,d0                         	| [cp   #0x1F] counting up from $00 to $1F
	jne	l_1E03                             	| [jr   nz,l_1E03]
	bset.b	#7,(a0)                         	| [set  7,(hl)] count|= $80 ... = $A0
l_1E03:
	cmp.b	#0x81,d0                         	| [cp   #0x81] counting down from $A0 to $81 (-$60 to -$7F)
	jne	l_1E09                             	| [jr   nz,l_1E09]
	bclr.b	#7,(a0)                         	| [res  7,(hl)] count &= ~$80 ... = $00

* Now we have updated the counter, and have D==1 if expanding, D==-1 if contracting.
* Every 8*4 (32) frames, we change the bitmap which determines the positions that are
* updated. This happens to correspond with the "flapping" animation... ~1/2 second per flap.
l_1E09:
	move.b	(a0),d2                         	| [ld   c,(hl)] grab nest_direction while we still have the pointer

	and.b	#0x07,d0                         	| [and  #0x07] previous_cntr % 8

	move.b	d3,d0                           	| [ld   a,d] direction counter increment (+1 or -1)
	move.b	d0,ds_9200_glbls+0x11           	| [ld   (ds_9200_glbls + 0x11),a] formatn_mv_signage, cpu2 cp with b_9A80 + 0x00

	move.b	d4,d0                           	| [ld   a,e] reload previous_nest_direction counter

* if ( previous_counter % 8 == 0 ) then update_bitmap i.e. even multiple of 8
	jne	l_1E23                             	| [jr   nz,l_1E23]
      ^^^^^^ TODO: review cpu flags (move.b,jne)

	lea	d_1E64_bitmap_tables(pc),a0        	| [ld   hl,#d_1E64_bitmap_tables]

* count * 2 i.e. count / 8 * 16 ... index into table row
	move.b	d2,d0                           	| [ld   a,c] A = updated_counter
	and.b	#0x18,d0                         	| [and  #0x18] make it even multiple of 8
	jbsr	rst_08                            	| [rst  0x08] HL += 2A   .... table entries are $10 bytes long

	move.b	d4,d0                           	| [ld   a,e] reload previous_nest_direction counter

	lea	ds10_9920(pc),a1                   	| [ld   de,#ds10_9920] $10 bytes copied from 1E64+2*A
	move.b	#0x00,d1                        	| [ld   bc,#0x0010] 16
	move.b	#0x10,d2                        	| [ld   bc,#0x0010] 16
	jbsr	ldir                              	| [ldir]
     ^^^^ TODO: review special instruction inputs

l_1E23:
* A ^= (HL) ... set Cy determines which parameter is taken. Bit-7 XOR'd with
* flip_screen-bit... done efficiently by rotating bit-7 into bit-0 and back.
	lea	b_9215_flip_screen(pc),a0          	| [ld   hl,#b_9215_flip_screen]
	rol.b	#1,d0                            	| [rlca] A == previous_counter
	move.b	(a0),d7
	eor.b	d7,d0                            	| [xor  (hl)]
	ror.b	#1,d0                            	| [rrca] Cy now indicates state of bit-7

* Setup parameters for first function call. The first call does just the
* left-most 5 columns. The second call does the rightmost 5 columns and the
* 6 row coordinates, which incidentally will have the same sign! So we stash
* the parameter for the second call in C, at the same time that B is set.

	lea	ds10_9920(pc),a0                   	| [ld   hl,#ds10_9920] 16 bytes copied from _bitmap_tables+2*A
	lea	ds_hpos_loc_offs(pc),a1            	| [ld   de,#ds_hpos_loc_offs] hl==ds10_9920

	jcc	l_1E36                             	| [jr   nc,l_1E36]

	move.b	#0x01,d1                        	| [ld   bc,#0x01FF] B==1, C==-1 (contracting group, non-inverted) 511
	move.b	#0xff,d2                        	| [ld   bc,#0x01FF] B==1, C==-1 (contracting group, non-inverted) 511
	jra	l_1E39                             	| [jr   l_1E39]

l_1E36:
	move.b	#0xff,d1                        	| [ld   bc,#0xFF01] B==-1, C==1 (expanding group, non-inverted) 65281
	move.b	#0x01,d2                        	| [ld   bc,#0xFF01] B==-1, C==1 (expanding group, non-inverted) 65281

l_1E39:
ld   ixl,#5                                ; 5 leftmost columns
	jbsr	c_1E43                            	| [call c_1E43]

* setup parameters for second function call
	move.b	d2,d1                           	| [ld   b,c] load second parameter
ld   ixl,0x0b                              ; 5 right columns + 6 rows

       * 1E43()

*=============================================================================
* c_1E43()
*  Description:
*   Compute row/col coordinates of formation in expand/contract movement.
*   The selected bitmap table determines whether any given coordinate
*   dimension is incremented at this update.
* IN:
*    HL == saved pointer into working copy of selected bitmap table ($10 bytes)
*    DE == saved pointer into home_posn_loc[]
*        ... object positioning (even: relative offsets .... odd: defaults/origin)
*    B == +/- 1 increment.
*    IXL == 5  (repeat count for 5 leftmost columns)
*    IXL == 11 (repeat count, for 5 rightmost columns + 6 rows which have the same sign)
* OUT:
*  ...
*-----------------------------------------------------------------------------
c_1E43:
j_1E43:
* check if updating this one
	ror.b	#1,(a0)                          	| [rrc  (hl)]
	jcc	l_1E5C_update_ptrs                 	| [jr   nc,l_1E5C_update_ptrs]

* obj_pos_rel[ n ] += B
	move.b	(a1),d0                         	| [ld   a,(de)] even-bytes: relative offset
	add.b	d1,d0                            	| [add  a,b] +/- 1
	move.b	d0,(a1)                         	| [ld   (de),a]

* _home_posn_org[ n ] += B ... 10 column coordinates, 6 row coordinates, 16-bits per coordinate
	lea	ds_hpos_spcoords(pc),a1            	| [ld   d,#>ds_hpos_spcoords]
	and.w	#0xFF,d4
	add.w	d4,a1
	      ^^^^ TODO: review XX value
	move.b	(a1),d0                         	| [ld   a,(de)]
	add.b	d1,d0                            	| [add  a,b] +/- 1
	move.b	d0,(a1)                         	| [ld   (de),a]

* check for carry
	roxr.b	#1,d0                           	| [rra]
      ^^^^^^ TODO: review cpu X flag
	eor.b	d1,d0                            	| [xor  b]
	rol.b	#1,d0                            	| [rlca]
	jcc	l_1E5A                             	| [jr   nc,l_1E5A]
* handle carry
	addq.w	#1,a1                           	| [inc  e]
	move.b	(a1),d0                         	| [ld   a,(de)] MSB
	eor.b	#0x01,d0                         	| [xor  #0x01]
	move.b	d0,(a1)                         	| [ld   (de),a]
	subq.w	#1,a1                           	| [dec  e] LSB again
 
l_1E5A:
	lea	ds_hpos_loc_offs(pc),a1            	| [ld   d,#>ds_hpos_loc_offs] reset pointer
	and.w	#0xFF,d4
	add.w	d4,a1
	      ^^^^ TODO: review XX value

l_1E5C_update_ptrs:
	addq.w	#2,a1                           	| [inc  e]
 	addq.w	#1,a0                           	| [inc  l]
 	subq.b	#1,ixl                          	| [dec  ixl]
	jne	j_1E43                             	| [jr   nz,j_1E43]

	rts                                    	| [ret]

*=============================================================================
* d_1E64_bitmap_tables
*  Description:
*   bitmaps determine at which intervals the corresponding coordinate will
*   be incremented... allows outmost and lowest coordinates to expand faster.
*
*                                       	|<-------------- COLUMNS --------------------->|<---------- ROWS ---------->|
*
*-----------------------------------------------------------------------------
d_1E64_bitmap_tables:

	.byte 0xFF,0x77,0x55,0x14,0x10,0x10,0x14,0x55,0x77,0xFF,0x00,0x10,0x14,0x55,0x77,0xFF
	.byte 0xFF,0x77,0x55,0x51,0x10,0x10,0x51,0x55,0x77,0xFF,0x00,0x10,0x51,0x55,0x77,0xFF
	.byte 0xFF,0x77,0x57,0x15,0x10,0x10,0x15,0x57,0x77,0xFF,0x00,0x10,0x15,0x57,0x77,0xFF
	.byte 0xFF,0xF7,0xD5,0x91,0x10,0x10,0x91,0xD5,0xF7,0xFF,0x00,0x10,0x91,0xD5,0xF7,0xFF

*=============================================================================
* f_1EA4()
*  Description:
*    Bomb position updater... this task is not disabled.
* IN:
*  ...
* OUT:
*  ...
*-----------------------------------------------------------------------------
f_1EA4:
* Determine y-increment: each frame alternates 2 or 3 pixels-per-frame
* increment to provide the average Y velocity, and negated for inverted screen.
	move.b	ds3_92A0_frame_cts+0,d0         	| [ld   a,(ds3_92A0_frame_cts + 0)]
	and.b	#0x01,d0                         	| [and  #0x01]
	addq.b	#2,d0                           	| [add  a,#2]
	move.b	d0,d1                           	| [ld   b,a]
	move.b	b_9215_flip_screen,d0           	| [ld   a,(b_9215_flip_screen)]
	                               	| [and  a]
	move.b	d1,d0                           	| [ld   a,b]
	jeq	l_1EB5                             	| [jr   z,l_1EB5]
      ^^^^^^ TODO: review cpu flags (move.b,jeq)
	neg.b	d0                               	| [neg]

l_1EB5:
ld   ixh,a
	move.b	#0x68,d6                        	| [ld   l,#0x68] offset into object group for missiles
	lea	b_92B0+0x00(pc),a1                 	| [ld   de,#b_92B0 + 0x00] bomb h-rate array ( 8 * 2 )
ld   ixl,0x08

l_1EBF_while:
* if sprite[bomb + n].code == $30 ...
	lea	ds_sprite_code(pc),a0              	| [ld   h,#>ds_sprite_code]
	and.w	#0xFF,d6
	add.w	d6,a0
	      ^^^^ TODO: review XX value
	move.b	(a0),d0                         	| [ld   a,(hl)]
	cmp.b	#0x30,d0                         	| [cp   #0x30] bomb sprite codes don't show up until some new-game inits are done
	jne	l_1EFF                             	| [jr   nz,l_1EFF]
* ... sprite[bomb + n].posn.x != 0
	lea	ds_sprite_posn(pc),a0              	| [ld   h,#>ds_sprite_posn]
	and.w	#0xFF,d6
	add.w	d6,a0
	      ^^^^ TODO: review XX value
	move.b	(a0),d0                         	| [ld   a,(hl)]
	                               	| [and  a]
	jeq	l_1EFF                             	| [jr   z,l_1EFF]

* Fun fixed point math: X rate in 92B0[ even ] has a scale factor of
* 32-counts -> 1 pixel-per-frame. Each frame, the (unchanging) dividend
* is loaded from 92B0, the previous MOD32 is added, the new MOD32 is stashed
* in 92B1, and the quotient becomes the new X-offset. Eventually those
* remainders add up to another whole divisor which will add an extra pixel
* to the offset every nth frame. Easy peasy!
* BTW there really is odd values in 92B0, but we just seem to not care about it i.e. mask 7E.

	exg	a1,a0                              	| [ex   de,hl] stash &sprite_posn[n].b0 in DE
	move.b	(a0),d1                         	| [ld   b,(hl)] bomb_rate[n].b0
	move.b	d1,d0                           	| [ld   a,b]
	and.b	#0x7E,d0                         	| [and  #0x7E] Bit-7 for negative ... and we don't want the 1 ???
	addq.w	#1,a0                           	| [inc  l]
            ^^^^ TODO check inc register d6 or a0
	add.b	(a0),d0                          	| [add  a,(hl)]
	move.b	d0,d2                           	| [ld   c,a] C = A = A + 92B0[odd] ... accumulated division remainder
	and.b	#0x1F,d0                         	| [and  #0x1F] MOD 32
	move.b	d0,(a0)+                         	| [ld   (hl),a] bomb_rate[n].b1
	=                           	| [inc  l]
* a >>= 5 (divide-by-32)
	move.b	d2,d0                           	| [ld   a,c]
	rol.b	#3,d0                            	| [rlca] * 3
	and.b	#0x07,d0                         	| [and  #0x07]

* use negative offset of X coordinate if bomb path is to the left
	btst.b	#7,d1                           	| [bit  7,b]
	jeq	l_1EE4                             	| [jr   z,l_1EE4]
	neg.b	d0                               	| [neg]

l_1EE4:
	exg	a1,a0                              	| [ex   de,hl] &sprite_posn[n].b0 from DE
* update X
	add.b	(a0),d0                          	| [add  a,(hl)]
	move.b	d0,(a0)                         	| [ld   (hl),a] 9868[ even ] += A

* update Y, and handle Cy for value > $ff
	addq.w	#1,a0                           	| [inc  l]
            ^^^^ TODO check inc register d6 or a0
	move.b	(a0),d0                         	| [ld   a,(hl)]
	add.b	ixh,d0                           	| [add  a,ixh]
	move.b	d0,(a0)                         	| [ld   (hl),a] sprite[n].y<7:0> += ixh

	roxr.b	#1,d0                           	| [rra] shifts CY into bit-7 on overflow from addition
      ^^^^^^ TODO: review cpu X flag
	move.b	ixh,d7
	eor.b	d7,d0                            	| [xor  ixh]
	rol.b	#1,d0                            	| [rlca] Cy xor'd with ixh<7> ... to Cy
	jcc	l_1EF9                             	| [jr   nc,l_1EF9]

* update "bit-8" of Y coordinate ... should only overflow the Y coordinate once.
	lea	ds_sprite_ctrl(pc),a0              	| [ld   h,#>ds_sprite_ctrl] sY<8>
	and.w	#0xFF,d6
	add.w	d6,a0
	      ^^^^ TODO: review XX value
	ror.b	#1,(a0)                          	| [rrc  (hl)] sY<8> into Cy
	INVERT_XC_FLAGS                        	| [ccf]
	roxl.b	#1,(a0)                         	| [rl   (hl)] sY<8>
      ^^^^^^ TODO: review cpu X flag, cmp doesn't affect it!

l_1EF9:
	addq.w	#1,a0                           	| [inc  l]
            ^^^^ TODO check inc register d6 or a0
	subq.b	#1,ixl                          	| [dec  ixl]
	jne	l_1EBF_while                       	| [jr   nz,l_1EBF_while]

	rts                                    	| [ret]

l_1EFF:
	addq.w	#1,a0                           	| [inc  l]
            ^^^^ TODO check inc register d6 or a0
	addq.w	#2,a1                           	| [inc  e]
            ^^^^ TODO check inc register d4 or a1 * 2
	jra	l_1EF9                             	| [jr   l_1EF9]

*=============================================================================
* f_1F04()
*  Description:
*   Read fire button input.
*   The IO port is determined according to whether or not the screen is flipped.
*   The button state is read from bit-4. Based on observation in the MAME
*   debugger, it appears that the IO control chip initially places the value
*   $1F on the port (bit-5 pulled low), and then some time following that bit-4
*   is pulled low ($0F). Presumably this is provide a debounce feature. If
*   there is no activity on either the button or the left-right control, then
*   the value read from the port is $3F.
* IN:
*  ...
* OUT:
*  ...
*-----------------------------------------------------------------------------
f_1F04:
* select the input port depending upon whether screen is flipped.
	move.b	b_9215_flip_screen,d0           	| [ld   a,(b_9215_flip_screen)]
	add.b	<ds3_99B5_io_input+0x01,d0       	| [add  a,#<ds3_99B5_io_input + 0x01] add lsb
	move.b	d0,d6                           	| [ld   l,a]
	lea	ds3_99B5_io_input+0x00(pc),a0      	| [ld   h,#>ds3_99B5_io_input + 0x00] msb
	and.w	#0xFF,d6
	add.w	d6,a0
	      ^^^^ TODO: review XX value
	btst.b	#4,(a0)                         	| [bit  4,(hl)]
	beq.b	0f                               	| [...]
	rts                                    	| [ret  nz] active low input [...]
0:
* else
       * call c_1F0F

*=============================================================================
* c_1F0F()
*  Description:
*   Intialize sprite objects for rockets.
*   rocket sprite.cclr[n].b0 is initialized by c_game_or_demo_init
*   Updates game shots fired count.
* IN:
*  ...
* OUT:
*  ...
*-----------------------------------------------------------------------------
c_1F0F:
* if ( 0 != sprite[ RCKT0 ].sX ) ...
	lea	ds_sprite_posn+0x64(pc),a0         	| [ld   hl,#ds_sprite_posn + 0x64] ROCKET_0
	lea	b_92A0+0x04(pc),a1                 	| [ld   de,#b_92A0 + 0x04] rockt_attribute[0]
	clr.b	d0                               	| [xor  a]
	cmp.b	(a0),d0                          	| [cp   (hl)] if (0)
	jeq	l_1F1E                             	| [jr   z,l_1F1E]

* ... then ... if ( 0 != sprite[ RCKT1 ].sX )  return
	move.b	#<ds_sprite_posn+0x66,d6        	| [ld   l,#<ds_sprite_posn + 0x66] ROCKET_1
	addq.w	#1,a1                           	| [inc  e] rockt_attribute[1]
            ^^^^ TODO check inc register d4 or a1
	cmp.b	(a0),d0                          	| [cp   (hl)] if (0 != sprite[RCKT1].sX)  ret
	beq.b	0f                               	| [...]
	rts                                    	| [ret  nz] [...]
0:

l_1F1E:
* save pointer to attribute, and stash 'offsetof( RCKT_X )' in E

	movem.w	d3/d4,-(sp)                    	| [push de] &rockt_attribute[n].posn.b0
	move.l	a1,-(sp)                        	| [push de] &rockt_attribute[n].posn.b0
	exg	a1,a0                              	| [ex   de,hl]

	lea	ds_sprite_ctrl+0x62+1(pc),a0       	| [ld   hl,#ds_sprite_ctrl + 0x62 + 1] sprite.ctrl[FIGHTR].b1
	move.b	d5,d3                           	| [ld   d,h]
	addq.w	#1,a1                           	| [inc  e] sprite[RCKT_X].ctrl.b1
            ^^^^ TODO check inc register d4 or a1

	btst.b	#2,(a0)                         	| [bit  2,(hl)] sprite.ctrl[FIGHTR].b1<2> ... ?
	jeq	l_1F2B                             	| [jr   z,l_1F2B]

	move.l	(sp)+,a1                        	| [pop  de]
	movem.w	(sp)+,d3/d4                    	| [pop  de]
	rts                                    	| [ret]


l_1F2B:
* sprite.ctrl[RCKT+n].b1 = sprite.ctrl[SHIP].b1 ... ship.sY, bit-8
	jbsr	ldd                               	| [ldd] e.g. *(9B65--) = *(9B63--)
     ^^^^ TODO: review special instruction inputs

	lea	ds_sprite_posn(pc),a0              	| [ld   h,#>ds_sprite_posn]
	and.w	#0xFF,d6
	add.w	d6,a0
	      ^^^^ TODO: review XX value
	move.b	d5,d3                           	| [ld   d,h] stash it
* sprite.posn[RCKT+n].b0 = sprite.posn[SPR_IDX_SHIP].b0  ... ship.sX
	jbsr	ldi                               	| [ldi] e.g. *(9B64++) = *(9B62++)
     ^^^^ TODO: review special instruction inputs
* sprite.posn[RCKT+n].b1 = sprite.posn[SPR_IDX_SHIP].b1  ... ship.sY, bit 0-7
	jbsr	ldd                               	| [ldd] e.g. *(9B65--) = *(9B63--)
     ^^^^ TODO: review special instruction inputs


* B = sprite.ctrl[SHIP].b0
	lea	ds_sprite_ctrl(pc),a0              	| [ld   h,#>ds_sprite_ctrl]
	and.w	#0xFF,d6
	add.w	d6,a0
	      ^^^^ TODO: review XX value
	move.b	d5,d3                           	| [ld   d,h]
	move.b	(a0),d1                         	| [ld   b,(hl)] sprite.ctrl[FGHTR].b0: normally 0 (not doubled or flipped)
                                                  * stash in B ... see l_1F5E below
	exg	a1,a0                              	| [ex   de,hl] HL := sprite.ctrl[RCKT].b0

* sprite.ctrl[RCKT].b0.dblw = (two_ship << 3 )
	move.b	ds_plyr_actv+_b_2ship,d0        	| [ld   a,(ds_plyr_actv +_b_2ship)]
	and.b	#0x01,d0                         	| [and  #0x01] make sure its only bit-0 I guess ?
	rol.b	#3,d0                            	| [rlca] * 3

* sprite.ctrl[SHIP].b0 ... typically 0, unless ship is spinning
	or.b	d1,d0                             	| [or   b] .ctrl[RCKT].b0|= .ctrl[SHIP].b0
	move.b	d0,(a0)                         	| [ld   (hl),a]

* determine rocket sprite code based on ship sprite code, which ranges from 6 (upright orientation)
* down to the 90 degree rotation. Rocket code can be 30, 31, or 33 (360, 315, or 90 degree).
* rocket sprite 32 is also 360 or 0 degree but not used ? (unless its the 2nd rocket, which is done by sprite doubling).
	lea	ds_sprite_code(pc),a1              	| [ld   d,#>ds_sprite_code]
	and.w	#0xFF,d4
	add.w	d4,a1
	      ^^^^ TODO: review XX value
	move.b	(a1),d0                         	| [ld   a,(de)]
	move.b	d3,d5                           	| [ld   h,d]
	and.b	#0x07,d0                         	| [and  #0x07] fighter sprite codes are $00...$07

	move.b	#0x30,d2                        	| [ld   c,#0x30] code $30 ... 360 degree default orientation
* if ( A >= 5 ) then  ... code = $30
	cmp.b	#5,d0                            	| [cp   #5]
	jcc	l_1F56_set_rocket_sprite_code      	| [jr   nc,l_1F56_set_rocket_sprite_code]
* else ( A >= 2 ) then .. code = $31
	addq.b	#1,d2                           	| [inc  c] code $31 ... 45 degree rotation
	cmp.b	#2,d0                            	| [cp   #2]
	jcc	l_1F56_set_rocket_sprite_code      	| [jr   nc,l_1F56_set_rocket_sprite_code]
* else  ... code = $33
	addq.b	#2,d2                           	| [inc  c] code $32 is skipped (also 360) * 2

l_1F56_set_rocket_sprite_code:
	move.b	d2,(a0)                         	| [ld   (hl),c]


* Displacement in both X and Y axis must be computed in order to launch rockets
* from the spinning ship. The "primary" axis of travel is whichever one the
* ship is more closely aligned with and is assigned the maximum displacement
* value of 6.
*
* If the code is 4 thru 6, sY is the primary axis of motion (norm
* for non-rotated ship), indicated by setting the orientation bit (+ $40).
*
* dX in the secondary axis is determined by the sprite rotation (code)
* as shown in the table below, where the displacement ranges from 0 (ship
* rotated 90 * n) to a maximum amount of 3 as the ship approaches a rotation
* of primary+45.
*
* See c_0704_update_rockets in cpu1.
*
*   code= 6     dS=0      $40     ... 7 - (6+1)
*   code= 5     dS=1      $40     ... 7 - (5+1)
*   code= 4     dS=2      $40     ... 7 - (4+1)
*   code= 3     dS=3      $00
*   code= 2     dS=2      $00
*   code= 1     dS=1      $00
*   code= 0     dS=0      $00

* if ( A >= 4 ) ...
	cmp.b	#4,d0                            	| [cp   #4] A == sprite.cclr[SHIP].b0;
	jcs	l_1F5E                             	| [jr   c,l_1F5E]

* ... dS = 7 - ( code + 1 ) + 0x40
	not.b	d0                               	| [cpl]
	add.b	0x40+7,d0                        	| [add  a,#0x40 + 7]
       ^^^^^^ TODO: review absolute 16-bit address read
* else ... no orientation swap needed, use sprite code for dS

l_1F5E:
	asl.b	#1,d0                            	| [sla  a] "orientation" bit into bit-7 ...
	move.b	d0,d2                           	| [ld   c,a] ... and displacement << 1  into bits 1:2

* sprite.ctrl bits ...  flipx into bit:5, flipy into bit:6
	move.b	d1,d0                           	| [ld   a,b] sprite.ctrl[SHIP].b0
	ror.b	#3,d0                            	| [rrca] * 3
	and.b	#0x60,d0                         	| [and  #0x60] mask of rotated SPRCTRL[0]:0 and SPRCTRL[0]:1 bits
	move.b	d0,d1                           	| [ld   b,a]

	move.b	b_9215_flip_screen,d0           	| [ld   a,(b_9215_flip_screen)]
	                               	| [and  a]
	move.b	d1,d0                           	| [ld   a,b] flipx/flipy bits (0x60)
	jne	l_1F71                             	| [jr   nz,l_1F71]
      ^^^^^^ TODO: review cpu flags (move.b,jne)
	eor.b	#0x60,d0                         	| [xor  #0x60] screen not flipped so invert those bits

l_1F71:
	or.b	d2,d0                             	| [or   c] bit7=orientation, bit6=flipY, bit5=flipX, 1:2=displacement
	move.l	(sp)+,a1                        	| [pop  de] pointer to rocket attribute
	movem.w	(sp)+,d3/d4                    	| [pop  de] pointer to rocket attribute
	move.b	d0,(a1)                         	| [ld   (de),a]

	lea	b_8800(pc),a0                      	| [ld   h,#>b_8800] disposition = 6 ... active rocket object
	and.w	#0xFF,d6
	add.w	d6,a0
	      ^^^^ TODO: review XX value
	move.b	#6,(a0)                         	| [ld   (hl),#6] L == offsetof(rocket)

	move.b	#1,d0                           	| [ld   a,#1]
	move.b	d0,b_9AA0+0x0F                  	| [ld   (b_9AA0 + 0x0F),a] 1 ... sound-fx count/enable registers, shot-sound

	move.w	ds_plyr_actv+_w_shot_ct(pc),a0  	| [ld   hl,(ds_plyr_actv +_w_shot_ct)]
                  ^^^^^^ TODO: review move.w into address register
	addq.w	#1,a0                           	| [inc  hl]
	move.b	a0,ds_plyr_actv+_w_shot_ct      	| [ld   (ds_plyr_actv +_w_shot_ct),hl] game shots fired count ++

	rts                                    	| [ret]
* end 1F04

*=============================================================================
* f_1F85()
*  Description:
*   Handle changes in controller IO Input bits, update ship movement.
*   (Called continuously in game-play, but also toward end of demo starting
*   when the two ships are joined.)
* IN:
*  ...
* OUT:
*  ...
*-----------------------------------------------------------------------------
f_1F85:
	move.b	ds_plyr_actv+_b_2ship,d0        	| [ld   a,(ds_plyr_actv +_b_2ship)]
	move.b	d0,d4                           	| [ld   e,a]

* read from io_input[1] or io_input[2] depending whether screen is flipped.
	move.b	b_9215_flip_screen,d0           	| [ld   a,(b_9215_flip_screen)]
	add.b	<ds3_99B5_io_input+0x01,d0       	| [add  a,#<ds3_99B5_io_input + 0x01] LSB
	move.b	d0,d6                           	| [ld   l,a]
	lea	ds3_99B5_io_input+0x00(pc),a0      	| [ld   h,#>ds3_99B5_io_input + 0x00] MSB
	and.w	#0xFF,d6
	add.w	d6,a0
	      ^^^^ TODO: review XX value
	move.b	(a0),d0                         	| [ld   a,(hl)]

*      call c_1F92

*=============================================================================
* c_1F92()
*  Description:
*   Skip real IO input in the demo.
*
*   The dX.flag determines the movement step (dX): when the ship movement
*   direction is changed, dX is 1 pixel increment for 1 frame and then 2 pixel
*   step thereafter as long as the control stick is held continously to the
*   direction. If the stick input is neutral, dX.flag (b_92A0[3]) is cleared.
*
*   In a two-ship configuration, the position is handled with respect to the
*   left ship... the right limit gets special handling accordingly.
*
* IN:
*   A == IO input control bits
*        2 ---> R
*        8 ---> L
*   E == actv_plyr_state[7]  .... double ship flag
*
* OUT:
*  ...
*-----------------------------------------------------------------------------
c_1F92:
* if ( ( A & 0x0A ) == $0A ... inputs are active low, neither left or right active
	and.b	#0x0A,d0                         	| [and  #0x0A]
	cmp.b	#0x0A,d0                         	| [cp   #0x0A]
	jeq	l_1FCF_no_input                    	| [jr   z,l_1FCF_no_input]

* invert the input bits if screen flipped (swap L/R direction)
	lea	b_9215_flip_screen(pc),a0          	| [ld   hl,#b_9215_flip_screen]
	btst.b	#0,(a0)                         	| [bit  0,(hl)]
	jeq	l_1FA1_set_ship_dx                 	| [jr   z,l_1FA1_set_ship_dx]
	eor.b	#0x0A,d0                         	| [xor  #0x0A] screen is flipped

* set ship.dX (1 or 2)
l_1FA1_set_ship_dx:
	lea	b_92A0+0x03(pc),a0                 	| [ld   hl,#b_92A0 + 0x03] ship_dX_flag
	move.b	d0,d1                           	| [ld   b,a] stash the control input bits
	move.b	#1,d2                           	| [ld   c,#1] ship_dX = 1
* toggle ship_dX_flag
	move.b	(a0),d0                         	| [ld   a,(hl)]
	eor.b	#0x01,d0                         	| [xor  #0x01]
	move.b	d0,(a0)                         	| [ld   (hl),a] dX.flag ^= 1

* if (0 == ship_dX_flag) ship_dX++
	jne	l_1FAE_handle_input_bits           	| [jr   nz,l_1FAE_handle_input_bits]
      ^^^^^^ TODO: review cpu flags (move.b,jne)
	addq.b	#1,d2                           	| [inc  c]

l_1FAE_handle_input_bits:
* if ( ship.posn.x == 0 ) return
	lea	ds_sprite_posn+0x62(pc),a0         	| [ld   hl,#ds_sprite_posn + 0x62] "main" ship (single) position
	move.b	(a0),d0                         	| [ld   a,(hl)]
	                               	| [and  a]
	bne.b	0f                               	| [...]
	rts                                    	| [ret  z] [...]
0:

* if ( input.Right ) ...
	btst.b	#1,d1                           	| [bit  1,b] if ( ! input bits.right ) ... inverted
	jne	l_1FC7_test_llmt                   	| [jr   nz,l_1FC7_test_llmt]

* if ( ship.posn.x > 0xD1) ... moving right: check right limit for double-ship
	move.b	(a0),d0                         	| [ld   a,(hl)]
	cmp.b	#0xD1,d0                         	| [cp   #0xD1] right limit, double-ship
	jcs	l_1FC0_test_rlmt_single            	| [jr   c,l_1FC0_test_rlmt_single]
* else if ( double_ship ) return
	btst.b	#0,d4                           	| [bit  0,e] if ( is_double_ship & 0x01 )
	beq.b	0f                               	| [...]
	rts                                    	| [ret  nz] at right limit of double-ship [...]
0:

l_1FC0_test_rlmt_single:
* if ( ship.posn.x >= 0xE1 ) return
	cmp.b	#0xE1,d0                         	| [cp   #0xE1] right limit, single-ship
	bcs.b	0f                               	| [...]
	rts                                    	| [ret  nc] [...]
0:
* add dX for right direction
	add.b	d2,d0                            	| [add  a,c] fighter dX
	move.b	d0,(a0)                         	| [ld   (hl),a]
	jra	l_1FD4_update_two_ship             	| [jr   l_1FD4_update_two_ship]

* ... else ... test left limit
l_1FC7_test_llmt:
* if ( ship.posn.x < 0x12 ) return
	move.b	(a0),d0                         	| [ld   a,(hl)]
	cmp.b	#0x12,d0                         	| [cp   #0x12] left limit
	bcc.b	0f                               	| [...]
	rts                                    	| [ret  c] [...]
0:
* else
	sub.b	d2,d0                            	| [sub  c] subtract dX
	move.b	d0,(a0)                         	| [ld   (hl),a]
	jra	l_1FD4_update_two_ship             	| [jr   l_1FD4_update_two_ship]

l_1FCF_no_input:
	clr.b	d0                               	| [xor  a]
	move.b	d0,b_92A0+0x03                  	| [ld   (b_92A0 + 0x03),a] ship_dX_flag = 0
	rts                                    	| [ret]


l_1FD4_update_two_ship:
* if ( ! two_ship_plyr )  return
	btst.b	#0,d4                           	| [bit  0,e]
	bne.b	0f                               	| [...]
	rts                                    	| [ret  z] [...]
0:
* else ... ship2.posn.x = ship1.posn.x + $0F
	add.b	#0x0F,d0                         	| [add  a,#0x0F] +single ship position
	move.b	d0,ds_sprite_posn+0x60          	| [ld   (ds_sprite_posn + 0x60), a] double ship position
	rts                                    	| [ret]

* end 1F85


* _l_1FDD:

*=============================================================================

*       .ds  0x23                                  ; pad

*=============================================================================

*           00002000  f_2000

*
* input file gg1-3.s
*
* gg1-3.s
*  gg1-3.2m, 'maincpu' (Z80)
*
*  Manages formation, attack convoys, boss/capture.
*
*
.module mob_mgr

.include "structs.inc"
.include "gg1-3.dep"

*.area ROM (ABS,OVR)
*       .org 0x1FFF
*       .db  0xFF                                   ; checksum 0x8C
*       .org 0x2000
.area CSEG20


*=============================================================================
* f_2000()
*  Description:
*    activated when the boss is destroyed that has captured the ship
* IN:
*  ...
* OUT:
*  ...
*-----------------------------------------------------------------------------
f_2000:
	move.b	ds_plyr_actv+_b_bmbr_boss_cobj,d0	| [ld   a,(ds_plyr_actv +_b_bmbr_boss_cobj)] object locator for captured ship
	move.b	d0,d6                           	| [ld   l,a]
	lea	b_8800(pc),a0                      	| [ld   h,#>b_8800]
	and.w	#0xFF,d6
	add.w	d6,a0
	      ^^^^ TODO: review XX value
	move.b	(a0),d0                         	| [ld   a,(hl)]
	                               	| [and  a]
	jne	l_20BF                             	| [jp   nz,l_20BF] no idea how it could be nz...
* if ( captr_status_1 == 0 )
	move.b	ds5_928A_captr_status+0x01,d0   	| [ld   a,(ds5_928A_captr_status + 0x01)]
	                               	| [and  a]
	jeq	l_20C7                             	| [jp   z,l_20C7]
* else if ( captr_status_1 == 1 )
	subq.b	#1,d0                           	| [dec  a]
	jeq	l_20D1_update_ship_spin            	| [jp   z,l_20D1_update_ship_spin]
* else ... status is 2 when stopped spinning and preparing for landing
	lea	ds_sprite_posn(pc),a0              	| [ld   h,#>ds_sprite_posn]
	and.w	#0xFF,d6
	add.w	d6,a0
	      ^^^^ TODO: review XX value
	move.b	(a0),d0                         	| [ld   a,(hl)]
	cmp.b	#0x80,d0                         	| [cp   #0x80]
	jeq	l_2026                             	| [jr   z,l_2026]
	jpl	l_2023                             	| [jp   p,l_2023]
	addq.b	#1,(a0)                         	| [inc  (hl)]
	jra	l_205E                             	| [jr   l_205E]
l_2023:
	subq.b	#1,(a0)                         	| [dec  (hl)]
	jra	l_205E                             	| [jr   l_205E]

l_2026:
	addq.w	#1,a0                           	| [inc l]
            ^^^^ TODO check inc register d6 or a0
	move.b	b_9215_flip_screen,d0           	| [ld   a,(b_9215_flip_screen)]
	                               	| [and  a]
	jne	l_204C                             	| [jr   nz,l_204C]
	move.b	(a0),d0                         	| [ld   a,(hl)]
	cmp.b	#0x29,d0                         	| [cp   #0x29]
	jne	l_2041                             	| [jr   nz,l_2041]
	lea	ds_sprite_ctrl(pc),a0              	| [ld   h,#>ds_sprite_ctrl]
	and.w	#0xFF,d6
	add.w	d6,a0
	      ^^^^ TODO: review XX value
	move.b	(a0),d0                         	| [ld   a,(hl)]
	lea	ds_sprite_posn(pc),a0              	| [ld   h,#>ds_sprite_posn]
	and.w	#0xFF,d6
	add.w	d6,a0
	      ^^^^ TODO: review XX value
	subq.b	#1,d0                           	| [dec  a]
	jne	l_2041                             	| [jr   nz,l_2041]
l_203A:
	move.b	#3,d0                           	| [ld   a,#3]
	move.b	d0,ds5_928A_captr_status+0x01   	| [ld   (ds5_928A_captr_status + 0x01),a] 3 (ships are joined now)
	jra	l_205E                             	| [jr   l_205E]

l_2041:
	addq.b	#1,(a0)                         	| [inc  (hl)]
	jne	l_205E                             	| [jr   nz,l_205E]
l_2044:
	lea	ds_sprite_ctrl(pc),a0              	| [ld   h,#>ds_sprite_ctrl] rescued ship is "landing"
	and.w	#0xFF,d6
	add.w	d6,a0
	      ^^^^ TODO: review XX value
	move.b	(a0),d0                         	| [ld   a,(hl)]
	eor.b	#0x01,d0                         	| [xor  #0x01]
	move.b	d0,(a0)                         	| [ld   (hl),a]
	jra	l_205E                             	| [jr   l_205E]
l_204C:
	move.b	(a0),d0                         	| [ld   a,(hl)] when?
	cmp.b	#0x37,d0                         	| [cp   #0x37]
	jne	l_2059                             	| [jr   nz,l_2059]
	lea	ds_sprite_ctrl(pc),a0              	| [ld   h,#>ds_sprite_ctrl]
	and.w	#0xFF,d6
	add.w	d6,a0
	      ^^^^ TODO: review XX value
	move.b	(a0),d0                         	| [ld   a,(hl)]
	lea	ds_sprite_posn(pc),a0              	| [ld   h,#>ds_sprite_posn]
	and.w	#0xFF,d6
	add.w	d6,a0
	      ^^^^ TODO: review XX value
	tst.b	d0                               	| [and  a]
	jeq	l_203A                             	| [jr   z,l_203A]
l_2059:
	subq.b	#1,(a0)                         	| [dec  (hl)]
	move.b	(a0),d0                         	| [ld   a,(hl)]
	addq.b	#1,d0                           	| [inc  a]
	jeq	l_2044                             	| [jr   z,l_2044]
l_205E:
	lea	ds_sprite_code+0x62(pc),a0         	| [ld   hl,#ds_sprite_code + 0x62] ship (1) sprite code
	move.b	(a0),d0                         	| [ld   a,(hl)]
	subq.b	#6,d0                           	| [sub  #6] glyphs 6 & 7 are both for upright ship... (7 is "wings closed" if captured)
	move.b	d0,d2                           	| [ld   c,a] ... so we have 0 or possibly 1 here.
	lea	ds_sprite_posn(pc),a0              	| [ld   h,#>ds_sprite_posn]
	and.w	#0xFF,d6
	add.w	d6,a0
	      ^^^^ TODO: review XX value
	jne	l_2075                             	| [jr   nz,l_2075]
	move.b	(a0),d0                         	| [ld   a,(hl)]
	cmp.b	#0x71,d0                         	| [cp   #0x71]
	jeq	l_2075                             	| [jr   z,l_2075]
	jpl	l_2073                             	| [jp   p,l_2073]
	addq.b	#1,(a0)                         	| [inc  (hl)] when?
	rts                                    	| [ret]
l_2073:
	subq.b	#1,(a0)                         	| [dec  (hl)]
	rts                                    	| [ret]

* the rescued ship has been moved horizontally to column adjacent to main-ship
l_2075:
	move.b	ds5_928A_captr_status+0x01,d0   	| [ld   a,(ds5_928A_captr_status + 0x01)] rescued ship is "landing" (becomes 3 when ships join)
	cmp.b	#3,d0                            	| [cp   #3]
	beq.b	0f                               	| [...]
	rts                                    	| [ret  nz] [...]
0:
 * both ships are now joined
	move.b	ds_plyr_actv+_b_bmbr_boss_cobj,d0	| [ld   a,(ds_plyr_actv +_b_bmbr_boss_cobj)] object locator for the captured ship
	move.b	d0,d6                           	| [ld   l,a]
	clr.b	(a0)+                             	| [ld   (hl),#0] 0 out the sprite position of the captured ship object e.g. 9300, 9302 etc.
	^^^^ d6;a0 todo                           	| [inc  l]
	                           	| [dec  c]
	tst.b	d2                           	| [inc  c]
	jeq	l_208F                             	| [jr   z,l_208F]

	lea	ds_sprite_posn+0x63(pc),a1         	| [ld   de,#ds_sprite_posn + 0x63] this is if ship (1) sprite code was 7
	clr.b	d0                               	| [xor  a]
	move.b	d0,ds_plyr_actv+_b_bmbr_boss_cflag	| [ld   (ds_plyr_actv +_b_bmbr_boss_cflag),a] 0 ... enable capture-mode selection
	jra	l_2097                             	| [jr   l_2097]

* ship sprite code was 6
l_208F:
	move.b	#1,d0                           	| [ld   a,#1]
	move.b	d0,ds_plyr_actv+_b_2ship        	| [ld   (ds_plyr_actv +_b_2ship),a]
	lea	ds_sprite_posn+0x61(pc),a1         	| [ld   de,#ds_sprite_posn + 0x61]

* capture ship rejoined with active ship
l_2097:
	move.b	(a0),d0                         	| [ld   a,(hl)] e.g. HL==9301 sprite_posn
	move.b	d0,(a1)                         	| [ld   (de),a] e.g. DE==9363 sprite_posn
	lea	ds_sprite_ctrl(pc),a0              	| [ld   h,#>ds_sprite_ctrl]
	and.w	#0xFF,d6
	add.w	d6,a0
	      ^^^^ TODO: review XX value
	move.b	d5,d3                           	| [ld   d,h]
	move.b	(a0),d0                         	| [ld   a,(hl)] e.g. HL==9B01.. ctrl_2:bit0==enable and ctrl2_bit7==sx_bit8
	move.b	d0,(a1)                         	| [ld   (de),a]
	subq.w	#1,a0                           	| [dec  l]
            ^^^^ TODO check dec register d6 or a0
	lea	b_8800(pc),a0                      	| [ld   h,#>b_8800]
	and.w	#0xFF,d6
	add.w	d6,a0
	      ^^^^ TODO: review XX value
	move.b	#0x80,(a0)                      	| [ld   (hl),#0x80] set captured ship object state inactive
	lea	ds_sprite_code(pc),a0              	| [ld   h,#>ds_sprite_code]
	and.w	#0xFF,d6
	add.w	d6,a0
	      ^^^^ TODO: review XX value
	move.b	d4,d6                           	| [ld   l,e]
	subq.w	#1,a0                           	| [dec  l]
            ^^^^ TODO check dec register d6 or a0
	move.b	#6,(a0)                         	| [ld   (hl),#6] sprite code 6
	addq.w	#1,a0                           	| [inc  l]
            ^^^^ TODO check inc register d6 or a0
	move.b	#9,(a0)                         	| [ld   (hl),#9] color map 9 for white ship
	subq.w	#1,a0                           	| [dec  l]
            ^^^^ TODO check dec register d6 or a0
	lea	ds_sprite_posn(pc),a0              	| [ld   h,#>ds_sprite_posn]
	and.w	#0xFF,d6
	add.w	d6,a0
	      ^^^^ TODO: review XX value
	move.b	#0x80,(a0)                      	| [ld   (hl),#0x80] put in center
	move.b	#1,d0                           	| [ld   a,#1]
	move.b	d0,ds_cpu0_task_actv+0x14       	| [ld   (ds_cpu0_task_actv + 0x14),a] 1 (f_0827 ... empty task)
	move.b	d0,ds_cpu0_task_actv+0x15       	| [ld   (ds_cpu0_task_actv + 0x15),a] 1 (f_1F04 ...fire button input))
	move.b	d0,ds_cpu1_task_actv+0x05       	| [ld   (ds_cpu1_task_actv + 0x05),a] 1 (cpu1:f_05EE .. Manage ship collision detection)
	move.b	d0,ds_99B9_star_ctrl+0x00       	| [ld   (ds_99B9_star_ctrl + 0x00),a] 1 (when ship on screen
* capture ship rejoined with active ship
l_20BF:
	clr.b	d0                               	| [xor  a]
	move.b	d0,ds_cpu0_task_actv+0x1D       	| [ld   (ds_cpu0_task_actv + 0x1D),a] 0 ... this task
	move.b	d0,b_9AA0+0x11                  	| [ld   (b_9AA0 + 0x11),a] 0 ... sound-fx count/enable registers, stop "rescued ship" music
	rts                                    	| [ret]

l_20C7:                                           ; *( ds5_928A_captr_status + 0x01 ) == 0
	addq.b	#1,d0                           	| [inc  a]
	move.b	d0,ds5_928A_captr_status+0x01   	| [ld   (ds5_928A_captr_status + 0x01),a] 1
	move.b	#2,d0                           	| [ld   a,#2]
	move.b	d0,ds4_game_tmrs+1              	| [ld   (ds4_game_tmrs + 1),a] 2
	rts                                    	| [ret]

l_20D1_update_ship_spin:
	lea	ds_sprite_ctrl(pc),a0              	| [ld   h,#>ds_sprite_ctrl] base address for c_2188
	and.w	#0xFF,d6
	add.w	d6,a0
	      ^^^^ TODO: review XX value
	move.b	ds4_game_tmrs+1,d0              	| [ld   a,(ds4_game_tmrs + 1)]
	move.b	d0,d4                           	| [ld   e,a]
	move.b	b_bugs_flying_nbr,d0            	| [ld   a,(b_bugs_flying_nbr)]
	or.b	d4,d0                             	| [or   e]
	move.b	d0,ds5_928A_captr_status+0x03   	| [ld   (ds5_928A_captr_status + 0x03),a]
	jbsr	c_2188_ship_spin                  	| [call c_2188_ship_spin] Base address in HL, retval in B
	subq.b	#1,d1                           	| [dec  b] what's in B?
	beq.b	0f                               	| [...]
	rts                                    	| [ret  nz] [...]
0:
* rescued ship stopped spinning ... begin "landing"
	move.b	d0,ds_cpu0_task_actv+0x14       	| [ld   (ds_cpu0_task_actv + 0x14),a] 0 (f_0827)
	move.b	d0,ds_cpu0_task_actv+0x15       	| [ld   (ds_cpu0_task_actv + 0x15),a] 0 (f_1F04 ...fire button input))
	move.b	d0,ds_cpu1_task_actv+0x05       	| [ld   (ds_cpu1_task_actv + 0x05),a] 0 (cpu1:f_05EE)
	move.b	#2,d0                           	| [ld   a,#2]
	move.b	d0,ds5_928A_captr_status+0x01   	| [ld   (ds5_928A_captr_status + 0x01),a] 2
	rts                                    	| [ret]
* end 2000?

*=============================================================================
* f_20F2()
*  Description:
*   handles the sequence where the tractor beam captures the ship.
* IN:
*  ...
* OUT:
*  ...
*-----------------------------------------------------------------------------
f_20F2:
	lea	ds_sprite_ctrl+0x62(pc),a0         	| [ld   hl,#ds_sprite_ctrl + 0x62] ship (1) position ...base address for c_2188
	jbsr	c_2188_ship_spin                  	| [call c_2188_ship_spin] Base address in HL, retval in B
	btst.b	#0,d1                           	| [bit  0,b]
	jne	l_2151                             	| [jr   nz,l_2151]
	move.b	ds5_928A_captr_status+0x01,d0   	| [ld   a,(ds5_928A_captr_status + 0x01)] check bit 7
	btst.b	#7,d0                           	| [bit  7,a]
	jne	l_215D                             	| [jr   nz,l_215D]
	move.b	ds5_928A_captr_status+0x03,d0   	| [ld   a,(ds5_928A_captr_status + 0x03)]
	                               	| [and  a]
	bne.b	0f                               	| [...]
	rts                                    	| [ret  z] [...]
0:
	lea	ds_sprite_posn(pc),a0              	| [ld   h,#>ds_sprite_posn]
	and.w	#0xFF,d6
	add.w	d6,a0
	      ^^^^ TODO: review XX value
	move.b	ds_plyr_actv+_b_bmbr_boss_cobj,d0	| [ld   a,(ds_plyr_actv +_b_bmbr_boss_cobj)] object index of capturing boss i.e. 30 34 36 32
	move.b	d0,d4                           	| [ld   e,a]
	move.b	d5,d3                           	| [ld   d,h]
	move.b	(a1),d0                         	| [ld   a,(de)] get capturing boss column position position
	cmp.b	(a0),d0                          	| [cp   (hl)] compare to ship position
	jeq	l_211A_move_ship_row               	| [jr   z,l_211A_move_ship_row] if equal
	jpl	l_2119_handle_ship_left            	| [jp   p,l_2119_handle_ship_left]
	subq.b	#1,(a0)                         	| [dec  (hl)] move ship left one step
	jra	l_211A_move_ship_row               	| [jr   l_211A_move_ship_row]

l_2119_handle_ship_left:
	addq.b	#1,(a0)                         	| [inc  (hl)] move ship right one step
l_211A_move_ship_row:
	addq.w	#1,a0                           	| [inc  l]
            ^^^^ TODO check inc register d6 or a0
	move.b	b_9215_flip_screen,d0           	| [ld   a,(b_9215_flip_screen)]
	                               	| [and  a]
	jeq	l_212C_not_flipped_screen          	| [jr   z,l_212C_not_flipped_screen]
* handle flipped screen
	addq.b	#1,(a0)                         	| [inc  (hl)]
	move.b	(a0),d0                         	| [ld   a,(hl)]
	cmp.b	#0x7A,d0                         	| [cp   #0x7A]
	jeq	l_214C_disable_firepower           	| [jr   z,l_214C_disable_firepower]
	cmp.b	#0x80,d0                         	| [cp   #0x80]
	jeq	l_2141_connected                   	| [jr   z,l_2141_connected]
	rts                                    	| [ret]

l_212C_not_flipped_screen:
	subq.b	#1,(a0)                         	| [dec  (hl)]
	move.b	(a0),d0                         	| [ld   a,(hl)]
	addq.b	#1,d0                           	| [inc  a]
	jne	l_2139                             	| [jr   nz,l_2139]
* handle overflow by toggling bit-0 (off)
	lea	ds_sprite_ctrl(pc),a0              	| [ld   h,#>ds_sprite_ctrl]
	and.w	#0xFF,d6
	add.w	d6,a0
	      ^^^^ TODO: review XX value
	move.b	(a0),d0                         	| [ld   a,(hl)]
	eor.b	#0x01,d0                         	| [xor  #0x01]
	move.b	d0,(a0)                         	| [ld   (hl),a]
	lea	ds_sprite_posn(pc),a0              	| [ld   h,#>ds_sprite_posn]
	and.w	#0xFF,d6
	add.w	d6,a0
	      ^^^^ TODO: review XX value
l_2139:
	move.b	(a0),d0                         	| [ld   a,(hl)]
	cmp.b	#0xE6,d0                         	| [cp   #0xE6]
	jeq	l_214C_disable_firepower           	| [jr   z,l_214C_disable_firepower]
	cmp.b	#0xE0,d0                         	| [cp   #0xE0]
	beq.b	0f                               	| [...]
	rts                                    	| [ret  nz] [...]
0:
l_2141_connected:
	clr.b	d0                               	| [xor  a]
	move.b	d0,ds5_928A_captr_status+0x03   	| [ld   (ds5_928A_captr_status + 0x03),a] 0
	addq.b	#1,d0                           	| [inc  a] huh?
	move.b	#7,d0                           	| [ld   a,#7] color map of redship
	move.b	d0,ds_sprite_code+0x63          	| [ld   (ds_sprite_code + 0x63),a]
	rts                                    	| [ret]

* disables your rockets when the boss has finally connected.
l_214C_disable_firepower:
	clr.b	d0                               	| [xor  a]
	move.b	d0,ds_cpu0_task_actv+0x15       	| [ld   (ds_cpu0_task_actv + 0x15),a] 0 ... f_1F04 (fire button input)
	rts                                    	| [ret]

 * either the boss made final connection with ship, or the boss was shot while beaming the ship
l_2151:
* if ( firepower_enabled )...
	move.b	ds_cpu0_task_actv+0x15,d0       	| [ld   a,(ds_cpu0_task_actv + 0x15)] f_1F04
	                               	| [and  a]
	jne	l_215D                             	| [jr   nz,l_215D]
* else ...
	addq.b	#1,d0                           	| [inc  a]
	move.b	d0,ds_9200_glbls+0x0D           	| [ld   (ds_9200_glbls + 0x0D),a] 1 ... boss connected with ship and firepower has been disabled
	jra	l_217F_finished                    	| [jr   l_217F_finished]

* the ship is in the beam but then shoots the boss
l_215D:
	lea	ds_sprite_posn(pc),a0              	| [ld   h,#>ds_sprite_posn]
	and.w	#0xFF,d6
	add.w	d6,a0
	      ^^^^ TODO: review XX value
	addq.w	#1,a0                           	| [inc  l]
            ^^^^ TODO check inc register d6 or a0
	move.b	b_9215_flip_screen,d0           	| [ld   a,(b_9215_flip_screen)]
	                               	| [and  a]
	jeq	l_216D                             	| [jr   z,l_216D]
	move.b	(a0),d0                         	| [ld   a,(hl)]
	cmp.b	#0x37,d0                         	| [cp   #0x37]
	jeq	l_217D                             	| [jr   z,l_217D]
	subq.b	#1,(a0)                         	| [dec  (hl)]
	rts                                    	| [ret]

l_216D:                                           ; when?
	move.b	(a0),d0                         	| [ld   a,(hl)]
	cmp.b	#0x29,d0                         	| [cp   #0x29]
	jeq	l_217D                             	| [jr   z,l_217D]
	addq.b	#1,(a0)                         	| [inc  (hl)]
	beq.b	0f                               	| [...]
	rts                                    	| [ret  nz] [...]
0:
	lea	ds_sprite_ctrl(pc),a0              	| [ld   h,#>ds_sprite_ctrl]
	and.w	#0xFF,d6
	add.w	d6,a0
	      ^^^^ TODO: review XX value
	move.b	(a0),d0                         	| [ld   a,(hl)]
	eor.b	#0x01,d0                         	| [xor  #0x01]
	move.b	d0,(a0)                         	| [ld   (hl),a]
	lea	ds_sprite_posn(pc),a0              	| [ld   h,#>ds_sprite_posn]
	and.w	#0xFF,d6
	add.w	d6,a0
	      ^^^^ TODO: review XX value
	rts                                    	| [ret]
l_217D:
	subq.b	#1,d1                           	| [dec  b]
	beq.b	0f                               	| [...]
	rts                                    	| [ret  nz] [...]
0:
l_217F_finished:
	clr.b	d0                               	| [xor  a]
	move.b	d0,ds_cpu0_task_actv+0x1C       	| [ld   (ds_cpu0_task_actv + 0x1C),a] 0: f_20F2 ... this task
	addq.b	#1,d0                           	| [inc  a]
	move.b	d0,ds_cpu1_task_actv+0x05       	| [ld   (ds_cpu1_task_actv + 0x05),a] 1: cpu1:f_05EE ... Manage ship collision detection
	rts                                    	| [ret]
* end 20F2

*=============================================================================
* c_2188_ship_spin()
*  Description:
*   Spins the ship, either when being captured, or being released.
* IN:
*   Base address in HL
* OUT:
*   B==
*-----------------------------------------------------------------------------
c_2188_ship_spin:
	move.b	(a0),d0                         	| [ld   a,(hl)]
	move.b	d0,d2                           	| [ld   c,a]
	lsr.b	#1,d0                            	| [srl  a]
	eor.b	d2,d0                            	| [xor  c]
	move.b	d0,d2                           	| [ld   c,a]
	lea	ds_sprite_code(pc),a0              	| [ld   h,#>ds_sprite_code]
	and.w	#0xFF,d6
	add.w	d6,a0
	      ^^^^ TODO: review XX value
	clr.b	d1                               	| [ld   b,#0]
	move.b	(a0),d0                         	| [ld   a,(hl)]
	and.b	#0x07,d0                         	| [and  #0x07]
	cmp.b	#6,d0                            	| [cp   #6]
	jne	l_21A7                             	| [jr   nz,l_21A7] iterated up and down between 0 and 6 as ship rotates in the beam
	                           	| [dec  c]
	tst.b	d2                           	| [inc  c]
	jne	l_21A7                             	| [jr   nz,l_21A7]
	scs	d7                              	| [ex   af,af'] ship rotated around through 180 degrees
         ^^^ TODO review: wrong if carry is needed or D7 used in between!
	move.b	ds5_928A_captr_status+0x03,d0   	| [ld   a,(ds5_928A_captr_status + 0x03)]
	                               	| [and  a]
	jne	l_21A6                             	| [jr   nz,l_21A6]
	addq.b	#1,d1                           	| [inc  b]
	rts                                    	| [ret]

l_21A6:
	scs	d7                              	| [ex   af,af']
         ^^^ TODO review: wrong if carry is needed or D7 used in between!
l_21A7:
	btst.b	#0,d2                           	| [bit  0,c]
	jne	l_21B2                             	| [jr   nz,l_21B2]
	cmp.b	#6,d0                            	| [cp   #6]
	jeq	l_21B8                             	| [jr   z,l_21B8]
	addq.b	#1,(a0)                         	| [inc  (hl)]
	jra	l_21C0                             	| [jr   l_21C0]
l_21B2:
	tst.b	d0                               	| [and  a]
	jeq	l_21B8                             	| [jr   z,l_21B8]
	subq.b	#1,(a0)                         	| [dec  (hl)]
	jra	l_21C0                             	| [jr   l_21C0]
l_21B8:
	subq.b	#1,d2                           	| [dec  c]
	jpl	l_21A7                             	| [jp   p,l_21A7]
	move.b	#3,d2                           	| [ld   c,#3]
	jra	l_21A7                             	| [jr   l_21A7]
l_21C0:
	move.b	d2,d0                           	| [ld   a,c]
	btst.b	#1,d0                           	| [bit  1,a]
	jeq	l_21C7                             	| [jr   z,l_21C7]
	eor.b	#0x01,d0                         	| [xor  #0x01]
l_21C7:
	lea	ds_sprite_ctrl(pc),a0              	| [ld   h,#>ds_sprite_ctrl]
	and.w	#0xFF,d6
	add.w	d6,a0
	      ^^^^ TODO: review XX value
	move.b	d0,(a0)                         	| [ld   (hl),a]
	rts                                    	| [ret]
* end 2188

*=============================================================================
* f_21CB()
*  Description:
*   Active when a boss diving down to capture the ship. Ends when the boss
*   takes position to start the beam.
* IN:
*  ...
* OUT:
*  ...
*-----------------------------------------------------------------------------
f_21CB:
* if ( HOMING == b_8800[ plyr_actv.captr_boss_id ] )
	lea	ds_plyr_actv+_b_bmbr_boss_cobj(pc),a0	| [ld   hl,#ds_plyr_actv +_b_bmbr_boss_cobj]
	move.b	(a0),d4                         	| [ld   e,(hl)]
	lea	b_8800(pc),a1                      	| [ld   d,#>b_8800]
	and.w	#0xFF,d4
	add.w	d4,a1
	      ^^^^ TODO: review XX value
	move.b	(a1),d0                         	| [ld   a,(de)]
	cmp.b	#9,d0                            	| [cp   #9]
	jne	l_221A                             	| [jr   nz,l_221A] exit
* ... then ...

* get the element of the bug_motion_que being used by this object. The byte-
* offset of the element is stored by plyr_actv.b09
	addq.w	#1,a0                           	| [inc  l] _b09_cboss_slot ... set by cpu-b as capturing boss starts dive

	move.b	(a0),d0                         	| [ld   a,(hl)]
ld   ixl,a
ld   ixh,>ds_bug_motion_que

	move.b	(0x0A,a2),d0                    	| [ld   a,0x0A(ix)] while !0, capture boss is diving
	                               	| [and  a]
	beq.b	0f                               	| [...]
	rts                                    	| [ret  nz] [...]
0:

	move.b	#0x0C,d0                        	| [ld   a,#0x0C]
	btst.b	#0,(0x05,a2)                    	| [bit  0,0x05(ix)] if set, negate (ix)0x0C ... capture boss nearly in position
	jeq	l_21EC                             	| [jr   z,l_21EC]
	neg.b	d0                               	| [neg]
l_21EC:
	move.b	d0,(0x0C,a2)                    	| [ld   0x0C(ix),a] 12 or -12 if (ix)0x05:0 set

	move.b	(0x05,a2),d0                    	| [ld   a,0x05(ix)]
	ror.b	#1,d0                            	| [rrca]
	move.b	(0x04,a2),d0                    	| [ld   a,0x04(ix)]
	roxr.b	#1,d0                           	| [rra]
      ^^^^^^ TODO: review cpu X flag
	sub.b	#0x78,d0                         	| [sub  #0x78]
	cmp.b	#0x10,d0                         	| [cp   #0x10]
	bcs.b	0f                               	| [...]
	rts                                    	| [ret  nc] [...]
0:

* in position
	move.b	ds_new_stage_parms+0x06,d0      	| [ld   a,(ds_new_stage_parms + 0x06)] plyr_state_actv[0x0A] ... ship capture status
	move.b	d0,ds_plyr_actv+_b_captr_flag   	| [ld   (ds_plyr_actv +_b_captr_flag),a] new_stage_parms[ 6 ]
	clr.b	d0                               	| [xor  a]
	move.b	d0,(0x0C,a2)                    	| [ld   0x0C(ix),a] 0
	move.b	d0,ds_cpu0_task_actv+0x19       	| [ld   (ds_cpu0_task_actv + 0x19),a] 0 (f_21CB)
	move.b	d0,ds5_928A_captr_status+0x01   	| [ld   (ds5_928A_captr_status + 0x01),a] 0
	move.b	d0,ds_9200_glbls+0x0D           	| [ld   (ds_9200_glbls + 0x0D),a] 0
	addq.b	#1,d0                           	| [inc  a]
	move.b	d0,ds_cpu0_task_actv+0x18       	| [ld   (ds_cpu0_task_actv + 0x18),a] 1 (f_2222 ... Boss starts tractor beam)
	move.b	d0,ds5_928A_captr_status+0x02   	| [ld   (ds5_928A_captr_status + 0x02),a] 1
	move.b	d0,ds5_928A_captr_status+0x03   	| [ld   (ds5_928A_captr_status + 0x03),a] 1
	rts                                    	| [ret]
l_221A:
	clr.b	d0                               	| [xor  a]
	move.b	d0,ds_cpu0_task_actv+0x19       	| [ld   (ds_cpu0_task_actv + 0x19),a] 0 (f_21CB)
	move.b	d0,ds_plyr_actv+_b_bmbr_boss_cflag	| [ld   (ds_plyr_actv +_b_bmbr_boss_cflag),a] 0 ... enable capture-mode selection
	rts                                    	| [ret]
* end 21CB

*=============================================================================
* f_2222()
*  Description:
*   Boss starts tractor beam
*   Activated by f_21CB (capture boss dives down)
* IN:
*  ...
* OUT:
*  ...
*-----------------------------------------------------------------------------
f_2222:
*  if ( frame_count % 4 != 0 ) goto 2257
	move.b	ds3_92A0_frame_cts+0,d0         	| [ld   a,(ds3_92A0_frame_cts + 0)] frame_ct%4 ... (provides 15Hz timer)
	move.b	d0,d2                           	| [ld   c,a]
	and.b	#0x03,d0                         	| [and  #0x03]
	jne	l_2257                             	| [jr   nz,l_2257]
*  else
	move.b	ds5_928A_captr_status+0x00,d0   	| [ld   a,(ds5_928A_captr_status + 0x00)] beam started
	neg.b	d0                               	| [neg]
	sub.b	#0x18,d0                         	| [sub  #0x18]
	move.b	#0x21,d5                        	| [ld   h,#0x21]
	rol.b	#1,d0                            	| [rlca]
	roxl.b	#1,d5                           	| [rl   h]
      ^^^^^^ TODO: review cpu X flag
	rol.b	#1,d0                            	| [rlca]
	roxl.b	#1,d5                           	| [rl   h]
      ^^^^^^ TODO: review cpu X flag
	and.b	#0xE0,d0                         	| [and  #0xE0]
	add.b	#0x15,d0                         	| [add  a,#0x15]
	move.b	d0,d6                           	| [ld   l,a]
	move.b	d2,d0                           	| [ld   a,c]
	ror.b	#2,d0                            	| [rrca] * 2
	and.b	#0x03,d0                         	| [and  #0x03]
	jne	l_2246                             	| [jr   nz,l_2246]
	addq.b	#1,d0                           	| [inc  a]
l_2246:
	add.b	#0x17,d0                         	| [add  a,#0x17]
	move.w	#0x0016,d3                      	| [ld   de,#0x0016] 22
	move.b	#6,d2                           	| [ld   c,#6]
l_224D:
	move.b	#0x0A,d1                        	| [ld   b,#0x0A]
l_224F:
	move.b	d0,(a0)                         	| [ld   (hl),a]
	addq.b	#1,d6                           	| [inc  l]
	subq.b	#1,d1                           	| [...]
	jne	l_224F                             	| [djnz l_224F]

	add.w	d3,a0                            	| [add  hl,de]
  ^^^^ TODO: review d3 computation above
	subq.b	#1,d2                           	| [dec  c]
	jne	l_224D                             	| [jr   nz,l_224D]

l_2257:
	lea	ds5_928A_captr_status+0x01(pc),a0  	| [ld   hl,#ds5_928A_captr_status + 0x01] check bit 7
	btst.b	#7,(a0)                         	| [bit  7,(hl)]
	jne	l_226A                             	| [jr   nz,l_226A]
	move.b	ds_plyr_actv+_b_bmbr_boss_cobj,d0	| [ld   a,(ds_plyr_actv +_b_bmbr_boss_cobj)]
	move.b	d0,d4                           	| [ld   e,a]
	lea	b_8800(pc),a1                      	| [ld   d,#>b_8800]
	and.w	#0xFF,d4
	add.w	d4,a1
	      ^^^^ TODO: review XX value
	move.b	(a1),d0                         	| [ld   a,(de)]
	cmp.b	#0x09,d0                         	| [cp   #0x09] 09 ... in a diving attack
	jne	l_2327_shot_boss_while_capturing   	| [jp   nz,l_2327_shot_boss_while_capturing]
l_226A:
* if  ( ( *( ds5_928A_captr_status + 0x02 )-- ) > 0 ) goto 233D
	lea	ds5_928A_captr_status+0x02(pc),a0  	| [ld   hl,#ds5_928A_captr_status + 0x02] -=1
	subq.b	#1,(a0)                         	| [dec  (hl)]
	jne	l_233D                             	| [jp   nz,l_233D]
* else
	move.b	ds_plyr_actv+_b_captr_flag,d0   	| [ld   a,(ds_plyr_actv +_b_captr_flag)] *( ds5_928A_captr_status + 0x02 )
	move.b	d0,(a0)                         	| [ld   (hl),a]
* if ( *(_captr_status + 0x01) & $80 ) goto 22AB
	lea	ds5_928A_captr_status+0x01(pc),a0  	| [ld   hl,#ds5_928A_captr_status + 0x01] check bit 7
	btst.b	#7,(a0)                         	| [bit  7,(hl)]
	jne	l_22AB                             	| [jr   nz,l_22AB]
* else
	move.b	d0,b_9AA0+0x05                  	| [ld   (b_9AA0 + 0x05),a] sound-fx count/enable registers, trigger capture beam sound

	move.b	ds_plyr_actv+_b_cboss_slot,d0   	| [ld   a,(ds_plyr_actv +_b_cboss_slot)] bug_flite_que[ plyr.cboss_slot ].b0D = $FF
	add.b	#0x0D,d0                         	| [add  a,#0x0D]
	move.b	d0,d4                           	| [ld   e,a]
	lea	ds_bug_motion_que(pc),a1           	| [ld   d,#>ds_bug_motion_que] bug_flite_que[ plyr.cboss_slot ].b0D = $FF
	and.w	#0xFF,d4
	add.w	d4,a1
	      ^^^^ TODO: review XX value
	st.b	d0                                	| [ld   a,#0xFF]
	move.b	d0,(a1)                         	| [ld   (de),a]

	addq.b	#1,(a0)                         	| [inc  (hl)]
	move.b	(a0),d0                         	| [ld   a,(hl)]
	and.b	#0x0F,d0                         	| [and  #0x0F]
	cmp.b	#0x0B,d0                         	| [cp   #0x0B]
	jeq	l_22D2                             	| [jr   z,l_22D2]
	btst.b	#6,(a0)                         	| [bit  6,(hl)]
	jne	l_22C1                             	| [jr   nz,l_22C1]
	move.w	d0,-(sp)                        	| [push af]
	move.b	d0,d2                           	| [ld   c,a]
	rol.b	#1,d0                            	| [rlca]
	add.b	d2,d0                            	| [add  a,c]
	lea	d_23A1-6(pc),a0                    	| [ld   hl,#d_23A1 - 6] get data src, getting ready to shoot the tractor beam
	jbsr	rst_08                            	| [rst  0x08] HL += 2A
	move.w	(sp)+,d0                        	| [pop  af]
	jbsr	c_238A                            	| [call c_238A]

	move.b	#6,d1                           	| [ld   b,#6]
l_22A4:
	move.b	(a0),d0                         	| [ld   a,(hl)]
	move.b	d0,(a1)                         	| [ld   (de),a]
	addq.w	#1,a0                           	| [inc  hl]
	jbsr	rst_20                            	| [rst  0x20] DE-=$20
	subq.b	#1,d1                           	| [...]
	jne	l_22A4                             	| [djnz l_22A4]
	rts                                    	| [ret]

l_22AB:
	addq.b	#1,(a0)                         	| [inc  (hl)]
	move.b	(a0),d0                         	| [ld   a,(hl)]
	and.b	#0x0F,d0                         	| [and  #0x0F]
	cmp.b	#0x0B,d0                         	| [cp   #0x0B]
	jne	l_22C5                             	| [jr   nz,l_22C5]
	clr.b	d0                               	| [xor  a]
	move.b	d0,ds_cpu0_task_actv+0x18       	| [ld   (ds_cpu0_task_actv + 0x18),a] 0 (f_2222 ... this one)
	move.b	d0,b_9AA0+0x05                  	| [ld   (b_9AA0 + 0x05),a] 0 ... sound-fx count/enable registers, capture beam sound active uno
	move.b	d0,b_9AA0+0x06                  	| [ld   (b_9AA0 + 0x06),a] 0 ... sound-fx count/enable registers, capture beam sound active deux
	move.b	d0,ds_plyr_actv+_b_bmbr_boss_cflag	| [ld   (ds_plyr_actv +_b_bmbr_boss_cflag),a] 0 ... enable capture-mode selection
	rts                                    	| [ret]

l_22C1:
	neg.b	d0                               	| [neg] from 2294, boss almost ready to attach to the ship
	add.b	#0x0B,d0                         	| [add  a,#0x0B]
l_22C5:
	jbsr	c_238A                            	| [call c_238A]

	move.b	#6,d1                           	| [ld   b,#6]
	move.b	#0x24,d2                        	| [ld   c,#0x24]
l_22CC:
	move.b	d2,d0                           	| [ld   a,c]
	move.b	d0,(a1)                         	| [ld   (de),a]
	jbsr	rst_20                            	| [rst  0x20] DE-=$20
	subq.b	#1,d1                           	| [...]
	jne	l_22CC                             	| [djnz l_22CC]

	rts                                    	| [ret]

l_22D2:
	btst.b	#6,(a0)                         	| [bit  6,(hl)] got the ship, ship is red, beam gone
	jeq	l_231C                             	| [jr   z,l_231C]
	move.b	ds_9200_glbls+0x0D,d0           	| [ld   a,(ds_9200_glbls + 0x0D)] if 1, boss has connected with ship and firepower disabled
	                               	| [and  a]
	jeq	l_22E3                             	| [jr   z,l_22E3]
	btst.b	#5,(a0)                         	| [bit  5,(hl)]
	jne	l_22E3                             	| [jr   nz,l_22E3]
	move.b	#0x68,(a0)                      	| [ld   (hl),#0x68]
	rts                                    	| [ret]

* capture beam has stopped (whether or not ship is captured or got destroyed by a bomb)
l_22E3:
	clr.b	d0                               	| [xor  a]
	move.b	d0,ds_cpu0_task_actv+0x18       	| [ld   (ds_cpu0_task_actv + 0x18),a] 0 (disable f_2222 ... this one)
	move.b	d0,b_9AA0+0x05                  	| [ld   (b_9AA0 + 0x05),a] 0 ... sound-fx count/enable registers, capture beam sound active uno
	move.b	d0,b_9AA0+0x06                  	| [ld   (b_9AA0 + 0x06),a] 0 ... sound-fx count/enable registers, capture beam sound active deux
	move.b	ds_9200_glbls+0x0D,d0           	| [ld   a,(ds_9200_glbls + 0x0D)] if 1, boss has connected with ship and firepower disabled
	                               	| [and  a]
	move.b	ds_plyr_actv+_b_cboss_slot,d0   	| [ld   a,(ds_plyr_actv +_b_cboss_slot)] bug_flite_que[ plyr.cboss_slot + $nn ] ... nn -> b0D or b08
	jne	l_2305                             	| [jr   nz,l_2305]
      ^^^^^^ TODO: review cpu flags (move.b,jne)
* if  0 == b_9200[$0D] ...
	add.b	#0x0D,d0                         	| [add  a,#0x0D]
	move.b	d0,d4                           	| [ld   e,a]
	lea	ds_bug_motion_que(pc),a1           	| [ld   d,#>ds_bug_motion_que] bug_flite_que[plyr.boss_slot].b0D = 1 ... token expiration on next step
	and.w	#0xFF,d4
	add.w	d4,a1
	      ^^^^ TODO: review XX value
	clr.b	d0                               	| [xor  a]
	move.b	d0,ds_plyr_actv+_b_bmbr_boss_cflag	| [ld   (ds_plyr_actv +_b_bmbr_boss_cflag),a] 0 ... enable capture-mode selection
	addq.b	#1,d0                           	| [inc  a]
	move.b	d0,ds_plyr_actv+_b_bmbr_boss_cobj	| [ld   (ds_plyr_actv +_b_bmbr_boss_cobj),a] 1 ... why 1?
	move.b	d0,(a1)                         	| [ld   (de),a] bug_flite_que[plyr.cboss_slot].b0D = 1 ... token expiration on next step
	rts                                    	| [ret]

* ... else ... (connected with ship)
l_2305:
	add.b	#8,d0                            	| [add  a,#8]
	move.b	d0,d6                           	| [ld   l,a]
	lea	ds_bug_motion_que(pc),a0           	| [ld   h,#>ds_bug_motion_que] bug_flite_que[plyr.cboss_slot].p08 = &db_046B[0] ... pointer to flite data
	and.w	#0xFF,d6
	add.w	d6,a0
	      ^^^^ TODO: review XX value
	lea	db_flv_cboss(pc),a1                	| [ld   de,#db_flv_cboss]
	move.b	d4,(a0)                         	| [ld   (hl),e]
	addq.b	#1,d6                           	| [inc  l]
	move.b	d3,(a0)                         	| [ld   (hl),d]

	clr.b	d0                               	| [xor  a]
	move.b	d0,ds_99B9_star_ctrl+0x01       	| [ld   (ds_99B9_star_ctrl + 0x01),a] 0
	addq.b	#1,d0                           	| [inc  a]
	move.b	d0,ds_cpu0_task_actv+0x11       	| [ld   (ds_cpu0_task_actv + 0x11),a] 1 (enable f_19B2 ... fighter captured)
	move.b	d0,ds5_928A_captr_status+0x04   	| [ld   (ds5_928A_captr_status + 0x04),a] 1 ... (fighter captured)
	rts                                    	| [ret]

l_231C:
	move.b	#0x40,d0                        	| [ld   a,#0x40] beam nearly got ship
	move.b	d0,ds5_928A_captr_status+0x02   	| [ld   (ds5_928A_captr_status + 0x02),a] 928C=928b=$40
	move.b	#0x40,d0                        	| [ld   a,#0x40] well this is inefficient ...!
	move.b	d0,ds5_928A_captr_status+0x01   	| [ld   (ds5_928A_captr_status + 0x01),a] 928C=928b=$40
	rts                                    	| [ret]

l_2327_shot_boss_while_capturing:
	move.b	#3,d0                           	| [ld   a,#3]
	move.b	d0,ds_plyr_actv+_b_captr_flag   	| [ld   (ds_plyr_actv +_b_captr_flag),a] 3 (shot_boss_while_capturing)
	move.b	#0x80,(a0)                      	| [ld   (hl),#0x80] HL == ds5_928A_captr_status + 0x01
	clr.b	d0                               	| [xor  a]
	move.b	d0,ds5_928A_captr_status+0x03   	| [ld   (ds5_928A_captr_status + 0x03),a] 0
	move.b	d0,ds_99B9_star_ctrl+0x01       	| [ld   (ds_99B9_star_ctrl + 0x01),a] 0
	addq.b	#1,d0                           	| [inc  a]
	move.b	d0,ds5_928A_captr_status+0x02   	| [ld   (ds5_928A_captr_status + 0x02),a] 1 ... shot_boss_while_capturing
	move.b	d0,ds_cpu0_task_actv+0x14       	| [ld   (ds_cpu0_task_actv + 0x14),a] 1  (f_1F85 ... control stick input)
	rts                                    	| [ret]

l_233D:
	move.b	ds5_928A_captr_status+0x01,d0   	| [ld   a,(ds5_928A_captr_status + 0x01)] if !$40 see 2323  (from 226E... beam just started)
	cmp.b	#0x40,d0                         	| [cp   #0x40]
	beq.b	0f                               	| [...]
	rts                                    	| [ret  nz] [...]
0:
* beam just about to grab ship
	move.b	b_9215_flip_screen,d0           	| [ld   a,(b_9215_flip_screen)]
	move.b	d0,d2                           	| [ld   c,a]
	move.b	ds_sprite_posn+0x62,d0          	| [ld   a,(ds_sprite_posn + 0x62)] ship (1) position
	btst.b	#0,d2                           	| [bit  0,c]
	jeq	l_2352                             	| [jr   z,l_2352]
	add.b	#0x0E,d0                         	| [add  a,#0x0E]
	neg.b	d0                               	| [neg]
l_2352:
	move.b	d0,d1                           	| [ld   b,a]
	move.b	ds5_928A_captr_status+0x00,d0   	| [ld   a,(ds5_928A_captr_status + 0x00)] beam is pulling the ship
	sub.b	d1,d0                            	| [sub  b]
	add.b	#0x1B,d0                         	| [add  a,#0x1B]
	cmp.b	#0x36,d0                         	| [cp   #0x36]
	bcs.b	0f                               	| [...]
	rts                                    	| [ret  nc] [...]
0:
* if ( game_state == ATTRACT_MODE ) goto 236d
	move.b	b8_9201_game_state,d0           	| [ld   a,(b8_9201_game_state)]  == ATTRACT_MODE
	subq.b	#1,d0                           	| [dec  a]
	jeq	l_236D                             	| [jr   z,l_236D]
* else if (  !  ( task_enabled  &&  !restart_stage )  return
	move.b	ds_cpu0_task_actv+0x14,d0       	| [ld   a,(ds_cpu0_task_actv + 0x14)] f_1D32 (Moves bug nest on and off the screen )
	move.b	d0,d2                           	| [ld   c,a]
	move.b	ds_9200_glbls+0x13,d0           	| [ld   a,(ds_9200_glbls + 0x13)]
	eor.b	#0x01,d0                         	| [xor  #0x01]
	and.b	d2,d0                            	| [and  c]
	bne.b	0f                               	| [...]
	rts                                    	| [ret  z] [...]
0:

l_236D:
	clr.b	d0                               	| [xor  a]
	move.b	d0,ds_cpu0_task_actv+0x14       	| [ld   (ds_cpu0_task_actv + 0x14),a] 0: f_1F85... control stick input
	move.b	d0,b_9AA0+0x05                  	| [ld   (b_9AA0 + 0x05),a] 0: sound-fx count/enable registers, capture beam sound active uno
	move.b	d0,ds_cpu1_task_actv+0x05       	| [ld   (ds_cpu1_task_actv + 0x05),a] 0 ... cpu1:f_05EE
	move.b	d0,ds_9200_glbls+0x13           	| [ld   (ds_9200_glbls + 0x13),a] 0
	addq.b	#1,d0                           	| [inc  a]
	move.b	d0,ds_cpu0_task_actv+0x1C       	| [ld   (ds_cpu0_task_actv + 0x1C),a] 1: f_20F2 ... tractor beam captures
	move.b	d0,b_9AA0+0x06                  	| [ld   (b_9AA0 + 0x06),a] 1 ... sound-fx count/enable registers, tractor beam
	move.b	d0,ds_99B9_star_ctrl+0x01       	| [ld   (ds_99B9_star_ctrl + 0x01),a] 1
	move.b	#0x0A,d0                        	| [ld   a,#0x0A]
	move.b	d0,ds_plyr_actv+_b_captr_flag   	| [ld   (ds_plyr_actv +_b_captr_flag),a] $0A ... tractor beam capturing ship
	rts                                    	| [ret]

*=============================================================================
* c_238A()
*  Description:
*   for f_2222
*   boss about to start tractor beam
* IN:
*   A==
* OUT:
*  ...
*-----------------------------------------------------------------------------
c_238A:
	move.b	d0,d2                           	| [ld   c,a]
	move.b	ds5_928A_captr_status+0x00,d0   	| [ld   a,(ds5_928A_captr_status + 0x00)] boss about to start tractor beam
	neg.b	d0                               	| [neg]
	add.b	#0x10,d0                         	| [add  a,#0x10]
	move.b	#0x20,d3                        	| [ld   d,#0x20]
	rol.b	#1,d0                            	| [rlca]
	roxl.b	#1,d3                           	| [rl   d]
      ^^^^^^ TODO: review cpu X flag
	rol.b	#1,d0                            	| [rlca]
	roxl.b	#1,d3                           	| [rl   d]
      ^^^^^^ TODO: review cpu X flag
	and.b	#0xE0,d0                         	| [and  #0xE0]
	add.b	#0x14,d0                         	| [add  a,#0x14]
	add.b	d2,d0                            	| [add  a,c]
	move.b	d0,d4                           	| [ld   e,a]
	rts                                    	| [ret]
* end 238A

*=============================================================================
* data for f_2222
* 6-bytes per entry, (table starts 6-bytes past the value ld'd to HL)
d_23A1:
	.byte 0x24,0x4E,0x4F,0x50,0x51,0x24,0x24,0x52,0x53,0x54
	.byte 0x55,0x24,0x24,0x56,0x57,0x58,0x59,0x24,0x24,0x5A,0x5B,0x5C,0x5D,0x24,0x24,0x5E
	.byte 0x5F,0x60,0x61,0x24,0x62,0x63,0x64,0x65,0x66,0x67,0x68,0x69,0x6A,0x6B,0x6C,0x6D
	.byte 0x6E,0x6F,0x70,0x71,0x72,0x73,0x74,0x75,0x76,0x77,0x78,0x79,0x7A,0x7B,0x7C,0x7D
	.byte 0x7E,0x7F

*=============================================================================
* f_23DD()
*  Description:
*   This task is never disabled.
*   Updates each object in obj_status[] and updates global count of active
*   objects.
*   Call here for f_1D32, but normally this is a periodic task called 60Hz.
*   Using bits <1:0> of framecounter as the state variable, 1 cycle of this
*   task is completed over four successive frames, i.e. the cycle is repeated
*   at a rate of 15Hz. Half of the objects are updated at each alternating odd
*   frame. On one even frame object count is updated.
*   The function body is broken out to a separate subroutine allowing the
*   frame count to be forced in A (needed for update at player changeover)
* IN:
*  ...
* OUT:
*  ...
*-----------------------------------------------------------------------------
f_23DD:
	move.b	ds3_92A0_frame_cts+0,d0         	| [ld   a,(ds3_92A0_frame_cts + 0)]

* c_23E0

*=============================================================================
* c_23E0()
*  Description:
*   Implementation of f_23DD()
*   See comments for f_23DD() above.
* IN:
*  A==_frame_counter
* OUT:
*  ...
*-----------------------------------------------------------------------------
c_23E0:
* check if even or odd frame
	btst.b	#0,d0                           	| [bit  0,a]
	jeq	l_2596_even_frame                  	| [jp   z,l_2596_even_frame]

* frame count bit-1 provides start index/offset of obj_status[], i.e. 0,4,8,etc.
* on frame 1 and 2,6,10,etc. on frame 3
	and.b	#0x02,d0                         	| [and  #0x02]
	move.b	d0,d4                           	| [ld   e,a] E==0 if frame 1, E==2 if frame 3

	move.b	b_bugs_actv_cnt,d0              	| [ld   a,(b_bugs_actv_cnt)]
ld   ixl,a                                 ; use as "local" variable for object counter

	move.b	#32,d1                          	| [ld   b,#32] size of object set / 2
l_23EF:
	lea	b_8800(pc),a1                      	| [ld   d,#>b_8800]
	and.w	#0xFF,d4
	add.w	d4,a1
	      ^^^^ TODO: review XX value
	move.b	(a1),d0                         	| [ld   a,(de)]
* test for $80 (inactive status)
	asl.b	#1,d0                            	| [sla  a] test for bit-7
	jcs	l_2416                             	| [jr   c,l_2416] DE+=4

	lea	d_23FF_jp_tbl(pc),a0               	| [ld   hl,#d_23FF_jp_tbl]
	jbsr	rst_10                            	| [rst  0x10] HL += A
	move.b	(a0),d0                         	| [ld   a,(hl)]
	addq.w	#1,a0                           	| [inc  hl]
	move.b	(a0),d5                         	| [ld   h,(hl)]
	move.b	d0,d6                           	| [ld   l,a]
	jra	(a0)                               	| [jp   (hl)]

d_23FF_jp_tbl:
	.long case_2416 | 80: inactive object (already tested for 0x80 so this .db is a placeholder)
	.long case_2488 | 01: assimilated into the collective and resting peacefully.
	.long case_245F | 02: rotating back into position in the collective
	.long case_254D | 03: state progression ... 7's to 3's, and then 9's, 2's, and finally 1's
	.long case_24B2 | 04: nearly fatally shot
	.long case_2535 | 05: showing a score bitmap for a bonus hit
	.long case_254D | 06  disable this one and the borg runs out of nukes
	.long case_2590 | 07: once for each orc as he is spawning (new stage)
	.long case_243C | 08: shot my damn ship (DE==8862 ... 8863 counts down from $0F for all steps of explosion)
	.long case_2422 | 09: ... after getting to the loop spot, or anytime on a diving attack.

l_2413:
	subq.b	#1,d4                           	| [dec  e] reset index/pointer to b0

l_2414_inc_active:
	addq.b	#1,ixl                          	| [inc  ixl] b_bugs_actv_cnt++

case_2416:
l_2416:
	move.b	#4,d0                           	| [ld   a,#4]
	add.b	d4,d0                            	| [add  a,e]
	move.b	d0,d4                           	| [ld   e,a] index += 4

	subq.b	#1,d1                           	| [...]
	jne	l_23EF                             	| [djnz l_23EF]

	move.b	#ixl,d0                         	| [ld  a,ixl] b_bugs_actv_cnt
	move.b	d0,b_bugs_actv_cnt              	| [ld  (b_bugs_actv_cnt),a]
	rts                                    	| [ret]

* 09: diving
case_2422:
	move.b	d4,d6                           	| [ld   l,e]
	lea	db_obj_home_posn_rc(pc),a0         	| [ld   h,#>db_obj_home_posn_rc]
	and.w	#0xFF,d6
	add.w	d6,a0
	      ^^^^ TODO: review XX value
	move.b	(a0),d2                         	| [ld   c,(hl)] row position index
	addq.b	#1,d6                           	| [inc  l]
	move.b	(a0),d6                         	| [ld   l,(hl)] column position index
	lea	ds_hpos_loc_offs(pc),a0            	| [ld   h,#>ds_hpos_loc_offs] .b0
	and.w	#0xFF,d6
	add.w	d6,a0
	      ^^^^ TODO: review XX value
	move.b	(a0),d0                         	| [ld   a,(hl)] X coordinate offset
	scs	d7                              	| [ex   af,af']
         ^^^ TODO review: wrong if carry is needed or D7 used in between!
	move.b	d2,d6                           	| [ld   l,c] row position index
	move.b	(a0),d2                         	| [ld   c,(hl)] Y coordinate offset

* get a pointer to corresponding element of bug_motion_que[] ... byte-offset (index) in 8800[n].b1
	addq.b	#1,d4                           	| [inc  e]
	move.b	(a1),d0                         	| [ld   a,(de)]
	add.b	#0x11,d0                         	| [add  a,#0x11] 0x11(ix)
	move.b	d0,d6                           	| [ld   l,a]
	lea	ds_bug_motion_que(pc),a0           	| [ld   h,#>ds_bug_motion_que]
	and.w	#0xFF,d6
	add.w	d6,a0
	      ^^^^ TODO: review XX value
	scs	d7                              	| [ex   af,af']
         ^^^ TODO review: wrong if carry is needed or D7 used in between!
	move.b	d0,(a0)                         	| [ld   (hl),a] X coordinate offset
	addq.b	#1,d6                           	| [inc  l] 0x12(ix)
	move.b	d2,(a0)                         	| [ld   (hl),c] y coordinate offset
	jra	l_2413                             	| [jp   l_2413] reset index to .b0 and continue

* 08: destruction of the ship
case_243C:
	lea	ds_sprite_code(pc),a0              	| [ld   h,#>ds_sprite_code]
	and.w	#0xFF,d6
	add.w	d6,a0
	      ^^^^ TODO: review XX value
	move.b	d4,d6                           	| [ld   l,e]
	addq.b	#1,d4                           	| [inc  e]
	move.b	(a1),d0                         	| [ld   a,(de)] obj_status[].mctl_q_index used for explosion counter
	subq.b	#1,d0                           	| [dec  a]
	jeq	l_2451                             	| [jr   z,l_2451] the counter (odd-byte) counts down to 0 (from $F) during explosion
	move.b	d0,(a1)                         	| [ld   (de),a]
	subq.b	#1,d4                           	| [dec  e]
	and.b	#0x03,d0                         	| [and  #0x03]
	jne	l_2416                             	| [jr   nz,l_2416]
	move.b	(a0),d0                         	| [ld   a,(hl)]
	addq.b	#4,d0                           	| [add  a,#4]
	move.b	d0,(a0)                         	| [ld   (hl),a]
	jra	l_2416                             	| [jp   l_2416]

l_2451:
	lea	ds_sprite_posn(pc),a0              	| [ld   h,#>ds_sprite_posn]
	and.w	#0xFF,d6
	add.w	d6,a0
	      ^^^^ TODO: review XX value
	clr.b	d0                               	| [xor  a]
	move.b	d0,(a0)                         	| [ld   (hl),a]
	lea	ds_sprite_ctrl(pc),a0              	| [ld   h,#>ds_sprite_ctrl]
	and.w	#0xFF,d6
	add.w	d6,a0
	      ^^^^ TODO: review XX value
	move.b	d0,(a0)                         	| [ld   (hl),a]
	subq.b	#1,d4                           	| [dec  e]
	move.b	#0x80,d0                        	| [ld   a,#0x80] set inactive code
	move.b	d0,(a1)                         	| [ld   (de),a]
	jra	l_2416                             	| [jp   l_2416]

* 02: reached home and rotating into resting position
case_245F:
	lea	ds_sprite_ctrl(pc),a0              	| [ld   h,#>ds_sprite_ctrl]
	and.w	#0xFF,d6
	add.w	d6,a0
	      ^^^^ TODO: review XX value
	move.b	d4,d6                           	| [ld   l,e]
	move.b	(a0),d0                         	| [ld   a,(hl)]
	and.b	#0x01,d0                         	| [and  #0x01] test flip X
	lea	ds_sprite_code(pc),a0              	| [ld   h,#>ds_sprite_code]
	and.w	#0xFF,d6
	add.w	d6,a0
	      ^^^^ TODO: review XX value
	jne	l_2473                             	| [jr   nz,l_2473]
	move.b	(a0),d0                         	| [ld   a,(hl)]
	and.b	#0x07,d0                         	| [and  #0x07]
	cmp.b	#6,d0                            	| [cp   #6]
	jeq	l_2483                             	| [jr   z,l_2483]
	addq.b	#1,(a0)                         	| [inc  (hl)]
	jra	l_249B                             	| [jr   l_249B]

l_2473:
	move.b	(a0),d0                         	| [ld   a,(hl)]
	and.b	#0x07,d0                         	| [and  #0x07]
	jne	l_2480                             	| [jr   nz,l_2480]
	lea	ds_sprite_ctrl(pc),a0              	| [ld   h,#>ds_sprite_ctrl]
	and.w	#0xFF,d6
	add.w	d6,a0
	      ^^^^ TODO: review XX value
	bclr.b	#0,(a0)                         	| [res  0,(hl)]
	lea	ds_sprite_code(pc),a0              	| [ld   h,#>ds_sprite_code] not used
	and.w	#0xFF,d6
	add.w	d6,a0
	      ^^^^ TODO: review XX value
	jra	l_249B                             	| [jr   l_249B]

l_2480:
	subq.b	#1,(a0)                         	| [dec  (hl)]
	jra	l_249B                             	| [jr   l_249B]

l_2483:
	move.b	#1,d0                           	| [ld   a,#1] disposition = 1: home
	move.b	d0,(a1)                         	| [ld   (de),a]
	jra	l_249B                             	| [jr   l_249B]

* 01: assimilated into the collective
case_2488:
	lea	ds_sprite_code(pc),a0              	| [ld   h,#>ds_sprite_code]
	and.w	#0xFF,d6
	add.w	d6,a0
	      ^^^^ TODO: review XX value
	move.b	d4,d6                           	| [ld   l,e]
* alternate between tile code 6 and 7 every 1/2 sec: rotate bit-1 of 4 Hz timer into Cy
* and then rl the Cy into bit-0 of sprite code
	move.b	ds3_92A0_frame_cts+2,d0         	| [ld   a,(ds3_92A0_frame_cts + 2)]
	ror.b	#1,(a0)                          	| [rrc  (hl)]
	ror.b	#2,d0                            	| [rrca] * 2
	roxl.b	#1,(a0)                         	| [rl   (hl)]
      ^^^^^^ TODO: review cpu X flag
	move.b	ds_9200_glbls+0x0B,d0           	| [ld   a,(ds_9200_glbls + 0x0B)] update stuff if enemy enable set
	                               	| [and  a]
	jeq	l_2414_inc_active                  	| [jp   z,l_2414_inc_active]

l_249B:
	lea	db_obj_home_posn_rc(pc),a0         	| [ld   h,#>db_obj_home_posn_rc]
	and.w	#0xFF,d6
	add.w	d6,a0
	      ^^^^ TODO: review XX value
	move.b	(a0),d2                         	| [ld   c,(hl)] row position index
	addq.b	#1,d6                           	| [inc  l]
	move.b	(a0),d6                         	| [ld   l,(hl)] column position index
	lea	ds_hpos_spcoords(pc),a0            	| [ld   h,#>ds_hpos_spcoords] L == offset to MSB
	and.w	#0xFF,d6
	add.w	d6,a0
	      ^^^^ TODO: review XX value
	move.b	(a0),d0                         	| [ld   a,(hl)]
	lea	ds_sprite_posn(pc),a1              	| [ld   d,#>ds_sprite_posn]
	and.w	#0xFF,d4
	add.w	d4,a1
	      ^^^^ TODO: review XX value
	move.b	d0,(a1)                         	| [ld   (de),a] X pix coordinate
	addq.b	#1,d4                           	| [inc  e]
	move.b	d2,d6                           	| [ld   l,c] row position index
	move.b	(a0),d0                         	| [ld   a,(hl)]
	move.b	d0,(a1)                         	| [ld   (de),a] Y pix coordinate
	lea	ds_sprite_ctrl(pc),a1              	| [ld   d,#>ds_sprite_ctrl] sprite.ctrl[n].sY (bit 8 into MSB)
	and.w	#0xFF,d4
	add.w	d4,a1
	      ^^^^ TODO: review XX value
	addq.b	#1,d6                           	| [inc  l]
	move.b	(a0),d0                         	| [ld   a,(hl)]
	move.b	d0,(a1)                         	| [ld   (de),a]
	jra	l_2413                             	| [jp   l_2413] reset index to .b0 and continue

* 04: rckt_hit_hdlr
case_24B2:
	move.b	d4,d6                           	| [ld   l,e]
	addq.b	#1,d4                           	| [inc  e] .b1
	move.b	(a1),d0                         	| [ld   a,(de)] b8800_obj_status[ E ].obj_idx (explosion count, see f_1DB3)
* if count == 45 then finish
	cmp.b	#0x45,d0                         	| [cp   #0x45]
	jeq	l_24E6_i_am_at_45                  	| [jr   z,l_24E6_i_am_at_45] set by f_1DB3
	addq.b	#1,d0                           	| [inc  a]
	move.b	d0,(a1)                         	| [ld   (de),a] 8800[odd]++ ... (40 -> 41, 42, 43, 44, 45 ) explosion changing
	subq.b	#1,d4                           	| [dec  e]
* if count == 44 then code = count + 3
	cmp.b	#0x45,d0                         	| [cp   #0x45]
	jne	l_24C2                             	| [jr   nz,l_24C2]
	addq.b	#3,d0                           	| [add  a,#3] end of explosion
l_24C2:
* if count < 44 then code = count
	cmp.b	#0x44,d0                         	| [cp   #0x44]
	jne	l_24E0                             	| [jr   nz,l_24E0]

* sprite.posn[ L ].b0 -= 8
	lea	ds_sprite_posn(pc),a0              	| [ld   h,#>ds_sprite_posn] .b0
	and.w	#0xFF,d6
	add.w	d6,a0
	      ^^^^ TODO: review XX value
	scs	d7                              	| [ex   af,af'] stash this till after the l_24DA
         ^^^ TODO review: wrong if carry is needed or D7 used in between!
	move.b	(a0),d0                         	| [ld   a,(hl)]
	sub.b	#8,d0                            	| [sub  #8]
	move.b	d0,(a0)                         	| [ld   (hl),a]

	addq.b	#1,d6                           	| [inc  l] .b1
	move.b	(a0),d0                         	| [ld   a,(hl)]
* subtract only in bits<7:0> then flip b9 on Cy
	sub.b	#8,d0                            	| [sub  #8]
	move.b	d0,(a0)                         	| [ld   (hl),a]
	jcc	l_24DA                             	| [jr   nc,l_24DA]
      ^^^^^^ TODO: review cpu flags (move.b,jcc)
	lea	ds_sprite_ctrl(pc),a0              	| [ld   h,#>ds_sprite_ctrl] killed boss that had the ship in the demo (not in game?)
	and.w	#0xFF,d6
	add.w	d6,a0
	      ^^^^ TODO: review XX value
	move.b	(a0),d0                         	| [ld   a,(hl)]
	eor.b	#0x01,d0                         	| [xor  #0x01]
	move.b	d0,(a0)                         	| [ld   (hl),a]

l_24DA:
	subq.b	#1,d6                           	| [dec  l] .b0
	lea	ds_sprite_ctrl(pc),a0              	| [ld   h,#>ds_sprite_ctrl]
	and.w	#0xFF,d6
	add.w	d6,a0
	      ^^^^ TODO: review XX value
	move.b	#0x0C,(a0)                      	| [ld   (hl),#0x0C]
	scs	d7                              	| [ex   af,af'] unstash A which is the count
         ^^^ TODO review: wrong if carry is needed or D7 used in between!
l_24E0:
	lea	ds_sprite_code(pc),a0              	| [ld   h,#>ds_sprite_code]
	and.w	#0xFF,d6
	add.w	d6,a0
	      ^^^^ TODO: review XX value
	move.b	d0,(a0)                         	| [ld   (hl),a]
	jra	l_2416                             	| [jp   l_2416]

l_24E6_i_am_at_45:
	subq.b	#1,d4                           	| [dec  e] restore pointer to .b0
	lea	b_9200_obj_collsn_notif(pc),a0     	| [ld   h,#>b_9200_obj_collsn_notif] 1?
	and.w	#0xFF,d6
	add.w	d6,a0
	      ^^^^ TODO: review XX value
	move.b	(a0),d0                         	| [ld   a,(hl)] .b0 ... stash the code for l_24FD
* if 1 ... (not special sprite code)
	cmp.b	#0x01,d0                         	| [cp   #0x01] hit-status register at 9200[i]==$01, unless it shows small score indicator
	jne	l_24FD                             	| [jr   nz,l_24FD]
* ... then ...
	lea	ds_sprite_posn(pc),a0              	| [ld   h,#>ds_sprite_posn]
	and.w	#0xFF,d6
	add.w	d6,a0
	      ^^^^ TODO: review XX value
	clr.b	(a0)                             	| [ld   (hl),#0]
	lea	ds_sprite_ctrl(pc),a0              	| [ld   h,#>ds_sprite_ctrl]
	and.w	#0xFF,d6
	add.w	d6,a0
	      ^^^^ TODO: review XX value
	clr.b	(a0)                             	| [ld   (hl),#0]
	lea	b_8800(pc),a0                      	| [ld   h,#>b_8800]
	and.w	#0xFF,d6
	add.w	d6,a0
	      ^^^^ TODO: review XX value
	move.b	#0x80,(a0)                      	| [ld   (hl),#0x80] $80 is code for inactive sprite
	jra	l_2416                             	| [jp   l_2416]

* Show the sprite with the small score text for shots that award bonus points:
*  Boss .. $35 (400)  $37 (800)  $3A (1600)  ... see d_1CFD
*  all 8 on bonus round are destroyed ($38 ... 1000 pts)----
*  all 3 bonus-bee destroyed  ($38 ... 1000 pts)
*  flying rogue ship (9202)..($38 .. 1000 pts)
l_24FD:
* code set at l_08B0 determines bonus text sprite code
	lea	ds_sprite_code(pc),a0              	| [ld   h,#>ds_sprite_code]
	and.w	#0xFF,d6
	add.w	d6,a0
	      ^^^^ TODO: review XX value
	move.b	d0,(a0)                         	| [ld   (hl),a] sprite_cclr[L].code = obj_collsn_notif[L]
	cmp.b	#0x37,d0                         	| [cp   #0x37] if code < 37, goto 250E
	jcs	l_250E                             	| [jr   c,l_250E]
	move.b	#0x0D,d2                        	| [ld   c,#0x0D] color
	addq.b	#1,d6                           	| [inc  l]
	cmp.b	#0x3A,d0                         	| [cp   #0x3A]
	jcs	l_250C                             	| [jr   c,l_250C] if code < 3A, goto 250C
	addq.b	#1,d2                           	| [inc  c] color++

l_250C:
	move.b	d2,(a0)                         	| [ld   (hl),c] sprite_cclr[L].clr=c
	subq.b	#1,d6                           	| [dec  l]
l_250E:
	lea	ds_sprite_posn(pc),a0              	| [ld   h,#>ds_sprite_posn]
	and.w	#0xFF,d6
	add.w	d6,a0
	      ^^^^ TODO: review XX value
	move.b	#8,d2                           	| [ld   c,#8]
	cmp.b	#0x3B,d0                         	| [cp   #0x3B]
	jcc	l_251C                             	| [jr   nc,l_251C] if code >= 3B, goto 251C
	clr.b	d2                               	| [ld   c,#0]
	move.b	(a0),d0                         	| [ld   a,(hl)]
	add.b	#8,d0                            	| [add  a,#8]
	move.b	d0,(a0)                         	| [ld   (hl),a]
l_251C:
	addq.b	#1,d6                           	| [inc  l]
	move.b	(a0),d0                         	| [ld   a,(hl)]
	add.b	#0x08,d0                         	| [add  a,#0x08]
	move.b	d0,(a0)                         	| [ld   (hl),a]
	lea	ds_sprite_ctrl(pc),a0              	| [ld   h,#>ds_sprite_ctrl]
	and.w	#0xFF,d6
	add.w	d6,a0
	      ^^^^ TODO: review XX value
* mrw_sprite.cclr[ L ].b1 ^= (0 != AF.pair.b1);
	jcc	l_2529                             	| [jr   nc,l_2529]
	move.b	(a0),d0                         	| [ld   a,(hl)]
	eor.b	#0x01,d0                         	| [xor  #0x01]
	move.b	d0,(a0)                         	| [ld   (hl),a]
l_2529:
	subq.b	#1,d6                           	| [dec  l]
	move.b	d2,(a0)                         	| [ld   (hl),c]
	lea	b_8800(pc),a0                      	| [ld   h,#>b_8800]
	and.w	#0xFF,d6
	add.w	d6,a0
	      ^^^^ TODO: review XX value
	move.b	#5,(a0)                         	| [ld   (hl),#5] state 05 (showing score bitmap)
	addq.b	#1,d6                           	| [inc  l]
	move.b	#0x13,(a0)                      	| [ld   (hl),#0x13] down counter for score bitmap
	jra	l_2416                             	| [jp   l_2416]

* 05: shot boss, showing the score bitmap
case_2535:
* pointer to b8800_obj_status[ L ] from DE
* b8800_obj_status[ L ].obj_idx-- ... count for score bitmap
	move.b	d4,d6                           	| [ld   l,e]
	addq.b	#1,d6                           	| [inc  l]
	move.b	d3,d5                           	| [ld   h,d]
	subq.b	#1,(a0)                         	| [dec  (hl)] down counter for score bitmap
	jne	l_2416                             	| [jp   nz,l_2416]

	subq.b	#1,d6                           	| [dec  l]
	move.b	#0x80,(a0)                      	| [ld   (hl),#0x80] disposition = inactive
	lea	ds_sprite_posn(pc),a0              	| [ld   h,#>ds_sprite_posn]
	and.w	#0xFF,d6
	add.w	d6,a0
	      ^^^^ TODO: review XX value
	clr.b	(a0)                             	| [ld   (hl),#0]
	lea	ds_sprite_ctrl(pc),a0              	| [ld   h,#>ds_sprite_ctrl]
	and.w	#0xFF,d6
	add.w	d6,a0
	      ^^^^ TODO: review XX value
	clr.b	(a0)                             	| [ld   (hl),#0]
* hmmm seems like we already done this ...
	move.b	#0x80,d0                        	| [ld   a,#0x80]
	move.b	d0,(a1)                         	| [ld   (de),a]
	jra	l_2416                             	| [jp   l_2416]

* 3 or 6: terminate cylons or bombs that have gone past the sides or bottom of screen
case_254D:
	lea	ds_sprite_posn(pc),a0              	| [ld   h,#>ds_sprite_posn] read directly from SFRs (not buffer RAM)
	and.w	#0xFF,d6
	add.w	d6,a0
	      ^^^^ TODO: review XX value
	move.b	d4,d6                           	| [ld   l,e] object offset
	bset.b	#7,d6                           	| [set  7,l] +=$80 ... set pointer to read directly from the SFR
	move.b	(a0),d0                         	| [ld   a,(hl)]
	cmp.b	#0xF4,d0                         	| [cp   #0xF4]
* if (posn.x > $F4) ... skip check Y
	jcc	l_2571                             	| [jr   nc,l_2571]
	addq.b	#1,d6                           	| [inc  l]
	move.b	(a0),d2                         	| [ld   c,(hl)] sprite_posn.y<0:7>
	lea	ds_sprite_ctrl(pc),a0              	| [ld   h,#>ds_sprite_ctrl]
	and.w	#0xFF,d6
	add.w	d6,a0
	      ^^^^ TODO: review XX value
	move.b	(a0),d0                         	| [ld   a,(hl)] sprite_posn.y<8>
	subq.b	#1,d6                           	| [dec  l]
	ror.b	#1,d0                            	| [rrca] sprite_posn.y<8> into Cy
	move.b	d2,d0                           	| [ld   a,c]
	roxr.b	#1,d0                           	| [rra] sprite_posn.y<8:1> in A
      ^^^^^^ TODO: review cpu X flag
cp   #22 >> 1                              ; 0x0B
	jcs	l_2571                             	| [jr   c,l_2571]
cp   #330 >> 1                             ; 0xA5
	jcc	l_2571                             	| [jr   nc,l_2571]

* in range ... if not a bomb then go increment count
	move.b	(a1),d0                         	| [ld   a,(de)] b_8800[e].obj_status
	cmp.b	#6,d0                            	| [cp   #6]
	jne	l_2414_inc_active                  	| [jp   nz,l_2414_inc_active] if not a bomb
	jra	l_2416                             	| [jp   l_2416] it's a bomb

l_2571:
	bclr.b	#7,d6                           	| [res  7,l]
	move.b	(a1),d0                         	| [ld   a,(de)]
	cmp.b	#3,d0                            	| [cp   #3] check if flying bug object
	jeq	l_2582_kill_bug_q_slot             	| [jr   z,l_2582_kill_bug_q_slot] if bug object

l_2578_mk_obj_inactive:
	move.b	#0x80,d0                        	| [ld   a,#0x80]
	move.b	d0,(a1)                         	| [ld   (de),a]
	lea	ds_sprite_posn(pc),a0              	| [ld   h,#>ds_sprite_posn]
	and.w	#0xFF,d6
	add.w	d6,a0
	      ^^^^ TODO: review XX value
	clr.b	(a0)                             	| [ld   (hl),#0]
	jra	l_2416                             	| [jp   l_2416]

l_2582_kill_bug_q_slot:
	addq.b	#1,d4                           	| [inc  e]
	move.b	(a1),d0                         	| [ld   a,(de)] b_8800[e].motion_q_idx
	subq.b	#1,d4                           	| [dec  e]
	add.b	#0x13,d0                         	| [add  a,#0x13]
	move.b	d0,d6                           	| [ld   l,a]
	lea	ds_bug_motion_que(pc),a0           	| [ld   h,#>ds_bug_motion_que]
	and.w	#0xFF,d6
	add.w	d6,a0
	      ^^^^ TODO: review XX value
	clr.b	(a0)                             	| [ld   (hl),#0] e.g. "0x13(ix)"
	move.b	d4,d6                           	| [ld   l,e]
	jra	l_2578_mk_obj_inactive             	| [jp   l_2578_mk_obj_inactive]

* 07: once for each orc as he is spawning (new stage)
case_2590:
	move.b	#3,d0                           	| [ld   a,#3]
	move.b	d0,(a1)                         	| [ld   (de),a] disposition = 3 ... from 7 (spawning)
	jra	l_2414_inc_active                  	| [jp   l_2414_inc_active]

l_2596_even_frame:
* if ( framect & 0x02 ) ...
	btst.b	#1,d0                           	| [bit  1,a] frame_count
	bne.b	0f                               	| [...]
	rts                                    	| [ret  z] [...]
0:
* ... update object_count
	lea	b_bugs_actv_cnt(pc),a0             	| [ld   hl,#b_bugs_actv_cnt] store active_objects_nbr and clear the object count
	move.b	(a0),d0                         	| [ld   a,(hl)]
	clr.b	(a0)                             	| [ld   (hl),#0]
	addq.b	#1,d6                           	| [inc  l]
	move.b	d0,(a0)                         	| [ld   (hl),a] b_bugs_actv_nbr = bugs_actv_cnt

	rts                                    	| [ret]

*=============================================================================
* void gctl_stg_new_atk_wavs_init()
*  Description:
*   Setup the mob to do its evil work. Builds up 5 configuration tables at
*   b_8920 which organizes the mob objects into the flying waves.
*   These are formed into the attack wave queue structures by f_2916().
*   The format is oriented toward having two flights of 4 creatures in each
*   wave, so they are configured in pairs and I refer to as "lefty" and "righty"
*   in each pair, although it is an arbitrary designation. In waves that fly
*   in a single trailing formation, they are still treated as pairs, but the
*   timing has to be managed to maintain uniform spacing. so there is
*   an additional flag in the control data byte of the lefty that causes a
*   delay before the entry of each righty.
* IN:
*  ...
* OUT:
*  ...
*-----------------------------------------------------------------------------
c_25A2:
	lea	db_attk_wav_IDs(pc),a0             	| [ld   hl,#db_attk_wav_IDs]
	move.b	a0,pb_attk_wav_IDs              	| [ld   (pb_attk_wav_IDs),hl]

* calculate pointer into data table:
*  set A as offset into table using stage count,
*  set DE as base pointer to data, either combat data or challenge stage data

* if past the highest stage ($17) we can only keep playing the last 4 levels
	move.b	ds_plyr_actv+_b_stgctr,d0       	| [ld   a,(ds_plyr_actv +_b_stgctr)] stage build caravan tables
	move.b	d0,d2                           	| [ld   c,a] stash it for is_challg_stg

* while ( A > $17 ) ...
l_25AC_while:
	cmp.b	#0x17,d0                         	| [cp   #0x17] 23 - ( 23 % 4 ) - 1 == 17 ... nbr of level indices
	jcs	l_25B4                             	| [jr   c,l_25B4]
* ... do ...
	subq.b	#4,d0                           	| [sub  #4]
	jra	l_25AC_while                       	| [jr   l_25AC_while]

* if ( ! challenge stage ) ...
l_25B4:
	move.b	d0,d1                           	| [ld   b,a] adjusted level
	addq.b	#1,d0                           	| [inc  a]
	and.b	#0x03,d0                         	| [and  #0x03]
	jeq	l_25D3_is_challg_stg               	| [jr   z,l_25D3_is_challg_stg]

* ... then ...
* HL = &idx_tbl[ rank * 17 ][ 0 ] ... select index table row, by rank
	move.b	b_mchn_cfg_rank,d0              	| [ld   a,(b_mchn_cfg_rank)]
	move.b	#17,d6                          	| [ld   l,#17]
	jbsr	c_104E_mul_16_8                   	| [call c_104E_mul_16_8] L = rank * 17
	move.b	d6,d0                           	| [ld   a,l]
	lea	d_combat_stg_dat_idx(pc),a0        	| [ld   hl,#d_combat_stg_dat_idx]
	jbsr	rst_10                            	| [rst  0x10] HL += A

	lea	d_combat_stg_dat(pc),a1            	| [ld   de,#d_combat_stg_dat] base data ptr

* set offset into index table @row ... index = level - ( level % 4 ) - 1
	move.b	d1,d0                           	| [ld   a,b] adjusted level
	lsr.b	#2,d1                            	| [srl  b] 2 shifts and the sub ... %4 * 2
	sub.b	d1,d0                            	| [sub  b]
	subq.b	#1,d0                           	| [dec  a]
	jra	l_25E0_set_data_ptr                	| [jr   l_25E0_set_data_ptr]

* base ptr for challenge stg ... only 1 index table to work with (no rank selection) e.g.
*  ptr = d_idx[ stage / 4  &  $07 ]
l_25D3_is_challg_stg:
	lea	d_challg_stg_data_idx(pc),a0       	| [ld   hl,#d_challg_stg_data_idx]
	move.b	d2,d0                           	| [ld   a,c] stage_counter
	lsr.b	#2,d0                            	| [srl  a] * 2
	and.b	#0x07,d0                         	| [and  #0x07] 8 elements in index table
	lea	d_challg_stg_dat(pc),a1            	| [ld   de,#d_challg_stg_dat] base data ptr


l_25E0_set_data_ptr:

* HL == stg_data_idx + row * 17 ... where row is rank
* A  == offset into stg data idx
* DE == &_stg_dat[0]

* p_data_tabl_row = &data_tbl[ data_row_offset ]
	jbsr	rst_10                            	| [rst  0x10] HL += A
	move.b	(a0),d0                         	| [ld   a,(hl)] A = data_row_offset = idx_tbl[ A ]
	exg	a1,a0                              	| [ex   de,hl] HL = _stg_dat[0]
	jbsr	rst_10                            	| [rst  0x10] HL += A

* First, load bomb-control params from the 2 byte header (once per stage).

* stg_parm_0E[ 0 ] = _stg_dat[row][0]
	move.b	(a0),d0                         	| [ld   a,(hl)]
	addq.w	#1,a0                           	| [inc  hl]
	move.b	d0,b_92E2+0x00                  	| [ld   (b_92E2 + 0x00),a] _stg_dat[0]
* stg_parm_0F[ 1 ] = _stg_dat[row][1]
	move.b	(a0),d0                         	| [ld   a,(hl)]
	addq.w	#1,a0                           	| [inc  hl]
	move.b	d0,b_92E2+0x01                  	| [ld   (b_92E2 + 0x01),a] _stg_dat[1] ... loaded to 0x0f(ix)

* Initialize table of attack-wave structs with start token of 1st group
	lea	ds_8920(pc),a1                     	| [ld   de,#ds_8920] attk_waves[n] = $7E
	move.b	#0x7E,d0                        	| [ld   a,#0x7E] start token of each group
	move.b	d0,(a1)                         	| [ld   (de),a]
	addq.b	#1,d4                           	| [inc  e]

* The 2-byte header is followed by a series of 8 structs of 3-bytes each
* which establish the parameters of each attack wave. The first of 3-bytes
* determines the presence of "transients" in the attack wave (and is
* the control variable for the following while() block)

l_25F5_while_not_end_stg_dat:

* while ( 0xFF != _stg_dat[n] )
	move.b	(a0),d0                         	| [ld   a,(hl)] A = _stg_dat[ 2 + 3 * n ]
	addq.w	#1,a0                           	| [inc  hl] HL = &_stg_dat + 2 + 3 * n + 1
	cmp.b	#0xFF,d0                         	| [cp   #0xFF] check for end token, stage data
	jeq	l_2681_end_of_table                	| [jp   z,l_2681_end_of_table]

	move.b	d0,d2                           	| [ld   c,a] A = _stg_dat[ 2 + 3 * n ]
	movem.w	d3/d4,-(sp)                    	| [push de] DE == &ds_8920[e]
	move.l	a1,-(sp)                        	| [push de] DE == &ds_8920[e]

	move.l	a0,-(sp)                        	| [push hl] HL == &_stg_dat[ 2 + 3 * n + 1 ]

* memset(tmp_buf, $ff, 16)
	lea	ds_atk_wav_tmp_buf(pc),a0          	| [ld   hl,#ds_atk_wav_tmp_buf] memset(..., $ff, $10) ...tmp array for assembling object IDs for each wave
	st.b	d0                                	| [ld   a,#0xFF]
	move.b	#0x10,d1                        	| [ld   b,#0x10]
	jbsr	rst_18                            	| [rst  0x18] memset((HL), A=fill, B=ct)

* if ( 0 != ( _stg_dat[ 2 + 3 * n + 0 ] ) & 0x0F ) ...
	move.b	d2,d0                           	| [ld   a,c] A = _stg_dat[ 2 + 3 * n + 0 ]
	and.b	#0x0F,d0                         	| [and  #0x0F]
	jeq	l_2636                             	| [jr   z,l_2636]

* ... then ...
	move.b	d0,d1                           	| [ld   b,a] sets the loop count ... after first bonus-round
	lsr.b	#1,d0                            	| [srl  a]
	addq.b	#4,d0                           	| [add  a,#4]
	move.b	d0,d4                           	| [ld   e,a]
l_2612:
j_2612:
	jbsr	c_1000                            	| [call c_1000] randomizer
	move.b	d0,d6                           	| [ld   l,a]
	clr.b	d5                               	| [ld   h,#0]
	move.b	d4,d0                           	| [ld   a,e]
	jbsr	c_divmod                          	| [call c_divmod] HL=HL/E
	btst.b	#0,d1                           	| [bit  0,b]
	jeq	l_2622                             	| [jr   z,l_2622]
	bset.b	#3,d0                           	| [set  3,a]
l_2622:
	lea	ds_atk_wav_tmp_buf(pc),a0          	| [ld   h,#>ds_atk_wav_tmp_buf] tmp_buf[ A ]
	and.w	#0xFF,d6
	add.w	d6,a0
	      ^^^^ TODO: review XX value
	move.b	d0,d6                           	| [ld   l,a]
	move.b	(a0),d0                         	| [ld   a,(hl)]
	addq.b	#1,d0                           	| [inc  a]
	jne	j_2612                             	| [jr   nz,j_2612]
	move.b	d1,d0                           	| [ld   a,b]
	rol.b	#1,d0                            	| [rlca]
	rol.b	#1,d2                            	| [rlc  c]
	jcc	l_2631                             	| [jr   nc,l_2631]
	or.b	#0x40,d0                          	| [or   #0x40]
l_2631:
	or.b	#0x38,d0                          	| [or   #0x38]
	move.b	d0,(a0)                         	| [ld   (hl),a]
	subq.b	#1,d1                           	| [...]
	jne	l_2612                             	| [djnz l_2612]


* Insert the 8 non-transient bugs into the temporary attack wave (object IDs of
* bugs that have a final home positions).... $FFs remain in unused slots, e.g.
*   0x58,0x5A,0x5C,0x5E,0xFF,0xFF,0xFF,0xFF,0x28,0x2A,0x2C,0x2E,0xFF,0xFF,0xFF,0xFF,

l_2636:
	lea	ds_atk_wav_tmp_buf(pc),a0          	| [ld   hl,#ds_atk_wav_tmp_buf]
	move.w	pb_attk_wav_IDs(pc),a1          	| [ld   de,(pb_attk_wav_IDs)]
                  ^^^^^^ TODO: review move.w into address register
	move.b	#8,d1                           	| [ld   b,#8]

l_263F_while_b:
j_263F_skip_until_ff:
	move.b	(a0),d0                         	| [ld   a,(hl)]
	cmp.b	#0xFF,d0                         	| [cp   #0xFF] check for unused position in tmp buffer
	jeq	l_2647_is_ff                       	| [jr   z,l_2647_is_ff]
	addq.w	#1,a0                           	| [inc  hl] skip if not $ff
	jra	j_263F_skip_until_ff               	| [jr   j_263F_skip_until_ff]

l_2647_is_ff:
	move.b	(a1),d0                         	| [ld   a,(de)] attk_wav_IDs[e]
	move.b	d0,(a0)                         	| [ld   (hl),a] atk_wav_tmp_buf[l] = attk_wav_IDs[e]
	addq.w	#1,a1                           	| [inc  de]
	addq.w	#1,a0                           	| [inc  hl]
	move.b	d1,d0                           	| [ld   a,b] loop count
	cmp.b	#5,d0                            	| [cp   #5]
	jne	l_2652                             	| [jr   nz,l_2652] if ct > 4 ... skip to atk_wav_tmp_buf[ l + 8 ]
	move.b	#8,d6                           	| [ld   l,#8] alignment to $0100 boundary!
l_2652:
	subq.b	#1,d1                           	| [...]
	jne	l_263F_while_b                     	| [djnz l_263F_while_b]

	move.b	a1,pb_attk_wav_IDs              	| [ld   (pb_attk_wav_IDs),de] &db_attk_wav_IDs[ 8 * n ]

	move.l	(sp)+,a0                        	| [pop  hl] HL == &_stg_dat[ 2 + 3 * n + 1 ]
	move.l	(sp)+,a1                        	| [pop  de] DE == &ds_8920[ $11 * n ]
	movem.w	(sp)+,d3/d4                    	| [pop  de] DE == &ds_8920[ $11 * n ]
	move.b	(a0),d1                         	| [ld   b,(hl)]
	addq.w	#1,a0                           	| [inc  hl]
	move.b	(a0),d2                         	| [ld   c,(hl)] HL == &_stg_dat[ 2 + 3 * n + 2 ]
	addq.w	#1,a0                           	| [inc  hl]

	move.l	a0,-(sp)                        	| [push hl] HL == &_stg_dat[ 2 + 3 * n + 0 ] ... next n

* tmp buffer looks like this with transients inserted at 'x' ...  UUUUxxxxVVVVxxxx
* where U and V are IDs loaded from db_attk_wav_IDs (UUUUVVVV)
* Loop X times to copy each pair of "lefty" and "righty" object IDs i.e. " bb uu cc vv"
* ... where B and C are used to select the bug motion depending whether he is a "lefty" or a "righty".
	lea	ds_atk_wav_tmp_buf(pc),a0          	| [ld   hl,#ds_atk_wav_tmp_buf]
l_2662_form_pair:
	move.b	d1,d0                           	| [ld   a,b] bb
	move.b	d0,(a1)                         	| [ld   (de),a]
* read_until_ff
	move.b	(a0),d0                         	| [ld   a,(hl)] UU
	cmp.b	#0xFF,d0                         	| [cp   #0xFF]
	jeq	l_2679_next_wave                   	| [jr   z,l_2679_next_wave]

	addq.b	#1,d4                           	| [inc  e]
	move.b	d0,(a1)                         	| [ld   (de),a]
	addq.b	#1,d4                           	| [inc  e]
	move.b	d2,d0                           	| [ld   a,c] cc
	move.b	d0,(a1)                         	| [ld   (de),a]
	addq.b	#1,d4                           	| [inc  e]
	bset.b	#3,d6                           	| [set  3,l] HL += $08
	move.b	(a0),d0                         	| [ld   a,(hl)] VV
	move.b	d0,(a1)                         	| [ld   (de),a]
	addq.b	#1,d4                           	| [inc  e]
	bclr.b	#3,d6                           	| [res  3,l] HL -= $08
	addq.w	#1,a0                           	| [inc  hl]
	jra	l_2662_form_pair                   	| [jr   l_2662_form_pair]

l_2679_next_wave:
	move.b	#0x7E,d0                        	| [ld   a,#0x7E] start token of each group (will overwrite with 7f if finished)
	move.b	d0,(a1)                         	| [ld   (de),a]
	addq.b	#1,d4                           	| [inc  e] DE = &ds_8920[ $11 * n + 1 ]
	move.l	(sp)+,a0                        	| [pop  hl] &_stg_dat[ 2 + 3 * n + 0 ]
	jra	l_25F5_while_not_end_stg_dat       	| [jp   l_25F5_while_not_end_stg_dat]


l_2681_end_of_table:
* pointer is already advanced, so decrement it so we overwrite the 7E with 7F
	subq.b	#1,d4                           	| [dec  e]

* check capture-mode and two-ship status
	move.b	ds_plyr_actv+_b_bmbr_boss_cflag,d0	| [ld   a,(ds_plyr_actv +_b_bmbr_boss_cflag)] 1 if capture-mode is active
	move.b	d0,d1                           	| [ld   b,a]
	move.b	ds_plyr_actv+_b_2ship,d0        	| [ld   a,(ds_plyr_actv +_b_2ship)]
	subq.b	#1,d0                           	| [dec  a]
	and.b	d1,d0                            	| [and  b]
	jeq	l_26A4_done                        	| [jr   z,l_26A4_done]
* !capture-mode and !two-ship-status... we have a rogue fighter in the mob.
	move.b	ds_plyr_actv+_b_not_chllg_stg,d0	| [ld   a,(ds_plyr_actv +_b_not_chllg_stg)] ==(stg_ctr+1)%4 ...i.e. 0 if challenge stage
	                               	| [and  a]
	jeq	l_26A4_done                        	| [jr   z,l_26A4_done] doesn't matter on a challenge stage.

* HL = DE-4 ... e.g. 8975-4==8971
	move.b	d3,d5                           	| [ld   h,d]
	move.b	d4,d0                           	| [ld   a,e]
	subq.b	#4,d0                           	| [sub  #4]
	move.b	d0,d6                           	| [ld   l,a]

	move.b	(a0),d0                         	| [ld   a,(hl)]
	move.b	d0,(a1)                         	| [ld   (de),a]
	addq.b	#1,d4                           	| [inc  e] e.g. DE = 8976
	move.b	#4,d0                           	| [ld   a,#4]
	move.b	d0,(a1)                         	| [ld   (de),a]
	addq.b	#1,d4                           	| [inc  e]
	move.b	#0x80+0x07,d0                   	| [ld   a,#0x80 + 0x07]
	move.b	d0,ds_sprite_code+0x04          	| [ld   (ds_sprite_code + 0x04),a] = $80 + $07

l_26A4_done:
	move.b	#0x7F,d0                        	| [ld   a,#0x7F] end token marker
	move.b	d0,(a1)                         	| [ld   (de),a] ($8920 + $11*5)

	rts                                    	| [ret]


*=============================================================================
* data for c_25A2
*-----------------------------------------------------------------------------

* Selection indices for stage data ... pre-computed multiples of 18 for row offsets.

* combat levels, e.g. 1,2,5,6,7,9 etc.
* 4 sets... 1 for each rank "B", "C", "D", or "A"
* In each set, one element per stage, i.e. 17 distinct stage configurations (see l_25AC)
* Indices are pre-multiplied (multiples of 0x12, i.e. row length of combat__stg_data)

d_combat_stg_dat_idx:
	.byte 0x00,0x12,0x24,0x36,0x00,0x48,0x6C,0x5A,0x48,0x6C,0x00,0x7E,0xA2,0x90,0xB4,0xD8,0xC6
	.byte 0x00,0x12,0x48,0x6C,0x5A,0x7E,0xA2,0x00,0x7E,0xD8,0xC6,0xB4,0xD8,0xC6,0xB4,0xD8,0xC6
	.byte 0x00,0x12,0x7E,0xA2,0x90,0x7E,0xD8,0xC6,0xB4,0xD8,0xC6,0xB4,0xD8,0xC6,0xB4,0xD8,0xC6
	.byte 0x00,0x12,0x48,0x36,0x24,0x48,0x6C,0x00,0x7E,0xA2,0x90,0xB4,0xD8,0x00,0xB4,0xD8,0xC6

* challenge stage e.g. 3,8,10 etc. 8 unique challenge stages.
d_challg_stg_data_idx:
	.byte 0x00,0x12,0x24,0x36,0x48,0x5A,0x6C,0x7E


* Stage data: each row is 1 level ... 5 waves of bug formations per level

* 2 byte header: ?
* one triplet of bytes for each of the 5 waves:
* byte 0:
*   c_25A2, controls loading of transients into attack wave table
* byte 1 & 2
*   bit 7     byte-2 only ... if clear, 2nd bug of pair is delayed for trailing formation
*   bit 6     if set selects second set of 3-bytes in db_2A6C[]
*   bits 0:5  index of word in LUT at db_2A3C ( 0x18 entries)
*   bit 0     also, if set,0e(ix) = 0x44 ... finalize_object

* combat stage data
d_combat_stg_dat:
	.byte 0x14,0x00, 0x00,0x00,0x40+0x80, 0x00,0x01,0x01+0x00, 0x00,0x41,0x41+0x00, 0x00,0x40,0x40+0x00, 0x00,0x00,0x00+0x00, 0xFF
	.byte 0x14,0x01, 0x00,0x42,0x02+0x80, 0x00,0x03,0x05+0x80, 0x00,0x43,0x45+0x80, 0x00,0x42,0x44+0x80, 0x00,0x02,0x04+0x80, 0xFF
	.byte 0x14,0x01, 0x82,0x00,0x40+0x80, 0x00,0x01,0x01+0x00, 0x00,0x41,0x41+0x00, 0x02,0x40,0x40+0x00, 0x02,0x00,0x00+0x00, 0xFF
	.byte 0x14,0x01, 0x82,0x02,0x42+0x80, 0x00,0x03,0x05+0x80, 0x00,0x43,0x45+0x80, 0x02,0x42,0x44+0x80, 0x02,0x02,0x04+0x80, 0xFF
	.byte 0x14,0x01, 0x82,0x00,0x40+0x80, 0x00,0x01,0x41+0x80, 0x00,0x41,0x01+0x80, 0x02,0x40,0x00+0x80, 0x02,0x40,0x00+0x80, 0xFF
	.byte 0x14,0x01, 0x82,0x00,0x40+0x80, 0x42,0x01,0x01+0x00, 0xF2,0x41,0x41+0x00, 0x02,0x40,0x40+0x00, 0x02,0x00,0x00+0x00, 0xFF
	.byte 0x14,0x01, 0xA4,0x02,0x42+0x80, 0x52,0x03,0x05+0x80, 0xF2,0x43,0x45+0x80, 0x02,0x42,0x44+0x80, 0x02,0x02,0x04+0x80, 0xFF
	.byte 0x14,0x01, 0x82,0x00,0x40+0x80, 0x52,0x01,0x41+0x80, 0xF2,0x41,0x01+0x80, 0x02,0x40,0x00+0x80, 0x02,0x40,0x00+0x80, 0xFF
	.byte 0x14,0x01, 0xA4,0x00,0x40+0x80, 0x42,0x01,0x01+0x00, 0xF4,0x41,0x41+0x00, 0x04,0x40,0x40+0x00, 0x04,0x00,0x00+0x00, 0xFF
	.byte 0x14,0x01, 0xA4,0x02,0x42+0x80, 0x52,0x03,0x05+0x80, 0xF4,0x43,0x45+0x80, 0x04,0x42,0x44+0x80, 0x04,0x02,0x04+0x80, 0xFF
	.byte 0x14,0x03, 0xA4,0x00,0x40+0x80, 0x54,0x01,0x41+0x80, 0xF4,0x41,0x01+0x80, 0x04,0x40,0x00+0x80, 0x04,0x40,0x00+0x80, 0xFF
	.byte 0x14,0x03, 0xA4,0x00,0x40+0x80, 0x54,0x01,0x01+0x00, 0xF4,0x41,0x41+0x00, 0x04,0x40,0x40+0x00, 0x04,0x00,0x00+0x00, 0xFF
	.byte 0x14,0x03, 0xA4,0x02,0x42+0x80, 0x54,0x03,0x05+0x80, 0xF4,0x43,0x45+0x80, 0x04,0x42,0x44+0x80, 0x04,0x02,0x04+0x80, 0xFF

* challenge stage data
d_challg_stg_dat:
	.byte 0xFF,0x00, 0x00,0x06,0x46+0x80, 0x00,0x07,0x07+0x00, 0x00,0x47,0x47+0x00, 0x00,0x46,0x46+0x00, 0x00,0x06,0x06+0x00, 0xFF
	.byte 0xFF,0x00, 0x00,0x08,0x48+0x80, 0x00,0x09,0x49+0x80, 0x00,0x09,0x49+0x80, 0x00,0x48,0x48+0x00, 0x00,0x08,0x08+0x00, 0xFF
	.byte 0xFF,0x00, 0x00,0x0A,0x4A+0x00, 0x00,0x0B,0x4B+0x80, 0x00,0x0B,0x4B+0x80, 0x00,0x0A,0x4A+0x00, 0x00,0x16,0x56+0x00, 0xFF
	.byte 0xFF,0x00, 0x00,0x0C,0x4C+0x80, 0x00,0x0D,0x0D+0x00, 0x00,0x4D,0x4D+0x00, 0x00,0x0C,0x4C+0x80, 0x00,0x17,0x57+0x80, 0xFF
	.byte 0xFF,0x00, 0x00,0x0E,0x0E+0x00, 0x00,0x0F,0x0F+0x00, 0x00,0x4F,0x4F+0x00, 0x00,0x0E,0x0E+0x00, 0x00,0x4E,0x4E+0x00, 0xFF
	.byte 0xFF,0x00, 0x00,0x10,0x10+0x00, 0x00,0x11,0x51+0x80, 0x00,0x11,0x51+0x80, 0x00,0x50,0x50+0x00, 0x00,0x10,0x10+0x00, 0xFF
	.byte 0xFF,0x00, 0x00,0x12,0x12+0x00, 0x00,0x13,0x13+0x00, 0x00,0x53,0x53+0x00, 0x00,0x52,0x52+0x00, 0x00,0x12,0x12+0x00, 0xFF
	.byte 0xFF,0x00, 0x00,0x14,0x54+0x80, 0x00,0x15,0x15+0x00, 0x00,0x55,0x55+0x00, 0x00,0x14,0x54+0x80, 0x00,0x14,0x54+0x80, 0xFF


* This is a table of object IDs which organizes the mob into the series of 5 waves.
db_attk_wav_IDs:
	.byte 0x58,0x5A,0x5C,0x5E,0x28,0x2A,0x2C,0x2E
	.byte 0x30,0x34,0x36,0x32,0x50,0x52,0x54,0x56
	.byte 0x42,0x46,0x40,0x44,0x4A,0x4E,0x48,0x4C
	.byte 0x1A,0x1E,0x20,0x24,0x22,0x26,0x18,0x1C
	.byte 0x08,0x0C,0x12,0x16,0x10,0x14,0x0A,0x0E


*=============================================================================
* c_2896()
*  Description:
*   stg_init_env
*   Called at beginning of each stage, including challenge stages and demo.
*   Initializes mrw_sprite[n].cclr.b0 for 3 sets of creatures. Color code is
*   packed into b<0:2>, and bomb-drop parameter packed into b<7>
*   Load attributes for challenge stage hit-8 bonus.
*
*   Default sprite code configuration:
*
*    00 00 00 00 00 00 00 00 18 00 18 00 18 00 18 00
*    18 00 18 00 18 00 18 00 18 00 18 00 18 00 18 00
*    18 00 18 00 18 00 18 00 18 00 18 00 18 00 18 00
*    08 00 08 00 08 00 08 00 00 00 00 00 00 00 00 00
*    10 00 10 00 10 00 10 00 10 00 10 00 10 00 10 00
*    10 00 10 00 10 00 10 00 10 00 10 00 10 00 10 00
*    00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
*    00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
*
*   Called before c_25A2.
* IN:
*  ...
* OUT:
*  ...
*-----------------------------------------------------------------------------
c_2896:

* once per stage, set the player's private pointer to attack wave object setup tables
	lea	ds_8920(pc),a0                     	| [ld   hl,#ds_8920] -> plyr_actv.p_atkwav_tbl

	move.b	a0,ds_plyr_actv+_p_atkwav_tbl   	| [ld   (ds_plyr_actv +_p_atkwav_tbl),hl] = &ds_8920[0] ... initialize it

* pointer to table of packed bits set in b<7>  ... see code leading up to _29AE
	lea	d_2908(pc),a3                      	| [ld   iy,#d_2908]

* if ( 0 == not_chllng_stg ) ...
	move.b	ds_plyr_actv+_b_not_chllg_stg,d0	| [ld   a,(ds_plyr_actv +_b_not_chllg_stg)] ==(stg_ctr+1)%4 ...i.e. 0 if challenge stage
	                               	| [and  a]
	jne	l_28CD_not_challenge_stage         	| [jr   nz,l_28CD_not_challenge_stage]
* ...
	move.b	ds_plyr_actv+_b_stgctr,d0       	| [ld   a,(ds_plyr_actv +_b_stgctr)] stage init sprite codes
	ror.b	#2,d0                            	| [rrca] * 2
	move.b	d0,d2                           	| [ld   c,a] table index (below)
	ror.b	#1,d0                            	| [rrca]
	move.b	d0,d1                           	| [ld   b,a]
	and.b	0xE0>>3,d0                       	| [and  #0xE0 >> 3] 0x1C ... test if stage >= 32
       ^^^^^^ TODO: review absolute 16-bit address read
	move.b	d1,d0                           	| [ld   a,b] .stage_ctr >> 3
	jeq	l_28B5                             	| [jr   z,l_28B5]
      ^^^^^^ TODO: review cpu flags (move.b,jeq)
	move.b	#3,d0                           	| [ld   a,#3] select index 3 if stage >= 32
l_28B5:
	and.b	#0x03,d0                         	| [and  #0x03] 4 entries in data (every 8 challenge stages the selection index is stepped)
	lea	d_stage_chllg_rnd_attrib(pc),a0    	| [ld   hl,#d_stage_chllg_rnd_attrib]
	jbsr	rst_08                            	| [rst  0x08] HL += 2A
	lea	ds2_stg_chllg_rnd_attrib(pc),a1    	| [ld   de,#ds2_stg_chllg_rnd_attrib] challenge bonus attributes (2 bytes from 2900[])
	move.b	d2,d0                           	| [ld   a,c]
	jbsr	ldi                               	| [ldi] "LD (DE),(HL)", DE++, HL++, BC--
     ^^^^ TODO: review special instruction inputs
	jbsr	ldi                               	| [ldi]
     ^^^^ TODO: review special instruction inputs

	lea	d_290E(pc),a0                      	| [ld   hl,#d_290E] 8 entries
	and.b	#0x07,d0                         	| [and  #0x07]
	jbsr	rst_10                            	| [rst  0x10] HL += A
	move.b	(a0),d3                         	| [ld   d,(hl)]
	move.b	d3,d4                           	| [ld   e,d]
	jra	l_28D0                             	| [jr   l_28D0]

l_28CD_not_challenge_stage:
 * Initialization values are base-code + 2 bits of color table.
 * 0x1B = 0x18 + 0x03
 * 0x08 = 0x08 + 0x00
 * 0x12 = 0x10 + 0x02
 * left shift codes by 1 bit because the flag (bit-7) will be rra'd from Cy
 * Results in 3-bits of color (multiple of 2)
	move.w	l_18+3)*2*l_0100+(l_10+2)*2(pc),a1	| [ld   de,#(0x18 + 3) * 2 * 0x0100  +  (0x10 + 2) * 2]
                  ^^^^^^ TODO: review move.w into address register

l_28D0:
	lea	ds_sprite_code+0x08(pc),a0         	| [ld   hl,#ds_sprite_code + 0x08] offsetof first bee in the group

ld  ixl,#1                                 ; start count for bit shifting

	move.b	#20,d1                          	| [ld   b,#20] 20 bees ... $08-$2E
ld   ixh,d                                 ; D == moth == $18	| $03
	jbsr	c_28E9                            	| [call c_28E9]

	move.b	#8,d1                           	| [ld   b,#8] 8 bosses and bonus-bees ... $30-$3E
ld   ixh,#(0x08 + 0x0) * 2                 ; code      == $08	| $00
	jbsr	c_28E9                            	| [call c_28E9]

	move.b	#16,d1                          	| [ld   b,#16] 16 moths ... $40-$5E
ld   ixh,e                                 ; E == bee  == $10	| $02
       * call c_28E9

*=============================================================================
* c_28E9()
*  Description:
*    Initialize a class of creatures.
* IN:
*  B == number of creatures in this class
*  HL == sprite_code_buf[ $08 + ? ]
*  IY == &d_2908[0], etc.
*  IXL == persistent count of bits shifted off of IY[ n++ ]
*  IXH == $36 or $10 or $24
* OUT:
*  ...
* First time, IXL==1, forcing C to be loaded.
* After that, reload C every 8 times.
* Each time, C is RL'd into Cy, and Cy RR'd into A.
*-----------------------------------------------------------------------------
c_28E9:
l_28E9:
* if ( --IXL == 0 )
	subq.b	#1,ixl                          	| [dec  ixl]
	jne	l_28F5                             	| [jr   nz,l_28F5]
* then ...  C = IY[ n++ ], IXL = 8
	move.b	(0x00,a3),d2                    	| [ld   c,0x00(iy)]
	addq.w	#1,a3                           	| [inc  iy]
ld   ixl,#8

l_28F5:
	rol.b	#1,d2                            	| [rlc  c]
	move.b	#ixh,d0                         	| [ld   a,ixh] base sprite-code parameter
	roxr.b	#1,d0                           	| [rra]
      ^^^^^^ TODO: review cpu X flag
	move.b	d0,(a0)                         	| [ld   (hl),a]
	addq.b	#2,d6                           	| [inc  l] * 2
	subq.b	#1,d1                           	| [...]
	jne	l_28E9                             	| [djnz l_28E9]

	rts                                    	| [ret]


*=============================================================================
* setup challenge stage bonus attributes at l_28B5 (b_9280 + 0x04)
* .b0: add to bug_collsn[$0F]
* .b1: obj_collsn_notif[] ... hit-flag + sprite-code for score tile
* (base-score multiples are * 10 thanks to d_scoreman_inc_lut[0])
d_stage_chllg_rnd_attrib:
	.byte 10, 0x80 + 0x38
	.byte 15, 0x80 + 0x39
	.byte 20, 0x80 + 0x3C
	.byte 30, 0x80 + 0x3D

d_2908:
	.byte 0xA5,0x5A,0xA9,0x0F,0x0A,0x50 | 44-bits used
d_290E:
	.byte 0x36,0x24,0xD4,0xBA,0xE4,0xCC,0xA8,0xF4

*=============================================================================
* f_2916()
*  Description:
*   Inserts creature objects from the attack wave table into the movement
*   queue. Essentially, it launches the attack formations swarming into the
*   screen. The table of attack wave structures is built in c_25A2.
*   Each struct starts with $7E, and the end of table marker is $7F.
*   This task will be enabled by stg_init_env... after the
*   creature classes and formation tables are initialized.
* IN:
*  ...
* OUT:
*  ...
*-----------------------------------------------------------------------------
f_2916:

* check for end of table
* if ( 7f == current_token ) goto complete
	move.w	ds_plyr_actv+_p_atkwav_tbl(pc),a0	| [ld   hl,(ds_plyr_actv +_p_atkwav_tbl)] &ds_8920[n]
                  ^^^^^^ TODO: review move.w into address register
	move.b	(a0),d0                         	| [ld   a,(hl)]
	cmp.b	#0x7F,d0                         	| [cp   #0x7F]
	jeq	l_2A29_attack_waves_complete       	| [jp   z,l_2A29_attack_waves_complete]

* check for start of table structure
* if ( 7e == token ) then .... else .... goto _next_pair
	cmp.b	#0x7E,d0                         	| [cp   #0x7E]
	jne	l_2953_next_pair                   	| [jr   nz,l_2953_next_pair]

* if ( ! _attack_wave_enable ) return
	move.b	ds_plyr_actv+_b_atk_wv_enbl,d0  	| [ld   a,(ds_plyr_actv +_b_atk_wv_enbl)] 0 if restarting the stage (respawning player ship)
	                               	| [and  a]
	bne.b	0f                               	| [...]
	rts                                    	| [ret  z] [...]
0:

* if ( 0 != bugs_flying_nbr ) goto _set_tmr0
	move.b	b_bugs_flying_nbr,d0            	| [ld   a,(b_bugs_flying_nbr)]
	                               	| [and  a]
	jne	l_294D_set_tmr0                    	| [jr   nz,l_294D_set_tmr0]

* if ( 0 == not_challenge_stg ) ...
	move.b	ds_plyr_actv+_b_not_chllg_stg,d0	| [ld   a,(ds_plyr_actv +_b_not_chllg_stg)] ==(stg_ctr+1)%4 ...i.e. 0 if challenge stage
	move.b	d0,d1                           	| [ld   b,a] this does nothing ;)
	tst.b	d0                               	| [and  a]
	jne	l_2944_attack_wave_start           	| [jr   nz,l_2944_attack_wave_start]
* ...
*  if ( 1 == game_tmrs[0] ) ..
	move.b	ds4_game_tmrs+0,d0              	| [ld   a,(ds4_game_tmrs + 0)] if tmr==1 ( on stage 3 ..challenge stage)
	cmp.b	#1,d0                            	| [cp   #1]
	jne	l_2942_chk_tmr0                    	| [jr   nz,l_2942_chk_tmr0]
*  ..
	move.b	#8,d0                           	| [ld   a,#8]
	move.b	d0,w_bug_flying_hit_cnt         	| [ld   (w_bug_flying_hit_cnt),a] 8 ... count down each flying bug hit
	rts                                    	| [ret]
*  ..
* if ( 0 != game_tmrs[0] ) return
l_2942_chk_tmr0:
	tst.b	d0                               	| [and  a] game_tmr0
	beq.b	0f                               	| [...]
	rts                                    	| [ret  nz] [...]
0:
* ...

* Finally... sending out next wave of creatures. We are on start token 7E so do nothing on this time step.
l_2944_attack_wave_start:
	addq.w	#1,a0                           	| [inc  hl]
	move.b	a0,ds_plyr_actv+_p_atkwav_tbl   	| [ld   (ds_plyr_actv +_p_atkwav_tbl),hl] +=1 (first element of byte-pair following the 7e)
	lea	ds_plyr_actv+_b_attkwv_ctr(pc),a0  	| [ld   hl,#ds_plyr_actv +_b_attkwv_ctr] +=1
	addq.b	#1,(a0)                         	| [inc  (hl)]
	rts                                    	| [ret]

l_294D_set_tmr0:
	move.b	#2,d0                           	| [ld   a,#2]
	move.b	d0,ds4_game_tmrs+0              	| [ld   (ds4_game_tmrs + 0),a] 2
	rts                                    	| [ret]
* ....

* finally, next token-pair !
l_2953_next_pair:
	move.b	d0,d2                           	| [ld   c,a] *.p_atkwav_tbl ... stash for later
* bit-7 is set if this toaster is a wing-man or a split waves, and therefore no delay,
* otherwise it is clear for trailing formation i.e. delay before launching.
* if ( 0 == *.p_atkwav_tbl & 0x80 ) ...
	btst.b	#7,d0                           	| [bit  7,a]
	jne	l_295E                             	| [jr   nz,l_295E]
* then ...
	move.b	ds3_92A0_frame_cts+0,d0         	| [ld   a,(ds3_92A0_frame_cts + 0)]
	and.b	#0x07,d0                         	| [and  #0x07]
	beq.b	0f                               	| [...]
	rts                                    	| [ret  nz] [...]
0:

* ready to stick another bug in the flying queue
l_295E:
* make byte offset into lut at db_2A3C  (_finalize_object) ... also we're done with bit-7
	asl.b	#1,d2                            	| [sla  c]

* find a slot in the queue
	move.b	#0x0C,d1                        	| [ld   b,#0x0C] number of structures in array
	move.w	#0x0014,d3                      	| [ld   de,#0x0014] size of 1 data structure 20
	lea	ds_bug_motion_que(pc),a2           	| [ld   ix,#ds_bug_motion_que]
l_2969_while:
	btst.b	#0,(0x13,a2)                    	| [bit  0,0x13(ix)]
	jeq	l_2974_got_slot                    	| [jr   z,l_2974_got_slot]
	add.w	d3,a2                            	| [add  ix,de] advance pointer
  ^^^^ TODO: review d3 computation above
	subq.b	#1,d1                           	| [...]
	jne	l_2969_while                       	| [djnz l_2969_while]

	rts                                    	| [ret] can't find a slot... bummer

* each time is another bug of a new wave formation getting ready to appear
l_2974_got_slot:
	addq.w	#1,a0                           	| [inc  hl]
	move.b	(a0),d0                         	| [ld   a,(hl)] atkwav_tbl[n].pair.h ... object ID/offset, e.g. 58
	move.b	d0,d1                           	| [ld   b,a] stash it

* if object >= $78  &&  object < $80 ) ...
	and.b	#0x78,d0                         	| [and  #0x78]
	cmp.b	#0x78,d0                         	| [cp   #0x78]
	move.b	d1,d0                           	| [ld   a,b]
	jne	l_2980                             	| [jr   nz,l_2980]
      ^^^^^^ TODO: review cpu flags (move.b,jne)
* ...  then ...
	bclr.b	#6,d0                           	| [res  6,a] what object is > $78?
l_2980:
	move.b	d0,(0x10,a2)                    	| [ld   0x10(ix),a] object index

	addq.w	#1,a0                           	| [inc  hl]
	move.b	a0,ds_plyr_actv+_p_atkwav_tbl   	| [ld   (ds_plyr_actv +_p_atkwav_tbl),hl] advance to next token-pair e.g. HL:=8923

	lea	b_8800(pc),a0                      	| [ld   h,#>b_8800]
	and.w	#0xFF,d6
	add.w	d6,a0
	      ^^^^ TODO: review XX value
	move.b	d0,d6                           	| [ld   l,a]
	move.b	#7,(a0)                         	| [ld   (hl),#7] 8800[L].l ... disposition = "spawning" ... i.e. case_2590

* store the slot index (offset) for this object
	addq.b	#1,d6                           	| [inc  l]
	move.b	#ixl,d4                         	| [ld   e,ixl]
	move.b	d4,(a0)                         	| [ld   (hl),e] 8800[L].h ... offset of slot (n*$14)

	lea	ds_sprite_posn(pc),a0              	| [ld   h,#>ds_sprite_posn]
	and.w	#0xFF,d6
	add.w	d6,a0
	      ^^^^ TODO: review XX value

* if ( object >= $38 && object < $40 ) then goto _setup_transients
	and.b	#0x38,d0                         	| [and  #0x38]
	cmp.b	#0x38,d0                         	| [cp   #0x38]
	jeq	l_29B3_setup_transients            	| [jr   z,l_29B3_setup_transients]
* else ...
* Init routine c_2896 has populated the sprite code buffer such that each even
* byte consists of the "primary" code (multiple of 8), AND'd with the color.
	subq.b	#1,d6                           	| [dec  l] e.g. HL=9358
	lea	ds_sprite_code(pc),a0              	| [ld   h,#>ds_sprite_code] sprite[L].code.b0 &= 0x78
	and.w	#0xFF,d6
	add.w	d6,a0
	      ^^^^ TODO: review XX value
	move.b	(a0),d0                         	| [ld   a,(hl)]
	move.b	d0,d3                           	| [ld   d,a] stash it
	and.b	#0x78,d0                         	| [and  #0x78] base sprite code for this object (multiple of 8)
	move.b	d0,(a0)                         	| [ld   (hl),a] sprite[n].cclr.b0
	addq.b	#1,d6                           	| [inc  l] .b1
	move.b	d3,d0                           	| [ld   a,d]
	and.b	#0x07,d0                         	| [and  #0x07] color table in bits <0:2>
	btst.b	#7,d3                           	| [bit  7,d]
	move.b	d0,(a0)                         	| [ld   (hl),a] sprite[n].cclr.b1

* if ( ! code_bit_7 )
	clr.b	d0                               	| [ld   a,#0]
	jeq	l_29AE                             	| [jr   z,l_29AE]
      ^^^^^^ TODO: review cpu flags (clr.b,jeq)
* else
	move.b	b_92E2+0x01,d0                  	| [ld   a,(b_92E2 + 0x01)] to 0x0F(ix) ... _stg_dat[1] ... bomb drop enable flags

l_29AE:
	move.b	d0,(0x0F,a2)                    	| [ld   0x0F(ix),a] 0, or b_92E2[1] ... bomb drop enable flags
	jra	l_29D1_finalize_object_setup       	| [jr   l_29D1_finalize_object_setup]

* handle the additional "transient" buggers that fly-in but don't join ... Stage 4 or higher.
l_29B3_setup_transients:
	lea	l_02*256+0x0010(pc),a1             	| [ld   de,#0x02 * 256 + 0x0010] redmoth, color 02, 270-deg rotation
	btst.b	#6,d1                           	| [bit  6,b]
	jne	l_29C7                             	| [jr   nz,l_29C7]
	lea	l_03*256+0x0018(pc),a1             	| [ld   de,#0x03 * 256 + 0x0018] yellowbee, color 03, 270-deg rotation
	move.b	ds_plyr_actv+_b_attkwv_ctr,d0   	| [ld   a,(ds_plyr_actv +_b_attkwv_ctr)]
	cmp.b	#0x02,d0                         	| [cp   #0x02]
	jne	l_29C7                             	| [jr   nz,l_29C7]
	lea	l_0000+0x0008(pc),a1               	| [ld   de,#0x0000 + 0x0008] boss, color 00, 270-deg rotation (>=stage 9)
l_29C7:
	lea	ds_sprite_code(pc),a0              	| [ld   h,#>ds_sprite_code]
	and.w	#0xFF,d6
	add.w	d6,a0
	      ^^^^ TODO: review XX value
	move.b	d3,(a0)                         	| [ld   (hl),d] color, e.g. 8B3B=$03
	subq.b	#1,d6                           	| [dec  l]
	move.b	d4,(a0)                         	| [ld   (hl),e] color, e.g. 8B3A=$18
	addq.b	#1,d6                           	| [inc  l]
	clr.b	(0x0F,a2)                        	| [ld   0x0F(ix),#0] setup transients ... bomb drop enable flags

l_29D1_finalize_object_setup:
	move.b	d2,d3                           	| [ld   d,c] first byte of token-pair, left-shifted 1 (byte-1 of _stg_dat triplet)
	bclr.b	#7,d2                           	| [res  7,c]
	move.b	#8,d1                           	| [ld   b,#8] critters that enter at the top
* if ( C & 0x02 ) ...
	btst.b	#1,d2                           	| [bit  1,c]
	jeq	l_29DC                             	| [jr   z,l_29DC]
* then ...
	move.b	#0x44,d1                        	| [ld   b,#0x44] critters that enter on the sides
l_29DC:
	move.b	d1,(0x0E,a2)                    	| [ld   0x0E(ix),b] $08 or $44 ... bomb drop counter

* ds_bug_move_queue[IX].b08 = db_2A3C[C] ... LSB of data pointer
	clr.b	d1                               	| [ld   b,#0]
	lea	db_2A3C(pc),a0                     	| [ld   hl,#db_2A3C]
	add.w	d1,a0                            	| [add  hl,bc] only C is significant
  ^^^^ TODO: review d1 computation above
	move.b	(a0),d0                         	| [ld   a,(hl)]
	addq.w	#1,a0                           	| [inc  hl]
	move.b	d0,(0x08,a2)                    	| [ld   0x08(ix),a] lo-byte of pointer e.g. cpu-sub1:001D

* get upper nibble of word at db_2A3C[w] (bits 5:7 will be masked by 0x0E below)
* rld (hl): Performs a 4-bit leftward rotation of the 12-bit number whose
* 4 most signigifcant bits are the 4 least significant bits of A
	clr.b	d0                               	| [xor  a]
	jbsr	rld                               	| [rld]
     ^^^^ TODO: review special instruction inputs
	move.b	d0,d1                           	| [ld   b,a]

* ds_bug_move_queue[IX].b09  = db_2A3C[C + 1] & 0x1F ... MSB of data pointer
	move.b	(a0),d0                         	| [ld   a,(hl)]
	and.b	#0x1F,d0                         	| [and  #0x1F]
	move.b	d0,(0x09,a2)                    	| [ld   0x09(ix),a] hi-byte of pointer e.g. cpu-sub1:001D

* ... get upper 4-bits of word at db_2A3C[w] which were rld'd into A: these
* are $2 thru $A even, and this is multiplied by 3 by the expression A*2+A
	move.b	d1,d0                           	| [ld   a,b]
	and.b	#0x0E,d0                         	| [and  #0x0E] bits 5:7 of db_2A3C[].b1
	move.b	d0,d1                           	| [ld   b,a]
	rol.b	#1,d0                            	| [rlca]
	add.b	d1,d0                            	| [add  a,b]
	lea	db_2A6C(pc),a0                     	| [ld   hl,#db_2A6C]
	jbsr	rst_10                            	| [rst  0x10] HL += A

* D is b0 of byte-pair (left shifted 1, so in _stg_dat it is 0x40)
* if ( D & 0x80 )
	btst.b	#7,d3                           	| [bit  7,d] 29FE
	jeq	l_2A05                             	| [jr   z,l_2A05]
* ... then ... HL += 3 ... selects the second set of 3 bytes
	addq.w	#3,a0                           	| [inc  hl] * 3

l_2A05:
	move.b	(a0),d0                         	| [ld   a,(hl)]
	addq.w	#1,a0                           	| [inc  hl]
	move.b	d0,(0x01,a2)                    	| [ld   0x01(ix),a] db_2A6C[L].b0
	move.b	(a0),d0                         	| [ld   a,(hl)]
	addq.w	#1,a0                           	| [inc  hl]
	move.b	d0,(0x03,a2)                    	| [ld   0x03(ix),a] db_2A6C[L].b1
	move.b	(a0),d0                         	| [ld   a,(hl)]
	addq.w	#1,a0                           	| [inc  hl]
	move.b	d0,(0x05,a2)                    	| [ld   0x05(ix),a] db_2A6C[L].b2

	clr.b	d0                               	| [xor  a]
	move.b	d0,(0x00,a2)                    	| [ld   0x00(ix),a] 0
	move.b	d0,(0x02,a2)                    	| [ld   0x02(ix),a] 0
	move.b	d0,(0x04,a2)                    	| [ld   0x04(ix),a] 0
	addq.b	#1,d0                           	| [inc  a]
	move.b	d0,(0x0D,a2)                    	| [ld   0x0D(ix),a] 1 ... expiration counter
	or.b	d3,d0                             	| [or   d] 1st byte of current byte-pair (left shifted 1, so in _stg_dat it is 0x40)
	and.b	#0x81,d0                         	| [and  #0x81] .b13<7> negates rotation angle
	move.b	d0,(0x13,a2)                    	| [ld   0x13(ix),a] A &= $81 ... .b13<0> makes object slot active
	rts                                    	| [ret]

* all 8 of the last wave of bees are on screen now... waiting for them to get in position.
* if (nbr_flying bugs > 0 ) return
l_2A29_attack_waves_complete:
	move.b	b_bugs_flying_nbr,d0            	| [ld   a,(b_bugs_flying_nbr)]
	                               	| [and  a]
	beq.b	0f                               	| [...]
	rts                                    	| [ret  nz] [...]
0:

* the last one has found its position in the collective.
	move.b	d0,ds_cpu0_task_actv+0x08       	| [ld   (ds_cpu0_task_actv + 0x08),a] 0  (f_2916 ... end of attack waves)
	addq.b	#1,d0                           	| [inc  a]
	move.b	d0,ds_cpu0_task_actv+0x04       	| [ld   (ds_cpu0_task_actv + 0x04),a] 1  (f_1A80 ... bonus-bee manager)
	move.b	d0,ds_cpu0_task_actv+0x10       	| [ld   (ds_cpu0_task_actv + 0x10),a] 1  (f_1B65 ... manage bomber attack )
	move.b	d0,ds_plyr_actv+_b_nestlr_inh   	| [ld   (ds_plyr_actv +_b_nestlr_inh),a] 1  ... inhibit nest left/right movement

	rts                                    	| [ret]


*=============================================================================

* bits 0:12  - pointer to data tables for flying pattern control.
* bits 13:15 - selection index into lut 2A6C.
db_2A3C:
	.long db_flv_001d + 0x0000, db_flv_0067 + 0x2000, db_flv_009f + 0x4000, db_flv_00d4 + 0x2000
	.long db_flv_017b + 0x0000, db_flv_01b0 + 0x6000, db_flv_01e8 + 0x0000, db_flv_01f5 + 0x2000
	.long db_flv_020b + 0x0000, db_flv_021b + 0x2000, db_flv_022b + 0x8000, db_flv_0241 + 0x2000
	.long db_flv_025d + 0x8000, db_flv_0279 + 0x2000, db_flv_029e + 0x0000, db_flv_02ba + 0x2000
	.long db_flv_02d9 + 0x0000, db_flv_02fb + 0x2000, db_flv_031d + 0x0000, db_flv_0333 + 0x2000
	.long db_flv_0fda + 0x0000, db_flv_0ff0 + 0x2000, db_flv_022b + 0xA000, db_flv_025d + 0xA000

* bits 13:15 from above provide bits<1:3> of the index
* bit-6 of _stg_dat provide bits<1> of the index (second set of 3-bytes in each pair)
db_2A6C:
* (ix)0x01 (ix)0x03 (ix)0x05
	.byte 0x9B,0x34,0x03 | 0
	.byte 0x9B,0x44,0x03
	.byte 0x23,0x00,0x00 | 2
	.byte 0x23,0x78,0x02
	.byte 0x9B,0x2C,0x03 | 4
	.byte 0x9B,0x4C,0x03
	.byte 0x2B,0x00,0x00 | 6
	.byte 0x2B,0x78,0x02
	.byte 0x9B,0x34,0x03 | 8
	.byte 0x9B,0x34,0x03
	.byte 0x9B,0x44,0x03 | A
	.byte 0x9B,0x44,0x03


*=============================================================================
* f_2A90()
*  Description:
*   left/right movement of collective while attack waves coming in at
*   start of round.
* IN:
*  ...
* OUT:
*  ...
*-----------------------------------------------------------------------------
f_2A90:

*  if ( frame_cnt % 4 != 0 ) return
	move.b	ds3_92A0_frame_cts+0,d0         	| [ld   a,(ds3_92A0_frame_cts + 0)]
	subq.b	#1,d0                           	| [dec  a] why -1 ?
	and.b	#0x03,d0                         	| [and  #0x03]
	beq.b	0f                               	| [...]
	rts                                    	| [ret  nz] [...]
0:

* check for exit condition
*  if  ! ( num_bugs != 0                	||  f_2916_active )  then ...
	move.b	b_bugs_actv_nbr,d0              	| [ld   a,(b_bugs_actv_nbr)]
	move.b	d0,d1                           	| [ld   b,a]
	move.b	ds_cpu0_task_actv+0x08,d0       	| [ld   a,(ds_cpu0_task_actv + 0x08)] f_2916 supervises attack waves
	or.b	d1,d0                             	| [or   b]
	jeq	l_2AE9_done                        	| [jr   z,l_2AE9_done]

* if ( 0 == nest_dir_lr ) then C = 1,  else C = -1
	move.b	ds_9200_glbls+0x0F,d0           	| [ld   a,(ds_9200_glbls + 0x0F)] nest direction... 1==left, 0==right
	                               	| [and  a]
	move.b	#1,d2                           	| [ld   c,#1]
	jeq	l_2AAB                             	| [jr   z,l_2AAB]
      ^^^^^^ TODO: review cpu flags (move.b,jeq)
	subq.b	#2,d2                           	| [dec  c] * 2

* initialize index and loop counter, update the table
l_2AAB:
	clr.b	d6                               	| [ld   l,#0] index into table
	move.b	#10,d1                          	| [ld   b,#10] nbr of column positions
l_2AAF:
* increment the relative position
	lea	ds_hpos_loc_offs(pc),a0            	| [ld   h,#>ds_hpos_loc_offs] even-bytes, relative offset, all 0's, then all 1's, etc. etc.
	and.w	#0xFF,d6
	add.w	d6,a0
	      ^^^^ TODO: review XX value
	move.b	(a0),d0                         	| [ld   a,(hl)]
	add.b	d2,d0                            	| [add  a,c] +1 or -1
	move.b	d0,(a0)                         	| [ld   (hl),a]
* increment sprite position LSB
	lea	ds_hpos_spcoords(pc),a0            	| [ld   h,#>ds_hpos_spcoords]
	and.w	#0xFF,d6
	add.w	d6,a0
	      ^^^^ TODO: review XX value
	move.b	(a0),d0                         	| [ld   a,(hl)]
	add.b	d2,d0                            	| [add  a,c]
	move.b	d0,(a0)                         	| [ld   (hl),a]
* HL+=2
	addq.b	#2,d6                           	| [inc  l] * 2
	subq.b	#1,d1                           	| [...]
	jne	l_2AAF                             	| [djnz l_2AAF]

* if ( 0 == nestlr_inh                  	||  0 != obj_pos_rel[0] )  ...
	move.b	ds_plyr_actv+_b_nestlr_inh,d0   	| [ld   a,(ds_plyr_actv +_b_nestlr_inh)]
	                               	| [and  a]
	move.b	ds_hpos_loc_offs+0x00,d0        	| [ld   a,(ds_hpos_loc_offs + 0x00)] check for 0 i.e. returned to center
	jeq	l_2AC9                             	| [jr   z,l_2AC9]
      ^^^^^^ TODO: review cpu flags (move.b,jeq)
	tst.b	d0                               	| [and  a]
	jeq	l_2ADA_done                        	| [jr   z,l_2ADA_done]
l_2AC9:
* ... then ...
* if ( 32 == obj_pos_rel[0] )  then nest_dir_lr = 1
	cmp.b	#32,d0                           	| [cp   #32]
	jne	l_2AD3                             	| [jr   nz,l_2AD3]

	move.b	#1,d0                           	| [ld   a,#1]
	move.b	d0,ds_9200_glbls+0x0F           	| [ld   (ds_9200_glbls + 0x0F),a] 1 ... nest direction... right limit reached
	rts                                    	| [ret]

l_2AD3:
* if ( -32 == obj_pos_rel[0] ) then nest_dir_lr = 0
	sub.b	#0xE0,d0                         	| [sub  #0xE0] -$20
	beq.b	0f                               	| [...]
	rts                                    	| [ret  nz] [...]
0:

	move.b	d0,ds_9200_glbls+0x0F           	| [ld   (ds_9200_glbls + 0x0F),a] 0 ... nest direction... left limit reached
	rts                                    	| [ret]

* the formation is complete... diving attacks shall commence
l_2ADA_done:
	clr.b	d0                               	| [xor  a]
	move.b	d0,ds_9200_glbls+0x0F           	| [ld   (ds_9200_glbls + 0x0F),a] 0 ... nest direction
	move.b	d0,ds_cpu0_task_actv+0x0A       	| [ld   (ds_cpu0_task_actv + 0x0A),a] 0 ... disable this task (f_2A90)
	addq.b	#1,d0                           	| [inc  a]
	move.b	d0,b_9AA0+0x00                  	| [ld   (b_9AA0 + 0x00),a] 1 ... sound-fx count/enable register, pulsing formation sound effect
	move.b	d0,ds_cpu0_task_actv+0x09       	| [ld   (ds_cpu0_task_actv + 0x09),a] 1 ... enable f_1DE6 ... collective bug movement
	rts                                    	| [ret]

* last bug of challenge is gone or killed
l_2AE9_done:
	move.b	d0,ds_cpu0_task_actv+0x0A       	| [ld   (ds_cpu0_task_actv + 0x0A),a] 0 ... disable this task (f_2A90)
	rts                                    	| [ret]


*=============================================================================
*
* Place 2C00 in its own segment so the pad is not needed.
*
*l_2AED:
*       .ds 0x0113                                 ; pad

*=============================================================================

* input file gg1-4.s
*
* gg1-4.s
*  gg1-4.2l 'maincpu' (Z80)
*
*  Hi-score dialog, power-on memory tests, and service-mode menu functions
*  combined into gg1-4 and removed files reset.s and svc_mode.s
*  from branch "sdasz80_03172012".
*
*
.module game_over

.include "sfrs.inc"
.include "structs.inc"
.include "gg1-4.dep"

*.area ROM (ABS,OVR)
*       .org 0x2FFF
*       .db 0x74                                   ; checksum
.area CSEG30


*=============================================================================
* _top5_dlg_proc()
*  Description:
*   Checks players score for ranking in the Best 5. Scores are 6 characters
*   BCD format, stored highest digit (100000's) at highest address of array.
*   This is called from game_ctrl (background task) and is blocking on the
*   game-timers.
*   Returns from 317F
* IN:
*  ...
* OUT:
*  ...
* Note: 83ED-83F2 is high score in tile RAM.
*-----------------------------------------------------------------------------
c_top5_dlg_proc:
	lea	0x8000+0x03E0+0x1D(pc),a0      	| [ld   hl,#0x8000 + 0x03E0 + 0x1D] 100000's digit of plyr1 score (83F8-FD)
	move.b	ds_plyr_actv+_b_plyr_nbr,d0     	| [ld   a,(ds_plyr_actv +_b_plyr_nbr)] 0==plyr1, 1==plyr2
	                               	| [and  a]
	jeq	l_300C                             	| [jr   z,l_300C]
	lea	0x8000+0x03E0+0x08(pc),a0      	| [ld   hl,#0x8000 + 0x03E0 + 0x08] 100000's digit of plyr2 score (83E3-E8)

l_300C:
* setup pointer to active player score in HL. Offset 5 advances pointer to 100000's place character.
	move.b	a0,b_8A00+0x00                  	| [ld   (b_8A00 + 0x00),hl] ptr to plyr1 score or plyr2 score on screen.

	lea	b_best5_score5+0x05(pc),a1         	| [ld   de,#b_best5_score5 + 0x05]
	jbsr	c_31F7_chk_score_rank             	| [call c_31F7_chk_score_rank] score > 5th place?
	bcs.b	0f                               	| [...]
	rts                                    	| [ret  nc] [...]
0:

	lea	b_best5_score4+0x05(pc),a1         	| [ld   de,#b_best5_score4 + 0x05]
	jbsr	c_31F7_chk_score_rank             	| [call c_31F7_chk_score_rank] score > 4th place?
	move.b	#5,d0                           	| [ld   a,#5]
	jcc	l_3047                             	| [jr   nc,l_3047]
      ^^^^^^ TODO: review cpu flags (move.b,jcc)

	lea	b_best5_score3+0x05(pc),a1         	| [ld   de,#b_best5_score3 + 0x05]
	jbsr	c_31F7_chk_score_rank             	| [call c_31F7_chk_score_rank] score > 4th place?
	move.b	#4,d0                           	| [ld   a,#4]
	jcc	l_3047                             	| [jr   nc,l_3047]
      ^^^^^^ TODO: review cpu flags (move.b,jcc)

	lea	b_best5_score2+0x05(pc),a1         	| [ld   de,#b_best5_score2 + 0x05]
	jbsr	c_31F7_chk_score_rank             	| [call c_31F7_chk_score_rank] score > 3th place?
	move.b	#3,d0                           	| [ld   a,#3]
	jcc	l_3047                             	| [jr   nc,l_3047]
      ^^^^^^ TODO: review cpu flags (move.b,jcc)

	lea	b_best5_score1+0x05(pc),a1         	| [ld   de,#b_best5_score1 + 0x05]
	jbsr	c_31F7_chk_score_rank             	| [call c_31F7_chk_score_rank] score > 2th place?
	move.b	#2,d0                           	| [ld   a,#2]
	jcc	l_3047                             	| [jr   nc,l_3047]
      ^^^^^^ TODO: review cpu flags (move.b,jcc)

	st.b	d0                                	| [ld   a,#0xFF]
	move.b	d0,0x9AA0+0x0C                  	| [ld   (0x9AA0 + 0x0C),a] special tune for 1st place
          ^^^^^^ TODO: review absolute 16-bit address write
	move.b	#1,d0                           	| [ld   a,#1]
	jra	l_304A                             	| [jr   l_304A]
l_3047:
	move.b	d0,0x9AA0+0x10                  	| [ld   (0x9AA0 + 0x10),a] select the tune
          ^^^^^^ TODO: review absolute 16-bit address write

l_304A:
* set the jp address for the subroutine.
	move.b	d0,b_8A00+0x11                  	| [ld   (b_8A00 + 0x11),a] 1==1ST place etc.
	lea	d_31A6(pc),a0                      	| [ld   hl,#d_31A6] jp table address
	subq.b	#1,d0                           	| [dec  a]
	jbsr	rst_08                            	| [rst  0x08] HL += 2A
	jbsr	c_3118_insert_top5_score          	| [call c_3118_insert_top5_score]

* insert new player name in table.
* data: 0,3,6,9,12 (12 for first place)
* the table gives repetition count for ldir below ( 5 - X * 3 ) where X is 1st through 5th place.
	move.b	b_8A00+0x11,d0                  	| [ld   a,(b_8A00 + 0x11)] 1==1ST place etc. ... d_31A1 [ A - 1 ]
	lea	d_31A1(pc),a0                      	| [ld   hl,#d_31A1] ld the table address
	subq.b	#1,d0                           	| [dec  a]
	jbsr	rst_10                            	| [rst  0x10] HL += A
	move.b	(a0),d0                         	| [ld   a,(hl)]
	lea	b_best5_name4+0x02(pc),a0          	| [ld   hl,#b_best5_name4 + 0x02] 3rd letter of 4th place name
	lea	b_best5_name5+0x02(pc),a1          	| [ld   de,#b_best5_name5 + 0x02] 3rd letter of 5th place name
	tst.b	d0                               	| [and  a]
	jeq	l_306C                             	| [jr   z,l_306C]
	move.b	d0,d2                           	| [ld   c,a]
	clr.b	d1                               	| [ld   b,#0]
lddr
* note, HL now == &newname[0] - 1
l_306C:
	move.b	#3,d1                           	| [ld   b,#3]
	move.b	#0x24,d0                        	| [ld   a,#0x24] clear the old name out (3 space characters)
	move.b	a0,b_8A00+0x04                  	| [ld   (b_8A00 + 0x04),hl] pointer to new name in table... address would be  &newname[0] - 1
l_3073:
	addq.b	#1,d6                           	| [inc  l] pre-increment since we start at ( &newname[0] - 1 )
	move.b	d0,(a0)                         	| [ld   (hl),a]
	subq.b	#1,d1                           	| [...]
	jne	l_3073                             	| [djnz l_3073]

	move.b	#0x49,d0                        	| [ld   a,#0x49]
	move.b	d0,b_8A00+0x10                  	| [ld   (b_8A00 + 0x10),a] $49 ... lower address byte of first character of name entry in tile-ram

	lea	s_327F_enter_your_initials(pc),a0  	| [ld   hl,#s_327F_enter_your_initials]
	jbsr	c_text_out_ce                     	| [call c_text_out_ce] "ENTER YOUR INITIALS !"
	jbsr	c_text_out                        	| [call c_text_out] "SCORE  NAME"          HL==3298
	jbsr	c_text_out_ce                     	| [call c_text_out_ce] "TOP 5"                HL==32AB

	lea	0x8000+0x0300+0x09(pc),a1      	| [ld   de,#0x8000 + 0x0300 + 0x09]
	move.w	b_8A00+0x00(pc),a0              	| [ld   hl,(b_8A00 + 0x00)] ptr to plyr1 score or plyr2 score on screen.
                  ^^^^^^ TODO: review move.w into address register
	jbsr	c_3275                            	| [call c_3275] puts players score below "SCORE"

* puts_AAA (default initials of new score entry) below NAME
	lea	0x8000+0x0140+0x09(pc),a0      	| [ld   hl,#0x8000 + 0x0140 + 0x09] row below 'A' in "NAME"
	move.w	#-32,d3                         	| [ld   de,#-32] offset 1 column right -32
	move.b	#0x0A,(a0)                      	| [ld   (hl),#0x0A]
	add.w	d3,a0                            	| [add  hl,de]
  ^^^^ TODO: review d3 computation above
	move.b	#0x0A,(a0)                      	| [ld   (hl),#0x0A]
	add.w	d3,a0                            	| [add  hl,de]
  ^^^^ TODO: review d3 computation above
	move.b	#0x0A,(a0)                      	| [ld   (hl),#0x0A]

	jbsr	c_puts_top5scores                 	| [call c_puts_top5scores]
	jbsr	c_plyr_initials_entry_hilite_line 	| [call c_plyr_initials_entry_hilite_line]

* wait 2 seconds
	move.b	#4,d0                           	| [ld   a,#4]
	move.b	d0,ds4_game_tmrs+2              	| [ld   (ds4_game_tmrs + 2),a]
l_30AA:
	move.b	ds4_game_tmrs+2,d0              	| [ld   a,(ds4_game_tmrs + 2)]
	                               	| [and  a]
	jne	l_30AA                             	| [jr   nz,l_30AA]

	move.b	#40,d0                          	| [ld   a,#40] 20 seconds
	move.b	d0,ds4_game_tmrs+2              	| [ld   (ds4_game_tmrs + 2),a] :=$28

* jp here from section _314C
l_30B5_next_char_selectn:
	jbsr	c_puts_top5scores                 	| [call c_puts_top5scores]
	jbsr	c_plyr_initials_entry_hilite_line 	| [call c_plyr_initials_entry_hilite_line]

* get time 0 from frame counter
	move.b	ds3_92A0_frame_cts+0,d0         	| [ld   a,(ds3_92A0_frame_cts + 0)]
	move.b	d0,d2                           	| [ld   c,a]

* jp here to return from section _stick_right
l_30BF_dlg_proc:
l_30BF_frame_sync:
	jbsr	c_32ED_top5_dlg_endproc           	| [call c_32ED_top5_dlg_endproc] checks coin-in once per frame
	move.b	ds3_92A0_frame_cts+0,d0         	| [ld   a,(ds3_92A0_frame_cts + 0)]
	cmp.b	d2,d0                            	| [cp   c]
	jeq	l_30BF_frame_sync                  	| [jr   z,l_30BF_frame_sync]

	move.b	d0,d2                           	| [ld   c,a]
	and.b	#0x0F,d0                         	| [and  #0x0F] 15 frames
	bne.b	0f                               	| [...]
	jbsr	c_3141_xor_char_color             	| [call z,c_3141_xor_char_color] alternate color 4 times/second
0:

* read IO port: setup for second player control panel if needed for tabletop
	lea	ds3_99B5_io_input+0x01(pc),a0      	| [ld   hl,#ds3_99B5_io_input + 0x01] plyr 1 input register
	move.b	b_9215_flip_screen,d0           	| [ld   a,(b_9215_flip_screen)]
	                               	| [and  a]
	jeq	l_30D8_chk_button                  	| [jr   z,l_30D8_chk_button]
	addq.w	#1,a0                           	| [inc  hl] HL := &io_input[2]
l_30D8_chk_button:
	btst.b	#4,(a0)                         	| [bit  4,(hl)] check for button (active low)
	jeq	j_314C_select_char                 	| [jp   z,j_314C_select_char] jp l_30B5 on 1st or 2nd letter selection...
                                                  * ... ret from _top5_dlg_proc after 3rd letter selection
	move.b	(a0),d0                         	| [ld   a,(hl)]
	and.b	#0x0A,d0                         	| [and  #0x0A]
	lea	b_8A00+0x02(pc),a0                 	| [ld   hl,#b_8A00 + 0x02] L==2, R==8 X=A   previous controller state
	lea	b_8A00+0x03(pc),a1                 	| [ld   de,#b_8A00 + 0x03] character selection counter/timer
	cmp.b	(a0),d0                          	| [cp   (hl)]
	jeq	l_30ED                             	| [jr   z,l_30ED]
	move.b	d0,(a0)                         	| [ld   (hl),a] the controller state has changed... save previous state
* reset the counter/timer
	move.b	#0xFD,d0                        	| [ld   a,#0xFD] (first timeout at next frame)
	move.b	d0,(a1)                         	| [ld   (de),a] (8A03) := $FD
* increment the counter/timer and check for 16 frames elapsed
l_30ED:
	move.b	(a1),d0                         	| [ld   a,(de)] DE==$8A03
	addq.b	#1,d0                           	| [inc  a]
	move.b	d0,(a1)                         	| [ld   (de),a] *($8A03)++
	and.b	#0x0F,d0                         	| [and  #0x0F]
	jne	l_30BF_dlg_proc                    	| [jr   nz,l_30BF_dlg_proc] done with this frame

* update letter selection every 1/4 second based on stick input.
	move.b	(a0),d0                         	| [ld   a,(hl)] get control stick value L==2, R==8 X==A
	cmp.b	#8,d0                            	| [cp   #8]
	jeq	l_311D_stick_right                 	| [jr   z,l_311D_stick_right] returns by  jp l_30BF
	cmp.b	#2,d0                            	| [cp   #2]
	jne	l_30BF_dlg_proc                    	| [jr   nz,l_30BF_dlg_proc] stick not left (or right)
	move.b	#40,d0                          	| [ld   a,#40] 20 seconds
	move.b	d0,ds4_game_tmrs+2              	| [ld   (ds4_game_tmrs + 2),a] reset timer

	move.b	b_8A00+0x10,d0                  	| [ld   a,(b_8A00 + 0x10)] lower byte of first character's address in v-ram
	move.b	d0,d6                           	| [ld   l,a]
	lea	0x8000+>l_0100(pc),a0          	| [ld   h,#>0x8000 + >0x0100]
	and.w	#0xFF,d6
	add.w	d6,a0
	      ^^^^ TODO: review XX value
	move.b	(a0),d0                         	| [ld   a,(hl)]
	subq.b	#1,d0                           	| [dec  a]
	cmp.b	#9,d0                            	| [cp   #9] check for if wrap around bottom-to-top
	bne.b	0f                               	| [...]
	jbsr	c_3138_lda2A                      	| [call z,c_3138_lda2A] A:=$2A  (allow the '.' character)
0:
	cmp.b	#0x29,d0                         	| [cp   #0x29]
	bne.b	0f                               	| [...]
	jbsr	c_313B_lda24                      	| [call z,c_313B_lda24] A:=$24  (24 is "space", 23 is 'Z')
0:
	move.b	d0,(a0)                         	| [ld   (hl),a]
	jra	l_30BF_dlg_proc                    	| [jp   l_30BF_dlg_proc]

*=============================================================================
* c_3118_insert_top5_score()
*  Description:
*   Inserts the new Top 5 score in the table.
* IN:
*  HL== jp table address from d_31A6, i.e:
*    case_31B0
*    case_31B4
*    case_31B8
*    case_31CE
*    case_31D9
* OUT:
*  ...
*-----------------------------------------------------------------------------
c_3118_insert_top5_score:
	move.b	(a0),d0                         	| [ld   a,(hl)]
	addq.w	#1,a0                           	| [inc  hl]
	move.b	(a0),d5                         	| [ld   h,(hl)]
	move.b	d0,d6                           	| [ld   l,a]
	jra	(a0)                               	| [jp   (hl)]
* returns from jp'd section

*=============================================================================
* l_311D_stick_right()
*  Description:
*   Update current character selection and reset the keep alive timer. Handles
*   wrap-around top-to-bottom
* IN:
*  ...
* OUT:
*  ...
*-----------------------------------------------------------------------------
l_311D_stick_right:
* get lower byte of current character's address in v-ram
	move.b	b_8A00+0x10,d0                  	| [ld   a,(b_8A00 + 0x10)] HL = $8000 + $0100 + b_8A00[ 0x10 ]
	move.b	d0,d6                           	| [ld   l,a]
	lea	0x8000+>l_0100(pc),a0          	| [ld   h,#>0x8000 + >0x0100]
	and.w	#0xFF,d6
	add.w	d6,a0
	      ^^^^ TODO: review XX value
	move.b	#40,d0                          	| [ld   a,#40] 20 seconds
	move.b	d0,ds4_game_tmrs+2              	| [ld   (ds4_game_tmrs + 2),a] reset timer
	move.b	(a0),d0                         	| [ld   a,(hl)]
	addq.b	#1,d0                           	| [inc  a]
	cmp.b	#0x2B,d0                         	| [cp   #0x2B] 2A is '.' character which is allowed
	bne.b	0f                               	| [...]
	jbsr	c_313E_lda0A                      	| [call z,c_313E_lda0A]
0:
	cmp.b	#0x25,d0                         	| [cp   #0x25] 2A is ' ' character which is allowed
	bne.b	0f                               	| [...]
	jbsr	c_3138_lda2A                      	| [call z,c_3138_lda2A]
0:
	move.b	d0,(a0)                         	| [ld   (hl),a]
	jra	l_30BF_dlg_proc                    	| [jp   l_30BF_dlg_proc]

*=============================================================================
* c_3138_lda2A()
*  Description:
*   Refactoring gone mad...
* IN:
*  ...
* OUT:
*  ...
*-----------------------------------------------------------------------------
c_3138_lda2A:
	move.b	#0x2A,d0                        	| [ld   a,#0x2A]
	rts                                    	| [ret]

*=============================================================================
* c_313B_lda24()
*  Description:
*    This seems somewhat inefficient.
* IN:
*  ...
* OUT:
*  ...
*-----------------------------------------------------------------------------
c_313B_lda24:
	move.b	#0x24,d0                        	| [ld   a,#0x24]
	rts                                    	| [ret]

*=============================================================================
* c_313E_lda0A()
*  Description:
*   Really?
* IN:
*  ...
* OUT:
*  ...
*-----------------------------------------------------------------------------
c_313E_lda0A:
	move.b	#0x0A,d0                        	| [ld   a,#0x0A]
	rts                                    	| [ret]

*=============================================================================
* c_3141_xor_char_color()
*  Description:
*    Invert current color code of selected character.
*    0 Cyan -> 5 Yellow
* IN:
*  *(b_8A00 + 0x10) == lower byte of selected character's address in v-ram
* OUT:
*  ...
*-----------------------------------------------------------------------------
c_3141_xor_char_color:
* lower byte of selected character's address in v-ram
	move.b	b_8A00+0x10,d0                  	| [ld   a,(b_8A00 + 0x10)] HL = $8400 + $0100 + b_8A00[ 0x10) ]
	move.b	d0,d6                           	| [ld   l,a]
	lea	m_color_ram+>l_0100(pc),a0         	| [ld   h,#>m_color_ram + >0x0100]
	and.w	#0xFF,d6
	add.w	d6,a0
	      ^^^^ TODO: review XX value
	move.b	(a0),d0                         	| [ld   a,(hl)]
	eor.b	#0x05,d0                         	| [xor  #0x05]
	move.b	d0,(a0)                         	| [ld   (hl),a]
	rts                                    	| [ret]

*=============================================================================
* j_314C_select_char()
*  Description:
*    'enter your intiials', handle fire button input.
*    Returns from _top5_dlg_proc after 3rd initial entered.
* IN:
*  ...
* OUT:
*  ...
*-----------------------------------------------------------------------------
j_314C_select_char:
* get the selected character from the 1st,2nd,or 3rd slot.
* get lower byte of current character's address in v-ram
	move.b	b_8A00+0x10,d0                  	| [ld   a,(b_8A00 + 0x10)] HL = $8400 + $0100 + b_8A00[ 0x10 ]
	move.b	d0,d6                           	| [ld   l,a]
	lea	m_color_ram+>l_0100(pc),a0         	| [ld   h,#>m_color_ram + >0x0100]
	and.w	#0xFF,d6
	add.w	d6,a0
	      ^^^^ TODO: review XX value
	clr.b	(a0)                             	| [ld   (hl),#0] set color to Cyan
	lea	0x8000+>l_0100(pc),a0          	| [ld   h,#>0x8000 + >0x0100]
	and.w	#0xFF,d6
	add.w	d6,a0
	      ^^^^ TODO: review XX value
	move.b	(a0),d2                         	| [ld   c,(hl)] copy the character from the input entry position in tile-ram
	move.b	#40,d0                          	| [ld   a,#40] 20 seconds
	move.b	d0,ds4_game_tmrs+2              	| [ld   (ds4_game_tmrs + 2),a] :=$28

* get the pointer to the new name entry in the table, and increment since it is actually ( &name[0] -1 )
	move.w	b_8A00+0x04(pc),a0              	| [ld   hl,(b_8A00 + 0x04)]
                  ^^^^^^ TODO: review move.w into address register
	addq.w	#1,a0                           	| [inc  hl]

	move.b	d2,(a0)                         	| [ld   (hl),c] copy the character to the table
	move.b	a0,b_8A00+0x04                  	| [ld   (b_8A00 + 0x04),hl] save the updated pointer

	lea	b_8A00+0x10(pc),a0                 	| [ld   hl,#b_8A00 + 0x10] get lower byte of current input character's address in v-ram
	move.b	(a0),d0                         	| [ld   a,(hl)]
	sub.b	#0x20,d0                         	| [sub  #0x20] offset one position (column) to the right
	move.b	d0,(a0)                         	| [ld   (hl),a]

* the characters are entered at xx49, xx29, xx09.
* so at the 3rd character, the sub $20 would result in a Cy.
	jcc	l_30B5_next_char_selectn           	| [jp   nc,l_30B5_next_char_selectn]
      ^^^^^^ TODO: review cpu flags (move.b,jcc)

* after 3rd character has been accepted, update the display and wait for the music to time out.
	jbsr	c_puts_top5scores                 	| [call c_puts_top5scores] selected character appears in the name under TOP 5
	jbsr	c_plyr_initials_entry_hilite_line 	| [call c_plyr_initials_entry_hilite_line]

	move.b	#76,d0                          	| [ld   a,#76]
	move.b	d0,ds3_92A0_frame_cts+0         	| [ld   (ds3_92A0_frame_cts + 0),a] :=$4C
l_3179:
	move.b	ds3_92A0_frame_cts+0,d0         	| [ld   a,(ds3_92A0_frame_cts + 0)]
	                               	| [and  a]
	jne	l_3179                             	| [jr   nz,l_3179]
	rts                                    	| [ret]

*=============================================================================
* c_plyr_initials_entry_hilite_line()
*  Description:
*   Hi-lite the row in yellow text corresponding to the player's score
*   ranking on the "Enter your initials" dialog screen.
* IN:
*  ...
* OUT:
*  ...
*-----------------------------------------------------------------------------
c_plyr_initials_entry_hilite_line:
	move.b	b_8A00+0x11,d0                  	| [ld   a,(b_8A00 + 0x11)] 1==1ST place etc.
	lea	d_3197_hiscore_line_ptrs(pc),a0    	| [ld   hl,#d_3197_hiscore_line_ptrs]
	subq.b	#1,d0                           	| [dec  a]
	jbsr	rst_08                            	| [rst  0x08] HL += 2A (determine index into table of word ptrs)
	move.b	(a0),d0                         	| [ld   a,(hl)]
	addq.w	#1,a0                           	| [inc  hl]
	move.b	(a0),d5                         	| [ld   h,(hl)]
	move.b	d0,d6                           	| [ld   l,a]
	move.b	#0x16,d1                        	| [ld   b,#0x16] number of characters to modify
	lea	-l_20(pc),a1                       	| [ld   de,#-0x20] advance 1 cell column to the right
l_3191:
	move.b	#5,(a0)                         	| [ld   (hl),#5] set character attribute byte to hi-lite color.
	add.w	d3,a0                            	| [add  hl,de]
  ^^^^ TODO: review d3 computation above
	subq.b	#1,d1                           	| [...]
	jne	l_3191                             	| [djnz l_3191]
	rts                                    	| [ret]

*=============================================================================
* Table of pointers to each line of on-screen Top 5 table. Reminider that each
* additional 2 byte increment offsets the pointer down 1 row (due to how v-ram
* is organized).
*
d_3197_hiscore_line_ptrs:
	.long m_color_ram + 0x0374
	.long m_color_ram + 0x0376
	.long m_color_ram + 0x0378
	.long m_color_ram + 0x037A
	.long m_color_ram + 0x037C

*=============================================================================
d_31A1:
	.byte 0x0C,0x09,0x06,0x03,0x00


*=============================================================================
*  Description:
*   pointers for c_3118_insert_top5_score
*-----------------------------------------------------------------------------
d_31A6:
	.long case_31B0
	.long case_31B4
	.long case_31B8
	.long case_31CE
	.long case_31D9

case_31B0:
	move.b	#0x12,d0                        	| [ld   a,#0x12]
	jra	l_31BA                             	| [jr   l_31BA]
case_31B4:
	move.b	#0x0C,d0                        	| [ld   a,#0x0C]
	jra	l_31BA                             	| [jr   l_31BA]
case_31B8:
	move.b	#0x06,d0                        	| [ld   a,#0x06]
l_31BA:
	lea	b_best5_score4+0x05(pc),a0         	| [ld   hl,#b_best5_score4 + 0x05]
	lea	b_best5_score5+0x05(pc),a1         	| [ld   de,#b_best5_score5 + 0x05]
	move.b	#0x00,d1                        	| [ld   bc,#0x0006] 6
	move.b	#0x06,d2                        	| [ld   bc,#0x0006] 6
lddr
	lea	b_best5_score4+0x05(pc),a1         	| [ld   de,#b_best5_score4 + 0x05]
	move.b	d0,d2                           	| [ld   c,a]
lddr
	jra	case_31D9                          	| [jp   case_31D9]

case_31CE:
	lea	b_best5_score5+0x05(pc),a1         	| [ld   de,#b_best5_score5 + 0x05]
	lea	b_best5_score4+0x05(pc),a0         	| [ld   hl,#b_best5_score4 + 0x05]
	move.b	#0x00,d1                        	| [ld   bc,#0x0006] 6
	move.b	#0x06,d2                        	| [ld   bc,#0x0006] 6
lddr

case_31D9:
	move.b	b_8A00+0x11,d0                  	| [ld   a,(b_8A00 + 0x11)] 1==1ST place etc. ... index into hi-score table ... d_31ED[ 2 * (A - 1) ]
	subq.b	#1,d0                           	| [dec  a]
	lea	d_31ED_hi_score_tbl(pc),a0         	| [ld   hl,#d_31ED_hi_score_tbl] array of addresses of score table elements
	jbsr	rst_08                            	| [rst  0x08] HL += 2A
	move.b	(a0),d4                         	| [ld   e,(hl)]
	addq.w	#1,a0                           	| [inc  hl]
	move.b	(a0),d3                         	| [ld   d,(hl)]
	move.w	b_8A00+0x00(pc),a0              	| [ld   hl,(b_8A00 + 0x00)] ptr to plyr1 score or plyr2 score on screen.
                  ^^^^^^ TODO: review move.w into address register
	move.b	#0x00,d1                        	| [ld   bc,#0x0006] 6
	move.b	#0x06,d2                        	| [ld   bc,#0x0006] 6
lddr
	rts                                    	| [ret]

*=============================================================================
* pointers to individual score strings of Top 5 table (documented elsewhere)
* scores only, complete table structure in s_32C5
d_31ED_hi_score_tbl:
	.long b_best5_score1 + 0x05
	.long b_best5_score2 + 0x05
	.long b_best5_score3 + 0x05
	.long b_best5_score4 + 0x05
	.long b_best5_score5 + 0x05

*=============================================================================
* c_31F7_chk_score_rank()
*  Description:
*  called by _top5_dlg_proc, once for each of 5th place score, 4th place etc.
*
* IN:
*  DE == pointer to 100000's digit (highest address) of score table entry.
*  $8A00 == pointer to 100000's digit (highest address) of either plyr1
*           or plyr2 score (6 characters in tile-ram).
* OUT:
*  Cy (Player Score > Table Entry)
*-----------------------------------------------------------------------------
c_31F7_chk_score_rank:
	move.w	b_8A00+0x00(pc),a0              	| [ld   hl,(b_8A00 + 0x00)] ptr to plyr1 score or plyr2 score on screen.
                  ^^^^^^ TODO: review move.w into address register
	move.b	#6,d1                           	| [ld   b,#6]
l_31FC:
	move.b	(a1),d0                         	| [ld   a,(de)] score digit

* skip "spaces" (only the 100000 place of table entry could be "space" character)
	cmp.b	#0x24,d0                         	| [cp   #0x24]
	jeq	l_320E                             	| [jr   z,l_320E]

* ... and since table entries are all at least 20000, then any space in the player score will not place.
	move.b	(a0),d0                         	| [ld   a,(hl)] ptr to plyr1 score or plyr2 score on screen
	cmp.b	#0x24,d0                         	| [cp   #0x24]
	bne.b	0f                               	| [...]
	rts                                    	| [ret  z] [...]
0:

	move.b	(a1),d0                         	| [ld   a,(de)]
l_3206:
* sets Cy if score digit > table digit
	cmp.b	(a0),d0                          	| [cp   (hl)] ptr to plyr1 score or plyr2 score on screen
	beq.b	0f                               	| [...]
	rts                                    	| [ret  nz] [...]
0:
l_3208:
	subq.b	#1,d6                           	| [dec  l]
	subq.b	#1,d4                           	| [dec  e]
	subq.b	#1,d1                           	| [...]
	jne	l_31FC                             	| [djnz l_31FC]

	clr.b	d0                               	| [xor  a]
	rts                                    	| [ret]

l_320E:
* table digit == $24
	cmp.b	(a0),d0                          	| [cp   (hl)] ptr to plyr1 score or plyr2 score on screen
	jeq	l_3208                             	| [jr   z,l_3208] if both spaces, jp to next
* score digit != $24 ...
	clr.b	d0                               	| [xor  a] "table digit"
	jra	l_3206                             	| [jr   l_3206]

*=============================================================================
* hiscore_heroes()
*  Description:
* IN:
*  ...
* OUT:
*  ...
*-----------------------------------------------------------------------------
c_mach_hiscore_show:
	lea	str_3345(pc),a0                    	| [ld   hl,#str_3345] 'GALACTIC HEROES'
	jbsr	c_text_out_ce                     	| [call c_text_out_ce]
	jbsr	c_text_out_ce                     	| [call c_text_out_ce] 'BEST 5'  hl==335c

*=============================================================================
* hiscore_scrn()
*  Description:
*   Common sub for Enter Initials and Galactic Heroes - display each score
*   entry under "TOP 5".
*
* IN:
*  ...
* OUT:
*  ...
*-----------------------------------------------------------------------------
c_puts_top5scores:
	lea	s_32B4_score_name(pc),a0           	| [ld   hl,#s_32B4_score_name]
	jbsr	c_text_out                        	| [call c_text_out] puts 'SCORE     NAME' below 'TOP 5'
	move.b	#1,d1                           	| [ld   b,#1] starting index for c_3231
	jbsr	c_3231                            	| [call c_3231] '1ST............'
	jbsr	c_3231                            	| [call c_3231] '2ND............'
	jbsr	c_3231                            	| [call c_3231] '3RD............'
	jbsr	c_3231                            	| [call c_3231] '4RD............'
                                                  * continue to '5TH' ...
*=============================================================================
* c_3231()
*  Description:
*   Setting lines for hi-score table. 1st,2nd,3rd,and 4th are by calling the
*   function. 5th is by allowing execution to fall through from c_puts_top5scores.
*   Each call to 3270 offsets DE for the next column (-$20) and advanced HL.
* IN:
*  B=rank (1 to 5)
* OUT:
*  B+=1
*-----------------------------------------------------------------------------
c_3231:
	move.b	d1,d0                           	| [ld   a,b] B=rank (1 to 5)
	subq.b	#1,d0                           	| [dec  a]
	add.b	d0,d0                            	| [add  a,a]
	add.b	d0,d0                            	| [add  a,a]
	add.b	d0,d0                            	| [add  a,a] A=offset into table ... (B-1)*8
	lea	s_32C5(pc),a0                      	| [ld   hl,#s_32C5] score placement characters: 'ST', 'ND', 'RD' etc.
	jbsr	rst_10                            	| [rst  0x10] HL += A
	move.b	(a0),d4                         	| [ld   e,(hl)] destination lo-byte
	addq.w	#1,a0                           	| [inc  hl]
	move.b	(a0),d3                         	| [ld   d,(hl)] destination hi-byte
	addq.w	#1,a0                           	| [inc  hl]
	move.b	d1,d0                           	| [ld   a,b] B=numerical score placement
	move.b	d0,(a1)                         	| [ld   (de),a] putc '5' of '5TH' on screen.
	jbsr	c_3273                            	| [call c_3273] DE:-=$20
	jbsr	c_3270                            	| [call c_3270] putc 'T' of '5TH' on screen.
	jbsr	c_3270                            	| [call c_3270] putc 'H' of '5TH' on screen.
	jbsr	c_3273                            	| [call c_3273] DE:-=$20
	jbsr	c_3273                            	| [call c_3273] DE:-=$20
	move.b	(a0),d0                         	| [ld   a,(hl)] const ptr to score (lo-byte)
	addq.w	#1,a0                           	| [inc  hl]
	move.b	(a0),d2                         	| [ld   c,(hl)] const ptr to score (lo-byte)
	addq.w	#1,a0                           	| [inc  hl]

	move.l	a0,-(sp)                        	| [push hl] save const ptr to player initials.
	move.b	d2,d5                           	| [ld   h,c]
	move.b	d0,d6                           	| [ld   l,a] HL=ptr to 6-bytes score text
	jbsr	c_3275                            	| [call c_3275] puts 'XXXXX' of 5th place on screen.
	move.b	d4,d0                           	| [ld   a,e]
	sub.b	0x20*6,d0                        	| [sub  #0x20 * 6] advance column ptr right 6 characters.
       ^^^^^^ TODO: review absolute 16-bit address read
	move.b	d0,d4                           	| [ld   e,a]
	jcc	l_3260                             	| [jr   nc,l_3260]
      ^^^^^^ TODO: review cpu flags (move.b,jcc)
	subq.b	#1,d3                           	| [dec  d] when not jr?
l_3260:
	move.l	(sp)+,a0                        	| [pop  hl]
	move.b	(a0),d0                         	| [ld   a,(hl)]
	addq.w	#1,a0                           	| [inc  hl]
	move.b	(a0),d5                         	| [ld   h,(hl)]
	move.b	d0,d6                           	| [ld   l,a]
	jbsr	c_3270                            	| [call c_3270] putc 1st initial
	jbsr	c_3270                            	| [call c_3270] putc 2nd initial
	jbsr	c_3270                            	| [call c_3270] putc 3rd initial
	addq.b	#1,d1                           	| [inc  b]
	rts                                    	| [ret]

*=============================================================================
* c_3270()
*  Description:
* IN:
*  HL=character to "putc".
*  DE=destination position.
* OUT:
*  Increments HL (useful for multi-character strings)
*-----------------------------------------------------------------------------
c_3270:
	move.b	(a0),d0                         	| [ld   a,(hl)]
	move.b	d0,(a1)                         	| [ld   (de),a]
	addq.w	#1,a0                           	| [inc  hl]

*=============================================================================
* c_3273()
*  Description:
*   Use with "puts" routines to advance one character to right in tile memory.
*   This is continuation of 3270 above, but also is called explicitly.
* IN:
*  ...
* OUT:
*  ...
*-----------------------------------------------------------------------------
c_3273:
	jbsr	rst_20                            	| [rst  0x20] DE-=$20
	rts                                    	| [ret]
* end 'call _3270'

*=============================================================================
* c_3275()
*  Description:
*  Copies a 6 byte string.
*  The format for '12345' is: "0x05 0x04 0x03 0x02 0x01 0x24" (24 is space)
* IN:
*  HL=pointer to source string (last character i.e. the "space")
*  DE="puts" destination address.
* OUT:
*  ...
*-----------------------------------------------------------------------------
c_3275:
	move.b	#6,d2                           	| [ld   c,#6]
l_3277:
	move.b	(a0),d0                         	| [ld   a,(hl)]
	move.b	d0,(a1)                         	| [ld   (de),a]
	subq.w	#1,a0                           	| [dec  hl]
	jbsr	rst_20                            	| [rst  0x20] DE-=$20
	subq.b	#1,d2                           	| [dec  c]
	jne	l_3277                             	| [jr   nz,l_3277]
	rts                                    	| [ret] end 'call _3275'

*=============================================================================
*  Description:
*   High score table strings.
*-----------------------------------------------------------------------------
s_327F_enter_your_initials:
* "ENTER YOUR INITIALS !"
	.long 0x8000 + 0x0320 + 0x04
	.byte 0x15
	.byte 0x04                                   | color code (c_text_out_ce)
	.byte 0x0E,0x17,0x1D,0x0E,0x1B,0x24,0x22,0x18,0x1E,0x1B,0x24,0x12,0x17,0x12,0x1D,0x12,0x0A,0x15,0x1C,0x24,0x2C
* "SCORE       NAME" (after l_3073, in cyan ... not color encoded)
	.long 0x8000 + 0x02E0 + 0x07
	.byte 0x10
	.byte 0x1C,0x0C,0x18,0x1B,0x0E,0x24,0x24,0x24,0x24,0x24,0x24,0x24,0x17,0x0A,0x16,0x0E
* "TOP 5" (32AB)
	.long 0x8000 + 0x0240 + 0x10
	.byte 0x05
	.byte 0x04                                   | color code (c_text_out_ce)
	.byte 0x1D,0x18,0x19,0x24,0x05
s_32B4_score_name:
* "SCORE     NAME" (c_puts_top5scores)
	.long 0x8000 + 0x0280 + 0x12
	.byte 0x0E
	.byte 0x1C,0x0C,0x18,0x1B,0x0E,0x24,0x24,0x24,0x24,0x24,0x17,0x0A,0x16,0x0E

* formatting for score table list at _3236
*  struct{
*   byte *position_address
*   char2[] text
*   byte *score_bcd    ( e.g. "123456" encoded as "06 05 04 03 02 01" and ptr=&"01")
*   byte *initials
s_32C5:
	.long 0x8000 + 0x0340 + 0x14
	.byte 0x1C,0x1D  || "ST"
          ^^^^^^ TODO: review absolute 16-bit address write
	.long b_best5_score1 + 0x05
	.long b_best5_name1
       *
	.long 0x8000 + 0x0340 + 0x16
	.byte 0x17,0x0D  || "ND"
          ^^^^^^ TODO: review absolute 16-bit address write
	.long b_best5_score2 + 0x05
	.long b_best5_name2
       *
	.long 0x8000 + 0x0340 + 0x18
	.byte 0x1B,0x0D  || "RD"
          ^^^^^^ TODO: review absolute 16-bit address write
	.long b_best5_score3 + 0x05
	.long b_best5_name3
       *
	.long 0x8000 + 0x0340 + 0x1A
	.byte 0x1D,0x11  || "TH"
          ^^^^^^ TODO: review absolute 16-bit address write
	.long b_best5_score4 + 0x05
	.long b_best5_name4
       *
	.long 0x8000 + 0x0340 + 0x1C
	.byte 0x1D,0x11  || "TH"
          ^^^^^^ TODO: review absolute 16-bit address write
	.long b_best5_score5 + 0x05
	.long b_best5_name5

*=============================================================================
* c_32ED_top5_dlg_endproc()
*  Description:
*   Closes the 'enter your initials' process.
*   checks credits available and exits early if credits are available.
* IN:
*  ...
* OUT:
*  ...
*-----------------------------------------------------------------------------
c_32ED_top5_dlg_endproc:
* if (free-play)
	move.b	ds3_99B5_io_input+0x00,d0       	| [ld   a,(ds3_99B5_io_input + 0x00)] io_input[credit_count]
	cmp.b	#0xA0,d0                         	| [cp   #0xA0]
	jeq	l_32FB_check_for_timeout           	| [jr   z,l_32FB_check_for_timeout]
* else if ( hw credit cnt > current credit count ) goto finish
	move.b	d0,d1                           	| [ld   b,a]
	move.b	b8_99B8_credit_cnt,d0           	| [ld   a,(b8_99B8_credit_cnt)]
	cmp.b	d1,d0                            	| [cp   b]
	jcs	l_3300_finish                      	| [jr   c,l_3300_finish]

l_32FB_check_for_timeout:
	move.b	ds4_game_tmrs+2,d0              	| [ld   a,(ds4_game_tmrs + 2)]
	                               	| [and  a]
	beq.b	0f                               	| [...]
	rts                                    	| [ret  nz] [...]
0:

* Time up. Copy available characters from input to Top 5 score name table.

* The pop forces 1 stack frame to be skipped (returns to caller of _top5_dlg_proc)
l_3300_finish:
	move.l	(sp)+,a0                        	| [pop  hl]

* Setup HL and DE as pointers for copy from input characters to new Top5 table name entry.
	lea	0x8000+>l_0100(pc),a0          	| [ld   h,#>0x8000 + >0x0100]
	and.w	#0xFF,d6
	add.w	d6,a0
	      ^^^^ TODO: review XX value
	move.b	b_8A00+0x10,d0                  	| [ld   a,(b_8A00 + 0x10)] lower byte of current character's address in v-ram
	move.b	d0,d6                           	| [ld   l,a]
	move.w	b_8A00+0x04(pc),a1              	| [ld   de,(b_8A00 + 0x04)] pointer to next name character to store in Top 5 table...
                  ^^^^^^ TODO: review move.w into address register
	addq.w	#1,a1                           	| [inc  de] ... actually it points to ( next_character - 1 )

* When the time runs out, 1, 2, or 3 characters may have already been selected
* by the player. Rather than keeping count, it simply checks that the column
* pointer from the input is off past the right limit. The rightmost input
* character is $8109 and will underflow when subtracting $20. Since the
* subtraction is done by addition (-21h == $DF), the inverse of the Cy flag can
* be used to detect the equivalent of the underflow of the subtraction.
l_330C:
	jbsr	ldi                               	| [ldi]
     ^^^^ TODO: review special instruction inputs
	move.b	#-0x21,d0                       	| [ld   a,#-0x21] subtract $21 since the LDI added 1 to HL
	subq.b	#1,d5                           	| [dec  h]
	add.b	d6,d0                            	| [add  a,l]
	jcc	l_3315                             	| [jr   nc,l_3315]
	addq.b	#1,d5                           	| [inc  h] L is 9, 29, or 49 so Cy is set, and we restor the  H...
l_3315:
	move.b	d0,d6                           	| [ld   l,a]
	btst.b	#0,d5                           	| [bit  0,h] if the Cy was set, then bit 0 should be set.
	jne	l_330C                             	| [jr   nz,l_330C]
	rts                                    	| [ret]

*=============================================================================
* c_text_out()
*  Description:
*  Text out, color attribute not encoded. Text blocks are length-encoded.
* IN:
*  HL=start address of string
* OUT:
*  HL=start address at next string
*-----------------------------------------------------------------------------
c_text_out:
* destination address
	move.b	(a0),d4                         	| [ld   e,(hl)] LSB
	addq.w	#1,a0                           	| [inc  hl]
	move.b	(a0),d3                         	| [ld   d,(hl)] MSB
	addq.w	#1,a0                           	| [inc  hl]
* byte count of string
	move.b	(a0),d1                         	| [ld   b,(hl)]
	addq.w	#1,a0                           	| [inc  hl]

l_3321:
	move.b	(a0),d0                         	| [ld   a,(hl)] character code
	move.b	d0,(a1)                         	| [ld   (de),a] putc
	addq.w	#1,a0                           	| [inc  hl] src++
	jbsr	rst_20                            	| [rst  0x20] DE-=$20
	subq.b	#1,d1                           	| [...]
	jne	l_3321                             	| [djnz l_3321]

	rts                                    	| [ret]

*=============================================================================
* c_text_out_ce()
*  Description:
*   Text out, color attribute encoded. Text blocks are length-encoded.
*   Used by game_over.
* IN:
*  ...
* OUT:
*  ...
*-----------------------------------------------------------------------------
c_text_out_ce:
	move.b	(a0),d4                         	| [ld   e,(hl)] LSB
	addq.w	#1,a0                           	| [inc  hl]
	move.b	(a0),d3                         	| [ld   d,(hl)] MSB
	addq.w	#1,a0                           	| [inc  hl]
	move.b	(a0),d1                         	| [ld   b,(hl)] strlen
	addq.w	#1,a0                           	| [inc  hl]
	move.b	(a0),d2                         	| [ld   c,(hl)] color
	addq.w	#1,a0                           	| [inc  hl]
	exg	a1,a0                              	| [ex   de,hl]
l_3331:
	move.b	(a1),d0                         	| [ld   a,(de)] data address
	move.b	d0,(a0)                         	| [ld   (hl),a]
	bset.b	#2,d5                           	| [set  2,h] dest+=$0400 (tile color regs)
	move.b	d2,(a0)                         	| [ld   (hl),c]
	bclr.b	#2,d5                           	| [res  2,h]
	addq.w	#1,a1                           	| [inc  de]
	move.b	#-0x20,d0                       	| [ld   a,#-0x20]
	subq.b	#1,d5                           	| [dec  h]
	add.b	d6,d0                            	| [add  a,l]
	jcc	l_3340                             	| [jr   nc,l_3340]
	addq.b	#1,d5                           	| [inc  h]
l_3340:
	move.b	d0,d6                           	| [ld   l,a]
	subq.b	#1,d1                           	| [...]
	jne	l_3331                             	| [djnz l_3331]

	exg	a1,a0                              	| [ex   de,hl]
	rts                                    	| [ret]

*=============================================================================
* strings for mach_hiscore_show
*=============================================================================
str_3345:
* "THE GALACTIC HEROES"
	.long 0x8000 + 0x0320 + 0x05
	.byte 0x13
	.byte 0x02
	.byte 0x1D,0x11,0x0E,0x24,0x10,0x0A,0x15,0x0A,0x0C,0x1D,0x12,0x0C,0x24,0x11,0x0E,0x1B,0x18,0x0E,0x1C
*_335C:
* "-- BEST 5 --"
	.long 0x8000 + 0x02C0 + 0x0C
	.byte 0x0C
	.byte 0x04
	.byte 0x26,0x26,0x24,0x0B,0x0E,0x1C,0x1D,0x24,0x05,0x24,0x26,0x26


*=============================================================================
* jp_RAM_test()
*  Description:
*   RAM test at powerup (from machine reset at 2c4) or Service-switch reset.
* IN:
*  ...
* OUT:
*  ...
*-----------------------------------------------------------------------------
jp_RAM_test:
	clr.b	d0                               	| [xor  a]
	move.b	d0,0x6823                       	| [ld   (0x6823),a] 0 ...halt CPU #2 and #3
          ^^^^^^ TODO: review absolute 16-bit address write
	addq.b	#1,d0                           	| [inc  a]
	move.b	d0,_sfr_6822                    	| [ld   (_sfr_6822),a] 1 ...cpu #3 nmi acknowledge/enable (Z80_IGNORE_INT)
di                                         ; disable interrupts
	move.b	d0,_sfr_watchdog                	| [ld   (_sfr_watchdog),a]
*  while ( tileramtestloopcount < $0a ){
	move.b	#0x0A,d1                        	| [ld   b,#0x0A] loop counter
_tileram_test_loop:
	jbsr	exx                               	| [exx] save outer loop count
     ^^^^ TODO: review special instruction inputs

	lea	0x8000(pc),a1                  	| [ld   de,#0x8000]
	move.w	#0x0000,d5                      	| [ld   hl,#0x0000] 0
	move.b	#0x04,d1                        	| [ld   bc,#0x0400] 1024
	move.b	#0x00,d2                        	| [ld   bc,#0x0400] 1024
_wr_zero_loop:
	move.b	d6,d0                           	| [ld   a,l] a:=0
	eor.b	d5,d0                            	| [xor  h]
	not.b	d0                               	| [cpl]
	add.b	d0,d0                            	| [add  a,a]
	add.b	d0,d0                            	| [add  a,a]
adc  hl,hl
	move.b	d6,d0                           	| [ld   a,l]
	move.b	d0,_sfr_watchdog                	| [ld   (_sfr_watchdog),a]
	move.b	d0,(a1)                         	| [ld   (de),a] a==1, de==tile_ram
	addq.w	#1,a1                           	| [inc  de]
	subq.w	#1,a4                           	| [dec  bc]
	move.b	d1,d0                           	| [ld   a,b]
	or.b	d2,d0                             	| [or   c]
	jne	_wr_zero_loop                      	| [jr   nz,_wr_zero_loop]

	lea	0x8000(pc),a1                  	| [ld   de,#0x8000]
	move.w	#0x0000,d5                      	| [ld   hl,#0x0000] 0
	move.b	#0x04,d1                        	| [ld   bc,#0x0400] 1024
	move.b	#0x00,d2                        	| [ld   bc,#0x0400] 1024
_rd_zero_loop:
	move.b	d6,d0                           	| [ld   a,l] a:=0
	eor.b	d5,d0                            	| [xor  h]
	not.b	d0                               	| [cpl]
	add.b	d0,d0                            	| [add  a,a]
	add.b	d0,d0                            	| [add  a,a]
adc  hl,hl
	move.b	(a1),d0                         	| [ld   a,(de)]
	eor.b	d6,d0                            	| [xor  l]
	jne	j_ramtest_ng                       	| [jp   nz,j_ramtest_ng]
	addq.w	#1,a1                           	| [inc  de]
	move.b	d0,_sfr_watchdog                	| [ld   (_sfr_watchdog),a]
	subq.w	#1,a4                           	| [dec  bc]
	move.b	d1,d0                           	| [ld   a,b]
	or.b	d2,d0                             	| [or   c]
	jne	_rd_zero_loop                      	| [jr   nz,_rd_zero_loop]

	lea	0x8000(pc),a1                  	| [ld   de,#0x8000]
	lea	l_5555(pc),a0                      	| [ld   hl,#0x5555]
	move.b	#0x04,d1                        	| [ld   bc,#0x0400] 1024
	move.b	#0x00,d2                        	| [ld   bc,#0x0400] 1024
_wr_5555_loop:
	move.b	d6,d0                           	| [ld   a,l]
	eor.b	d5,d0                            	| [xor  h]
	not.b	d0                               	| [cpl]
	add.b	d0,d0                            	| [add  a,a]
	add.b	d0,d0                            	| [add  a,a]
adc  hl,hl
	move.b	d6,d0                           	| [ld   a,l]
	move.b	d0,_sfr_watchdog                	| [ld   (_sfr_watchdog),a]
	move.b	d0,(a1)                         	| [ld   (de),a]
	addq.w	#1,a1                           	| [inc  de]
	subq.w	#1,a4                           	| [dec  bc]
	move.b	d1,d0                           	| [ld   a,b]
	or.b	d2,d0                             	| [or   c]
	jne	_wr_5555_loop                      	| [jr   nz,_wr_5555_loop]

	lea	0x8000(pc),a1                  	| [ld   de,#0x8000]
	lea	l_5555(pc),a0                      	| [ld   hl,#0x5555]
	move.b	#0x04,d1                        	| [ld   bc,#0x0400] 1024
	move.b	#0x00,d2                        	| [ld   bc,#0x0400] 1024
_rd_5555_loop:
	move.b	d6,d0                           	| [ld   a,l]
	eor.b	d5,d0                            	| [xor  h]
	not.b	d0                               	| [cpl]
	add.b	d0,d0                            	| [add  a,a]
	add.b	d0,d0                            	| [add  a,a]
adc  hl,hl
	move.b	(a1),d0                         	| [ld   a,(de)]
	eor.b	d6,d0                            	| [xor  l]
	jne	j_ramtest_ng                       	| [jp   nz,j_ramtest_ng]
	addq.w	#1,a1                           	| [inc  de]
	move.b	d0,_sfr_watchdog                	| [ld   (_sfr_watchdog),a]
	subq.w	#1,a4                           	| [dec  bc]
	move.b	d1,d0                           	| [ld   a,b]
	or.b	d2,d0                             	| [or   c]
	jne	_rd_5555_loop                      	| [jr   nz,_rd_5555_loop]

	lea	0x8000(pc),a1                  	| [ld   de,#0x8000]
	lea	l_AAAA(pc),a0                      	| [ld   hl,#0xAAAA]
	move.b	#0x04,d1                        	| [ld   bc,#0x0400] 1024
	move.b	#0x00,d2                        	| [ld   bc,#0x0400] 1024
_wr_aaaa_loop:
	move.b	d6,d0                           	| [ld   a,l]
	eor.b	d5,d0                            	| [xor  h]
	not.b	d0                               	| [cpl]
	add.b	d0,d0                            	| [add  a,a]
	add.b	d0,d0                            	| [add  a,a]
adc  hl,hl
	move.b	d6,d0                           	| [ld   a,l]
	move.b	d0,_sfr_watchdog                	| [ld   (_sfr_watchdog),a]
	move.b	d0,(a1)                         	| [ld   (de),a]
	addq.w	#1,a1                           	| [inc  de]
	subq.w	#1,a4                           	| [dec  bc]
	move.b	d1,d0                           	| [ld   a,b]
	or.b	d2,d0                             	| [or   c]
	jne	_wr_aaaa_loop                      	| [jr   nz,_wr_aaaa_loop]

	lea	0x8000(pc),a1                  	| [ld   de,#0x8000]
	lea	l_AAAA(pc),a0                      	| [ld   hl,#0xAAAA]
	move.b	#0x04,d1                        	| [ld   bc,#0x0400] 1024
	move.b	#0x00,d2                        	| [ld   bc,#0x0400] 1024
_rd_aaaa_loop:
	move.b	d6,d0                           	| [ld   a,l]
	eor.b	d5,d0                            	| [xor  h]
	not.b	d0                               	| [cpl]
	add.b	d0,d0                            	| [add  a,a]
	add.b	d0,d0                            	| [add  a,a]
adc  hl,hl
	move.b	(a1),d0                         	| [ld   a,(de)]
	eor.b	d6,d0                            	| [xor  l]
	jne	j_ramtest_ng                       	| [jp   nz,j_ramtest_ng]
	addq.w	#1,a1                           	| [inc  de]
	move.b	d0,_sfr_watchdog                	| [ld   (_sfr_watchdog),a]
	subq.w	#1,a4                           	| [dec  bc]
	move.b	d1,d0                           	| [ld   a,b]
	or.b	d2,d0                             	| [or   c]
	jne	_rd_aaaa_loop                      	| [jr   nz,_rd_aaaa_loop]

	jbsr	exx                               	| [exx] load outer loop count
     ^^^^ TODO: review special instruction inputs
	subq.b	#1,d1                           	| [dec  b] giant_loop_counter--
	jne	_tileram_test_loop                 	| [jp   nz,_tileram_test_loop]
*  } // end while tile ram test loop

*  color RAM, tile RAM, and data RAM tests.
ld   sp,#0x8000 + 0x0400               ; tmp stack for function calls

	lea	m_color_ram(pc),a1                 	| [ld   de,#m_color_ram]
	jbsr	c_ram_test_block                  	| [call c_ram_test_block]

	lea	ds_8800_RAM0(pc),a1                	| [ld   de,#ds_8800_RAM0] $0400 bytes
	jbsr	c_ram_test_block                  	| [call c_ram_test_block]

	lea	ds_9000_RAM1(pc),a1                	| [ld   de,#ds_9000_RAM1] $0400 bytes
	jbsr	c_ram_test_block                  	| [call c_ram_test_block]

	lea	ds20_99E0(pc),a0                   	| [ld   hl,#ds20_99E0] reset 00's to 9000 task tbl ($20 bytes)
	lea	ds_cpu0_task_actv(pc),a1           	| [ld   de,#ds_cpu0_task_actv] reset 00's from 99E0_mchn_data ($20 bytes)
	move.b	#0x00,d1                        	| [ld   bc,#0x0020] 32
	move.b	#0x20,d2                        	| [ld   bc,#0x0020] 32
	jbsr	ldir                              	| [ldir]
     ^^^^ TODO: review special instruction inputs

	lea	ds_9800_RAM2(pc),a1                	| [ld   de,#ds_9800_RAM2] $0400 bytes
	jbsr	c_ram_test_block                  	| [call c_ram_test_block]

	lea	ds_cpu0_task_actv(pc),a0           	| [ld   hl,#ds_cpu0_task_actv] reset 00's to 99E0_mchn_data ($20 bytes)
	lea	ds20_99E0(pc),a1                   	| [ld   de,#ds20_99E0] reset 00's from 9000 task tbl ($20 bytes)
	move.b	#0x00,d1                        	| [ld   bc,#0x0020] 32
	move.b	#0x20,d2                        	| [ld   bc,#0x0020] 32
	jbsr	ldir                              	| [ldir]
     ^^^^ TODO: review special instruction inputs

ld   sp,#ds_8800_RAM0 + 0x0300             ; tmp stack for function calls
	lea	0x8000(pc),a1                  	| [ld   de,#0x8000] 8000-83ff Video RAM
	jbsr	c_ram_test_block                  	| [call c_ram_test_block]

	jbsr	c_tileram_regs_clr                	| [call c_tileram_regs_clr]

	lea	str_3B7E(pc),a0                    	| [ld   hl,#str_3B7E] load start address of src string "RAM  OK"
	jbsr	c_text_out                        	| [call c_text_out] display "RAM  OK"

	move.b	d0,_sfr_watchdog                	| [ld   (_sfr_watchdog),a]
	jbsr	c_svc_clr_snd_regs                	| [call c_svc_clr_snd_regs] $9AA0, $40 bytes

* enable f_05BE in CPU-sub1 (empty task) ... disabled in game_ctrl start
	move.b	#7,d0                           	| [ld   a,#7]
	move.b	d0,ds_cpu1_task_actv+0x00       	| [ld   (ds_cpu1_task_actv + 0x00),a] 7 ... skips to f_05BE in CPU-sub task-table

	jbsr	c_spriteposn_regs_init            	| [call c_spriteposn_regs_init]
	jra	j_romtest_mgr                      	| [jp   j_romtest_mgr] should jr back to Test_menu_init

*=============================================================================
* c_ram_test_block()
*  Description:
*   call ram_test_single repeatedly.
* IN:
*  ...
* OUT:
*  ...
*-----------------------------------------------------------------------------
c_ram_test_block:
	move.b	#0x1E,d1                        	| [ld   b,#0x1E] count
	move.w	#0x0000,d5                      	| [ld   hl,#0x0000] 0
l_3484:
	movem.w	d1/d2,-(sp)                    	| [push bc]
	jbsr	c_ram_test_single                 	| [call c_ram_test_single]

	movem.w	(sp)+,d1/d2                    	| [pop  bc]
	subq.b	#1,d1                           	| [...]
	jne	l_3484                             	| [djnz l_3484]
	rts                                    	| [ret]
* end

*=============================================================================
* c_ram_test_single()
*  Description:
* IN:
*  ...
* OUT:
*  ...
*-----------------------------------------------------------------------------
c_ram_test_single:
	movem.w	d3/d4,-(sp)                    	| [push de]
	move.l	a1,-(sp)                        	| [push de]

	move.l	a0,-(sp)                        	| [push hl]
	move.b	#0x04,d1                        	| [ld   bc,#0x0400] 1024
	move.b	#0x00,d2                        	| [ld   bc,#0x0400] 1024
l_3491:
	move.b	d6,d0                           	| [ld   a,l]
	eor.b	d5,d0                            	| [xor  h]
	not.b	d0                               	| [cpl]
	add.b	d0,d0                            	| [add  a,a]
	add.b	d0,d0                            	| [add  a,a]
adc  hl,hl
	move.b	d6,d0                           	| [ld   a,l]
	move.b	d0,_sfr_watchdog                	| [ld   (_sfr_watchdog),a]
	move.b	d0,(a1)                         	| [ld   (de),a]
	addq.w	#1,a1                           	| [inc  de]
	subq.w	#1,a4                           	| [dec  bc]
	move.b	d1,d0                           	| [ld   a,b]
	or.b	d2,d0                             	| [or   c]
	jne	l_3491                             	| [jr   nz,l_3491]
	move.l	(sp)+,a0                        	| [pop  hl]
	move.l	(sp)+,a1                        	| [pop  de]
	movem.w	(sp)+,d3/d4                    	| [pop  de]
	movem.w	d3/d4,-(sp)                    	| [push de]
	move.l	a1,-(sp)                        	| [push de]
	move.b	#0x04,d1                        	| [ld   bc,#0x0400] 1024
	move.b	#0x00,d2                        	| [ld   bc,#0x0400] 1024
l_34A9:
	move.b	d6,d0                           	| [ld   a,l]
	eor.b	d5,d0                            	| [xor  h]
	not.b	d0                               	| [cpl]
	add.b	d0,d0                            	| [add  a,a]
	add.b	d0,d0                            	| [add  a,a]
adc  hl,hl
	move.b	(a1),d0                         	| [ld   a,(de)]
	eor.b	d6,d0                            	| [xor  l]
	jne	j_ramtest_ng                       	| [jp   nz,j_ramtest_ng]
	addq.w	#1,a1                           	| [inc  de]
	move.b	d0,_sfr_watchdog                	| [ld   (_sfr_watchdog),a]
	subq.w	#1,a4                           	| [dec  bc]
	move.b	d1,d0                           	| [ld   a,b]
	or.b	d2,d0                             	| [or   c]
	jne	l_34A9                             	| [jr   nz,l_34A9]
	move.l	(sp)+,a1                        	| [pop  de]
	movem.w	(sp)+,d3/d4                    	| [pop  de]
	rts                                    	| [ret]

*=============================================================================
* j_ramtest_ng()
*  Description:
*   Handle no-good ram test, do diagnostics and loop forever.
* IN:
*  ...
* OUT:
*  ...
*-----------------------------------------------------------------------------
j_ramtest_ng:
	move.b	d0,d1                           	| [ld   b,a]
	move.b	d3,d0                           	| [ld   a,d]
	roxr.b	#2,d0                           	| [rra] * 2
      ^^^^^^ TODO: review cpu X flag
	and.b	#0x07,d0                         	| [and  #0x07]
	cmp.b	#4,d0                            	| [cp   #4]
	jcs	l_34CB                             	| [jr   c,l_34CB]
	subq.b	#1,d0                           	| [dec  a]
l_34CB:
	cmp.b	#5,d0                            	| [cp   #5]
	jcs	l_34D0                             	| [jr   c,l_34D0]
	subq.b	#1,d0                           	| [dec  a]
l_34D0:
	move.b	d0,d4                           	| [ld   e,a]
	move.b	d1,d0                           	| [ld   a,b]
	move.b	#0x15,d3                        	| [ld   d,#0x15]
	and.b	#0x0F,d0                         	| [and  #0x0F]
	jne	l_34DA                             	| [jr   nz,l_34DA]
	move.b	#0x11,d3                        	| [ld   d,#0x11]
l_34DA:
	move.b	d0,_sfr_watchdog                	| [ld   (_sfr_watchdog),a]
	jbsr	exx                               	| [exx]
     ^^^^ TODO: review special instruction inputs
	lea	0x8000(pc),a0                  	| [ld   hl,#0x8000]
	lea	0x8000+0x01(pc),a1             	| [ld   de,#0x8000 + 0x01]
	move.b	#0x04,d1                        	| [ld   bc,#0x0400] 1024
	move.b	#0x00,d2                        	| [ld   bc,#0x0400] 1024
	move.b	#0x24,(a0)                      	| [ld   (hl),#0x24]
	jbsr	ldir                              	| [ldir]
     ^^^^ TODO: review special instruction inputs
	clr.b	(a0)                             	| [ld   (hl),#0x00]
	move.b	#0x03,d1                        	| [ld   bc,#0x03FF] 1023
	move.b	#0xff,d2                        	| [ld   bc,#0x03FF] 1023
	jbsr	ldir                              	| [ldir]
     ^^^^ TODO: review special instruction inputs
	move.b	d0,_sfr_watchdog                	| [ld   (_sfr_watchdog),a]
	jbsr	exx                               	| [exx]
     ^^^^ TODO: review special instruction inputs
	lea	0x8000+0x02E0+0x02(pc),a0      	| [ld   hl,#0x8000 + 0x02E0 + 0x02]
	move.b	#0x1B,(a0)                      	| [ld   (hl),#0x1B]
	move.b	#0xE0,d0                        	| [ld   a,#0xE0]
	subq.b	#1,d5                           	| [dec  h]
	jbsr	rst_10                            	| [rst  0x10] HL += A
	move.b	#0x0A,(a0)                      	| [ld   (hl),#0x0A]
	move.b	#0xE0,d0                        	| [ld   a,#0xE0]
	subq.b	#1,d5                           	| [dec  h]
	jbsr	rst_10                            	| [rst  0x10] HL += A
	move.b	#0x16,(a0)                      	| [ld   (hl),#0x16]
	move.b	#0xA0,d0                        	| [ld   a,#0xA0]
	subq.b	#1,d5                           	| [dec  h]
	jbsr	rst_10                            	| [rst  0x10] HL += A
	move.b	d4,(a0)                         	| [ld   (hl),e]
	move.b	#0xE0,d0                        	| [ld   a,#0xE0]
	subq.b	#1,d5                           	| [dec  h]
	jbsr	rst_10                            	| [rst  0x10] HL += A
	move.b	d3,(a0)                         	| [ld   (hl),d]

* same as spriteposn_vregs_init
	lea	sfr_sprite_posn(pc),a0             	| [ld   hl,#sfr_sprite_posn] $80 bytes
	move.b	#0x80,d1                        	| [ld   b,#0x80]
l_3516:
	move.b	#0xF1,(a0)                      	| [ld   (hl),#0xF1] init value
	addq.w	#1,a0                           	| [inc  hl]
	subq.b	#1,d1                           	| [...]
	jne	l_3516                             	| [djnz l_3516]

l_ramtest_ng_4ever:
	move.b	d0,_sfr_watchdog                	| [ld   (_sfr_watchdog),a]
	jra	l_ramtest_ng_4ever                 	| [jp   l_ramtest_ng_4ever]

*=============================================================================
* c_rom_test_csum_calc()
*  Description:
*   C is set to $00 by the caller, indicating the expected checksum
*   result. Adding the last byte of each rom section results in a 0 checksum.
* IN:
*  ...
* OUT:
*  ...
*-----------------------------------------------------------------------------
c_rom_test_csum_calc:

	move.l	a0,-(sp)                        	| [push hl]
	exg	a1,a0                              	| [ex   de,hl] Swap the starting address from DE to HL.
	move.b	#0x10,d3                        	| [ld   d,#0x10] Set the MSB of the number of bytes to be summed ($1000)
	clr.b	d0                               	| [xor  a] A==$00
	move.b	d0,d1                           	| [ld   b,a] B==$00, so we now have BC==00. The first dec will roll
                                                  * thru to $FF, giving an effective count of $100.
l_3527:
	add.b	(a0),d0                          	| [add  a,(hl)] Begin the checksum loop, with start address now in HL
	move.b	d0,_sfr_watchdog                	| [ld   (_sfr_watchdog),a]
	addq.w	#1,a0                           	| [inc  hl]
	subq.b	#1,d1                           	| [...]
	jne	l_3527                             	| [djnz l_3527] CPU 1 & CPU 2 kick in around the time this is first called
	subq.b	#1,d3                           	| [dec  d]
	jne	l_3527                             	| [jr   nz,l_3527] The MSB of the repeat count is the outer loop count.
	exg	a1,a0                              	| [ex   de,hl]
	move.l	(sp)+,a0                        	| [pop  hl]
	cmp.b	d2,d0                            	| [cp   c] final sum must be $00
	bne.b	0f                               	| [...]
	rts                                    	| [ret  z] end 'call c_rom_test_csum_calc' [...]
0:

*=============================================================================
* j_romtest_ng()
*  Description:
*   Loops for ever if any rom checksum is failed.
*   this code segment also used for CPU1 or CPU2 failed checksum
*
*  ROM test status flags:
*  $9100 = 0  CPU-sub rom test status, pause/resume (and returns test result)
*  $9101 = 0  CPU-sub2 rom test status, pause/resume (and returns test result)
*  $9102      CPU0 test state: 1->$0000, 2->$1000 ... 4->$3000 $FF->CPU0 ROM test complete
*             Error code, failed ROM test (either sub CPU), passed as parameter to subroutine.
*
* IN:
*  ...
* OUT:
*  ...
*-----------------------------------------------------------------------------
j_romtest_ng:
	lea	str_3B88(pc),a0                    	| [ld   hl,#str_3B88]
	jbsr	c_text_out                        	| [call c_text_out]
	lea	0x8000+0x0240+0x04(pc),a1      	| [ld   de,#0x8000 + 0x0240 + 0x04]
	lea	ds_rom_test_status+0x02(pc),a0     	| [ld   hl,#ds_rom_test_status + 0x02] load error code
	clr.b	d0                               	| [xor  a]
	jbsr	rld                               	| [rld] rld  (hl)
     ^^^^ TODO: review special instruction inputs
	move.b	d0,(a1)                         	| [ld   (de),a]
	jbsr	rst_20                            	| [rst  0x20] DE-=$20
	clr.b	d0                               	| [xor  a]
	jbsr	rld                               	| [rld] rld  (hl)
     ^^^^ TODO: review special instruction inputs
	move.b	d0,(a1)                         	| [ld   (de),a]
l_romtest_ng_4ever:
	move.b	d0,_sfr_watchdog                	| [ld   (_sfr_watchdog),a]
	jra	l_romtest_ng_4ever                 	| [jp   l_romtest_ng_4ever]

*=============================================================================
* j_romtest_mgr()
*  Description:
*   Coordinate ROM tests between multiple CPUs.
*   jp here following end of RAM tests.
* IN:
*  ...
* OUT:
*  ...
*-----------------------------------------------------------------------------
j_romtest_mgr:
	lea	ds_rom_test_status(pc),a0          	| [ld   hl,#ds_rom_test_status] initialize 3 bytes

	clr.b	(a0)                             	| [ld   (hl),#0x00] (9101) = 0 ... resume CPUsub1
	addq.w	#1,a0                           	| [inc  hl]
	clr.b	(a0)                             	| [ld   (hl),#0x00] (9101) = 0 ... resume CPUsub2
	addq.w	#1,a0                           	| [inc  hl]
	move.b	#0x01,(a0)                      	| [ld   (hl),#0x01] (9102) = 1 ... checking CPU0-region $0000

	clr.b	d0                               	| [xor  a]
	move.b	d0,b_svc_test_snd_slctn         	| [ld   (b_svc_test_snd_slctn),a] 0 (init the test-mode sound-selection variable.)
	addq.b	#1,d0                           	| [inc  a]
	move.b	d0,0x6823                       	| [ld   (0x6823),a] 1 (enable sub CPUs)
          ^^^^^^ TODO: review absolute 16-bit address write

	move.w	#0x0000,d3                      	| [ld   de,#0x0000] start address of test ($1000 bytes are checked per call) 0
	clr.b	d2                               	| [ld   c,#0]
	jbsr	c_rom_test_csum_calc              	| [call c_rom_test_csum_calc]
	addq.b	#1,(a0)                         	| [inc  (hl)] ($9102) = 2 (checking CPU0-region $1000)
	clr.b	d2                               	| [ld   c,#0]
	jbsr	c_rom_test_csum_calc              	| [call c_rom_test_csum_calc]
	addq.b	#1,(a0)                         	| [inc  (hl)] ($9102) = 3 (checking CPU0-region $2000)
	clr.b	d2                               	| [ld   c,#0]
	jbsr	c_rom_test_csum_calc              	| [call c_rom_test_csum_calc]
	addq.b	#1,(a0)                         	| [inc  (hl)] ($9102) = 4 (checking CPU0-region $3000)
	clr.b	d2                               	| [ld   c,#0]
	jbsr	c_rom_test_csum_calc              	| [call c_rom_test_csum_calc]

	move.b	#0xFF,(a0)                      	| [ld   (hl),#0xFF] ($9102) = $FF (CPU0 complete)

l_CPU1_rom_test:
	move.b	ds_rom_test_status+0x00,d0      	| [ld   a,(ds_rom_test_status + 0x00)] check for CPU1 test result
	move.b	d0,_sfr_watchdog                	| [ld   (_sfr_watchdog),a]
	tst.b	d0                               	| [and  a]
	jeq	l_CPU1_rom_test                    	| [jr   z,l_CPU1_rom_test] wait for result (non-zero)

	addq.b	#1,d0                           	| [inc  a] $FF+1=0
	jeq	l_CPU2_rom_test                    	| [jr   z,l_CPU2_rom_test]
	subq.b	#1,d0                           	| [dec  a]
	move.b	d0,ds_rom_test_status+0x02      	| [ld   (ds_rom_test_status + 0x02),a] grab error code...
	jra	j_romtest_ng                       	| [jp   j_romtest_ng] ...ends in infinite loop

l_CPU2_rom_test:
	move.b	ds_rom_test_status+0x01,d0      	| [ld   a,(ds_rom_test_status + 0x01)] check for CPU1 test result
	move.b	d0,_sfr_watchdog                	| [ld   (_sfr_watchdog),a]
	tst.b	d0                               	| [and  a]
	jeq	l_CPU2_rom_test                    	| [jr   z,l_CPU2_rom_test] wait for result (non-zero)

	addq.b	#1,d0                           	| [inc  a] $FF+1=0
	jeq	j_Test_menu_init                   	| [jr   z,j_Test_menu_init] DONE... JP to SVC MODE!

	subq.b	#1,d0                           	| [dec  a]
	move.b	d0,ds_rom_test_status+0x02      	| [ld   (ds_rom_test_status + 0x02),a] grab error code...
	jra	j_romtest_ng                       	| [jp   j_romtest_ng] ...ends in infinite loop

*
d_params_switch_mode:
	.byte 0x05,0x05,0x05,0x05
d_params_snd_test:
	.byte 0x30,0x40,0x00,0x02,0xDF
	.byte 0x40,0x30,0x30,0x03,0xDF
	.byte 0x10,0x20

*=============================================================================
* j_Test_menu_init()
*  Description:
*   jr here from completion of ROM tests.
*   'RAM OK' and 'ROM OK' actually shown right side up, but then in ShowCfg the
*   flip screen gets set because of the check that is done on the IO input value.
* IN:
*  ...
* OUT:
*  ...
*-----------------------------------------------------------------------------
j_Test_menu_init:
	lea	str_3B88(pc),a0                    	| [ld   hl,#str_3B88] ld src address of string "ROM  OK"
	jbsr	c_text_out                        	| [call c_text_out] display "ROM OK"
	jbsr	c_svc_updt_dsply                  	| [call c_svc_updt_dsply] prints remaining dsw configured options (upside down)

* memset( rom_test_status,0,3)
	lea	ds_rom_test_status(pc),a0          	| [ld   hl,#ds_rom_test_status] memset(...,0,3)...allows sub CPUs to resume.
	move.b	#3,d1                           	| [ld   b,#3]
l_35C3:
	clr.b	(a0)                             	| [ld   (hl),#0]
	addq.w	#1,a0                           	| [inc  hl]
	subq.b	#1,d1                           	| [...]
	jne	l_35C3                             	| [djnz l_35C3]

* Initialize scheduler table before interrupts are enabled (otherwise task scheduler could infinite loop!)
	move.b	#0x20,d0                        	| [ld   a,#0x20]
	move.b	d0,ds_cpu0_task_actv+0          	| [ld   (ds_cpu0_task_actv + 0),a] $20 ... only task 0 (empty task) can be called

* set IO controller state - $05 (go in "switch" mode)
	lea	d_params_switch_mode(pc),a0        	| [ld   hl,#d_params_switch_mode] IO data (05,05,05,05)
	lea	l_7000(pc),a1                      	| [ld   de,#0x7000] IO data xfer (write)
	move.b	#0x00,d1                        	| [ld   bc,#0x0004] num IO params 4
	move.b	#0x04,d2                        	| [ld   bc,#0x0004] num IO params 4
	jbsr	exx                               	| [exx] swap args to shadow regs
     ^^^^ TODO: review special instruction inputs
	move.b	#0xA1,d0                        	| [ld   a,#0xA1]
	*move.b	d0,0x7100                       	| [ld   (0x7100),a] IO cmd ( $A1 -> go into switch mode)
          ^^^^^^ TODO: review absolute 16-bit address write
	move.b	d0,_sfr_watchdog                	| [ld   (_sfr_watchdog),a]
	jbsr	c_io_cmd_wait                     	| [call c_io_cmd_wait]

	clr.b	d0                               	| [xor  a]
	move.b	d0,_sfr_watchdog                	| [ld   (_sfr_watchdog),a]

* wait 02 frames to verify that CPU-sub1 is alive and updating the frame counter
	move.b	d0,ds3_92A0_frame_cts+0         	| [ld   (ds3_92A0_frame_cts + 0),a] 0
*  while ( frame_cnt != 2 )
l_35E9:
	move.b	ds3_92A0_frame_cts+0,d0         	| [ld   a,(ds3_92A0_frame_cts + 0)]
	cmp.b	#2,d0                            	| [cp   #2]
	jne	l_35E9                             	| [jr   nz,l_35E9]

* setup IO command params
	lea	d_params_snd_test(pc),a0           	| [ld   hl,#d_params_snd_test]
	lea	l_7000(pc),a1                      	| [ld   de,#0x7000] IO data xfer (write)
	move.b	#0x00,d1                        	| [ld   bc,#0x000C] num IO params 12
	move.b	#0x0c,d2                        	| [ld   bc,#0x000C] num IO params 12
	jbsr	exx                               	| [exx]
     ^^^^ TODO: review special instruction inputs
	move.b	#0xA8,d0                        	| [ld   a,#0xA8]
	*move.b	d0,0x7100                       	| [ld   (0x7100),a] IO cmd ($A8 -> bang sound)
          ^^^^^^ TODO: review absolute 16-bit address write

	move.b	d0,_sfr_watchdog                	| [ld   (_sfr_watchdog),a]
	jbsr	c_io_cmd_wait                     	| [call c_io_cmd_wait]

* setup interrupt mode and toggle the latch (enable cpu0_rst38)
	move.b	d0,_sfr_watchdog                	| [ld   (_sfr_watchdog),a]
im   1
	lea	_sfr_6820(pc),a0                   	| [ld   hl,#_sfr_6820] maincpu irq acknowledge/enable
	clr.b	(a0)                             	| [ld   (hl),#0]
	move.b	#1,(a0)                         	| [ld   (hl),#1] enable IRQ1
ei

	jbsr	c_svc_test_sound_sel              	| [call c_svc_test_sound_sel]

* wait 8 frames (while test sound??)
	clr.b	d0                               	| [xor  a]
	move.b	d0,ds3_92A0_frame_cts+0         	| [ld   (ds3_92A0_frame_cts + 0),a] 0
* while ( frame_cnt != 8 )
l_3619:
	move.b	ds3_92A0_frame_cts+0,d0         	| [ld   a,(ds3_92A0_frame_cts + 0)]
	and.b	#0x08,d0                         	| [and  #0x08]
	jeq	l_3619                             	| [jr   z,l_3619]


*=============================================================================
* j_Test_menu_proc()
*  Description:
*   Process runner for test menu selection.
*   If the svc switch is NOT set, it simply continues to Machine Init.
* IN:
*  ...
* OUT:
*  ...
* TODO: put the PORT defintions from MAME in here somewhere as reference
* e.g.
*   PORT_SERVICE( 0x08, IP_ACTIVE_LOW )
*
* IO Input Registers for "switch" mode
*   [0] test switch & credits in
*       $7D fire 2
*       $7E fire 1
*       $7B 1 start
*       $77 2 start
*       $6F coin 1
*       $5F coin 2
*       $3F 'service 1' (99999999)
*   [1] control panel 1
*       $F7 (L)
*       $FD (R)
*   [2] control panel 2 (table-top cabinet cfg)
*       $7F (L)
*       $DF (R)
*
*-----------------------------------------------------------------------------
j_Test_menu_proc:

* synchronize with next frame transition.

* prev_frame_cts[0] = frame_cts[0]
	move.b	ds3_92A0_frame_cts+0,d0         	| [ld   a,(ds3_92A0_frame_cts + 0)] Get t0.
	move.b	d0,d2                           	| [ld   c,a]

*  while ( frame_cts[0] == prev_frame_cts[0] )
l_3624:
	move.b	ds3_92A0_frame_cts+0,d0         	| [ld   a,(ds3_92A0_frame_cts + 0)] Get t1.
	cmp.b	d2,d0                            	| [cp   c]
	jeq	l_3624                             	| [jr   z,l_3624]

* 9110-9116 used as temp array to capture/debounce successive input states.
	move.w	b_svc_test_inp_buf+0x06(pc),a0  	| [ld   hl,#(b_svc_test_inp_buf + 0x06)]
                  ^^^^^^ TODO: review move.w into address register
	move.w	b_svc_test_inp_buf+0x07(pc),a1  	| [ld   de,#(b_svc_test_inp_buf + 0x07)]
                  ^^^^^^ TODO: review move.w into address register
	move.b	#0x00,d1                        	| [ld   bc,#0x0007] 7
	move.b	#0x07,d2                        	| [ld   bc,#0x0007] 7
lddr                                       ; (9117):=(9116) etc. etc.
                                                  * HL==910F, DE==9110
	exg	a1,a0                              	| [ex   de,hl] HL:=9110  ( debounce[0] )
* (3636)
*  if ( IN0H_8 == INACTIVE ) goto Machine_init
	move.w	ds3_99B5_io_input+0x00(pc),a1   	| [ld   de,#(ds3_99B5_io_input + 0x00)]
                  ^^^^^^ TODO: review move.w into address register
	move.b	(a1),d0                         	| [ld   a,(de)]
	btst.b	#7,d0                           	| [bit  7,a] ACTIVE_LOW i.e. if bit_7==1 switch is off
	jne	j_36BA_Machine_init                	| [jp   nz,j_36BA_Machine_init]

* Read IN0 (button conditions) into B
	move.b	d0,(a0)                         	| [ld   (hl),a] save new input value to debounce[0]
	addq.w	#1,a0                           	| [inc  hl]
	or.b	(a0),d0                           	| [or   (hl)] Trigger on input received now t(0) or t(-1) ...
	addq.w	#1,a0                           	| [inc  hl]
	not.b	d0                               	| [cpl] A:=~A (1's compl.)
	and.b	(a0),d0                          	| [and  (hl)] Input stimulus is new if not active at t(-2)
	addq.w	#1,a0                           	| [inc  hl]
	and.b	(a0),d0                          	| [and  (hl)] Checking against saved condition of last frame...
	move.b	d0,(a0)                         	| [ld   (hl),a] ... and save the input condition this frame.
	move.b	d0,d1                           	| [ld   b,a] stash the button condition in B for now...

* Read IN1 (stick conditions) into B
	addq.w	#1,a0                           	| [inc  hl] HL:=9114
	addq.w	#1,a1                           	| [inc  de] DE:=99b6  (stick input from IN1)
	move.b	(a1),d0                         	| [ld   a,(de)]
	move.b	d0,(a0)                         	| [ld   (hl),a] save new input value to debounce[4]
	addq.w	#1,a0                           	| [inc  hl]
	or.b	(a0),d0                           	| [or   (hl)] or t(-1) value
	addq.w	#1,a0                           	| [inc  hl]
	not.b	d0                               	| [cpl]
	and.b	(a0),d0                          	| [and  (hl)] not t(-2)
	addq.w	#1,a0                           	| [inc  hl]
	and.b	(a0),d0                          	| [and  (hl)] and t(-1) condition
	move.b	d0,(a0)                         	| [ld   (hl),a] ... and save the input condition this frame.
	move.b	d0,d6                           	| [ld   l,a] grab the stick condition

	move.b	d1,d5                           	| [ld   h,b] grab button condition from B

* active low input states are now inverted in HL.
* Successive left shifts (into Cy) with the countdown in B indicate the active input.
	move.b	#0x10,d1                        	| [ld   b,#0x10] counter...
l_3659:
*  for ( B==16; B>0; B-- ) { if (bit_set) call input_hdlr }
	add.w	d5,a0                            	| [add  hl,hl] does left shift (into Cy)
  ^^^^ TODO: review d5 computation above
	bcc.b	0f                               	| [...]
	jbsr	c_svc_test_input_hdlr             	| [call c,c_svc_test_input_hdlr]
0:
	subq.b	#1,d1                           	| [...]
	jne	l_3659                             	| [djnz l_3659]

	jbsr	c_svc_updt_dsply                  	| [call c_svc_updt_dsply] this also flips the screen back to "normal"

* Check timer to erase Machine Totals info.
* First time here, timer register contains stray data from tests and is
* not specifically initialized. Resulting countdown time about 14 minutes...
* Timer is reset to 15 seconds after data is displayed the first time..
*  if ( 15sec_tmr == 0 ) goto 3672
	move.w	w_svc_15sec_tmr(pc),a0          	| [ld   hl,(w_svc_15sec_tmr)] lsb first)
                  ^^^^^^ TODO: review move.w into address register
	move.b	d5,d0                           	| [ld   a,h]
	or.b	d6,d0                             	| [or   l]
	jeq	l_3672                             	| [jr   z,l_3672]

*  else if ( --15sec_tmr == 0 ) clr_999999()
	subq.w	#1,a0                           	| [dec  hl]
	move.b	a0,w_svc_15sec_tmr              	| [ld   (w_svc_15sec_tmr),hl] timer--
	move.b	d5,d0                           	| [ld   a,h]
	or.b	d6,d0                             	| [or   l]
	bne.b	0f                               	| [...]
	jbsr	c_svc_machine_ttls_erase          	| [call z,c_svc_machine_ttls_erase]
0:

l_3672:
	move.b	b_svc_test_inp_buf+0x00,d0      	| [ld   a,(b_svc_test_inp_buf + 0x00)] check fire button... (non-debounced)
	roxr.b	#1,d0                           	| [rra] right-rotate IN0L_0 (into Cy) ...
      ^^^^^^ TODO: review cpu X flag
	jcc	l_367F                             	| [jr   nc,l_367F] active_low, Cy==0 if active (start new sound)
	clr.b	d0                               	| [xor  a]
	move.b	d0,b_svc_eastregg_keyprs_cnt    	| [ld   (b_svc_eastregg_keyprs_cnt),a] 0 (reset count)
	jra	j_Test_menu_proc                   	| [jp   j_Test_menu_proc]

* Fire Button hit... start new sound (kills last one)
l_367F:
	move.b	b_svc_test_inp_buf+0x07,d0      	| [ld   a,(b_svc_test_inp_buf + 0x07)] check stick input conditions for left/right
	and.b	#0x0F,d0                         	| [and  #0x0F] f7=left, fd=right (active low) (i.e. conditions are 8 left, 2 right)
	jeq	j_Test_menu_proc                   	| [jp   z,j_Test_menu_proc]

	move.b	d0,d2                           	| [ld   c,a] holding Fire button DOWN then pushing stick left or right. (pc=3687)
	lea	d_easteregg_trigger(pc),a0         	| [ld   hl,#d_easteregg_trigger]
	lea	b_svc_eastregg_keyprs_cnt(pc),a1   	| [ld   de,#b_svc_eastregg_keyprs_cnt]
	move.b	(a1),d0                         	| [ld   a,(de)] always 0 ...?
	jbsr	rst_10                            	| [rst  0x10] HL += A
	move.b	(a0),d0                         	| [ld   a,(hl)] d_easteregg_trigger[0]
	cmp.b	d2,d0                            	| [cp   c]
	jeq	l_3699                             	| [jr   z,l_3699]
	clr.b	d0                               	| [xor  a] pushed stick left (always a==02 from table[0])
	move.b	d0,(a1)                         	| [ld   (de),a] keyprs_cnt = 0
	jra	j_Test_menu_proc                   	| [jp   j_Test_menu_proc]

l_3699:
	exg	a1,a0                              	| [ex   de,hl] pushed stick right
	addq.b	#1,(a0)                         	| [inc  (hl)] (9271):=1
	addq.w	#1,a1                           	| [inc  de] 3783
	move.b	(a1),d0                         	| [ld   a,(de)] A = 2
	addq.b	#1,d0                           	| [inc  a] A = 3
	jne	j_Test_menu_proc                   	| [jp   nz,j_Test_menu_proc]

* easter egg time: get here and it will put c1981 NAMCO LTD. in huge characters!
	jbsr	c_tileram_regs_clr                	| [call c_tileram_regs_clr]
	jbsr	c_spriteposn_regs_init            	| [call c_spriteposn_regs_init]

	lea	d_easteregg_data(pc),a1            	| [ld   de,#d_easteregg_data]
	lea	0x8000+0x0040+0x02(pc),a0      	| [ld   hl,#0x8000 + 0x0040 + 0x02]

	move.b	#0x1C,d1                        	| [ld   b,#0x1C] each count is 1 column (28)
*  while ( b-- != 0 ) call EasterEgg
l_36AF:
	jbsr	c_svc_easteregg_hdlr              	| [call c_svc_easteregg_hdlr]
	subq.b	#1,d1                           	| [...]
	jne	l_36AF                             	| [djnz l_36AF]

* easter egg screen... checking IO input...
*  while( test_switch_on ) {}
l_36B4:
	move.b	ds3_99B5_io_input+0x00,d0       	| [ld   a,(ds3_99B5_io_input + 0x00)] check for test switch
	add.b	d0,d0                            	| [add  a,a] active low... $80+$80 sets carry if off.
	jcc	l_36B4                             	| [jr   nc,l_36B4]

* fall through to machine_init

*=============================================================================
* j_36BA_Machine_init()
*  Description:
*   Waits a short delay by the frame counter, re-checks Test-switch prior to
*   display of the cross hatch test pattern before "normal" startup.
*
*     Per Bally Manual "If you wish to keep this test pattern on the monitor screen
*     for futher use, slide Self-Test switch back to the "ON" position after the
*     cross hatch appears and before it disappears."
*
*   Once the Test-switch is turned Off, proceeds to set the IO controller to "credit"
*   mode and waits for input data to start (IO data requests are being done in the
*   "Task manager" periodic process.
* IN:
*  ...
* OUT:
*  ...
*-----------------------------------------------------------------------------
j_36BA_Machine_init:
** wait 8 frame counts
*	clr.b	d0                               	| [xor  a]
*	move.b	d0,ds3_92A0_frame_cts+0         	| [ld   (ds3_92A0_frame_cts + 0),a] 0
**  while ( vtimer < 0x08 ) {}
*l_36BE:
*	move.b	ds3_92A0_frame_cts+0,d0         	| [ld   a,(ds3_92A0_frame_cts + 0)]
*	cmp.b	#8,d0                            	| [cp   #8]
*	jcs	l_36BE                             	| [jr   c,l_36BE]
*
**  Make sure Test-switch is Off before proceeding? (not sure how it could get
**  out of Self-test mode if it were on.... ???)
**  if ( test_switch_on ) { goto test_menu }
*	move.b	ds3_99B5_io_input+0x00,d0       	| [ld   a,(ds3_99B5_io_input + 0x00)] check for test switch
*	add.b	d0,d0                            	| [add  a,a] active low... $80+$80 sets carry if off.
*	jcc	j_Test_menu_proc                   	| [jp   nc,j_Test_menu_proc]
*
*	jbsr	c_spriteposn_regs_init            	| [call c_spriteposn_regs_init]
*
** drawing the cross hatch pattern - tile ram layout is pretty clumsy!
*	lea	0x8000(pc),a0                  	| [ld   hl,#0x8000]
*
*	move.b	#0x10,d1                        	| [ld   b,#0x10]
*l_36D4:
*	move.b	#0x28,(a0)                      	| [ld   (hl),#0x28]
*	addq.w	#1,a0                           	| [inc  hl]
*	move.b	#0x27,(a0)                      	| [ld   (hl),#0x27]
*	addq.w	#1,a0                           	| [inc  hl]
*	subq.b	#1,d1                           	| [...]
*	jne	l_36D4                             	| [djnz l_36D4]
*
*	move.b	#0x10,d1                        	| [ld   b,#0x10]
*l_36DE:
*	move.b	#0x2D,(a0)                      	| [ld   (hl),#0x2D]
*	addq.w	#1,a0                           	| [inc  hl]
*	move.b	#0x2B,(a0)                      	| [ld   (hl),#0x2B]
*	addq.w	#1,a0                           	| [inc  hl]
*	subq.b	#1,d1                           	| [...]
*	jne	l_36DE                             	| [djnz l_36DE]
*
*	move.b	#0x10,d1                        	| [ld   b,#0x10]
*l_36E8:
*	move.b	#0x28,(a0)                      	| [ld   (hl),#0x28]
*	addq.w	#1,a0                           	| [inc  hl]
*	move.b	#0x2D,(a0)                      	| [ld   (hl),#0x2D]
*	addq.w	#1,a0                           	| [inc  hl]
*	subq.b	#1,d1                           	| [...]
*	jne	l_36E8                             	| [djnz l_36E8]
*
*	move.b	#0x10,d1                        	| [ld   b,#0x10]
*l_36F2:
*	move.b	#0x27,(a0)                      	| [ld   (hl),#0x27]
*	addq.w	#1,a0                           	| [inc  hl]
*	move.b	#0x2B,(a0)                      	| [ld   (hl),#0x2B]
*	addq.w	#1,a0                           	| [inc  hl]
*	subq.b	#1,d1                           	| [...]
*	jne	l_36F2                             	| [djnz l_36F2]
*
** remainder of cross hatch pattern is copied, i.e.  *(0x8000 + DE) = *(0x8000 + HL)
*	exg	a1,a0                              	| [ex   de,hl]
*
*	lea	0x8000+0x0040(pc),a0           	| [ld   hl,#0x8000 + 0x0040] DE==$8080
*	move.b	#0x03,d1                        	| [ld   bc,#0x0340] 832
*	move.b	#0x40,d2                        	| [ld   bc,#0x0340] 832
*	jbsr	ldir                              	| [ldir]
*     ^^^^ TODO: review special instruction inputs
*
*	lea	0x8000(pc),a0                  	| [ld   hl,#0x8000] DE==$83C0
*	move.b	#0x00,d1                        	| [ld   bc,#0x0040] 64
*	move.b	#0x40,d2                        	| [ld   bc,#0x0040] 64
*	jbsr	ldir                              	| [ldir]
*     ^^^^ TODO: review special instruction inputs
*
** wait about two seconds before checking Test-switch.
*	clr.b	d0                               	| [xor  a]
*	move.b	d0,ds3_92A0_frame_cts+0         	| [ld   (ds3_92A0_frame_cts + 0),a] :=0
**  while ( vtimer < 0x80 ) {}
*l_370F:
*	move.b	ds3_92A0_frame_cts+0,d0         	| [ld   a,(ds3_92A0_frame_cts + 0)]
*	add.b	d0,d0                            	| [add  a,a] count $80
*	jcc	l_370F                             	| [jr   nc,l_370F]
*
** if you wish to keep this test pattern on the monitor ...slide switch back to ON
**  while( test_switch_on ) {}
*l_3715:
*	move.b	ds3_99B5_io_input+0x00,d0       	| [ld   a,(ds3_99B5_io_input + 0x00)] check for test switch
*	add.b	d0,d0                            	| [add  a,a] active low... $80+$80 sets carry if off.
*	jcc	l_3715                             	| [jr   nc,l_3715]
*
*di
*	jbsr	c_io_cmd_wait                     	| [call c_io_cmd_wait]
*
**  timer = -2...  while ( timer != 0 ) {}
*	move.b	#-2,d0                          	| [ld   a,#-2]
*	move.b	d0,ds3_92A0_frame_cts+0         	| [ld   (ds3_92A0_frame_cts + 0),a] :=$FE) (-2)
*l_3724:
*	move.b	ds3_92A0_frame_cts+0,d0         	| [ld   a,(ds3_92A0_frame_cts + 0)]
*	                               	| [and  a]
*	jne	l_3724                             	| [jr   nz,l_3724]
*
*	move.b	d0,_sfr_watchdog                	| [ld   (_sfr_watchdog),a]
*
**  do {
*l_372D:
** setup for IO cmd $E1 - typical values might be:
**        01 01 01 01 01 02 03 00 .....Mame interprets as follows:
** 01 + 4 arguments: set coinage
** 02: go in "credit" mode and enable start buttons
** 03: disable joystick remapping (Galaga needs only L/R joy indications)
** 00: nop
*	lea	ds8_9280_tmp_IO_parms(pc),a0       	| [ld   hl,#ds8_9280_tmp_IO_parms] writing default IO params for credit-mode (8 bytes)
*	lea	l_7000(pc),a1                      	| [ld   de,#0x7000] IO data xfer (write)
*	move.b	#0x00,d1                        	| [ld   bc,#0x0008] 8
*	move.b	#0x08,d2                        	| [ld   bc,#0x0008] 8
*	jbsr	exx                               	| [exx]
*     ^^^^ TODO: review special instruction inputs
*	move.b	#0xE1,d0                        	| [ld   a,#0xE1]
*	*move.b	d0,0x7100                       	| [ld   (0x7100),a] IO cmd ($E1 -> go into credit mode)
*          ^^^^^^ TODO: review absolute 16-bit address write
*	jbsr	c_io_cmd_wait                     	| [call c_io_cmd_wait]
*
** Wait for valid status from IO controller?
** Setup for IO cmd $B1 ...read 3 bytes (num credits, plyr 1, plyr 2)
*	lea	l_7000(pc),a0                      	| [ld   hl,#0x7000] IO data xfer (read)
*	lea	ds3_9288_tmp_IO_data(pc),a1        	| [ld   de,#ds3_9288_tmp_IO_data]
*	move.b	#0x00,d1                        	| [ld   bc,#0x0003] 3
*	move.b	#0x03,d2                        	| [ld   bc,#0x0003] 3
*	jbsr	exx                               	| [exx]
*     ^^^^ TODO: review special instruction inputs
*	move.b	#0xB1,d0                        	| [ld   a,#0xB1] IO command "only issued after $E1" (go into credit mode)
*	*move.b	d0,0x7100                       	| [ld   (0x7100),a] IO cmd ($B1 -> reading/polling data)
*          ^^^^^^ TODO: review absolute 16-bit address write
*	jbsr	c_io_cmd_wait                     	| [call c_io_cmd_wait]
*
**  } while ( a > $a0                    	|| ( a & $0f > $09 ) )
*	move.b	ds3_9288_tmp_IO_data,d0         	| [ld   a,(ds3_9288_tmp_IO_data)] $FF if in test-mode when test switch off...
*	cmp.b	#0xA1,d0                         	| [cp   #0xA1] $A0 (100d) may be valid for credit mode? so compare to $A1
*	jcc	l_372D                             	| [jr   nc,l_372D] generate a Cy if A<$A1
*	and.b	#0x0F,d0                         	| [and  #0x0F]
*	cmp.b	#0x0A,d0                         	| [cp   #0x0A] in credit mode bcd digits should be less than 9
*	jcc	l_372D                             	| [jr   nc,l_372D]
*
** svc switch off... let'er rip!
*ei
*	clr.b	d0                               	| [xor  a]
*	move.b	d0,0x8000+0x0200+0x10       	| [ld   (0x8000 + 0x0200 + 0x10),a] 0 in middle of screen
	jbsr	osd_enable_interrupts
	jra	j_Game_init_02d3                        	| [jp   j_Game_init_02d3]


*=============================================================================
* c_svc_easteregg_hdlr()
*  Description:
*   Easter Egg screen!
* IN:`
*  ...
* OUT:
*  ...
*-----------------------------------------------------------------------------
c_svc_easteregg_hdlr:
	jbsr	c_3774                            	| [call c_3774]
	jbsr	c_3774                            	| [call c_3774]
	jbsr	c_3774                            	| [call c_3774]
	move.b	#0x05,d0                        	| [ld   a,#0x05]
	jra	rst_HLplusA                        	| [jp   rst_HLplusA] returns to caller from HLplusA

*=============================================================================
* c_3774()
*  Description:
* IN:
*  ...
* OUT:
*  ...
*-----------------------------------------------------------------------------
c_3774:
	move.b	(a1),d0                         	| [ld   a,(de)]
	move.b	#8,d2                           	| [ld   c,#8]
l_3777:
	add.b	d0,d0                            	| [add  a,a]
	jcc	l_377B                             	| [jr   nc,l_377B]
	addq.b	#1,(a0)                         	| [inc  (hl)]
l_377B:
	addq.w	#1,a0                           	| [inc  hl]
	subq.b	#1,d2                           	| [dec  c]
	jne	l_3777                             	| [jr   nz,l_3777]
	addq.w	#1,a1                           	| [inc  de]
	addq.w	#1,a0                           	| [inc  hl]
	rts                                    	| [ret]

*=============================================================================
* control input sequence to trigger Easter Egg.
* ... 5R 6L 3R 7L
d_easteregg_trigger:
	.byte 0x02,0x02,0x02,0x02,0x02
	.byte 0x08,0x08,0x08,0x08,0x08,0x08
	.byte 0x02,0x02,0x02
	.byte 0x08,0x08,0x08,0x08,0x08,0x08,0x08
	.byte 0xFF

* easter egg screen data
d_easteregg_data:
	.byte 0x01,0x3E,0x00,0x7F,0x41,0x00,0x21,0x41,0x00,0x00
	.byte 0x41,0x00,0x36,0x3E,0x00,0x49,0x00,0x03,0x49,0x22,0x03,0x49,0x41,0x00,0x36,0x41
	.byte 0x3E,0x00,0x3E,0x41,0x3E,0x00,0x41,0x49,0x7F,0x41,0x49,0x20,0x7F,0x49,0x18,0x00
	.byte 0x32,0x20,0x40,0x00,0x7F,0x40,0x01,0x00,0x7F,0x7F,0x3F,0x40,0x21,0x44,0x40,0x00
	.byte 0x44,0x00,0x3C,0x44,0x01,0x42,0x3F,0x01,0x81,0x00,0x01,0xA5,0x7F,0x01,0xA5,0x04
	.byte 0x7F,0x99,0x08,0x00,0x42,0x10,0x00,0x3C,0x7F,0x00

*=============================================================================
* c_io_cmd_wait()
*  Description:
*   wait for IO_ACKRDY "command executed" ($10) read from IO chip status sfr.
* IN:
*  ...
* OUT:
*  ...
*-----------------------------------------------------------------------------
c_io_cmd_wait:
while_io_cmd_wait:
	move.b	0x7100,d0                       	| [ld   a,(0x7100)] read IO status
       ^^^^^^ TODO: review absolute 16-bit address read
	cmp.b	#0x10,d0                         	| [cp   #0x10]
	bne.b	0f                               	| [...]
	rts                                    	| [ret  z] [...]
0:
	jra	while_io_cmd_wait                  	| [jr   while_io_cmd_wait]


_l_37F4:



*=============================================================================
* c_svc_updt_dsply()
*  Description:
*   Displays dip switch configuration in test screen.
* IN:
*  ...
* OUT:
*  ...
*   Switches are active low, i.e. OFF -> 1, ON -> 0
*   Bally machine apparently does not have a config switch for the cab type.
*   DSWA is not the same as NAMCO.
*   Notes from Mame136 galaga.c:
*   The Cabinet Type "dip switch" actually comes from the edge connector, but is mapped
*   in memory in place of dip switch #8. dip switch #8 selects single/dual coin counters
*   and is entirely handled by hardware.
*
*   DSWA -> sfr_dsw_X:1 (6J)
*                         SW#8 SW#7 SW#6 SW#5 SW#4 SW#3 SW#2 SW#1
*            DIFFICULTY      -    -    -    -    -    -    X    X
*               UNKNOWN      -    -    -    -    -    X    -    -  (@ f_0ECA)
* SOUND IN ATTRACT MODE      -    -    -    -    X    -    -    -
*          FREEZE VIDEO      -    -    -    X    -    -    -    -
*          CABINET TYPE      X    -    -    -    -    -    -    -
*
*  DSWB -> sfr_dsw_X:0 (6K)
*                      SW#8 SW#7 SW#6 SW#5 SW#4 SW#3 SW#2 SW#1
*   COINS PER CREDIT      -    -    -    -    -    X    X    X
*  BONUS SHIPS AWARD      -    -    X    X    X    -    -    -
*    NBR OF FIGHTERS      X    X    -    -    -    -    -    -
*
*
*-----------------------------------------------------------------------------
c_svc_updt_dsply:

* CABINET TYPE (DSWA)
* 0x80 -> UPRIGHT
* 0x00 -> TABLE

	move.b	_sfr_dsw8,d0                    	| [ld   a,(_sfr_dsw8)] cabinet type
	roxr.b	#1,d0                           	| [rra] get DSWA#8 (sfr_dsw8:1)
      ^^^^^^ TODO: review cpu X flag
* inverting the bit provides the index
	addq.b	#1,d0                           	| [inc  a] invert bit in bit-0
	and.b	#0x01,d0                         	| [and  #0x01]
	move.b	d0,b_mchn_cfg_cab_type          	| [ld   (b_mchn_cfg_cab_type),a]
*  svc_cab_type( a )
	lea	str_3ACC(pc),a0                    	| [ld   hl,#str_3ACC] 0-"UPRIGHT", 1-"TABLE"
	jbsr	rst_08                            	| [rst  0x08] HL += 2A
	jbsr	c_svc_cab_type                    	| [call c_svc_cab_type]

* By pushing the "1 PLAYER" and the "2 PLAYER" buttons at the same time, the
* picture will turn updside down and stay that way until you release the buttons.
* If the buttons are not pushed, the picture stays inverted momentarily until
* a 0 is read from the IO chip (due to residual non-zero value left from memory test).
	move.b	ds3_99B5_io_input+0x00,d0       	| [ld   a,(ds3_99B5_io_input + 0x00)]
	clr.b	d2                               	| [ld   c,#0]
	and.b	#0x0C,d0                         	| [and  #0x0C] 08->2plyr_start, 04->1plyr_start
	jne	l_380F                             	| [jr   nz,l_380F]
	addq.b	#1,d2                           	| [inc  c] c:=1  (flips the screen)
l_380F:
	move.b	d2,d0                           	| [ld   a,c]
	*move.b	d0,0xA007                       	| [ld   (0xA007),a] flip screen control
          ^^^^^^ TODO: review absolute 16-bit address write

* DIFFICULTY LEVEL SETTING (DSWA)
*    0x00  = 0 -> A (MEDIUM)
*    0x01  = 1 -> C (HARD)
*    0x02  = 2 -> D (HARDEST)
*    0x03  = 3 -> A (EASY)

	lea	_sfr_dsw1(pc),a0                   	| [ld   hl,#_sfr_dsw1] difficulty level
	move.b	(a0),d0                         	| [ld   a,(hl)]
	roxr.b	#1,d0                           	| [rra] get DSWA#1 (sfr_dsw1:1)
      ^^^^^^ TODO: review cpu X flag
	and.b	#0x01,d0                         	| [and  #0x01]
	move.b	d0,d2                           	| [ld   c,a]

	addq.w	#1,a0                           	| [inc  hl]
	move.b	(a0),d0                         	| [ld   a,(hl)]
	and.b	#0x02,d0                         	| [and  #0x02] get DSWA#2 (sfr_dsw2:1)
	or.b	d2,d0                             	| [or   c] lo-bit in C
	move.b	d0,b_mchn_cfg_rank              	| [ld   (b_mchn_cfg_rank),a]

	lea	str_3A68(pc),a0                    	| [ld   hl,#str_3A68] base_address of rank-characters (B/C/D/A)
	jbsr	rst_10                            	| [rst  0x10] HL += A
	lea	0x8000+0x0220+0x0C(pc),a1      	| [ld   de,#0x8000 + 0x0220 + 0x0C] rank-character ("B", "C", "D", or "A")
	jbsr	ldi                               	| [ldi] (DE)<-(HL) ..."X" of "RANK X" displayed
     ^^^^ TODO: review special instruction inputs
	lea	str_3AE4(pc),a0                    	| [ld   hl,#str_3AE4] "RANK"
	jbsr	c_text_out                        	| [call c_text_out] display "RANK"


* NUMBER OF FIGHTERS (DSWB)
*     0x00 -> 2
*     0x40 -> 4
*     0x80 -> 3
*     0xC0 -> 5

* configuration setting is "number of fighters - 1"
	lea	_sfr_dsw7(pc),a0                   	| [ld   hl,#_sfr_dsw7] get DSWB#7 (sfr_dsw7:0)
	move.b	(a0),d0                         	| [ld   a,(hl)] hi-bit
	addq.w	#1,a0                           	| [inc  hl] get DSWB#8 (sfr_dsw8:0)
	move.b	(a0),d2                         	| [ld   c,(hl)] lo-bit
	roxr.b	#1,d2                           	| [rr   c] "right-shift" lo-bit into Cy flag.
      ^^^^^^ TODO: review cpu X flag
adc  a,a                                   ; "left-shift" the hi-bit and add the lo-bit from Cy flag.
	and.b	#0x03,d0                         	| [and  #0x03]
	addq.b	#1,d0                           	| [inc  a] this gives "cfg = nbr_of_ships - 1"
	move.b	d0,b_mchn_cfg_nships            	| [ld   (b_mchn_cfg_nships),a]

*  0x8000[$02EA] = mchn_cfg_nships + 1
	addq.b	#1,d0                           	| [inc  a]
	move.b	d0,0x8000+0x02E0+0x0A       	| [ld   (0x8000 + 0x02E0 + 0x0A),a] "X" of "X SHIPS" displayed
*  text_out($3AEB)
	lea	str_3AEB(pc),a0                    	| [ld   hl,#str_3AEB] "SHIPS"
	jbsr	c_text_out                        	| [call c_text_out]


* load default IO params (sets up credit-mode and joystick remapping - see _372D)
* 4 arguments to "set coinage" command (9281-4) will be updated below to capture
* dip switch changes for credit-mode.
	lea	d_3AC4(pc),a0                      	| [ld   hl,#d_3AC4]
	lea	ds8_9280_tmp_IO_parms(pc),a1       	| [ld   de,#ds8_9280_tmp_IO_parms] default IO params for credit-mode (8 bytes)
	move.b	#0x00,d1                        	| [ld   bc,#0x0008] 8
	move.b	#0x08,d2                        	| [ld   bc,#0x0008] 8
	jbsr	ldir                              	| [ldir]
     ^^^^ TODO: review special instruction inputs

* COINS PER CREDIT (DSWB)
*  Mask   SW#1 SW#2 SW#3
*  0x00   ON   ON   ON  - free play
*  0x04   ON   ON   OFF - 4-coin/1-credit
*  0x02   ON   OFF  ON  - 3-coin/1-credit
*  0x06   ON   OFF  OFF - 2-coin/1-credit
*  0x01   OFF  ON   ON  - 2-coin/3-credit
*  0x05   OFF  ON   OFF - 1-coin/3-credit
*  0x03   OFF  OFF  ON  - 1-coin/2-credit
*  0x07   OFF  OFF  OFF - 1-coin/1-credit

	lea	_sfr_dsw1(pc),a0                   	| [ld   hl,#_sfr_dsw1] coins per credit
	move.b	#3,d1                           	| [ld   b,#3] 3 bits
	clr.b	d0                               	| [xor  a]
l_385C:
	move.b	(a0),d2                         	| [ld   c,(hl)]
	roxr.b	#1,d2                           	| [rr   c] "right-shift" lo-bit into Cy flag.
      ^^^^^^ TODO: review cpu X flag
adc  a,a                                   ; "left-shift" the hi-bit and add the lo-bit from Cy flag.
	addq.w	#1,a0                           	| [inc  hl]
	subq.b	#1,d1                           	| [...]
	jne	l_385C                             	| [djnz l_385C]

	and.b	#0x07,d0                         	| [and  #0x07] 3-bits only please

* if ( free_play )
	jeq	l_389B                             	| [jr   z,l_389B]
* else  TableOffset=(Index-1)*8 ... resulting offsets are $00,$08,$10,$18,$20,$28,$30)
	subq.b	#1,d0                           	| [dec  a]
	add.b	d0,d0                            	| [add  a,a]
	add.b	d0,d0                            	| [add  a,a]
	add.b	d0,d0                            	| [add  a,a]

* Update 4 arguments to "set coinage" command from the table.
	lea	str_3A6C(pc),a0                    	| [ld   hl,#str_3A6C]
	jbsr	rst_10                            	| [rst  0x10] HL += A
	lea	ds8_9280_tmp_IO_parms+1(pc),a1     	| [ld   de,#ds8_9280_tmp_IO_parms + 1]
	move.b	#0x00,d1                        	| [ld   bc,#0x0004] 4
	move.b	#0x04,d2                        	| [ld   bc,#0x0004] 4
	jbsr	ldir                              	| [ldir]
     ^^^^ TODO: review special instruction inputs
* the next four bytes are the text characters
	lea	0x8000+0x02E0+0x08(pc),a1      	| [ld   de,#0x8000 + 0x02E0 + 0x08]
	jbsr	ldi                               	| [ldi] show digit for number of coins
     ^^^^ TODO: review special instruction inputs
	lea	0x8000+0x0220+0x08(pc),a1      	| [ld   de,#0x8000 + 0x0220 + 0x08]
	jbsr	ldi                               	| [ldi] show " " or "S"
     ^^^^ TODO: review special instruction inputs
	lea	0x8000+0x01E0+0x08(pc),a1      	| [ld   de,#0x8000 + 0x01E0 + 0x08]
	jbsr	ldi                               	| [ldi] show digit for number of credits
     ^^^^ TODO: review special instruction inputs
	lea	0x8000+0x00E0+0x08(pc),a1      	| [ld   de,#0x8000 + 0x00E0 + 0x08]
	jbsr	ldi                               	| [ldi] show " " or "S"
     ^^^^ TODO: review special instruction inputs

	move.b	#0x24,d0                        	| [ld   a,#0x24]
	move.b	d0,0x8000+0x0200+0x08       	| [ld   (0x8000 + 0x0200 + 0x08),a] shows a space after "COIN(S)"
	lea	str_3AF3(pc),a0                    	| [ld   hl,#str_3AF3] " COIN"
	jbsr	c_text_out                        	| [call c_text_out]
	jbsr	c_text_out                        	| [call c_text_out] "CREDIT" of "X CREDIT"
	jra	l_38AB                             	| [jr   l_38AB]

* Update 4 arguments to "set coinage" command from the table for free-play mode
l_389B:
	lea	ds8_9280_tmp_IO_parms+1(pc),a0     	| [ld   hl,#ds8_9280_tmp_IO_parms + 1] 4 bytes (arguments to "set coinage" command)
	move.b	#4,d1                           	| [ld   b,#4]
l_38A0:
	clr.b	(a0)                             	| [ld   (hl),#0]
	addq.w	#1,a0                           	| [inc  hl]
	subq.b	#1,d1                           	| [...]
	jne	l_38A0                             	| [djnz l_38A0]

	lea	str_3B04(pc),a0                    	| [ld   hl,#str_3B04]
	jbsr	c_text_out                        	| [call c_text_out] "FREE PLAY"

* Bonus Ships Awarded (DSWB)
* Mask  Selection    S#4 S#5 S#6    Index into table 3AA4
* 0x20  20-60-60     ON  ON  OFF    1
* 0x10  20-70-70     ON  OFF ON     2
* 0x30  20-80-80     ON  OFF OFF    3
* 0x08  30-100-100   OFF ON  ON     4
* 0x28  30-120-120   OFF ON  OFF    5
* 0x18  20-60        OFF OFF ON     6
* 0x38  30-80        OFF OFF OFF    7
* 0x00  None         ON  ON  ON     0
* Bonus config displayed in following format:
* 1ST BONUS  X0000 PTS
* 2ND BONUS XX0000 PTS
* AND EVERY XX0000 PTS

l_38AB:
	lea	_sfr_dsw4(pc),a0                   	| [ld   hl,#_sfr_dsw4] bonus levels

	move.b	#3,d1                           	| [ld   b,#3] 3 positions to read
	clr.b	d0                               	| [xor  a]
l_38B1:
	move.b	(a0),d2                         	| [ld   c,(hl)]
	roxr.b	#1,d2                           	| [rr   c] "right-shift" lo-bit into Cy flag.
      ^^^^^^ TODO: review cpu X flag
adc  a,a                                   ; "left-shift" the hi-bit and add the lo-bit from Cy flag.
	addq.w	#1,a0                           	| [inc  hl]
	subq.b	#1,d1                           	| [...]
	jne	l_38B1                             	| [djnz l_38B1]

*  if ( 0 == switch_selection ) goto 392D  // display "BONUS NOTHING", ret to 35be
	and.b	#0x07,d0                         	| [and  #0x07]
	jeq	l_392D                             	| [jp   z,l_392D]

	move.b	d0,d2                           	| [ld   c,a]
	move.b	b_mchn_cfg_nships,d0            	| [ld   a,(b_mchn_cfg_nships)] Bonus levels depend upon number of fighters starting.
	and.b	#0x04,d0                         	| [and  #0x04] note: num_ships = mchn_cfg_nships + 1
	add.b	d0,d0                            	| [add  a,a]
	add.b	d2,d0                            	| [add  a,c] add dsw value
	add.b	d0,d0                            	| [add  a,a] a:=a*2 ... use as offset into table
	lea	str_3AA4(pc),a0                    	| [ld   hl,#str_3AA4] bonus config data
	jbsr	rst_10                            	| [rst  0x10] HL += A...A==2,C,4,6,E,8,A
	lea	w_mchn_cfg_bonus(pc),a1            	| [ld   de,#w_mchn_cfg_bonus] ld two-bytes (str_3AA4)
	jbsr	ldi                               	| [ldi]
     ^^^^ TODO: review special instruction inputs
	jbsr	ldi                               	| [ldi]
     ^^^^ TODO: review special instruction inputs
	subq.w	#1,a0                           	| [dec  hl] point to second byte of two-byte Table entry
	move.b	#1,d2                           	| [ld   c,#1] flag tells 38DA that it was 'called' i.e. get out by return
	jbsr	c_38DA                            	| [call c_38DA] display 'second and every' bonus settings
	subq.w	#1,a0                           	| [dec  hl] point to first byte of two-byte table entry
	clr.b	d2                               	| [ld   c,#0] flag allows 3904 ret to occur

*=============================================================================
* c_38DA()
*  Description:
* IN:
*  ...
* OUT:
*  ...
*-----------------------------------------------------------------------------
c_38DA:
	move.b	(a0),d0                         	| [ld   a,(hl)] ld one byte from the two-byte table entry
	addq.b	#1,d0                           	| [inc  a] setup test for $FF in the bonus-none parameters
	jeq	l_393B                             	| [jp   z,l_393B] if 'bonus none', skip the 'second and every' display (when?)
	move.b	d2,d0                           	| [ld   a,c] first-pass (second-and-every) indicated by 1, second-pass indicated by 0..
	add.b	d0,d0                            	| [add  a,a] ...so A==2 or A==0  (offset from 3B1A to string address loaded into HL)

	move.l	a0,-(sp)                        	| [push hl] save address of table-entry
	lea	str_3B1A(pc),a0                    	| [ld   hl,#str_3B1A] i.e., 1E 3B "1ST BONUS ", 36 3B "2ND BONUS"
	jbsr	rst_10                            	| [rst  0x10] HL += A                                  ; HL += A
	move.b	(a0),d0                         	| [ld   a,(hl)] get LSB of src address
	addq.w	#1,a0                           	| [inc  hl]
	move.b	(a0),d5                         	| [ld   h,(hl)] get MSB of src address
	move.b	d0,d6                           	| [ld   l,a] ld LSB to L
	movem.w	d1/d2,-(sp)                    	| [push bc] C holds the so-called 'first-bonus/second-bonus' flag, save it!
	jbsr	c_text_out                        	| [call c_text_out] display "2ND BONUS" or "1ST BONUS"
	jbsr	c_text_out                        	| [call c_text_out] display "0000 PTS" of "??? BONUS XX0000 PTS"...
                                                  * HL==$3B2B or HL==$3B42, as there are two copies of "0000 PTS"
                                                  * DE==$80B2, that value will be used later......?

	movem.w	(sp)+,d1/d2                    	| [pop  bc] get back the first-pass-second-pass flag
	move.l	(sp)+,a0                        	| [pop  hl] get back the address of the table-entry
	move.b	(a0),d0                         	| [ld   a,(hl)] ld the table-entry...
	and.b	#0x7F,d0                         	| [and  #0x7F] ... and mask out bit-7 which indicates there is no 'and-every' setting
	exg	a1,a0                              	| [ex   de,hl] save address of table-entry in HL... DE==$80B2 (address of ' ' in "PTS ")
	lea	0x8000+0x01E0+0x10(pc),a0      	| [ld   hl,#0x8000 + 0x01E0 + 0x10]
	move.b	d2,d1                           	| [ld   b,c] the first time through here, C==1...
	subq.b	#1,d1                           	| [...]
	jne	l_38FF                             	| [djnz l_38FF] ... so the second time, when the Flag is 0 we skip next two lines
	addq.w	#2,a0                           	| [inc  hl] * 2
l_38FF:
	jbsr	c_391E                            	| [call c_391E] display "X" of "??? BONUS XX0000 PTS"
	exg	a1,a0                              	| [ex   de,hl] HL:= to second-or-first-table-entry again
	subq.b	#1,d2                           	| [dec  c] C:=$00 at end of first-pass...
	beq.b	0f                               	| [...]
	rts                                    	| [ret  nz] ...after second-pass, ret to _35BE, end 'call _37F4' (displaying dsw menu) [...]
0:
	exg	a1,a0                              	| [ex   de,hl] save the current bonus-parameter-table-entry into DE
	move.b	(a1),d0                         	| [ld   a,(de)] A:=$86 for 20-60 setting, the second of the two byte-parameters
	btst.b	#7,d0                           	| [bit  7,a] if (bit-7)...
	jne	l_3949                             	| [jp   nz,l_3949] ... then jp (bit test is Z flag... bit-7 set if no 'and-every' bonus)
	lea	0x8000+0x01E0+0x14(pc),a0      	| [ld   hl,#0x8000 + 0x01E0 + 0x14] address of character X in "AND EVERY X 0000 PTS"
	jbsr	c_391E                            	| [call c_391E] display XX of "AND EVERY XX0000 PTS"
	movem.w	d3/d4,-(sp)                    	| [push de]
	move.l	a1,-(sp)                        	| [push de]
	lea	str_3B4D(pc),a0                    	| [ld   hl,#str_3B4D] "AND EVERY"
	jbsr	c_text_out                        	| [call c_text_out]
	jbsr	c_text_out                        	| [call c_text_out] display "0000 PTS" of "AND EVERY XX0000 PTS"  ( HL expected to be $3B59)
	move.l	(sp)+,a0                        	| [pop  hl]
	rts                                    	| [ret]
* end 'call 38DA', ret to _38D7

*=============================================================================
* c_391E()
*  Description:
*   converts bonus levels to decimal and display on screen
*   on entry, HL==address_to_write_to
*               A==value from bonus-parameter-table
* IN:
*  ...
* OUT:
*  ...
*-----------------------------------------------------------------------------
c_391E:
	cmp.b	#0x0A,d0                         	| [cp   #0x0A] check if value if > 10
	move.b	#0x24,d1                        	| [ld   b,#0x24] start with a ' ' (space) character in B
	jcs	l_3928                             	| [jr   c,l_3928] if Cy, it means that A<$0A, so jr past the display of the 10's place digit
      ^^^^^^ TODO: review cpu flags (move.b,jcs)
	move.b	#1,d1                           	| [ld   b,#1] value is 10 or greater...
	sub.b	#0x0A,d0                         	| [sub  #0x0A] ...so subtract off the value of 10...
l_3928:
	move.b	d1,(a0)                         	| [ld   (hl),b] ...and write a "1" to screen for the "10's" place
	bclr.b	#5,d6                           	| [res  5,l] i.e.  HL:-=$20, which will offset 1 column to the right on the screen
	move.b	d0,(a0)                         	| [ld   (hl),a] write the "one's" place to the screen
	rts                                    	| [ret] end 'call _391E'
* jp here from 38BA
l_392D:
	lea	str_3B64(pc),a0                    	| [ld   hl,#str_3B64] "BONUS NOTHING"
	jbsr	c_text_out                        	| [call c_text_out]
	lea	w_mchn_cfg_bonus(pc),a0            	| [ld   hl,#w_mchn_cfg_bonus]
	move.b	#0xFF,(a0)                      	| [ld   (hl),#0xFF]
	addq.w	#1,a0                           	| [inc  hl]
	move.b	#0xFF,(a0)                      	| [ld   (hl),#0xFF]
* put space characters on the line where "2ND BONUS ?????? PTS" goes ( jp here from $38DC??? )
l_393B:
	exg	a1,a0                              	| [ex   de,hl] save HL
	lea	0x8000+0x0320+0x12(pc),a0      	| [ld   hl,#0x8000 + 0x0320 + 0x12]
	move.b	#0x16,d1                        	| [ld   b,#0x16] writing out $16 characters
* while ( b > 0 )
l_3941:
	move.b	#0x24,(a0)                      	| [ld   (hl),#0x24] space ' '
	move.b	#0xE0,d0                        	| [ld   a,#0xE0]
	subq.b	#1,d5                           	| [dec  h] effectively, HL:-=$100
	jbsr	rst_10                            	| [rst  0x10] HL += A, which adds back $E0, effectively we've done HL:-=$20
	subq.b	#1,d1                           	| [...]
	jne	l_3941                             	| [djnz l_3941]

* jp here from $3909... putting space character on the line where "AND EVERY ?????? PTS" goes
l_3949:
	lea	0x8000+0x0320+0x14(pc),a0      	| [ld   hl,#0x8000 + 0x0320 + 0x14]
	move.b	#0x16,d1                        	| [ld   b,#0x16]
l_394E:
	move.b	#0x24,(a0)                      	| [ld   (hl),#0x24]
	move.b	#0xE0,d0                        	| [ld   a,#0xE0]
	subq.b	#1,d5                           	| [dec  h]
	jbsr	rst_10                            	| [rst  0x10] HL += A
	subq.b	#1,d1                           	| [...]
	jne	l_394E                             	| [djnz l_394E]
	exg	a1,a0                              	| [ex   de,hl] see 393b
	rts                                    	| [ret] if jp'd to _392D, ret to _35BE... end 'call _37F4' (displaying dsw options)
                                                  * if jp'd to _393B,l_3949 end 'call 38DA', ret to _35BE

*=============================================================================
* c_tileram_regs_clr()
*  Description:
* IN:
*  ...
* OUT:
*  ...
*-----------------------------------------------------------------------------
c_tileram_regs_clr:
	lea	0x8000(pc),a0                  	| [ld   hl,#0x8000]
	lea	0x8000+0x01(pc),a1             	| [ld   de,#0x8000 + 0x01]
	move.b	#0x04,d1                        	| [ld   bc,#0x0400] 1024
	move.b	#0x00,d2                        	| [ld   bc,#0x0400] 1024
	move.b	#0x24,(a0)                      	| [ld   (hl),#0x24]
	jbsr	ldir                              	| [ldir]
     ^^^^ TODO: review special instruction inputs
	move.b	#3,(a0)                         	| [ld   (hl),#3] now filling in at $8400 (color ram)...
	move.b	#0x03,d1                        	| [ld   bc,#0x03FF] 1023
	move.b	#0xff,d2                        	| [ld   bc,#0x03FF] 1023
	jbsr	ldir                              	| [ldir]
     ^^^^ TODO: review special instruction inputs
	move.b	#7,d0                           	| [ld   a,#7] star ctrl default param
	move.b	d0,ds_99B9_star_ctrl+0x05       	| [ld   (ds_99B9_star_ctrl + 0x05),a] :=7
	rts                                    	| [ret]
* end call

*=============================================================================
* c_spriteposn_regs_init()
*  Description:
* IN:
*  ...
* OUT:
*  ...
*-----------------------------------------------------------------------------
c_spriteposn_regs_init:
	lea	sfr_sprite_posn(pc),a0             	| [ld   hl,##sfr_sprite_posn] $80 bytes
	move.b	#0x80,d1                        	| [ld   b,#0x80] length of sprite position regs
l_3977:
	move.b	#0xF1,(a0)                      	| [ld   (hl),#0xF1]
	addq.w	#1,a0                           	| [inc  hl]
	subq.b	#1,d1                           	| [...]
	jne	l_3977                             	| [djnz l_3977]
	rts                                    	| [ret] extra garbage on screen gone with RAM OK showing
* end call

*=============================================================================
* c_svc_machine_totals()
*  Description:
*   Show "remaining" counts of Games Played and Points Scored, in this format:
*   'XX.XYYY.YYYY.ZZZZ.ZAAA.'
*   The indicators are subtracted from their maximum...
*    i.e. 999-UUU=XXX or 9999999-UUUUUUU=YYYYYYY
*
*   XXX:     b16_99E0_ttl_plays_bcd  (lower 3 BCD nibbles only i.e. 0-999)
*
*   YYYYYYY: b32_99E2_sum_score_bcd  (lower 3 BCD nibbles only i.e. 0-999)
*
*   ZZZZZ:   b32_99E6_gametime_secs_bcd (5 BCD digits of seconds count ...
*            ... omit the 1/60th count)
*   AAA:     b16_99EA_bonus_ct_bcd  (lower 3 BCD nibbles only i.e. 0-999)
* IN:
*  ...
* OUT:
*  ...
* NOTE: the game time and bonus count would only be non-zero if the machine is
*       warm reset during a running game. MAME (136) doesn't seem to handle
*       warm reset properly and it hangs at "RAM OK".
*-----------------------------------------------------------------------------
c_svc_machine_totals:
	lea	b16_99E0_ttl_plays_bcd(pc),a0      	| [ld   hl,#b16_99E0_ttl_plays_bcd]
	lea	0x8000+0x0340+0x1E(pc),a1      	| [ld   de,#0x8000 + 0x0340 + 0x1E] at lower left of screen

* the first set has 2 digits, followed by the '.'
	move.b	#2,d2                           	| [ld   c,#2]

	move.b	#1,d1                           	| [ld   b,#1]
	jbsr	c_3997                            	| [call c_3997] XX.X

	move.b	#3,d1                           	| [ld   b,#3]
	jbsr	c_3997                            	| [call c_3997] ____YYY.YYYY

	move.b	#2,d1                           	| [ld   b,#2]
	jbsr	c_3997                            	| [call c_3997] HL=99E6

	addq.w	#1,a0                           	| [inc  hl] skip 1/60th part of timer.

	move.b	#1,d1                           	| [ld   b,#1]

* 3997 again ("inline")... do the bonus-count portion ("AAA")

*=============================================================================
* c_3997()
*  Description:
* IN:
*  ...
* OUT:
*  ...
*-----------------------------------------------------------------------------
c_3997:
	jbsr	c_39AA                            	| [call c_39AA]
l_399A:
	jbsr	c_39A0                            	| [call c_39A0] does 39AA also
	subq.b	#1,d1                           	| [...]
	jne	l_399A                             	| [djnz l_399A]
	rts                                    	| [ret]

*=============================================================================
* c_39A0()
*  Description:
* IN:
*  ...
* OUT:
*  ...
*-----------------------------------------------------------------------------
c_39A0:
	move.b	#0x99,d0                        	| [ld   a,#0x99]
	sub.b	(a0),d0                          	| [sub  (hl)]
	roxr.b	#4,d0                           	| [rra] * 4
	jbsr	c_39AE                            	| [call c_39AE]

* optimization: fall-through to c_39AA

*=============================================================================
* c_39AA()
*  Description:
* IN:
*  ...
* OUT:
*  ...
*-----------------------------------------------------------------------------
c_39AA:
	move.b	#0x99,d0                        	| [ld   a,#0x99]
	sub.b	(a0),d0                          	| [sub  (hl)]
	addq.w	#1,a0                           	| [inc  hl]

* optimization: fall through to call c_39AE

*=============================================================================
* c_39AE()
*  Description:
*   Put Digit.
*   The running count in C is checked... when ==0,  put the '.'
*   Updates tile position to right (-$20) for each character shown.
* IN:
*  A=character code to display.
*  C=remaining count of digits in the sequence
* OUT:
*  C=remaining count of digits in the sequence
*  DE= next tile position.
*-----------------------------------------------------------------------------
c_39AE:
	and.b	#0x0F,d0                         	| [and  #0x0F]
	move.b	d0,(a1)                         	| [ld   (de),a]
	jbsr	rst_20                            	| [rst  0x20] DE-=$20
	subq.b	#1,d2                           	| [dec  c]
	beq.b	0f                               	| [...]
	rts                                    	| [ret  nz] [...]
0:
	move.b	#0x2A,d0                        	| [ld   a,#0x2A] '.' character
	move.b	#4,d2                           	| [ld   c,#4]
	move.b	d0,(a1)                         	| [ld   (de),a]
	jbsr	rst_20                            	| [rst  0x20] DE-=$20
	rts                                    	| [ret]

*=============================================================================
* c_svc_machine_ttls_erase()
*  Description:
*   Erases Machine Totals
* IN:
*  ...
* OUT:
*  ...
*-----------------------------------------------------------------------------
c_svc_machine_ttls_erase:
	lea	0x8000+0x0340+0x1E(pc),a0      	| [ld   hl,#0x8000 + 0x0340 + 0x1E]

	move.b	#0x17,d1                        	| [ld   b,#0x17] nr of characters to fill
	lea	-l_20(pc),a1                       	| [ld   de,#-0x20]
l_39C3:
	move.b	#0x24,(a0)                      	| [ld   (hl),#0x24]
	add.w	d3,a0                            	| [add  hl,de]
  ^^^^ TODO: review d3 computation above
	subq.b	#1,d1                           	| [...]
	jne	l_39C3                             	| [djnz l_39C3]

	rts                                    	| [ret]

*=============================================================================
* c_svc_test_input_hdlr()
*  Description:
*   Handle inputs during Self-Test Mode.
*   Moving the controller left or right, and pressing any game button or
*   activating the coin switches results in the selection and activation of
*   the various game sounds.
*   There is also an additional mode, undocumented in the Bally Manual, which
*   displays the Machine Information if a "Service Switch" is activated.
*   This switch is not documented in the Bally manual.
*   MAME does however have a defintion of the switch, i.e.
*   	PORT_BIT( 0x04, IP_ACTIVE_LOW, IPT_SERVICE1 )
* IN:
*  B=countdown from $10 representing active input state in terms of
*     bit-position in HL.
* OUT:
*  saves BC, HL
*-----------------------------------------------------------------------------

* c_svc_test_input_hdlr : entry point is below...

l_39C9_call397D:

	move.l	a0,-(sp)                        	| [push hl]
	jbsr	c_svc_machine_totals              	| [call c_svc_machine_totals]

*  reset Machine Totals timer
	move.w	15*60(pc),a0                    	| [ld   hl,#(15 * 60)]
                  ^^^^^^ TODO: review move.w into address register
	move.b	a0,w_svc_15sec_tmr              	| [ld   (w_svc_15sec_tmr),hl] init timer (15*60)

	move.l	(sp)+,a0                        	| [pop  hl]

	movem.w	(sp)+,d1/d2                    	| [pop  bc]
	rts                                    	| [ret]

c_svc_test_input_hdlr:
	movem.w	d1/d2,-(sp)                    	| [push bc]
	move.b	d1,d0                           	| [ld   a,b] b==$10?  (_3657)
	cmp.b	#0xF,d0                          	| [cp   #0xF] IPT_SERVICE1 (MAME key_9)
	jeq	l_39C9_call397D                    	| [jr   z,l_39C9_call397D]
	cmp.b	#2,d0                            	| [cp   #2] If stick pushed right... 0x10 - 0x0E
	jeq	l_39F5                             	| [jr   z,l_39F5] ... then....
	cmp.b	#0x4,d0                          	| [cp   #0x4] else if stick pushed left...
	jne	l_3A21                             	| [jr   nz,l_3A21] ...else
	move.b	b_svc_test_snd_slctn,d0         	| [ld   a,(b_svc_test_snd_slctn)] ... then load the current sound selection...
	subq.b	#0x01,d0                        	| [sub  #0x01] ... and decrement.
	jcc	l_39ED                             	| [jr   nc,l_39ED] If no carry (negative wrap-around)...
	move.b	#0x11,d0                        	| [ld   a,#0x11] else wrap around to highest sound #17...
l_39ED:
	move.b	d0,b_svc_test_snd_slctn         	| [ld   (b_svc_test_snd_slctn),a]
	jra	j_39FC                             	| [jr   j_39FC]

*=============================================================================
* c_svc_test_sound_sel()
*  Description:
*   sound check
* IN:
*  ...
* OUT:
*  ...
*-----------------------------------------------------------------------------
c_svc_test_sound_sel:
	movem.w	d1/d2,-(sp)                    	| [push bc]
	jra	j_39FC                             	| [jr   j_39FC]

l_39F5:
	move.b	b_svc_test_snd_slctn,d0         	| [ld   a,(b_svc_test_snd_slctn)] stick was pushed right...
	addq.b	#1,d0                           	| [inc a] ... go to next higher sound selection.
	move.b	d0,b_svc_test_snd_slctn         	| [ld   (b_svc_test_snd_slctn),a] (save update sound selection)

j_39FC:
	move.b	b_svc_test_snd_slctn,d0         	| [ld   a,(b_svc_test_snd_slctn)] ... and get sound selection (in case jp'd here from decrement case).
	cmp.b	#0x12,d0                         	| [cp   #0x12] if incremented sound selection != $17...
	jcs	l_3A04                             	| [jr   c,#l_3A04] ... then ...
	clr.b	d0                               	| [xor  a] else let sound selection equal 0...
l_3A04:
	move.b	d0,b_svc_test_snd_slctn         	| [ld   (b_svc_test_snd_slctn),a]

	move.l	a0,-(sp)                        	| [push hl]
	clr.b	d2                               	| [ld   c,#0] character "0"
	cmp.b	#0x0A,d0                         	| [cp   #0x0A]
	jcs	l_3A11                             	| [jr   c,#l_3A11]
	addq.b	#1,d2                           	| [inc  c] when is that jr taken?
	sub.b	#0x0A,d0                         	| [sub  #0x0A]
l_3A11:
	lea	0x8000+0x0220+0x0E(pc),a0      	| [ld   hl,#0x8000 + 0x0220 + 0x0E] dest address of "0"
	move.b	d2,(a0)                         	| [ld   (hl),c] displayed "0" of "SOUND 00"
	move.b	#0x0E,d6                        	| [ld   l,#0x0E]
	move.b	d0,(a0)                         	| [ld   (hl),a] displayed (2nd) "0" of "SOUND 00"
	lea	str_3A47(pc),a0                    	| [ld   hl,#str_3A47]
	jbsr	c_text_out                        	| [call c_text_out] display "SOUND" of "SOUND 00"
	move.l	(sp)+,a0                        	| [pop  hl]

	movem.w	(sp)+,d1/d2                    	| [pop  bc]
	rts                                    	| [ret] end 'call _39F2' (sound check)
l_3A21:                                           ; ... else (stick not left or right)
	move.b	b_svc_test_snd_slctn,d0         	| [ld   a,(b_svc_test_snd_slctn)]
	cmp.b	#0x12,d0                         	| [cp   #0x12]
	jcs	l_3A29                             	| [jr   c,l_3A29]
	clr.b	d0                               	| [xor  a] (selection is never >$11 so the jr is always taken)
l_3A29:
	move.b	d0,b_svc_test_snd_slctn         	| [ld   (b_svc_test_snd_slctn),a]
	exg	a1,a0                              	| [ex   de,hl]
	jbsr	c_svc_clr_snd_regs                	| [call c_svc_clr_snd_regs]
	lea	d_3A4F(pc),a0                      	| [ld   hl,#d_3A4F] d_3A4F[ test_snd_slctn ]
	jbsr	rst_10                            	| [rst  0x10] HL += A
	move.b	(a0),d6                         	| [ld   l,(hl)]
	lea	b_9A00(pc),a0                      	| [ld   h,#>b_9A00] sound_fx_status[ d_3A4F[ test_snd_slctn ] ] = 1
	and.w	#0xFF,d6
	add.w	d6,a0
	      ^^^^ TODO: review XX value
	move.b	#1,(a0)                         	| [ld   (hl),#1]
	exg	a1,a0                              	| [ex   de,hl]

	movem.w	(sp)+,d1/d2                    	| [pop  bc]
	rts                                    	| [ret]

*=============================================================================
* c_svc_clr_snd_regs()
*  Description:
*   Initialize data structures for sound manager.
* IN:
*  ...
* OUT:
*  ...
*-----------------------------------------------------------------------------
c_svc_clr_snd_regs:
	lea	ds_9AA0(pc),a0                     	| [ld   hl,#ds_9AA0] sound mgr SFRs, clear $40 bytes
	move.b	#0x40,d1                        	| [ld   b,#0x40] length to fill
l_3A41:
	clr.b	(a0)                             	| [ld   (hl),#0] fill with 0
	addq.w	#1,a0                           	| [inc  hl]
	subq.b	#1,d1                           	| [...]
	jne	l_3A41                             	| [djnz l_3A41]
	rts                                    	| [ret]

*-----------------------------------------------------------------------------
str_3A47:
	.long 0x8000 + 0x02E0 + 0x0E
	.byte 0x05
	.byte 0x1C,0x18,0x1E,0x17,0x0D || "SOUND"

* offsets to $9AA0 count/enable for individual sound effects for sound-test selection
d_3A4F:
	.byte <b_9AA0 + 0x01  | 00
	.byte <b_9AA0 + 0x02  | 01
	.byte <b_9AA0 + 0x03  | 02
	.byte <b_9AA0 + 0x04  | 03
	.byte <b_9AA0 + 0x07  | 04
	.byte <b_9AA0 + 0x0A  | 05
	.byte <b_9AA0 + 0x0B  | 06
	.byte <b_9AA0 + 0x0C  | 07
	.byte <b_9AA0 + 0x0D  | 08
	.byte <b_9AA0 + 0x0E  | 09
	.byte <b_9AA0 + 0x0F  | 10
	.byte <b_9AA0 + 0x10  | 11
	.byte <b_9AA0 + 0x12  | 12
	.byte <b_9AA0 + 0x13  | 13
	.byte <b_9AA0 + 0x14  | 14
	.byte <b_9AA0 + 0x15  | 15
	.byte <b_9AA0 + 0x16  | 16
	.byte <b_9AA0 + 0x19  | 17

*=============================================================================
* c_svc_cab_type()
*  Description:
*   wrapper for c_text_out (dereferences the pointer passed in HL)
*   (caller is displaying the cab-type)
* IN:
*  ...
* OUT:
*  ...
*-----------------------------------------------------------------------------
c_svc_cab_type:
	move.b	(a0),d0                         	| [ld   a,(hl)] LSB
	addq.w	#1,a0                           	| [inc  hl]
	move.b	(a0),d5                         	| [ld   h,(hl)] MSB
	move.b	d0,d6                           	| [ld   l,a] LSB
	jra	c_text_out                         	| [jp   c_text_out] jp instead of calling so we only have to ret once
* (returns from subroutine at $331B)


*=============================================================================
*
* Text strings and other data
*
*-----------------------------------------------------------------------------

* text-characters for difficulty settings-MEDIUM,HARD,HARDEST,EASY respectively
str_3A68:
	.byte 0x0B,0x0C,0x0D,0x0A

* format characters for COIN/CREDIT display
str_3A6C:
	.byte 0x04,0x01,0x04,0x01,0x04,0x1C,0x01,0x24  || 4-coin(s)/1-credit( )
	.byte 0x03,0x01,0x03,0x01,0x03,0x1C,0x01,0x24  || 3-coin(s)/1-credit( )
	.byte 0x02,0x01,0x02,0x01,0x02,0x1C,0x01,0x24  || 2-coin(s)/1-credit( )
	.byte 0x02,0x03,0x02,0x03,0x02,0x1C,0x03,0x1C  || 2-coin(s)/3-credit(s)
	.byte 0x01,0x03,0x01,0x03,0x01,0x24,0x03,0x1C  || 1-coin( )/3-credit(s)
	.byte 0x01,0x02,0x01,0x02,0x01,0x24,0x02,0x1C  || 1-coin( )/2-credit(s)
	.byte 0x01,0x01,0x01,0x01,0x01,0x24,0x01,0x24  || 1-coin( )/1-credit( )

* bonus-setting parameters...e.g. $02,$06 -> "20000-60000-60000"
str_3AA4:
	.byte 0xFF,0xFF        || NO BONUS SHIPS GIVEN WITH THIS SETTING
          ^^^^^^ TODO: review absolute 16-bit address write
	.byte 0x02,0x06
	.byte 0x02,0x07
	.byte 0x02,0x08
	.byte 0x03,0x0A
	.byte 0x03,0x0C
	.byte 0x02,0x06 + 0x80 || bit-7 means there's no 'and-every' bonus
          ^^^^^^ TODO: review absolute 16-bit address write
	.byte 0x03,0x08 + 0x80 || bit-7 means there's no 'and-every' bonus
          ^^^^^^ TODO: review absolute 16-bit address write

* ???????????
str_3AB4:
	.byte 0xFF,0xFF,0x03,0x0A,0x03,0x0C,0x03,0x0F,0x03,0x8A,0x03,0x8C,0x03,0x8F,0x03,0xFF

* default params for IO test
d_3AC4:
	.byte 0x01,0x01,0x01,0x01,0x01,0x02,0x03,0x00

* pointers to cabinet-types strings.
str_3ACC:
	.long str_3AD0                               | pointer to "UPRIGHT" text
	.long str_3ADA                               | pointer to "TABLE" text
str_3AD0:
	.long 0x8000 + 0x02E0 + 0x06
	.byte 0x07
	.byte 0x1E,0x19,0x1B,0x12,0x10,0x11,0x1D || "UPRIGHT"
str_3ADA:
	.long 0x8000 + 0x02E0 + 0x06
	.byte 0x07
	.byte 0x1D,0x0A,0x0B,0x15,0x0E,0x24,0x24 || "TABLE  "
str_3AE4:
	.long 0x8000 + 0x02E0 + 0x0C
	.byte 0x04
	.byte 0x1B,0x0A,0x17,0x14 || "RANK",
str_3AEB:
	.long 0x8000 + 0x02A0 + 0x0A
	.byte 0x05
	.byte 0x1C,0x11,0x12,0x19,0x1C || "SHIPS",
str_3AF3:
	.long 0x8000 + 0x02C0 + 0x08
	.byte 0x05
	.byte 0x24,0x0C,0x18,0x12,0x17 || " COIN",
str_3AFB:
	.long 0x8000 + 0x01A0 + 0x08
	.byte 0x06
	.byte 0x0C,0x1B,0x0E,0x0D,0x12,0x1D || "CREDIT"
str_3B04:
	.long 0x8000 + 0x02E0 + 0x08
	.byte 0x12
	.byte 0x0F,0x1B,0x0E,0x0E,0x24,0x19,0x15,0x0A,0x22 || "FREE PLAY"
	.byte 0x24,0x24,0x24,0x24,0x24,0x24,0x24,0x24,0x24
	.byte 0x24 || extra space character?
str_3B1A:
	.long str_1ST_BONUS
	.long str_2ND_BONUS
str_1ST_BONUS:
	.long 0x8000 + 0x0330
	.byte 0x0A
	.byte 0x01,0x1C,0x1D,0x24,0x0B,0x18,0x17,0x1E,0x1C,0x24 || "1ST BONUS "
str_3B2B:
	.long 0x8000 + 0x01B0
	.byte 0x08
	.byte 0x00,0x00,0x00,0x00,0x24,0x19,0x1D,0x1C || "0000 PTS"
str_2ND_BONUS:
	.long 0x8000 + 0x0320 + 0x12
	.byte 0x09
	.byte 0x02,0x17,0x0D,0x24,0x0B,0x18,0x17,0x1E,0x1C || "2ND BONUS"
str_3B42:
	.long 0x8000 + 0x01B0 + 0x02
	.byte 0x08
	.byte 0x00,0x00,0x00,0x00,0x24,0x19,0x1D,0x1C || "0000 PTS"
str_3B4D:
	.long 0x8000 + 0x0320 + 0x14
	.byte 0x09
	.byte 0x0A,0x17,0x0D,0x24,0x0E,0x1F,0x0E,0x1B,0x22 || "AND EVERY"
str_3B59:
	.long 0x8000 + 0x01A0 + 0x14
	.byte 0x08
	.byte 0x00,0x00,0x00,0x00,0x24,0x19,0x1D,0x1C || "0000 PTS"
str_3B64:
	.long 0x8000 + 0x0320 + 0x10
	.byte 0x16
	.byte 0x0B,0x18,0x17,0x1E,0x1C,0x24,0x17,0x18,0x1D,0x11,0x12,0x17,0x10 || "BONUS NOTHING"
	.byte 0x24,0x24,0x24,0x24,0x24,0x24,0x24,0x24,0x24
	.byte 0x24 || this seems to be extra character
str_3B7E:
	.long 0x8000 + 0x02E0 + 0x02
	.byte 0x07
	.byte 0x1B,0x0A,0x16,0x24,0x24,0x18,0x14 || "RAM  OK"
str_3B88:
	.long 0x8000 + 0x02E0 + 0x04
	.byte 0x07
	.byte 0x1B,0x18,0x16,0x24,0x24,0x18,0x14 || "ROM  OK"


_l_3B92:

*       .org 0x3FFF
*       .db 0x2E                                   ; checksum

*
* input file gg1-5.s
*
* gg1-5.s
*  gg1-5.3f, CPU 'sub' (Z80)
*
.module cpu_sub

.include "sfrs.inc"
.include "structs.inc"
.include "gg1-5.dep"

.BANK cpu_sub (BASE=0x000000, FSFX=_sub)
.area ROM (ABS,OVR,BANK=cpu_sub)


*.org 0x0000

*=============================================================================
* RST_00()
*  Description:
* IN:
*  ...
* OUT:
*  ...
*-----------------------------------------------------------------------------
rst_00_cpu1:
ld   sp,#ds_stk_cpu1_init
	jra	CPU1_RESET                         	| [jp   CPU1_RESET]

*.org 0x0008

*=============================================================================
* RST_08()
*  Description:
*
* IN:
*  ...
* OUT:
*  ...
*-----------------------------------------------------------------------------
rst_08:
	add.b	d0,d0                            	| [add  a,a]
	jcc	_RST_10                            	| [jr   nc,_RST_10]
	addq.b	#1,d5                           	| [inc  h] when?
	jra	_RST_10                            	| [jp   _RST_10]

*.org 0x0010

*=============================================================================
* RST_10()
*  Description:
*   HL += A
* IN:
*
* OUT:
*  ...
*-----------------------------------------------------------------------------
_RST_10:
	LOAD_D5_16_FROM_D5D6
	and.w	#0xFF,d0
	add.w	d0,d5
	LOAD_D5D6_FROM_D5_16
	   	| [add  a,l]
	  	| [ld   l,a]
	   	| [...]
	 	| [ret  nc] [...]
	  	| [inc  h] when?
	rts                                    	| [ret]

*.org 0x0018

*=============================================================================
* RST_18()
*  Description:
*   Is not referenced by rst (when does this get used? - same as sub2 ROM)
* IN:
*  ...
* OUT:
*  ...
*-----------------------------------------------------------------------------
_RST_18:
	move.b	d0,(a0)                         	| [ld   (hl),a]
	addq.w	#1,a0                           	| [inc  hl]
	subq.b	#1,d1                           	| [...]
	jne	_RST_18                            	| [djnz _RST_18]
	rts                                    	| [ret]


rst_18_video:
* memset((HL), A=fill, B=ct)
	exg		a0,d7
0:
	jbsr	osd_w_videoram
	addq.w	#1,d7
	subq.b	#1,d1
	bne.b	0b
	exg		a0,d7
	rts

rst_18_color:
	exg		a0,d7
* memset((HL), A=fill, B=ct)
0:
	jbsr	osd_w_colorram
	addq.w	#1,d7
	subq.b	#1,d1
	bne.b	0b
	exg		a0,d7
	rts

*-----------------------------------------------------------------------------

db_flv_001d:
	.byte  0x23,0x06,0x16,0x23,0x00,0x19,0xF7
	.long  p_flv_004b
	.byte  0x23,0xF0,0x02,0xF0
	.long  p_flv_005e
	.byte  0x23,0xF0,0x24,0xFB,0x23,0x00,0xFF,0xFF


*.org 0x0034

*=============================================================================
* RST_34()
*  Description:
*   Wrapper function to allow normal call/return for task invocation (can't
*   call to a reference).
* IN:
*  ...
* OUT:
*  ...
*-----------------------------------------------------------------------------
c_0034:
	jra	(a0)                               	| [jp   (hl)]


*.org 0x0038

*=============================================================================
* RST_38()
*  Description:
* IN:
*  ...
* OUT:
*  ...
*-----------------------------------------------------------------------------
	jra	jp_0513_rst38                      	| [jp   jp_0513_rst38]


*.org 0x003b

*=============================================================================
* Function pointers for periodic tasks on this CPU (ds_cpu1_task_actvbl)
* The following bytes are copied from (d_05B7) to ds_cpu1_task_actvbl[1]
*   0x01,0x01,0x00,0x01,0x01,0x00,0x0A
d_003B_task_table:
	.long f_05BE  | null-task (only slot with a "null" task enabled)
	.long f_05BF  | [1]: update sprite RAM
	.long f_08D3  | [2]: bug motion runner
	.long f_05BE  | null-task
	.long f_06F5  | [4]: rocket hit-detection
	.long f_05EE  | [5]: hit-detection
	.long f_05BE  | null-task
	.long f_0ECA  | [7] ... ?


*=============================================================================
p_flv_004b:
	.byte 0x23,0xf0,0x26,0x23,0x14,0x13,0xfe
	.byte 0x0d,0x0b,0x0a,0x08,0x06,0x04,0x03,0x01,0x23,0xff
	.byte 0xff,0xff
p_flv_005e:
	.byte 0x44,0xe4,0x18,0xfb,0x44,0x00,0xff,0xff
	.byte 0xc9 | junk ?

db_flv_0067:
	.byte 0x23,0x08,0x08,0x23,0x03,0x1b,0x23,0x08,0x0f,0x23,0x16,0x15,0xf7
	.long p_flv_0084
	.byte 0x23,0x16,0x03,0xf0
	.long p_flv_0097
	.byte 0x23,0x16,0x19,0xfb,0x23,0x00,0xff,0xff
p_flv_0084:
	.byte 0x23,0x16,0x01,0xfe
	.byte 0x0d,0x0c,0x0a,0x08,0x06,0x04,0x03,0x01,0x23,0xfc
	.byte 0x30,0x23,0x00,0xff
	.byte 0xff
p_flv_0097:
	.byte 0x44,0x27,0x0e,0xfb,0x44,0x00,0xff,0xff

db_flv_009f:
	.byte 0x33,0x06,0x18,0x23,0x00,0x18,0xf7
	.long p_flv_00b6
	.byte 0x23,0xf0,0x08,0xf0
	.long p_flv_00cc
	.byte 0x23,0xf0,0x20,0xfb,0x23,0x00,0xff,0xff
p_flv_00b6:
	.byte 0x23,0xf0,0x20,0x23,0x10,0x0d,0xfe
	.byte 0x1a,0x18,0x15,0x10,0x0c,0x08,0x05,0x03,0x23,0xfe
	.byte 0x30,0x23,0x00,0xff
	.byte 0xff
p_flv_00cc:
	.byte 0x33,0xe0,0x10,0xfb,0x44,0x00,0xff,0xff

db_flv_00d4:
	.byte 0x23,0x03,0x18,0x33,0x04,0x10,0x23,0x08,0x0a,0x44,0x16,0x12,0xf7
	.long p_flv_0160
	.byte 0x44,0x16,0x03,0xf0
	.long p_flv_0173 | stg 13
	.byte 0x44,0x16,0x1d,0xfb,0x23,0x00,0xff,0xff

db_flv_00f1:
	.byte 0x12,0x18,0x17,0x12,0x00,0x80,0xff
* this is probably fill
.ds 8

* Copy of home position LUT from task_man
sprt_fmtn_hpos:
	.byte 0x14,0x06,0x14,0x0c,0x14,0x08,0x14,0x0a,0x1c,0x00,0x1c,0x12,0x1e,0x00,0x1e,0x12
	.byte 0x1c,0x02,0x1c,0x10,0x1e,0x02,0x1e,0x10,0x1c,0x04,0x1c,0x0e,0x1e,0x04,0x1e,0x0e
	.byte 0x1c,0x06,0x1c,0x0c,0x1e,0x06,0x1e,0x0c,0x1c,0x08,0x1c,0x0a,0x1e,0x08,0x1e,0x0a
	.byte 0x16,0x06,0x16,0x0c,0x16,0x08,0x16,0x0a,0x18,0x00,0x18,0x12,0x1a,0x00,0x1a,0x12
	.byte 0x18,0x02,0x18,0x10,0x1a,0x02,0x1a,0x10,0x18,0x04,0x18,0x0e,0x1a,0x04,0x1a,0x0e
	.byte 0x18,0x06,0x18,0x0c,0x1a,0x06,0x1a,0x0c,0x18,0x08,0x18,0x0a,0x1a,0x08,0x1a,0x0a

p_flv_0160:
	.byte 0x44,0x16,0x06,0xfe
	.byte 0x0c,0x0b,0x0a,0x08,0x06,0x04,0x02,0x01,0x23,0xfe
	.byte 0x30,0x23,0x00,0xff
	.byte 0xff
p_flv_0173:
	.byte 0x66,0x20,0x14,0xfb,0x44,0x00,0xff,0xff

db_flv_017b:
	.byte 0x23,0x06,0x18,0x23,0x00,0x18,0xf7
	.long p_flv_0192
	.byte 0x44,0xf0,0x08,0xf0
	.long p_flv_01a8
	.byte 0x44,0xf0,0x20,0xfb,0x23,0x00,0xff,0xff
p_flv_0192:
	.byte 0x44,0xf0,0x26,0x23,0x10,0x0b,0xfe
	.byte 0x22,0x20,0x1e,0x1b,0x18,0x15,0x12,0x10,0x23,0xfe
	.byte 0x30,0x23,0x00,0xff
	.byte 0xff
p_flv_01a8:
	.byte 0x66,0xe0,0x10,0xfb,0x44,0x00,0xff,0xff

db_flv_01b0:
	.byte 0x23,0x03,0x20,0x23,0x08,0x0f,0x23,0x16,0x12,0xf7
	.long p_flv_01ca
	.byte 0x23,0x16,0x03,0xf0
	.long p_flv_01e0
	.byte 0x23,0x16,0x1d,0xfb,0x23,0x00,0xff,0xff
p_flv_01ca:
	.byte 0x23,0x16,0x01,0xfe
	.byte 0x0d,0x0c,0x0b,0x09,0x07,0x05,0x03,0x02,0x23,0x02,0x20,0x23,0xfc
	.byte 0x12,0x23,0x00,0xff
	.byte 0xff
p_flv_01e0:
	.byte 0x44,0x20,0x14,0xfb,0x44,0x00,0xff,0xff

db_flv_01e8:
	.byte 0x23,0x00,0x10,0x23,0x01,0x40,0x22,0x0c,0x37,0x23,0x00,0xff,0xff

db_flv_01f5:
	.byte 0x23,0x02,0x3a,0x23,0x10,0x09,0x23,0x00,0x18,0x23,0x20,0x10
	.byte 0x23,0x00,0x18,0x23,0x20,0x0d,0x23,0x00,0xff,0xff

db_flv_020b:
	.byte 0x23,0x00,0x10,0x23,0x01,0x30,0x00,0x40,0x08,0x23,0xff,0x30,0x23,0x00,0xff,0xff

db_flv_021b:
	.byte 0x23,0x00,0x30,0x23,0x05,0x80,0x23,0x05,0x4c,0x23,0x04,0x01,0x23,0x00,0x50,0xff

db_flv_022b:
	.byte 0x23,0x00,0x28,0x23,0x06,0x1d,0x23,0x00,0x11,0x00,0x40,0x08,0x23,0x00,0x11
	.byte 0x23,0xfa,0x1d,0x23,0x00,0x50,0xff

db_flv_0241:
	.byte 0x23,0x00,0x21,0x00,0x20,0x10,0x23,0xf8,0x20,0x23,0xff,0x20,0x23,0xf8,0x1b
	.byte 0x23,0xe8,0x0b,0x23,0x00,0x21,0x00,0x20,0x08,0x23,0x00,0x42,0xff

db_flv_025d:
	.byte 0x23,0x00,0x08,0x00,0x20,0x08,0x23,0xf0,0x20,0x23,0x10,0x20,0x23,0xf0,0x40
	.byte 0x23,0x10,0x20,0x23,0xf0,0x20,0x00,0x20,0x08,0x23,0x00,0x30,0xff

db_flv_0279:
	.byte 0x23,0x10,0x0c,0x23,0x00,0x20,0x23,0xe8,0x10
	.byte 0x23,0xf4,0x10,0x23,0xe8,0x10,0x23,0xf4,0x32,0x23,0xe8,0x10,0x23,0xf4,0x32
	.byte 0x23,0xe8,0x10,0x23,0xf4,0x10,0x23,0xe8,0x0e,0x23,0x02,0x30,0xff

db_flv_029e:
	.byte 0x23,0xf1,0x08,0x23,0x00,0x10,0x23,0x05,0x3c,0x23,0x07,0x42,0x23,0x0a,0x40
	.byte 0x23,0x10,0x2d,0x23,0x20,0x19,0x00,0xfc,0x14,0x23,0x02,0x4a,0xff

db_flv_02ba:
	.byte 0x23,0x04,0x20,0x23,0x00,0x16,0x23,0xf0,0x30,0x23,0x00,0x12,0x23,0x10,0x30
	.byte 0x23,0x00,0x12,0x23,0x10,0x30,0x23,0x00,0x16,0x23,0x04,0x20,0x23,0x00,0x10,0xff

db_flv_02d9:
	.byte 0x23,0x00,0x15,0x00,0x20,0x08,0x23,0x00,0x11
	.byte 0x00,0xe0,0x08,0x23,0x00,0x18,0x00,0x20,0x08,0x23,0x00,0x13
	.byte 0x00,0xe0,0x08,0x23,0x00,0x1f,0x00,0x20,0x08,0x23,0x00,0x30,0xff

db_flv_02fb:
	.byte 0x23,0x02,0x0e,0x23,0x00,0x34
	.byte 0x23,0x12,0x19,0x23,0x00,0x20,0x23,0xe0,0x0e,0x23,0x00,0x12,0x23,0x20,0x0e
	.byte 0x23,0x00,0x0c,0x23,0xe0,0x0e,0x23,0x1b,0x08,0x23,0x00,0x10,0xff

db_flv_031d:
	.byte 0x23,0x00,0x0d,0x00,0xc0,0x04,0x23,0x00,0x21,0x00,0x40,0x06,0x23,0x00,0x51
	.byte 0x00,0xc0,0x06,0x23,0x00,0x73,0xff

db_flv_0333:
	.byte 0x23,0x08,0x20,0x23,0x00,0x16,0x23,0xe0,0x0c,0x23,0x02,0x0b
	.byte 0x23,0x11,0x0c,0x23,0x02,0x0b,0x23,0xe0,0x0c,0x23,0x00,0x16,0x23,0x08,0x20,0xff

db_flv_atk_yllw:
	.byte 0x12,0x18,0x1e
p_flv_0352:
	.byte 0x12,0x00,0x34,0x12,0xfb,0x26
p_flv_0358:
	.byte 0x12,0x00,0x02,0xfc
	.byte 0x2e,0x12,0xfa,0x3c,0xfa
	.long p_flv_039e
p_flv_0363:
	.byte 0x12,0xf8,0x10,0x12,0xfa,0x5c,0x12,0x00,0x23
p_flv_036c:
	.byte 0xf8,0xf9,0xef
	.long p_flv_037c
	.byte 0xf6,0xab
	.byte 0x12,0x01,0x28,0x12,0x0a,0x18,0xfd
	.long p_flv_0352
p_flv_037c:
	.byte 0xf6,0xb0
	.byte 0x23,0x08,0x1e,0x23,0x00,0x19,0x23,0xf8,0x16,0x23,0x00,0x02,0xfc
	.byte 0x30,0x23,0xf7,0x26,0xfa
	.long p_flv_039e
	.byte 0x23,0xf0,0x0a,0x23,0xf5,0x31,0x23,0x00,0x10,0xfd
	.long p_flv_036c | oops shot captured fighter
p_flv_039e:
	.byte 0x12,0xf8,0x10,0x12,0x00,0x40,0xfb,0x12,0x00,0xff,0xff

db_flv_atk_red:
	.byte 0x12,0x18,0x1d
p_flv_03ac:
	.byte 0x12,0x00,0x28,0x12,0xfa,0x02,0xf3
  * $03B3
	.byte 0x3f,0x3b,0x36,0x32,0x28,0x26,0x24,0x22
  * $03BB
	.byte 0x12,0x04,0x30,0x12,0xfc,0x30,0x12,0x00,0x18,0xf8,0xf9,0xfa
	.long p_flv_040c
	.byte 0xef
	.long p_flv_03d7
p_flv_03cc:
	.byte 0xf6,0xb0
	.byte 0x12,0x01,0x28,0x12,0x0a,0x15,0xfd
	.long p_flv_03ac
p_flv_03d7:
	.byte 0xf6,0xc0
	.byte 0x23,0x08,0x10,0x23,0x00,0x23,0x23,0xf8,0x0f,0x23,0x00,0x48,0xf8,0xf9,0xfa
	.long p_flv_040c
	.byte 0xf6,0xb0
	.byte 0x23,0x08,0x20,0x23,0x00,0x08,0x23,0xf8,0x02,0xf3
	.byte 0x34,0x31,0x2d,0x29,0x22,0x26,0x1f,0x18
	.byte 0x23,0x08,0x18,0x23,0xf8,0x18,0x23,0x00,0x10,0xf8,0xf9,0xfd
	.long p_flv_03cc
p_flv_040c:
	.byte 0xfb
	.byte 0x12,0x00,0xff,0xff
db_flv_0411:
	.byte 0x12,0x18,0x14
p_flv_0414:
	.byte 0x12,0x03,0x2a,0x12,0x10,0x40,0x12,0x01,0x20,0x12,0xfe,0x71
p_flv_0420:
	.byte 0xf9,0xf1,0xfa
	.long p_flv_040c
p_flv_0425:
	.byte 0xef
	.long p_flv_0430
	.byte 0xf6,0xab
	.byte 0x12,0x02,0x20,0xfd
	.long p_flv_0414
p_flv_0430:
	.byte 0xf6,0xb0
	.byte 0x23,0x04,0x1a,0x23,0x03,0x1d,0x23,0x1a,0x25,0x23,0x03,0x10,0x23,0xfd,0x48,0xfd
	.long p_flv_0420

db_fltv_rogefgter:
	.byte 0x12,0x18,0x14,0x12,0x03,0x2a,0x12,0x10,0x40,0x12,0x01,0x20,0x12,0xfe,0x78,0xff

db_0454: ; capture mode boss
	.byte 0x12,0x18,0x14,0xf4
	.byte 0x12,0x00,0x04,0xfc
	.byte 0x48,0x00,0xfc,0xff
	.byte 0x23,0x00,0x30,0xf8,0xf9,0xfa
	.long p_flv_040c
	.byte 0xfd
	.long p_flv_0425
db_flv_cboss:
	.byte 0x12,0x18,0x14,0xfb
	.byte 0x12,0x00,0xff,0xff
db_0473:
	.byte 0x12,0x18,0x1e,0x12,0x00,0x08,0xf2
	.long p_flv_0499
	.byte 0x00,0x00,0x0a,0xf2
	.long p_flv_0499
	.byte 0x00,0x00,0x0a
	.byte 0x12,0x00,0x2c,0x12,0xfb,0x26,0x12,0x00,0x02,0xfc
	.byte 0x2e
	.byte 0x12,0xfa,0x3c,0xfa
	.long p_flv_039e
	.byte 0xfd
	.long p_flv_0363
p_flv_0499:
	.byte 0x12,0x00,0x2c,0x12,0xfb,0x26,0x12,0x00,0x02,0xfc
	.byte 0x2e
	.byte 0x12,0xfa,0x18,0x12,0x00,0x10,0xff
db_04AB:
	.byte 0x12,0x18,0x13,0xf2
	.long p_flv_04c6
	.byte 0x00,0x00,0x08,0xf2
	.long p_flv_04cf
	.byte 0x00,0x00,0x08,0x12,0x18,0x0b,0x12,0x00,0x34,0x12,0xfb,0x26,0xfd
	.long p_flv_0358

db_flv_04c6:
p_flv_04c6:
	.byte 0x12,0x00,0x10,0x12,0x18,0x0b,0xfd
	.long p_flv_04d8

db_flv_04cf:
p_flv_04cf:
	.byte 0x12,0x00,0x08,0x12,0x18,0x0b,0x12,0x00,0x06

db_flv_04d8:
p_flv_04d8:
	.byte 0x12,0x00,0x22,0x12,0xfb,0x26,0x12,0x00,0x02,0xfc
	.byte 0x2e
	.byte 0x12,0xfa,0x18,0x12,0x00,0x20,0xff
db_04EA:
	.byte 0x12,0x18,0x1e,0x12,0x00,0x14,0xf2
	.long p_flv_0502
	.byte 0x12,0x00,0x08,0xf2
	.long p_flv_0502
	.byte 0x12,0x00,0x18,0x12,0xfb,0x26,0xfd
	.long p_flv_0358

db_flv_0502:
p_flv_0502:
	.byte 0x12,0xe2,0x01,0xf3
	.byte 0x08,0x07,0x06,0x05,0x04,0x03,0x02,0x01,0xf5
	.byte 0x23,0x00,0x48,0xff

*=============================================================================
* jp_0513_rst38()
*  Description:
*    RST $0038 handler.
*    The first part uses vsync signal to develop clock references.
*      ds3_92A0_frame_cts[0]: 60Hz (base rate)
*      ds3_92A0_frame_cts[1]:  2Hz (div 32)
*      ds3_92A0_frame_cts[2]:  4Hz (div 16)
*    The counters are not reset in the course of the game operation.
*
*    For efficiency, bit masking is used instead of division so the real base
*    period is 64 which is close enough to 60Hz.
*
*    Note: frame_cts[2] is used as baserate to 4 Game Timers in CPU0:f_1DD2
*   (rescaled to develop a 2Hz clock)

* IN:
*  ...
* OUT:
*  ...
*-----------------------------------------------------------------------------
jp_0513_rst38:
	clr.b	d0                               	| [xor  a]
	move.b	d0,_sfr_6821                    	| [ld   (_sfr_6821),a] 0 ...CPU-sub1 IRQ acknowledge/enable
	move.b	_sfr_dsw5,d0                    	| [ld   a,(_sfr_dsw5)] DSWA: freeze video
	and.b	#0x02,d0                         	| [and  #0x02] freeze_ctrl_dsw (6j)
	jeq	l_0575                             	| [jp   z,l_0575] if paused, goto 0575 // done

* frame_cntr++
	move.b	ds3_92A0_frame_cts+0,d0         	| [ld   a,(ds3_92A0_frame_cts + 0)]
	addq.b	#1,d0                           	| [inc  a]
	move.b	d0,ds3_92A0_frame_cts+0         	| [ld   (ds3_92A0_frame_cts + 0),a] +=1

* L==t[1], H==t[2]

	MOVE_TO_REG	ds3_92A0_frame_cts+1,d5     	| [ld   hl,(ds3_92A0_frame_cts + 1)] load 16-bits
	LOAD_D5D6_FROM_D5_16

* if ( cnt % 20 == 1 ) ... update 4Hz (H) only
	and.b	#0x1F,d0                         	| [and  #0x1F] MOD $20
	subq.b	#1,d0                           	| [dec  a]
	jeq	l_0536                             	| [jr   z,l_0536]

* else  if ( cnt % 20 == 0 ) ...
	addq.b	#1,d0                           	| [inc  a] restores original value and allows test for 0
	jne	l_0537                             	| [jr   nz,l_0537] A!=0 && A!=1 .... do nothing (why reload from HL?)
* ...
* Before incrementing 4Hz, assert that 4Hz is ODD on frame where _92A0[0] increments to 0.
	move.b	d5,d0                           	| [ld   a,h] t[2] ... MSB
	or.b	#0x01,d0                          	| [or   #0x01]
	move.b	d0,d5                           	| [ld   h,a]

* update both 4Hz and 2Hz
	addq.b	#1,d6                           	| [inc  l] t[1] = L++ ... 2Hz
l_0536:
	addq.b	#1,d5                           	| [inc  h] t[2] = H++ ... 4Hz
l_0537:
	LOAD_D5_16_FROM_D5D6
	MOVE_TO_VAR	d5,ds3_92A0_frame_cts+1         	| [ld   (ds3_92A0_frame_cts + 1),hl] [1]: 32-frame ... ~2Hz timer

* flag = ( num_bugs < param07 ) && ds_cpu0_task_actv[0x15]
	move.b	ds_new_stage_parms+0x07,d0      	| [ld   a,(ds_new_stage_parms + 0x07)] number of aliens left when continous bombing can start
	move.b	d0,d4                           	| [ld   e,a]
	move.b	b_bugs_actv_nbr,d0              	| [ld   a,(b_bugs_actv_nbr)]
	cmp.b	d4,d0                            	| [cp   e]
	SET_X_FROM_C
	roxl.b	#1,d1                           	| [rl   b] Cy set if E > A ... shift into B ... clever.
	move.b	ds_cpu0_task_actv+0x15,d0       	| [ld   a,(ds_cpu0_task_actv + 0x15)] cpu0:f_1F04 (reads fire button input)
	and.b	d1,d0                            	| [and  b]
	and.b	#0x01,d0                         	| [and  #0x01] mask off bit-0
	move.b	d0,b_92A0+0x0A                  	| [ld   (b_92A0 + 0x0A),a] continuous bombing flag (set here by tasking kernel)

* find the first ready task.. may run more than one.
	clr.w	d2                               	| [ld   c,#0]
l_054F_while:
	lea	ds_cpu1_task_actv(pc),a0           	| [ld   hl,#ds_cpu1_task_actv]
	add.w	d2,a0										| [ld   a,c]
												| [add  a,l]
											| [ld   l,a]
	move.b	(a0),d0                         	| [ld   a,(hl)]
	                               	| [and  a]
	jne	l_055C                             	| [jr   nz,l_055C]
	addq.b	#1,d2                           	| [inc  c]
	jra	l_054F_while                       	| [jr   l_054F_while]

l_055C:
	move.b	d0,d1                           	| [ld   b,a] A == task status
	lea	d_003B_task_table(pc),a0           	| [ld   hl,#d_003B_task_table]
	moveq	#0,d0
	
	move.b	d2,d0                           	| [ld   a,c] C == task index
	add.w	d0,d0                            	| [sla  a] *=2 ... (sizeof pointer)
	add.w	d0,d0                            	| [sla  a] *=2 ... (sizeof pointer)
	                         	| [add  a,l]
	                        	| [ld   l,a]
	                        	| [ld   e,(hl)]
	                        	| [inc  hl]
	                        	| [ld   d,(hl)]
	                       	| [ex   de,hl]
	move.l	(a0,d0.w),a0
	movem.w	d1/d2,-(sp)                    	| [push bc]

	jbsr	c_0034                            	| [call c_0034] (jumps to (a0) from task table)

	movem.w	(sp)+,d1/d2                    	| [pop  bc]
	move.b	d1,d0                           	| [ld   a,b] "status" actually adds to index
	add.b	d2,d0                            	| [add  a,c]
	move.b	d0,d2                           	| [ld   c,a]
	and.b	#0xF8,d0                         	| [and  #0xF8] if index < 8 then repeat loop
	jeq	l_054F_while                       	| [jr   z,l_054F_while]

l_0575:
	move.b	#1,d0                           	| [ld   a,#1]
	move.b	d0,_sfr_6821                    	| [ld   (_sfr_6821),a] 1 ...CPU-sub1 IRQ acknowledge/enable
ei
	rts                                    	| [ret]

*=============================================================================
* RESET()
*  Description:
*   entry point from RST 00
*   Tests the ROM space (length $1000)
* IN:
*  ...
* OUT:
*  ...
*-----------------------------------------------------------------------------
CPU1_RESET:
	lea	ds_rom_test_status+0x00(pc),a1     	| [ld   de,#ds_rom_test_status + 0x00] pause/resume flag

* wait for master CPU to acknowledge/resume (0)
l_057F:
	move.b	(a1),d0                         	| [ld   a,(de)]
	                               	| [and  a]
	jne	l_057F                             	| [jr   nz,l_057F]

* compute ROM checksum
	move.b	d0,d5                           	| [ld   h,a]
	move.b	d0,d6                           	| [ld   l,a]
	move.b	#0x00,d1                        	| [ld   bc,#0x0010] Sets B as inner loop count ($100) and C as outer ($10) 16
	move.b	#0x10,d2                        	| [ld   bc,#0x0010] Sets B as inner loop count ($100) and C as outer ($10) 16
l_0588:
	add.b	(a0),d0                          	| [add  a,(hl)]
	addq.w	#1,a0                           	| [inc  hl]
	subq.b	#1,d1                           	| [...]
	jne	l_0588                             	| [djnz l_0588]
	subq.b	#1,d2                           	| [dec  c]
	jne	l_0588                             	| [jr   nz,l_0588]
	cmp.b	#0xFF,d0                         	| [cp   #0xFF]
	jeq	l_0595                             	| [jr   z,l_0595]
	move.b	#0x11,d0                        	| [ld   a,#0x11] set error code

l_0595:
	move.b	d0,(a1)                         	| [ld   (de),a] copy checksum result to the global variable

* wait for master to acknowledge/resume (0)
l_0596:
	move.b	(a1),d0                         	| [ld   a,(de)]
	                               	| [and  a]
	jne	l_0596                             	| [jr   nz,l_0596]

im   1

	clr.b	d0                               	| [xor  a]
	move.b	d0,ds_89E0                      	| [ld   (ds_89E0),a] 0

* set task-enable defaults
	lea	d_05B7(pc),a0                      	| [ld   hl,#d_05B7]
	lea	ds_cpu1_task_actv+1(pc),a1         	| [ld   de,#ds_cpu1_task_actv + 1] cp $07 bytes (d_05B7)
	move.b	#0x00,d1                        	| [ld   bc,#0x0007] 7
	move.b	#0x07,d2                        	| [ld   bc,#0x0007] 7
	jbsr	ldir                              	| [ldir]
     ^^^^ TODO: review special instruction inputs

	move.b	#1,d0                           	| [ld   a,#1]
	move.b	d0,_sfr_6821                    	| [ld   (_sfr_6821),a] 1 ... IRQ acknowledge/enable
ei

l_05B1:
ld   sp,#ds_stk_cpu1_init
	jra	l_05B1                             	| [jp   l_05B1] loop forever

*=============================================================================
* init data for (ds_cpu1_task_actvbl + 0x01)
d_05B7:
	.byte 0x01,0x01,0x00,0x01,0x01,0x00,0x0A

*=============================================================================
* f_05BE()
*  Description:
*   null task
* IN:
*  ...
* OUT:
*  ...
*-----------------------------------------------------------------------------
f_05BE:
	rts                                    	| [ret]

*=============================================================================
* f_05BF()
*  Description:
*   works in conjunction with f_0828 of main CPU to update sprite RAM
* IN:
*  ...
* OUT:
*  ...
*-----------------------------------------------------------------------------
f_05BF:
	move.b	#1,d0                           	| [ld   a,#1]
	move.b	d0,b_CPU2_in_progress           	| [ld   (b_CPU2_in_progress),a] 1

	lea	mrw_sprite_code(pc),a0             	| [ld   hl,#mrw_sprite_code]
	lea	sfr_sprite_code(pc),a1             	| [ld   de,#sfr_sprite_code]
	move.b	#0x00,d1                        	| [ld   bc,#0x0040] 64
	move.b	#0x40,d2                        	| [ld   bc,#0x0040] 64
	jbsr	ldir                              	| [ldir]
     ^^^^ TODO: review special instruction inputs
	lea	mrw_sprite_posn(pc),a0             	| [ld   hl,#mrw_sprite_posn]
	lea	sfr_sprite_posn(pc),a1             	| [ld   de,#sfr_sprite_posn]
	move.b	#0x40,d2                        	| [ld   c,#0x40]
	jbsr	ldir                              	| [ldir]
     ^^^^ TODO: review special instruction inputs
	lea	mrw_sprite_ctrl(pc),a0             	| [ld   hl,#mrw_sprite_ctrl]
	lea	sfr_sprite_ctrl(pc),a1             	| [ld   de,#sfr_sprite_ctrl]
	move.b	#0x40,d2                        	| [ld   c,#0x40]
	jbsr	ldir                              	| [ldir]
     ^^^^ TODO: review special instruction inputs

	clr.b	d0                               	| [xor  a]
	move.b	d0,b_CPU2_in_progress           	| [ld   (b_CPU2_in_progress),a] 0

l_05E7_while_wait_for_main_CPU:
	move.b	b_CPU1_in_progress,d0           	| [ld   a,(b_CPU1_in_progress)]
	subq.b	#1,d0                           	| [dec  a]
	jeq	l_05E7_while_wait_for_main_CPU     	| [jr   z,l_05E7_while_wait_for_main_CPU]

	rts                                    	| [ret]

*=============================================================================
* f_05EE()
*  Description:
*    Manage ship collision detection
* IN:
*  ...
* OUT:
*  ...
*-----------------------------------------------------------------------------
f_05EE:
* if ( task_state == inactive ) return
	move.b	ds_cpu0_task_actv+0x14,d0       	| [ld   a,(ds_cpu0_task_actv + 0x14)] f_1F85 (input and ship movement)
	                               	| [and  a]
	bne.b	0f                               	| [...]
	rts                                    	| [ret  z] [...]
0:

	move.b	d0,ds_9200_glbls+0x17           	| [ld   (ds_9200_glbls + 0x17),a] 1 ... no_restart_stg

* if ( plyr_is_two_ship ) ...
	move.b	ds_plyr_actv+_b_2ship,d0        	| [ld   a,(ds_plyr_actv +_b_2ship)]
	                               	| [and  a]
	jeq	l_0613                             	| [jr   z,l_0613]

* ... handle 2-ship configuration
	lea	ds_sprite_posn+0x60(pc),a0         	| [ld   hl,#ds_sprite_posn + 0x60] fighter2 position
	move.b	(a0),d0                         	| [ld   a,(hl)]
	                               	| [and  a]
	jeq	l_0613                             	| [jr   z,l_0613]

	jbsr	hitd_fghtr_notif                  	| [call hitd_fghtr_notif] HL == &sprite_posn_base[0x60]  ...ship2 position
	move.b	b8_ship_collsn_detectd_status,d0	| [ld   a,(b8_ship_collsn_detectd_status)] fighter hit notif (2)
	                               	| [and  a]
	jeq	l_0613                             	| [jr   z,l_0613]

	jbsr	hitd_fghtr_hit                    	| [call hitd_fghtr_hit] fighter2 collision
	clr.b	d0                               	| [xor  a]
	move.b	d0,ds_plyr_actv+_b_bmbr_boss_cflag	| [ld   (ds_plyr_actv +_b_bmbr_boss_cflag),a] 0 ... enable capture-mode selection

l_0613:
* if ( ship position == 0 ) return
	lea	ds_sprite_posn+0x62(pc),a0         	| [ld   hl,#ds_sprite_posn + 0x62] fighter1 position
	move.b	(a0),d0                         	| [ld   a,(hl)]
	                               	| [and  a]
	bne.b	0f                               	| [...]
	rts                                    	| [ret  z] [...]
0:

	jbsr	hitd_fghtr_notif                  	| [call hitd_fghtr_notif] HL == sprite_posn_base + 0x62 ... fighter (1) position (only L significant)
       * L passed to c_0681_ship_collisn_detect preserved in E
	move.b	b8_ship_collsn_detectd_status,d0	| [ld   a,(b8_ship_collsn_detectd_status)] fighter hit notif (1)
	                               	| [and  a]
	bne.b	0f                               	| [...]
	rts                                    	| [ret  z] [...]
0:

* 621 bug or bomb collided with ship
	move.b	ds_plyr_actv+_b_2ship,d0        	| [ld   a,(ds_plyr_actv +_b_2ship)]
	                               	| [and  a]
	jeq	l_0639_not_two_ship                	| [jr   z,l_0639_not_two_ship]

	clr.b	d0                               	| [xor  a]
	move.b	d0,ds_plyr_actv+_b_bmbr_boss_cflag	| [ld   (ds_plyr_actv +_b_bmbr_boss_cflag),a] 0 ... enable capture-mode selection
	move.b	ds_sprite_posn+0x60,d0          	| [ld   a,(ds_sprite_posn + 0x60)] get ship 2 position
	move.b	d0,ds_sprite_posn+0x62          	| [ld   (ds_sprite_posn + 0x62),a] ship_1_position = ship_2_position
	move.b	sfr_sprite_posn+0x62,d0         	| [ld   a,(sfr_sprite_posn + 0x62)]
	lea	sfr_sprite_posn+0x60(pc),a0        	| [ld   hl,#sfr_sprite_posn + 0x60]
	jra	l_064F                             	| [jr   l_064F] handle ship collision

l_0639_not_two_ship:
	clr.b	d0                               	| [xor  a]
	move.b	d0,ds_cpu0_task_actv+0x14       	| [ld   (ds_cpu0_task_actv + 0x14),a] 0 ... f_1F85 (input and fighter movement)
	move.b	d0,ds_cpu0_task_actv+0x15       	| [ld   (ds_cpu0_task_actv + 0x15),a] 0 ... f_1F04 (fire button input)
	move.b	d0,ds_cpu1_task_actv+0x05       	| [ld   (ds_cpu1_task_actv + 0x05),a] 0 ... f_05EE (this task, fighter hit-detection)
	move.b	d0,ds_99B9_star_ctrl+0x00       	| [ld   (ds_99B9_star_ctrl + 0x00),a] 0 ... 1 when fighter on screen
	move.b	d0,ds_9200_glbls+0x17           	| [ld   (ds_9200_glbls + 0x17),a] 0 ... no_restart_stg (not docked fighters)

* hitd_fghtr_hit(tmpSx, SPR_IDX_SHIP + 0, 0)

*=============================================================================
* hitd_fghtr_hit()
*  Description:
*   handle a collision detected on fighter
* IN:
*   HL == &sprite_posn_base[0x60]  ... ship2 position (if call hitd_fghtr_hit)
*   HL == &sprite_posn_sfr[0x60] ... (if jp  l_064F)

*   E == object/index of fighter1 or fighter2 .b0
* OUT:
*  ...
*-----------------------------------------------------------------------------
hitd_fghtr_hit:
	exg	a1,a0                              	| [ex   de,hl]
	lea	ds_sprite_posn(pc),a0              	| [ld   h,#>ds_sprite_posn] read directly from SFRs (not buffer RAM) ... already 0'd by hitd_dspchr
	and.w	#0xFF,d6
	add.w	d6,a0
	      ^^^^ TODO: review XX value
	bset.b	#7,d6                           	| [set  7,l]
	move.b	(a0),d0                         	| [ld   a,(hl)]

l_064F:
	sub.b	#8,d0                            	| [sub  #8]
	bclr.b	#7,d6                           	| [res  7,l]
	move.b	d0,(a0)                         	| [ld   (hl),a]
	addq.b	#1,d6                           	| [inc  l]
	move.b	(a0),d0                         	| [ld   a,(hl)]
	sub.b	#8,d0                            	| [sub  #8]
	move.b	d0,(a0)                         	| [ld   (hl),a]
	lea	ds_sprite_code(pc),a0              	| [ld   h,#>ds_sprite_code]
	and.w	#0xFF,d6
	add.w	d6,a0
	      ^^^^ TODO: review XX value
	move.b	#0x0B,(a0)                      	| [ld   (hl),#0x0B] color
	subq.b	#1,d6                           	| [dec  l]
	move.b	#0x20,(a0)                      	| [ld   (hl),#0x20] explosion tile
	lea	b_8800(pc),a0                      	| [ld   h,#>b_8800]
	and.w	#0xFF,d6
	add.w	d6,a0
	      ^^^^ TODO: review XX value
	move.b	#8,(a0)                         	| [ld   (hl),#8] .state, disposition from $80 to "exploding"
	addq.b	#1,d6                           	| [inc  l]
	move.b	#0x0F,(a0)                      	| [ld   (hl),#0x0F] mctrl_q index used for explosion counter
	subq.b	#1,d6                           	| [dec  l]
	lea	ds_sprite_ctrl(pc),a0              	| [ld   h,#>ds_sprite_ctrl]
	and.w	#0xFF,d6
	add.w	d6,a0
	      ^^^^ TODO: review XX value
	move.b	0x08                            	|0x04,(a0)| [ld   (hl),#0x08| 0x04] dblh, dblw
	clr.b	d0                               	| [xor  a]
	move.b	d0,ds_plyr_actv+_b_2ship        	| [ld   (ds_plyr_actv +_b_2ship),a] 0

	move.b	b8_9201_game_state,d0           	| [ld   a,(b8_9201_game_state)]
	subq.b	#1,d0                           	| [dec  a]
	move.b	d0,b_9AA0+0x19                  	| [ld   (b_9AA0 + 0x19),a] sound-fx count/enable registers, "bang" sound (not in Attract Mode)

* if no_restart_stg  ret ...
	move.b	ds_9200_glbls+0x17,d0           	| [ld   a,(ds_9200_glbls + 0x17)] no_restart_stg is set if docked fighters
	                               	| [and  a]
	beq.b	0f                               	| [...]
	rts                                    	| [ret  nz] [...]
0:
* ... else  set restart_stg_flag
	addq.b	#1,d0                           	| [inc  a]
	move.b	d0,ds_9200_glbls+0x13           	| [ld   (ds_9200_glbls + 0x13),a] 1  ... restart stage flag (ship-input-movement flag not active )
	rts                                    	| [ret]

*=============================================================================
* hitd_fghtr_notif()
*  Description:
*   hit notification for fighter
* IN:
*  L == sprite_posn_base[] ... offset (FIGHTER1 or FIGHTER2)
* OUT:
*  E == preserved offset passed as argument in L
*-----------------------------------------------------------------------------
hitd_fghtr_notif:
	clr.b	d0                               	| [xor  a]
	move.b	d0,b8_ship_collsn_detectd_status	| [ld   (b8_ship_collsn_detectd_status),a] 0 ... fighter hit notif

	lea	b_8800(pc),a0                      	| [ld   h,#>b_8800]
	and.w	#0xFF,d6
	add.w	d6,a0
	      ^^^^ TODO: review XX value
	move.b	(a0),d0                         	| [ld   a,(hl)]
	lea	ds_sprite_posn(pc),a0              	| [ld   h,#>ds_sprite_posn]
	and.w	#0xFF,d6
	add.w	d6,a0
	      ^^^^ TODO: review XX value
	cmp.b	#8,d0                            	| [cp   #8] fighter disposition 08 if already dooomed ...
	bne.b	0f                               	| [...]
	rts                                    	| [ret  z] ... so gtf out! [...]
0:

	move.b	(a0),d0                         	| [ld   a,(hl)] sprite.pos.x
ld   ixl,a
	addq.b	#1,d6                           	| [inc  l]
	move.b	(a0),d1                         	| [ld   b,(hl)] get row bits 0:7
	lea	ds_sprite_ctrl(pc),a0              	| [ld   h,#>ds_sprite_ctrl] get row bit-8
	and.w	#0xFF,d6
	add.w	d6,a0
	      ^^^^ TODO: review XX value
	move.b	(a0),d0                         	| [ld   a,(hl)]
	ror.b	#1,d0                            	| [rrca] y<8> -> Cy
	roxr.b	#1,d1                           	| [rr   b] Cy -> b<7>
      ^^^^^^ TODO: review cpu X flag
ld   ixh,b                                 ; y<15:8> of fixed-point
	subq.b	#1,d6                           	| [dec  l]
	move.b	d6,d4                           	| [ld   e,l] preserved object/index of fighter passed as argument in L

* if ( cpu0:f_2916  active ) ...
	move.b	ds_cpu0_task_actv+0x08,d0       	| [ld   a,(ds_cpu0_task_actv + 0x08)] cpu0:f_2916 ...supervises attack waves
	                               	| [and  a]
	jeq	l_06A8                             	| [jr   z,l_06A8]
* ... then ...
       * only transients can do collision in attack wave
	move.b	#0x38,d6                        	| [ld   l,#0x38] transients
	move.b	#0x04,d1                        	| [ld   b,#0x04]
	jra	l_06AC_                            	| [jr   l_06AC_]

* ... else ...not attack wave, set parameters to check all
l_06A8:
	clr.b	d6                               	| [ld   l,#0x00] check objects $00 - $5E
	move.b	#0x30,d1                        	| [ld   b,#0x30]

l_06AC_:
	jbsr	hitd_det_fghtr                    	| [call hitd_det_fghtr]

	move.b	#0x68,d6                        	| [ld   l,#0x68] bombs
	move.b	#0x08,d1                        	| [ld   b,#0x08]
	jbsr	hitd_det_fghtr                    	| [call hitd_det_fghtr]

	rts                                    	| [ret]

*=============================================================================
* hitd_det_fghtr()
*  Description:
*   Do ship collision detection.
* IN:
*  L==starting object/index of alien or bomb
*  B==repeat count ($08 or $30)
*  ixl == fighter x<7:0>
*  ixh == fighter y<15:8> of fixed-point
* OUT:
*  b8_ship_collsn_detectd_status
*-----------------------------------------------------------------------------
hitd_det_fghtr:
while_06B7:
	lea	b_9200_obj_collsn_notif(pc),a0     	| [ld   h,#>b_9200_obj_collsn_notif] sprt_hit_notif
	and.w	#0xFF,d6
	add.w	d6,a0
	      ^^^^ TODO: review XX value
	move.b	(a0),d0                         	| [ld   a,(hl)]
	lea	b_8800(pc),a0                      	| [ld   h,#>b_8800]
	and.w	#0xFF,d6
	add.w	d6,a0
	      ^^^^ TODO: review XX value
	or.b	(a0),d0                           	| [or   (hl)]
	rol.b	#1,d0                            	| [rlca]
	jcs	l_06F0                             	| [jr   c,l_06F0]

	move.b	(a0),d0                         	| [ld   a,(hl)]
	and.b	#0xFE,d0                         	| [and  #0xFE]
	cmp.b	#4,d0                            	| [cp   #4]
	jeq	l_06F0                             	| [jr   z,l_06F0]

	lea	ds_sprite_posn(pc),a0              	| [ld   h,#>ds_sprite_posn]
	and.w	#0xFF,d6
	add.w	d6,a0
	      ^^^^ TODO: review XX value
	move.b	(a0),d0                         	| [ld   a,(hl)]
	                               	| [and  a]
	jeq	l_06F0                             	| [jr   z,l_06F0]

	sub.b	ixl,d0                           	| [sub  ixl] x<7:0>
	subq.b	#7,d0                           	| [sub  #7]
	add.b	#13,d0                           	| [add  a,#13]
	jcc	l_06F0                             	| [jr   nc,l_06F0]

	addq.b	#1,d6                           	| [inc  l]
	move.b	(a0),d0                         	| [ld   a,(hl)]
	lea	ds_sprite_ctrl(pc),a0              	| [ld   h,#>ds_sprite_ctrl]
	and.w	#0xFF,d6
	add.w	d6,a0
	      ^^^^ TODO: review XX value
	move.b	(a0),d2                         	| [ld   c,(hl)]
	subq.b	#1,d6                           	| [dec  l]
	ror.b	#1,d2                            	| [rrc  c]
	roxr.b	#1,d0                           	| [rra]
      ^^^^^^ TODO: review cpu X flag
	sub.b	ixh,d0                           	| [sub  ixh]
	subq.b	#4,d0                           	| [sub  #4]
	addq.b	#7,d0                           	| [add  a,#7]
	jcc	l_06F0                             	| [jr   nc,l_06F0]

	move.b	#1,d0                           	| [ld   a,#1]
	move.b	d0,b8_ship_collsn_detectd_status	| [ld   (b8_ship_collsn_detectd_status),a] 1 ... fighter hit notif

	or.b	d0,d0                             	| [or   a] nz if fighter hit
	scs	d7                              	| [ex   af,af']
         ^^^ TODO review: wrong if carry is needed or D7 used in between!
	jra	hitd_dspchr                        	| [jp   hitd_dspchr] return to 'call hitd_det_fghtr'
l_06F0:
	addq.b	#2,d6                           	| [inc  l] * 2
	subq.b	#1,d1                           	| [...]
	jne	while_06B7                         	| [djnz while_06B7]

	rts                                    	| [ret]

*=============================================================================
* f_06F5()
*  Description:
*    rocket motion and hit-detection manager
* IN:
*  ...
* OUT:
*  ...
*-----------------------------------------------------------------------------
f_06F5:
	lea	b_92A0+0x04+0(pc),a1               	| [ld   de,#b_92A0 + 0x04 + 0] rocket "attribute"
	lea	ds_sprite_posn+0x64(pc),a0         	| [ld   hl,#ds_sprite_posn + 0x64] rocket
	jbsr	rckt_man                          	| [call rckt_man]

	lea	b_92A0+0x04+1(pc),a1               	| [ld   de,#b_92A0 + 0x04 + 1] rocket "attribute"
	lea	ds_sprite_posn+0x66(pc),a0         	| [ld   hl,#ds_sprite_posn + 0x66] rocket
       * call rckt_man

*=============================================================================
* rckt_man()
*  Description:
*    rocket motion and hit-detection manager
* IN:
*   DE == pointer to rocket "attribute", e.g. &b_92A0_4[0], &b_92A0_4[1]
*         Value is E0 if the ship is oriented normally, not rotated.
*         bit7=orientation, bit6=flipY, bit5=flipX, 1:2=displacement
*   HL == pointer to rocket sprite 0 or 1 ... sprite_posn[$64], sprite_posn[$66]
* OUT:
*  ...
*-----------------------------------------------------------------------------
rckt_man:
* if (0 == rocket.posn[hl].x<7:0>) return
	move.b	(a0),d0                         	| [ld   a,(hl)]
	                               	| [and  a]
	bne.b	0f                               	| [...]
	rts                                    	| [ret  z] [...]
0:

* else ...
	move.b	(a1),d0                         	| [ld   a,(de)] rocket "attribute"
	move.b	d0,d1                           	| [ld   b,a]

* if horizontal orientation, dY = A' ... dY is variable ...
	and.b	#0x07,d0                         	| [and  #0x07] I thought it was only bits 1:2 ?
	scs	d7                              	| [ex   af,af']
         ^^^ TODO review: wrong if carry is needed or D7 used in between!

* ... and dX == A ... maximum displacement in X
	move.b	#6,d0                           	| [ld   a,#6]

* if ( vertical orientation ) ...
	btst.b	#7,d1                           	| [bit  7,b] from l_1F71, bit set if vertical orientation
	jeq	l_0713                             	| [jr   z,l_0713]

* ... swap, i.e. dY = A' = 6 ... dY is maximum, and dX = A ... variable
	scs	d7                              	| [ex   af,af']
         ^^^ TODO review: wrong if carry is needed or D7 used in between!

l_0713:
* if ( ! flipY ) then  dX = ~A
	btst.b	#6,d1                           	| [bit  6,b] flipY: inverted...
	jeq	l_0719                             	| [jr   z,l_0719]
	neg.b	d0                               	| [neg] .. NOT flipY...negate X offset (non-flipped sprite is leftfacing)

l_0719:
* add new dX
	add.b	(a0),d0                          	| [add  a,(hl)] dX is 0 unless the ship is spinning/captured
	move.b	d0,(a0)                         	| [ld   (hl),a]

* if (mrw_sprite.posn[hl].b0 >= 240) ... one test for X limits ($F0) or < 0 ($FF)
	cmp.b	#0xF0,d0                         	| [cp   #0xF0]
	jcc	l_0763_disable_rocket              	| [jr   nc,l_0763_disable_rocket]

* rocket.sX passed to hitd_det_rckt
ld   ixl,a


* NOW onto sY...............

	addq.b	#1,d6                           	| [inc  l] offset[1] ... sprite_posn.sy
* get the stashed dY
	scs	d7                              	| [ex   af,af']
         ^^^ TODO review: wrong if carry is needed or D7 used in between!
* if ( ! flipX ) then  dY = -dY
	btst.b	#5,d1                           	| [bit  5,b] inverted flipX
	jeq	l_0729                             	| [jr   z,l_0729]
	neg.b	d0                               	| [neg] negate dY if NOT flipX (2's comp)
l_0729:
	move.b	d0,d2                           	| [ld   c,a] stash the dY

* add new dY to .sY<7:0>
	add.b	(a0),d0                          	| [add  a,(hl)]
	move.b	d0,(a0)                         	| [ld   (hl),a] sprite.posn[hl].b1

* determines the sign, toggle position.sy:8 on overflow/carry. simple idea, complicated explanation.
	roxr.b	#1,d0                           	| [rra] Cy from the addition rotated into b7
      ^^^^^^ TODO: review cpu X flag
	eor.b	d2,d0                            	| [xor  c] sign bit of addend/subtrahend
	lea	ds_sprite_ctrl(pc),a0              	| [ld   h,#>ds_sprite_ctrl] sy.bit-8 (SPR[n].CTRL.b1:0)
	and.w	#0xFF,d6
	add.w	d6,a0
	      ^^^^ TODO: review XX value
	rol.b	#1,d0                            	| [rlca]
	jcc	l_0738                             	| [jr   nc,l_0738]
* compliment sy:8  (handles both overflow and underflow situation)
	ror.b	#1,(a0)                          	| [rrc  (hl)]

	bcs.b	0f
	clr.b	d7
	bra.b	1f
0:
	st.b	d7
1:
	cmp.b	#1,d7                            	| [ccf]
	roxl.b	#1,(a0)                         	| [rl   (hl)]
      ^^^^^^ TODO: review cpu X flag, cmp doesn't affect it!

* rocket.sy<8:1>, passed to hitd_det_rckt in IXH
l_0738:
	move.b	(a0),d2                         	| [ld   c,(hl)] rocket.sy<8>
	lea	ds_sprite_posn(pc),a0              	| [ld   h,#>ds_sprite_posn]
	and.w	#0xFF,d6
	add.w	d6,a0
	      ^^^^ TODO: review XX value
	move.b	(a0),d0                         	| [ld   a,(hl)] rocket.sy<7:0>
	ror.b	#1,d2                            	| [rrc  c] rotate bit-8 into Cy
	roxr.b	#1,d0                           	| [rra] rotate bit-8 from Cy into A
      ^^^^^^ TODO: review cpu X flag
ld   ixh,a                                 ; stash sy<8:1> for hit-detection parameter

* if ( rocket.sY < 40                   	|| rocket.sY >= 312 ) then _disable_rocket
	cmp.b	#20,d0                           	| [cp   #20] 0x14  0x28 >> 1
	jcs	l_0760_disable_rocket_wposn        	| [jr   c,l_0760_disable_rocket_wposn] L is offset to sY, so first L--
	cmp.b	#156,d0                          	| [cp   #156] 0x9C   0x138 >> 1
	jcc	l_0760_disable_rocket_wposn        	| [jr   nc,l_0760_disable_rocket_wposn] L is offset to sY, so first L--

* index of rocket object/sprite passed through to hitd_dspchr (odd, i.e. b1)
	move.b	d6,d4                           	| [ld   e,l]

* if ( task_active ) then ... else _call_hit_detection_all
	move.b	ds_cpu0_task_actv+0x1D,d0       	| [ld   a,(ds_cpu0_task_actv + 0x1D)] cpu0:f_2000 (capturing boss destroyed, rescued ship spinning)
	                               	| [and  a]
	jeq	l_0757_call_hit_detection_all      	| [jr   z,l_0757_call_hit_detection_all]

* else
* ...the capturing boss is destroyed and the rescued ship is up there spinning,
* and for a precious couple of seconds we get to keep firing rockets at our
* bitter foes... so we need to make sure to ignore the rescued ship objects
* ( $00, thru $06 ) ... in a moment, rockets will be disabled while the
* the rescued ship is landing.

	lea	ds_sprite_posn+0x08(pc),a0         	| [ld   hl,#ds_sprite_posn + 0x08] skip first 4 objects...
	move.b	#44,d1                          	| [ld   b,#44] 0x30 - 4

	jra	l_075C_call_hit_detection          	| [jr   l_075C_call_hit_detection]

l_0757_call_hit_detection_all:
* reset HL and count to check $30 objects
	lea	ds_sprite_posn+0x00(pc),a0         	| [ld   hl,#ds_sprite_posn + 0x00]
	move.b	#0x30,d1                        	| [ld   b,#0x30]

l_075C_call_hit_detection:
	jbsr	hitd_det_rckt                     	| [call hitd_det_rckt]
	rts                                    	| [ret]

* terminate out of bounds rockets
l_0760_disable_rocket_wposn:
	subq.b	#1,d6                           	| [dec  l] .b0 (sX)
	lea	ds_sprite_posn(pc),a0              	| [ld   h,#>ds_sprite_posn] x
	and.w	#0xFF,d6
	add.w	d6,a0
	      ^^^^ TODO: review XX value

* when testing X limits, &sprite_posn[0] already in H so skip loading it
l_0763_disable_rocket:
	clr.b	(a0)                             	| [ld   (hl),#0] x
	lea	ds_sprite_ctrl(pc),a0              	| [ld   h,#>ds_sprite_ctrl]
	and.w	#0xFF,d6
	add.w	d6,a0
	      ^^^^ TODO: review XX value
	clr.b	(a0)                             	| [ld   (hl),#0] attribute bits

	rts                                    	| [ret]

*=============================================================================
* hitd_det_rckt()
*  Description:
*   rocket hit detection
* IN:
*  E == LSB of pointer to object/sprite passed through to
*       hitd_dspchr (odd, i.e. offset to b1)
*  HL == pointer to sprite.posn[], starting object object to test ... 0, or
*        +8 skips 4 objects... see explanation at l_0757.
*  B == count ... $30, or ($30 - 4) as per explanation above.
*  IXL == rocket.sx
*  IXH == rocket.sy<8:1>
* OUT:
*  ...
*-----------------------------------------------------------------------------
hitd_det_rckt:

l_076A_while_object:

* obj_status[L].state<7> ... $80 == inactive object
* obj_collsn_notif[L].b0 ... $81 = hit notification already in progress

* if (0x80 != ( obj_status[L].state & _obj_collsn_notif[L] ))
	lea	b_9200_obj_collsn_notif(pc),a0     	| [ld   h,#>b_9200_obj_collsn_notif] is hit notification already in progress
	and.w	#0xFF,d6
	add.w	d6,a0
	      ^^^^ TODO: review XX value
	move.b	(a0),d0                         	| [ld   a,(hl)]
	lea	b_8800(pc),a0                      	| [ld   h,#>b_8800]
	and.w	#0xFF,d6
	add.w	d6,a0
	      ^^^^ TODO: review XX value
	or.b	(a0),d0                           	| [or   (hl)]
	rol.b	#1,d0                            	| [rlca]
	jcs	l_07B4_next_object                 	| [jr   c,l_07B4_next_object]

* if EXPLODING or SCORE_BITM then next object
	move.b	(a0),d0                         	| [ld   a,(hl)]
	move.b	d0,d2                           	| [ld   c,a]
	and.b	#0xFE,d0                         	| [and  #0xFE] tests for SCORE_BITM (5) also
	cmp.b	#4,d0                            	| [cp   #4] disposition EXPLODING
	jeq	l_07B4_next_object                 	| [jr   z,l_07B4_next_object]

* test dX and dY for within +/- 3 pixels, using the addition
* offset with "Cy" so only 1 test needed for (d>-3 && d<+3 )

* check Y coordinate ... sY<8:1> in A
	addq.b	#1,d6                           	| [inc  l]
	lea	ds_sprite_ctrl(pc),a0              	| [ld   h,#>ds_sprite_ctrl] sprite.sy<8>
	and.w	#0xFF,d6
	add.w	d6,a0
	      ^^^^ TODO: review XX value
	move.b	(a0),d3                         	| [ld   d,(hl)]
	lea	ds_sprite_posn(pc),a0              	| [ld   h,#>ds_sprite_posn] sprite.sy<7:0>
	and.w	#0xFF,d6
	add.w	d6,a0
	      ^^^^ TODO: review XX value
	move.b	(a0),d0                         	| [ld   a,(hl)]
	ror.b	#1,d3                            	| [rrc  d]
	roxr.b	#1,d0                           	| [rra]
      ^^^^^^ TODO: review cpu X flag
	subq.b	#1,d6                           	| [dec  l]

	sub.b	ixh,d0                           	| [sub  ixh] sprite.sy<1:8> -= rocket.sy<1:8>
	subq.b	#3,d0                           	| [sub  #3] tolerance for hit-check (divided by 2 to account for scaling)
	addq.b	#6,d0                           	| [add  a,#6]
	jcc	l_07B4_next_object                 	| [jr   nc,l_07B4_next_object]

* check X coordinate
	move.b	d2,d0                           	| [ld   a,c] reload object status e.g. 8800[L]
	subq.b	#1,d0                           	| [dec  a]
	and.b	#0xFE,d0                         	| [and  #0xFE]
	scs	d7                              	| [ex   af,af'] object status to hitd_dspchr
         ^^^ TODO review: wrong if carry is needed or D7 used in between!

	move.b	ds_plyr_actv+_b_2ship,d0        	| [ld   a,(ds_plyr_actv +_b_2ship)]
	                               	| [and  a]

	move.b	(a0),d0                         	| [ld   a,(hl)] sprite.sX

	jne	l_07A4                             	| [jr   nz,l_07A4] and  a
      ^^^^^^ TODO: review cpu flags (move.b,jne)

	sub.b	ixl,d0                           	| [sub  ixl] sprite.sX -= rocket.sX
	subq.b	#6,d0                           	| [sub  #6]
	add.b	#11,d0                           	| [add  a,#11]
	jcs	hitd_dspchr_rckt                   	| [jr   c,hitd_dspchr_rckt]
	jra	l_07B4_next_object                 	| [jr   l_07B4_next_object]

l_07A4:
	sub.b	ixl,d0                           	| [sub  ixl] sprite.sX -= rocket.sX
	sub.b	#20,d0                           	| [sub  #20]
	add.b	#11,d0                           	| [add  a,#11]
	jcs	hitd_dspchr_rckt                   	| [jr   c,hitd_dspchr_rckt]
	addq.b	#4,d0                           	| [add  a,#4]
	jcs	l_07B4_next_object                 	| [jr   c,l_07B4_next_object]
	add.b	#11,d0                           	| [add  a,#11]
	jcs	hitd_dspchr_rckt                   	| [jr   c,hitd_dspchr_rckt]

l_07B4_next_object:
	addq.b	#2,d6                           	| [inc  l] * 2
	subq.b	#1,d1                           	| [...]
	jne	l_076A_while_object                	| [djnz l_076A_while_object]

	rts                                    	| [ret]

*=============================================================================
* hitd_dspchr()
*  Description:
*   Detect collisions from the reference of the rocket ... update hit count
*   and call common subroutine.
* IN:
*   L == offset/index of destroyed enemy/bomb sprite[n].b1
*   E == offset/index of sprite[rocket.n].b1
*   A' == object status
* OUT:
*  ...
* RETURN:
*   1 on jp   l_07B4_next_object
*   0
*-----------------------------------------------------------------------------
hitd_dspchr_rckt:

	move.b	d6,d0                           	| [ld   a,l] stash L, use HL for 16-bits math
	move.w	ds_plyr_actv+_w_hit_ct(pc),a0   	| [ld   hl,(ds_plyr_actv +_w_hit_ct)]
                  ^^^^^^ TODO: review move.w into address register
	addq.w	#1,a0                           	| [inc  hl]
	move.b	a0,ds_plyr_actv+_w_hit_ct       	| [ld   (ds_plyr_actv +_w_hit_ct),hl]
	move.b	d0,d6                           	| [ld   l,a] restore L

* hitd_dspchr

*=============================================================================
* hitd_dspchr()
*  Description:
*   collisions are detected from the reference of the rocket or fighter - this
*   function is common to both rocket and fighter hit detection, and
*   dispatches the target appropriately.
* IN:
*   L == offset/index of destroyed enemy/bomb sprite[n].b1
*   E == offset/index of rocket[n].b1 ... sprite.posn[RCKTn].y must
*        be set to zero as required for correct handling in rckt_sprite_init
*   E == offset/index of fighter[n].b0 ... sprite.ctrl[FGHTRn].b0 is set to 0 ... does it matter?
*   A' == object status
* OUT:
*  ...
* RETURN:
*  ...
*-----------------------------------------------------------------------------
hitd_dspchr:
	lea	ds_sprite_posn(pc),a1              	| [ld   d,#>ds_sprite_posn] _sprite_posn[E].b0 = 0 ... sX
	and.w	#0xFF,d4
	add.w	d4,a1
	      ^^^^ TODO: review XX value
	clr.b	d0                               	| [xor  a]
	move.b	d0,(a1)                         	| [ld   (de),a]
	lea	ds_sprite_ctrl(pc),a1              	| [ld   d,#>ds_sprite_ctrl] _sprite_ctrl[E].b0 = 0 ... attributes
	and.w	#0xFF,d4
	add.w	d4,a1
	      ^^^^ TODO: review XX value
	move.b	d0,(a1)                         	| [ld   (de),a]

	addq.b	#1,d6                           	| [inc  l]
	lea	ds_sprite_code(pc),a0              	| [ld   h,#>ds_sprite_code] sprite.cclr.b1 ...
	and.w	#0xFF,d6
	add.w	d6,a0
	      ^^^^ TODO: review XX value
	move.b	(a0),d0                         	| [ld   a,(hl)]
	move.b	d0,d2                           	| [ld   c,a] ... for later ....
	tst.b	d0                               	| [and  a]
	jeq	l_08CA_hit_green_boss              	| [jp   z,l_08CA_hit_green_boss] color map 0 is the "green" boss
	subq.b	#1,d6                           	| [dec  l]
	cmp.b	#0x0B,d0                         	| [cp   #0x0B] color map $B is for "bombs"
	jeq	l_0815_bomb_hit                    	| [jr   z,l_0815_bomb_hit]

* if rocket or ship collided with bug
	scs	d7                              	| [ex   af,af'] un-stash parameter ... 1 if moving bug (hit by rocket or fighter)
         ^^^ TODO review: wrong if carry is needed or D7 used in between!
	jne	l_081E_hdl_flyng_bug               	| [jr   nz,l_081E_hdl_flyng_bug] will come back to $07DB or l_07DF

* else if rocket hit stationary bug
	scs	d7                              	| [ex   af,af'] re-stash parameter
         ^^^ TODO review: wrong if carry is needed or D7 used in between!

l_07DB:
* set it up for elimination
	lea	b_9200_obj_collsn_notif(pc),a0     	| [ld   h,#>b_9200_obj_collsn_notif] = $81
	and.w	#0xFF,d6
	add.w	d6,a0
	      ^^^^ TODO: review XX value
	move.b	#0x81,(a0)                      	| [ld   (hl),#0x81]

l_07DF:
* if capture boss ...
	move.b	ds_plyr_actv+_b_bmbr_boss_cobj,d0	| [ld   a,(ds_plyr_actv +_b_bmbr_boss_cobj)]
	sub.b	d6,d0                            	| [sub  l]
	jne	l_07EC                             	| [jr   nz,l_07EC]
* ... then ...
	move.b	d0,ds_plyr_actv+_b_bmbr_boss_cflag	| [ld   (ds_plyr_actv +_b_bmbr_boss_cflag),a] 0: shot the boss that was starting the capture beam
	addq.b	#1,d0                           	| [inc  a]
	move.b	d0,ds_plyr_actv+_b_bmbr_boss_cobj	| [ld   (ds_plyr_actv +_b_bmbr_boss_cobj),a] 1: invalidate the capture boss object

l_07EC:
* use the sprite color to get index to sound

	move.l	a0,-(sp)                        	| [push hl] &obj_collsn_notif[L]

* if sprite color == 7 ... (check for red captured ship)
	move.b	d2,d0                           	| [ld   a,c] .... sprite.cclr.b1
	cmp.b	#0x07,d0                         	| [cp   #0x07]
	jne	l_07F5                             	| [jr   nz,l_07F5]
	subq.b	#1,d0                           	| [dec  a]
	jra	l_07F8_                            	| [jr   l_07F8_]
* ... else ...
l_07F5:
	subq.b	#1,d0                           	| [dec  a]
	and.b	#0x03,d0                         	| [and  #0x03]

l_07F8_:
	lea	b_9AA0+0x01(pc),a0                 	| [ld   hl,#b_9AA0 + 0x01] b_9AA0[1 + A] = 1 ... sound-fx count/enable registers
	jbsr	rst_10                            	| [rst  0x10] HL += A
	move.b	#1,(a0)                         	| [ld   (hl),#1]

* if sprite color == 7
	move.b	d2,d0                           	| [ld   a,c] .... sprite.cclr.b1
	cmp.b	#0x07,d0                         	| [cp   #0x07]
	jne	l_0808                             	| [jr   nz,l_0808]
	lea	ds_plyr_actv+_b_bmbr_boss_cflag(pc),a0	| [ld   hl,#ds_plyr_actv +_b_bmbr_boss_cflag] 0 ... enable capture-mode selection
	clr.b	(a0)                             	| [ld   (hl),#0]

l_0808:
* _bug_collsn[ color ] += 1
	lea	ds_bug_collsn_hit_mult+0x00(pc),a0 	| [ld   hl,#ds_bug_collsn_hit_mult + 0x00] rocket/bug or ship/bug collision
	jbsr	rst_10                            	| [rst  0x10] HL += A ... _collsn_hit_mult[sprite.cclr.b1]
	addq.b	#1,(a0)                         	| [inc  (hl)]

	scs	d7                              	| [ex   af,af'] un-stash parameter/flag
         ^^^ TODO review: wrong if carry is needed or D7 used in between!
	jeq	l_0811                             	| [jr   z,l_0811]
	addq.b	#1,(a0)                         	| [inc  (hl)] shot blue boss
l_0811:
	move.l	(sp)+,a0                        	| [pop  hl]
	jra	l_07B4_next_object                 	| [jp   l_07B4_next_object]

* this invalidates the bomb object... but what about the ship?
l_0815_bomb_hit:
	lea	ds_sprite_posn(pc),a0              	| [ld   h,#>ds_sprite_posn] sprite[L].sx = 0 ... bomb colliding with fighter
	and.w	#0xFF,d6
	add.w	d6,a0
	      ^^^^ TODO: review XX value
	clr.b	(a0)                             	| [ld   (hl),#0]
	lea	b_8800(pc),a0                      	| [ld   h,#>b_8800] sprt_mctl_objs[L].state
	and.w	#0xFF,d6
	add.w	d6,a0
	      ^^^^ TODO: review XX value
	move.b	#0x80,(a0)                      	| [ld   (hl),#0x80] disposition = INACTIVE

	rts                                    	| [ret]

* Handle flying bug collision (bullet or ship). Not stationary bugs.
l_081E_hdl_flyng_bug:
	lea	b_8800(pc),a0                      	| [ld   h,#>b_8800]
	and.w	#0xFF,d6
	add.w	d6,a0
	      ^^^^ TODO: review XX value

	move.l	a0,-(sp)                        	| [push hl]
	scs	d7                              	| [ex   af,af'] re-stash parameter
         ^^^ TODO review: wrong if carry is needed or D7 used in between!
	addq.b	#1,d6                           	| [inc  l]
	move.b	(a0),d0                         	| [ld   a,(hl)] sprt_mctl_objs[L].mctl_idx

	lea	ds_bug_motion_que(pc),a0           	| [ld   h,#>ds_bug_motion_que] bug_motion_que[A].b13 = 0 (release this slot)
	and.w	#0xFF,d6
	add.w	d6,a0
	      ^^^^ TODO: review XX value
	add.b	#0x13,d0                         	| [add  a,#0x13]
	move.b	d0,d6                           	| [ld   l,a]
	clr.b	(a0)                             	| [ld   (hl),#0]

	lea	b_bug_flyng_hits_p_round(pc),a0    	| [ld   hl,#b_bug_flyng_hits_p_round] +=1
	addq.b	#1,(a0)                         	| [inc  (hl)]

* bug_flying_hit_cnt is probably only meaningful in challenge rounds. In other
* rounds it is simply intiialized to 0 at start of round.
	lea	w_bug_flying_hit_cnt(pc),a0        	| [ld   hl,#w_bug_flying_hit_cnt] hit_cnt -= 1 ... reset 8 each challenge_wave
	subq.b	#1,(a0)                         	| [dec  (hl)]
	move.l	(sp)+,a0                        	| [pop  hl] &sprt_mctl_objs[L].mctl_idx

	jne	l_0849                             	| [jr   nz,l_0849]
      ^^^^^^ TODO: review cpu flags (move.l,jne)

* award bonus points for destroying complete formation of 8 on challenge stage
	lea	b_9200_obj_collsn_notif(pc),a0     	| [ld   h,#>b_9200_obj_collsn_notif] = b_9280[4 + 1]
	and.w	#0xFF,d6
	add.w	d6,a0
	      ^^^^ TODO: review XX value
	move.b	ds2_stg_chllg_rnd_attrib+1,d0   	| [ld   a,(ds2_stg_chllg_rnd_attrib + 1)] sprite code + flag
	move.b	d0,(a0)                         	| [ld   (hl),a]

	move.b	ds2_stg_chllg_rnd_attrib+0,d0   	| [ld   a,(ds2_stg_chllg_rnd_attrib + 0)] add "score" to bug_collsn[$0F] (why add?)
	move.b	d0,d5                           	| [ld   h,a]
	move.b	ds_bug_collsn_hit_mult+0x0F,d0  	| [ld   a,(ds_bug_collsn_hit_mult + 0x0F)]
	add.b	d5,d0                            	| [add  a,h]
	move.b	d0,ds_bug_collsn_hit_mult+0x0F  	| [ld   (ds_bug_collsn_hit_mult + 0x0F),a] += b_9280[4 + 0] ... "score"

	jra	l_07DF                             	| [jr   l_07DF]

l_0849:
* handle special cases of flying bugs, then jp   l_07DF

* if (hit == captured ship)
	move.b	d2,d0                           	| [ld   a,c] .... sprite.cclr.b1
	cmp.b	#7,d0                            	| [cp   #7] color map 7 ... red captured ship
	jne	l_0852                             	| [jr   nz,l_0852]

	move.b	#0xB8,d3                        	| [ld   d,#0xB8]
	jra	l_08B0_set_bonus_sprite_code       	| [jr   l_08B0_set_bonus_sprite_code]

* else if ( hit bonus-bee or clone bonus-bee )
l_0852:
	move.b	ds_plyr_actv+_b_bbee_obj,d0     	| [ld   a,(ds_plyr_actv +_b_bbee_obj)] get object of parent bonus-bee
	cmp.b	d6,d0                            	| [cp   l]
	jeq	l_08B6                             	| [jp   z,l_08B6]

	move.b	d6,d0                           	| [ld   a,l] check if this one is one of the clones ("transients" i.e.... $38 etc.)
	and.b	#0x38,d0                         	| [and  #0x38]
	cmp.b	#0x38,d0                         	| [cp   #0x38]
	jeq	l_08B6                             	| [jp   z,l_08B6]

* else if ! blue-boss ... l_07DB
	move.b	d2,d0                           	| [ld   a,c] .... sprite.cclr.b1
	cmp.b	#0x01,d0                         	| [cp   #0x01] color map 1 ... blue boss hit once
	jne	l_07DB                             	| [jp   nz,l_07DB]

* ... else ... handle blue boss
* check for captured-fighter
	movem.w	d3/d4,-(sp)                    	| [push de] &ds_sprite_ctrl[E]
	move.l	a1,-(sp)                        	| [push de] &ds_sprite_ctrl[E]
	move.b	d6,d0                           	| [ld   a,l]
	and.b	#0x07,d0                         	| [and  #0x07] mask off to reference the captured ship
	move.b	d0,d4                           	| [ld   e,a]
	lea	b_8800(pc),a1                      	| [ld   d,#>b_8800]
	and.w	#0xFF,d4
	add.w	d4,a1
	      ^^^^ TODO: review XX value
	move.b	(a1),d0                         	| [ld   a,(de)]
	cmp.b	#9,d0                            	| [cp   #9] is this a valid capture ship status ...i.e. diving? ...status may still...
	jne	l_0899                             	| [jr   nz,l_0899] ...be $80 meaning I have killed the boss before he pulls the ship all in!
* captured ship is diving

	move.l	a0,-(sp)                        	| [push hl] stash the boss object locator e.g. b_8830
	exg	a1,a0                              	| [ex   de,hl] HL := &sprt_mctl_objs[ ].b0
	addq.b	#1,d6                           	| [inc  l]
	move.b	(a0),d0                         	| [ld   a,(hl)] sprt_mctl_objs[ HL ].mctl_idx
	add.b	#0x13,d0                         	| [add  a,#0x13] mctl_mpool[n].b13
	move.b	d0,d4                           	| [ld   e,a]
	lea	ds_bug_motion_que(pc),a1           	| [ld   d,#>ds_bug_motion_que] mctl_mpool[n].b13 == 0 ... make slot inactive
	and.w	#0xFF,d4
	add.w	d4,a1
	      ^^^^ TODO: review XX value
	clr.b	d0                               	| [xor  a]
	move.b	d0,(a1)                         	| [ld   (de),a]
	lea	ds_sprite_code(pc),a0              	| [ld   h,#>ds_sprite_code]
	and.w	#0xFF,d6
	add.w	d6,a0
	      ^^^^ TODO: review XX value
	move.b	#9,(a0)                         	| [ld   (hl),#9] color map 9 for white ship
	subq.b	#1,d6                           	| [dec  l]
	move.b	d6,d0                           	| [ld   a,l]
	move.b	d0,ds_plyr_actv+_b_bmbr_boss_cobj	| [ld   (ds_plyr_actv +_b_bmbr_boss_cobj),a] updated object locator token of rescued ship   (token was 1)
	lea	b_8800(pc),a0                      	| [ld   h,#>b_8800] the captured ship object becomes inactive (0)
	and.w	#0xFF,d6
	add.w	d6,a0
	      ^^^^ TODO: review XX value
	clr.b	d0                               	| [xor  a]
	move.b	d0,(a0)                         	| [ld   (hl),a]
	move.b	d0,ds5_928A_captr_status+0x01   	| [ld   (ds5_928A_captr_status + 0x01),a] 0
	addq.b	#1,d0                           	| [inc  a]
	move.b	d0,ds_cpu0_task_actv+0x1D       	| [ld   (ds_cpu0_task_actv + 0x1D),a] 1 ... shot the boss that captured the ship
	move.b	d0,ds5_928A_captr_status+0x03   	| [ld   (ds5_928A_captr_status + 0x03),a] 1
	move.b	d0,b_9AA0+0x11                  	| [ld   (b_9AA0 + 0x11),a] 1 ... sound-fx count/enable registers, "rescued ship" music
	move.l	(sp)+,a0                        	| [pop  hl] restore boss object locator e.g. b_883x

l_0899:
* lone blue boss killed, or boss killed before pulling the beam all in
	move.l	(sp)+,a1                        	| [pop  de] ds_sprite_ctrl[n].b1
	movem.w	(sp)+,d3/d4                    	| [pop  de] ds_sprite_ctrl[n].b1

	move.l	a0,-(sp)                        	| [push hl] sprt_mctl_objs[L] (boss) e.g. b_8830
	move.b	#6,d0                           	| [ld   a,#6]
	move.b	d0,ds4_game_tmrs+1              	| [ld   (ds4_game_tmrs + 1),a] 6 ... captured ship timer
	move.b	d6,d0                           	| [ld   a,l]
	and.b	#7,d0                            	| [and  #7] gets offset of object from $30
	lea	ds_plyr_actv+_ds_bmbr_boss_scode(pc),a0	| [ld   hl,#ds_plyr_actv +_ds_bmbr_boss_scode] bonus code/scoring attributes for 1 of 4 flying bosses
	jbsr	rst_10                            	| [rst  0x10] HL += A
	move.b	(a0),d0                         	| [ld   a,(hl)] .b0 ... add to bug_collsn[$0F] (adjusted scoring increment)
	addq.b	#1,d6                           	| [inc  l]
	move.b	(a0),d3                         	| [ld   d,(hl)] .b1 -> obj_collsn_notif[L] ... sprite code + 0x80
l_08AA:
	lea	ds_bug_collsn_hit_mult+0x0F(pc),a0 	| [ld   hl,#ds_bug_collsn_hit_mult + 0x0F] bonus score increment boss killed
	add.b	(a0),d0                          	| [add  a,(hl)]
	move.b	d0,(a0)                         	| [ld   (hl),a]
	move.l	(sp)+,a0                        	| [pop  hl]

* jp here if shot the flying captured ship
l_08B0_set_bonus_sprite_code:
	lea	b_9200_obj_collsn_notif(pc),a0     	| [ld   h,#>b_9200_obj_collsn_notif]
	and.w	#0xFF,d6
	add.w	d6,a0
	      ^^^^ TODO: review XX value
	move.b	d3,(a0)                         	| [ld   (hl),d] shot boss ... (9230):=BA B5. B7?   B8 if hit captured ship
	jra	l_07DF                             	| [jp   l_07DF]

l_08B6:

	move.l	a0,-(sp)                        	| [push hl]
	lea	b8_99B0_X3attackcfg_ct(pc),a0      	| [ld   hl,#b8_99B0_X3attackcfg_ct] decrement (HL) (counter for triple attack?)
	subq.b	#1,(a0)                         	| [dec  (hl)]
	move.l	(sp)+,a0                        	| [pop  hl]
	jne	l_07DB                             	| [jp   nz,l_07DB]
      ^^^^^^ TODO: review cpu flags (move.l,jne)
	move.b	b8_99B2_X3attackcfg_parm1,d0    	| [ld   a,(b8_99B2_X3attackcfg_parm1)] 99B0==0 ... destroyed all 3 of triple-attack
	move.b	d0,d3                           	| [ld   d,a]
	move.b	b8_99B1_X3attackcfg_parm0,d0    	| [ld   a,(b8_99B1_X3attackcfg_parm0)]

	move.l	a0,-(sp)                        	| [push hl]

	jra	l_08AA                             	| [jp   l_08AA]

l_08CA_hit_green_boss:
	addq.b	#1,d0                           	| [inc  a]
	move.b	d0,(a0)                         	| [ld   (hl),a]
	move.b	d0,b_9AA0+0x04                  	| [ld   (b_9AA0 + 0x04),a] sound-fx count/enable registers, hit_green_boss
	subq.b	#1,d6                           	| [dec  l]

	jra	l_07B4_next_object                 	| [jp   l_07B4_next_object]


*=============================================================================
* f_08D3()
*  Description:
*   bug motion runner
*   The flying bugs are tracked by the queue (ds_bug_motion_que) which is
*   populated by f_2916.
* IN:
*  ...
* OUT:
*  ...
*-----------------------------------------------------------------------------
f_08D3:
	lea	ds_bug_motion_que(pc),a2           	| [ld   ix,#ds_bug_motion_que]

	move.b	#0x0C,d0                        	| [ld   a,#0x0C]
	move.b	d0,b_bug_que_idx                	| [ld   (b_bug_que_idx),a] 12 ... nbr of queue structures

	lea	b_bugs_flying_cnt(pc),a0           	| [ld   hl,#b_bugs_flying_cnt] capture the (previous) count and zero the current count
	move.b	(a0),d0                         	| [ld   a,(hl)]
	clr.b	(a0)                             	| [ld   (hl),#0]
	addq.w	#1,a0                           	| [inc  hl] b_bugs_flying_nbr
	move.b	d0,(a0)                         	| [ld   (hl),a] = bugs_flying_cnt

* traverse the object-motion queue
for__pool_idx:
	btst.b	#0,(0x13,a2)                    	| [bit  0,0x13(ix)] check for activated state
	jeq	next__pool_idx                     	| [jp   z,next__pool_idx]

	lea	b_bugs_flying_cnt(pc),a0           	| [ld   hl,#b_bugs_flying_cnt] +=1
	addq.b	#1,(a0)                         	| [inc  (hl)]

	move.b	(0x10,a2),d6                    	| [ld   l,0x10(ix)] object identifier...8800[L]
	lea	b_8800(pc),a0                      	| [ld   h,#>b_8800]
	and.w	#0xFF,d6
	add.w	d6,a0
	      ^^^^ TODO: review XX value

* 9 is diving, 7 is spawning, 3 (and 6) bomb?
* if (!(A == 3                          	|| A == 7|| A == 9)) ...
	move.b	(a0),d0                         	| [ld   a,(hl)]
	cmp.b	#3,d0                            	| [cp   #3] status 3 is what?
	jeq	mctl_fltpn_dspchr                  	| [jr   z,mctl_fltpn_dspchr]
	cmp.b	#9,d0                            	| [cp   #9] if 8800[L]==9 ... flying into formation or diving out.
	jeq	mctl_fltpn_dspchr                  	| [jr   z,mctl_fltpn_dspchr]
	cmp.b	#7,d0                            	| [cp   #7] if 8800[L]==7 ... spawning (new stage)
* ... then ...
* status==4 ... shot a non-flying capturing boss (ship will soon go rogue and launch out)
* HL==8830, *HL==04, 8831==40
	jne	case_0E49_make_object_inactive     	| [jp   nz,case_0E49_make_object_inactive] sets object state to $80


mctl_fltpn_dspchr:
* load a new flight segment if this one timed out, otherwise go directly to flite path handler and continue with same data-set
	subq.b	#1,(0x0D,a2)                    	| [dec  0x0D(ix)] check for expiration of this data-set
	jne	l_0C05_flite_pth_cont              	| [jp   nz,l_0C05_flite_pth_cont]

* flight-path vector has expired... setup HL as pointer to next data token
	move.b	(0x08,a2),d6                    	| [ld   l,0x08(ix)]
	move.b	(0x09,a2),d5                    	| [ld   h,0x09(ix)]


* this label allows reading the next token after doing state-selection
j_090E_flite_path_init:
	move.b	(a0),d0                         	| [ld   a,(hl)] data_set[n + 0]

* get next token and check if ordinary data or state-selection
* if (token < 0xEF) ... then skip processing of jp-table
	cmp.b	#0xEF,d0                         	| [cp   #0xEF]
	jcs	l_0BDC_flite_pth_load              	| [jp   c,l_0BDC_flite_pth_load] if token < $ef, continue to flight-path handler

* else ...
*  complimented token indexes into jp-tbl for selection of next state

* the current data pointer could be copied from HL into 92FA,92FB or loaded directly from ix($08)ix($09) by handler
*

	move.l	a0,-(sp)                        	| [push hl] ptr to data table
	not.b	d0                               	| [cpl]
	lea	d_0920_jp_tbl(pc),a0               	| [ld   hl,#d_0920_jp_tbl]
	jbsr	rst_08                            	| [rst  0x08] HL += 2A
	move.b	(a0),d0                         	| [ld   a,(hl)]
	addq.w	#1,a0                           	| [inc  hl]
	move.b	(a0),d5                         	| [ld   h,(hl)]
	move.b	d0,d6                           	| [ld   l,a]
	exg	(sp),a0                            	| [ex   (sp),hl] restore HL and goto stacked address in one-fell-swoop.. sneaky!
	rts                                    	| [ret]

d_0920_jp_tbl:
	.long case_0E49_make_object_inactive
	.long case_0B16   | attack elements that break formation to attack ship (level 3+)
	.long case_0B46   | returning to base: moths or bosses from top of screen, bees from bottom of loop-around.
	.long case_0B4E   | bee dive and starting loopback, or boss left position and starting dive down
	.long case_0AA0   | attack wave element hits turning point and heads to home
	.long case_0BD1   | bee has flown under bottom of screen and now turns for home
	.long case_0B5F   | bee has flown under bottom of screen and now turns for home
	.long case_0B87   | tractor beam reaches ship
	.long case_0B98   | attack wave
	.long case_0BA8   | one red moth left in "free flight mode"
	.long case_0942   | ?
	.long case_0A53   | capture boss diving
	.long case_0A01   | diving elements have left formation and fired
	.long case_097B   | bonus bee
	.long case_0968   | diving attacks stop and bugs go home
	.long case_0955   | attack wave
	.long case_094E   | one red moth left in "free flight mode"

* when ... no idea
case_0942:  ; $0A
	move.b	(0x10,a2),d4                    	| [ld   e,0x10(ix)] offset of object ...8800[E]
	lea	b_8800(pc),a1                      	| [ld   d,#>b_8800]
	and.w	#0xFF,d4
	add.w	d4,a1
	      ^^^^ TODO: review XX value
	move.b	#0x03,d0                        	| [ld   a,#0x03] set to state 3
	move.b	d0,(a1)                         	| [ld   (de),a]
	addq.w	#1,a0                           	| [inc  hl] ptr to data table
	jra	j_090E_flite_path_init             	| [jp   j_090E_flite_path_init]

* continuous-bombing mode
case_094E:  ; $10 (0xEF)
	move.b	ds_new_stage_parms+0x09,d0      	| [ld   a,(ds_new_stage_parms + 0x09)] jumps the pointer on/after stage 8
	                               	| [and  a]
	jra	l_0959                             	| [jp   l_0959]

* attack wave
case_0955:  ; $0F
	move.b	ds_new_stage_parms+0x08,d0      	| [ld   a,(ds_new_stage_parms + 0x08)] jumps the pointer on/after stage 8
	                               	| [and  a]

l_0959:
	jeq	l_0963                             	| [jr   z,l_0963]

* not until stage 8 ... load a pointer from data tbl into .p08 (09)
	addq.w	#1,a0                           	| [inc  hl] ptr to data table
	move.b	(a0),d0                         	| [ld   a,(hl)]
	addq.w	#1,a0                           	| [inc  hl]
	move.b	(a0),d5                         	| [ld   h,(hl)]
	move.b	d0,d6                           	| [ld   l,a]
	jra	l_0B8C                             	| [jp   l_0B8C] skips inc hl ($0B8C), update $08, $09, $0D, break

l_0963:
* skip loading new address
	addq.w	#2,a0                           	| [inc  hl] ptr to data table * 2
	jra	l_0B8B                             	| [jp   l_0B8B] inc hl and finalize

* diving attacks stop and bugs go home
case_0968:  ; $0E
	move.b	(0x10,a2),d4                    	| [ld   e,0x10(ix)] home_posn_rc[ obj_id ]
	lea	sprt_fmtn_hpos(pc),a1              	| [ld   d,#>sprt_fmtn_hpos] home_posn_rc[ ix($10) ]
	and.w	#0xFF,d4
	add.w	d4,a1
	      ^^^^ TODO: review XX value
	move.b	(a1),d0                         	| [ld   a,(de)] row position index
	move.b	d0,d4                           	| [ld   e,a]
	lea	ds_hpos_loc_orig(pc),a1            	| [ld   d,#>ds_hpos_loc_orig] b1: copy of origin data
	and.w	#0xFF,d4
	add.w	d4,a1
	      ^^^^ TODO: review XX value
	addq.b	#1,d4                           	| [inc  e]
	move.b	(a1),d0                         	| [ld   a,(de)] copy of origin data
	add.b	#0x20,d0                         	| [add  a,#0x20]
	move.b	d0,(0x01,a2)                    	| [ld   0x01(ix),a] sY<8:1>
	jra	l_0B8B                             	| [jp   l_0B8B] inc hl and finalize

* yellow alien special attack leader started dive ready to replicate
case_097B:  ; $0D

	move.l	a0,-(sp)                        	| [push hl] ptr to data table
	move.b	(0x10,a2),d4                    	| [ld   e,0x10(ix)] object offset of bee that is to be split
* find an inactive ($80) yellow alien or getout.
	lea	b_8800+0x38(pc),a0                 	| [ld   hl,#b_8800 + 0x38]
	move.b	#4,d1                           	| [ld   b,#4]
l_0984:
	move.b	(a0),d0                         	| [ld   a,(hl)]
	rol.b	#1,d0                            	| [rlca] test bit 7 (0x80 if disposition == inactive)
	jcs	l_098F_do_split_off_bonus_bee      	| [jr   c,l_098F_do_split_off_bonus_bee]
	addq.b	#2,d6                           	| [inc  l] * 2
	subq.b	#1,d1                           	| [...]
	jne	l_0984                             	| [djnz l_0984]
	jra	l_09FA_bonusbee_creat_fail         	| [jp   l_09FA_bonusbee_creat_fail]

l_098F_do_split_off_bonus_bee:
	lea	ds_sprite_code(pc),a0              	| [ld   h,#>ds_sprite_code]
	and.w	#0xFF,d6
	add.w	d6,a0
	      ^^^^ TODO: review XX value
	move.b	d5,d3                           	| [ld   d,h]
	move.b	(a1),d0                         	| [ld   a,(de)] _sprite_code[index attack leader]
	move.b	d0,(a0)                         	| [ld   (hl),a]
	addq.b	#1,d6                           	| [inc  l] .b1
	addq.b	#1,d4                           	| [inc  e] .b1
	move.b	(a1),d0                         	| [ld   a,(de)] _sprite_cclr[index attack leader]
	move.b	d0,(a0)                         	| [ld   (hl),a]
	subq.b	#1,d6                           	| [dec  l] .b0
	move.b	d6,d0                           	| [ld   a,l]
	scs	d7                              	| [ex   af,af'] stash index of spawning yellow alien
         ^^^ TODO review: wrong if carry is needed or D7 used in between!

* find available slot or getout
	lea	ds_bug_motion_que+0xF0-1(pc),a0    	| [ld   hl,#ds_bug_motion_que + 0xF0 - 1] start at end/top of segment
	lea	-l_14(pc),a1                       	| [ld   de,#-0x14] sizeof array element
	move.b	#0x0C,d1                        	| [ld   b,#0x0C] nbr of object in the array
l_09A3:
	move.b	(a0),d0                         	| [ld   a,(hl)]
	and.b	#0x01,d0                         	| [and  #0x01] check if this slot available
	jeq	l_09AE_doit                        	| [jr   z,l_09AE_doit]
	add.w	d3,a0                            	| [add  hl,de]
  ^^^^ TODO: review d3 computation above
	subq.b	#1,d1                           	| [...]
	jne	l_09A3                             	| [djnz l_09A3]

	jra	l_09FA_bonusbee_creat_fail         	| [jp   l_09FA_bonusbee_creat_fail]

l_09AE_doit:
	add.w	d3,a0                            	| [add  hl,de]
  ^^^^ TODO: review d3 computation above
	addq.w	#1,a0                           	| [inc  hl]
	move.b	(0x00,a2),d0                    	| [ld   a,0x00(ix)] coordinate of parent alien
	move.b	#ixl,d4                         	| [ld   e,ixl]
	move.b	#ixh,d3                         	| [ld   d,ixh]
	exg	a1,a0                              	| [ex   de,hl]
ld   iyl,e
ld   iyh,d
	move.b	#0x00,d1                        	| [ld   bc,#0x0006] 6
	move.b	#0x06,d2                        	| [ld   bc,#0x0006] 6
	jbsr	ldir                              	| [ldir]
     ^^^^ TODO: review special instruction inputs
	move.b	#6,d2                           	| [ld   c,#6]
	add.w	d1,a0                            	| [add  hl,bc]
  ^^^^ TODO: review d1 computation above
	exg	a1,a0                              	| [ex   de,hl]
	add.w	d3,a0                            	| [add  hl,de]
  ^^^^ TODO: review d3 computation above
	exg	a1,a0                              	| [ex   de,hl]
	move.b	#4,d2                           	| [ld   c,#4]
	jbsr	ldir                              	| [ldir]
     ^^^^ TODO: review special instruction inputs
	move.b	(0x13,a2),d0                    	| [ld   a,0x13(ix)] 0x13(iy)
	move.b	d0,(0x13,a3)                    	| [ld   0x13(iy),a]

* load new data pointer from data and store in flite q object
	move.l	(sp)+,a0                        	| [pop  hl] special attack, pushes hl right away
	addq.w	#1,a0                           	| [inc  hl]
	move.b	(a0),d0                         	| [ld   a,(hl)]
	move.b	d0,(0x08,a3)                    	| [ld   0x08(iy),a]
	addq.w	#1,a0                           	| [inc  hl]
	move.b	(a0),d0                         	| [ld   a,(hl)]
	move.b	d0,(0x09,a3)                    	| [ld   0x09(iy),a]

	move.b	#0x01,(0x0A,a3)                 	| [ld   0x0A(iy),#0x01]
	move.b	#0x02,(0x0B,a3)                 	| [ld   0x0B(iy),#0x02]
	move.b	#0x01,(0x0D,a3)                 	| [ld   0x0D(iy),#0x01]
	scs	d7                              	| [ex   af,af'] index of spawning yellow alien
         ^^^ TODO review: wrong if carry is needed or D7 used in between!
	move.b	d0,(0x10,a3)                    	| [ld   0x10(iy),a]
	move.b	d0,d4                           	| [ld   e,a]
	lea	b_8800(pc),a1                      	| [ld   d,#>b_8800]
	and.w	#0xFF,d4
	add.w	d4,a1
	      ^^^^ TODO: review XX value
	move.b	#9,d0                           	| [ld   a,#9] 09: diving -> 8800[i]
	move.b	d0,(a1)                         	| [ld   (de),a]
	addq.b	#1,d4                           	| [inc  e]
	move.b	#iyl,d0                         	| [ld   a,iyl]
	move.b	d0,(a1)                         	| [ld   (de),a]
	addq.w	#1,a0                           	| [inc  hl] new ptr loaded to b08/b09, but HL is advanced, still in same data series
	jra	j_090E_flite_path_init             	| [jp   j_090E_flite_path_init]

l_09FA_bonusbee_creat_fail:
* skip two bytes of 16-bit address and inc hl to next data
	move.l	(sp)+,a0                        	| [pop  hl] ptr to data table
	addq.w	#3,a0                           	| [inc  hl] * 3
	jra	j_090E_flite_path_init             	| [jp   j_090E_flite_path_init]

* Red alien element has left formation - use deltaX to fighter to select flight
* plan. This occurs when approximately mid-screen, after initial jump from
* formation.
case_0A01:  ; $0C
* stash 2 copies of hl

	move.l	a0,-(sp)                        	| [push hl] ptr to data table
	exg	a1,a0                              	| [ex   de,hl]

	move.b	b_9215_flip_screen,d0           	| [ld   a,(b_9215_flip_screen)]
	move.b	d0,d2                           	| [ld   c,a]

* setup horizontal limits for targetting
	move.b	ds_sprite_posn+0x62,d0          	| [ld   a,(ds_sprite_posn + 0x62)] ship_1_position
	cmp.b	#0x1E,d0                         	| [cp   #0x1E]
	jcc	l_0A10                             	| [jr   nc,l_0A10]
	move.b	#0x1E,d0                        	| [ld   a,#0x1E]
l_0A10:
	cmp.b	#0xD1,d0                         	| [cp   #0xD1]
	jcs	l_0A16                             	| [jr   c,l_0A16]
	move.b	#0xD1,d0                        	| [ld   a,#0xD1]

l_0A16:
	btst.b	#0,d2                           	| [bit  0,c]
	jeq	l_0A1E                             	| [jr   z,l_0A1E]
	add.b	#0x0E,d0                         	| [add  a,#0x0E]
	neg.b	d0                               	| [neg]

* (fighterX - alienX) / 4 ... 9.7 fixed point math
l_0A1E:
	lsr.b	#1,d0                            	| [srl  a]
	sub.b	(0x03,a2),d0                     	| [sub  0x03(ix)]
	roxr.b	#1,d0                           	| [rra] divide again by 2 ... Cy from sub into b7
	btst.b	#7,(0x13,a2)                    	| [bit  7,0x13(ix)] if !z  then  a=-a
	jeq	l_0A2C_                            	| [jr   z,l_0A2C_]
* negative (clockwise) rotation ... approach to waypoint is from right to left
	neg.b	d0                               	| [neg]

l_0A2C_:
* test if offset'ed result still out of range negative (overflow if addition to negative delta is greater than 0)
	add.b	0x30>>1,d0                       	| [add  a,#0x30>>1] offset to positive range for selection of index
       ^^^^^^ TODO: review absolute 16-bit address read
	jpl	l_0A32                             	| [jp   p,l_0A32]
	clr.b	d0                               	| [xor  a] result still negative (S is set )
l_0A32:
	cmp.b	#0x30,d0                         	| [cp   #0x30]
	jcs	l_0A38                             	| [jr   c,l_0A38]
	move.b	#0x2F,d0                        	| [ld   a,#0x2F] set upper limit
l_0A38:
	move.b	d0,d5                           	| [ld   h,a]
	move.b	#6,d0                           	| [ld   a,#6]
	jbsr	c_0EAA                            	| [call c_0EAA] HL = HL / A
	move.b	d5,d0                           	| [ld   a,h]
	addq.b	#1,d0                           	| [inc  a]
	exg	a1,a0                              	| [ex   de,hl] restore hl
	jbsr	rst_10                            	| [rst  0x10] HL += A
	move.b	(a0),d0                         	| [ld   a,(hl)]
	move.b	d0,(0x0D,a2)                    	| [ld   0x0D(ix),a]

	move.l	(sp)+,a0                        	| [pop  hl] restore hl again
	move.b	#9,d0                           	| [ld   a,#9]
	jbsr	rst_10                            	| [rst  0x10] HL += A
* don't actually need to load from l and h here ;)
	move.b	d6,(0x08,a2)                    	| [ld   0x08(ix),l] pointer.b0
	move.b	d5,(0x09,a2)                    	| [ld   0x09(ix),h] pointer.b1
	jra	l_0BFF_flite_pth_skip_load         	| [jp   l_0BFF_flite_pth_skip_load] save pointer and goto _flite_pth_cont

* capturing boss starts dive
case_0A53:  ; $0B

	move.l	a0,-(sp)                        	| [push hl]
	move.b	b_9215_flip_screen,d0           	| [ld   a,(b_9215_flip_screen)]
	move.b	d0,d2                           	| [ld   c,a]
	move.b	ds_sprite_posn+0x62,d0          	| [ld   a,(ds_sprite_posn + 0x62)] ship_1_position
	addq.b	#3,d0                           	| [add  a,#3]
	and.b	#0xF8,d0                         	| [and  #0xF8]
	addq.b	#1,d0                           	| [inc  a]
cp   #82 >> 1                              ; $29
	jcc	l_0A66                             	| [jr   nc,l_0A66]
	move.b	#0x29,d0                        	| [ld   a,#0x29]
l_0A66:
cp   #404 >> 1                             ; $CA
	jcs	l_0A6C                             	| [jr   c,l_0A6C]
      ^^^^^^ TODO: review cpu flags (move.b,jcs)
	move.b	#402>>1,d0                      	| [ld   a,#402 >> 1] $C9
l_0A6C:
	btst.b	#0,d2                           	| [bit  0,c] check flip screen
	jeq	l_0A73                             	| [jr   z,l_0A73]
	add.b	#13,d0                           	| [add  a,#13] flipped
	not.b	d0                               	| [cpl]
l_0A73:
	move.b	d0,ds5_928A_captr_status+0x00   	| [ld   (ds5_928A_captr_status + 0x00),a]
	lsr.b	#1,d0                            	| [srl  a]
	move.b	d0,d4                           	| [ld   e,a]
	move.b	#0x48,d3                        	| [ld   d,#0x48]
	move.b	(0x01,a2),d5                    	| [ld   h,0x01(ix)]
	move.b	(0x03,a2),d6                    	| [ld   l,0x03(ix)]
	jbsr	c_0E5B                            	| [call c_0E5B] HL = c_0E5B(DE, H, L) ... determine rotation angle
	lsr.b	#1,d5                            	| [srl  h]
	roxr.b	#1,d6                           	| [rr   l]
	move.b	d6,(0x04,a2)                    	| [ld   0x04(ix),l]
	move.b	d5,(0x05,a2)                    	| [ld   0x05(ix),h]

	clr.b	d0                               	| [xor  a]
	move.b	d0,ds5_928A_captr_status+0x01   	| [ld   (ds5_928A_captr_status + 0x01),a] 0
	addq.b	#1,d0                           	| [inc  a]
	move.b	d0,ds_cpu0_task_actv+0x19       	| [ld   (ds_cpu0_task_actv + 0x19),a] 1: f_21CB ... boss diving to capture position
	move.b	#ixl,d0                         	| [ld   a,ixl]
	move.b	d0,ds_plyr_actv+_b_cboss_slot   	| [ld   (ds_plyr_actv +_b_cboss_slot),a] ixl ... offset of slot used by capture boss, referenced by cpu0:f_21CB
	move.l	(sp)+,a0                        	| [pop  hl] ptr to data table
	addq.w	#1,a0                           	| [inc  hl]
	jra	j_090E_flite_path_init             	| [jp   j_090E_flite_path_init]

* attack wave element hits turning point and heads to home
case_0AA0:  ; $04

	move.l	a0,-(sp)                        	| [push hl] ptr to data table

	move.b	(0x10,a2),d6                    	| [ld   l,0x10(ix)] update object disposition ... i.e. 8800[L]
	lea	b_8800(pc),a0                      	| [ld   h,#>b_8800]
	and.w	#0xFF,d6
	add.w	d6,a0
	      ^^^^ TODO: review XX value
	move.b	#9,(a0)                         	| [ld   (hl),#9] disposition = 9: diving/homing (currently 3)

	lea	sprt_fmtn_hpos(pc),a0              	| [ld   h,#>sprt_fmtn_hpos] home_posn_rc[ ix($10) ]
	and.w	#0xFF,d6
	add.w	d6,a0
	      ^^^^ TODO: review XX value
	move.b	(a0),d2                         	| [ld   c,(hl)] row index
	addq.b	#1,d6                           	| [inc  l]
	move.b	(a0),d6                         	| [ld   l,(hl)] column index

	lea	ds_hpos_loc_t(pc),a0               	| [ld   h,#>ds_hpos_loc_t]
	and.w	#0xFF,d6
	add.w	d6,a0
	      ^^^^ TODO: review XX value
	move.b	(a0),d1                         	| [ld   b,(hl)] x offset
	addq.b	#1,d6                           	| [inc  l]
	move.b	(a0),d4                         	| [ld   e,(hl)] x coordinate (ds_hpos_loc_orig)

	move.b	d2,d6                           	| [ld   l,c] row position index
	move.b	(a0),d2                         	| [ld   c,(hl)] y offset
	addq.b	#1,d6                           	| [inc  l]
	move.b	(a0),d3                         	| [ld   d,(hl)] y coordinate (ds_hpos_loc_orig)

	lsr.b	#1,d4                            	| [srl  e] x coordinate
	movem.w	d3/d4,-(sp)                    	| [push de] y coord, x coord >> 1
	move.l	a1,-(sp)                        	| [push de] y coord, x coord >> 1

	move.b	d1,(0x11,a2)                    	| [ld   0x11(ix),b] step x coord (x offset)
	move.b	d2,(0x12,a2)                    	| [ld   0x12(ix),c] step y coord (y offset)

	move.b	b_9215_flip_screen,d0           	| [ld   a,(b_9215_flip_screen)]
	                               	| [and  a]
	jeq	l_0ACD                             	| [jr   z,l_0ACD]
* flipped ... negate the steps
	move.b	d1,d0                           	| [ld   a,b]
	neg.b	d0                               	| [neg]
	move.b	d0,d1                           	| [ld   b,a]
	move.b	d2,d0                           	| [ld   a,c]
	neg.b	d0                               	| [neg]
	move.b	d0,d2                           	| [ld   c,a]
l_0ACD:
* add y-offset to .b00/.b01 (sra/rr -> 9.7 fixed-point scaling)
	move.b	(0x00,a2),d6                    	| [ld   l,0x00(ix)] .b00
	move.b	(0x01,a2),d5                    	| [ld   h,0x01(ix)] .b01 ... sY<8:1>
	move.b	d2,d3                           	| [ld   d,c] step y coord, y offset
	clr.b	d4                               	| [ld   e,#0]
	asr.b	#1,d3                            	| [sra  d]
	roxr.b	#1,d4                           	| [rr   e]
	add.w	d3,a0                            	| [add  hl,de]
  ^^^^ TODO: review d3 computation above
	move.b	d6,(0x00,a2)                    	| [ld   0x00(ix),l] .b00
	move.b	d5,(0x01,a2)                    	| [ld   0x01(ix),h] .b01
	move.b	d5,d4                           	| [ld   e,h] y, .b01 (bits<1:8> of integer portion)

* add x-offset to .b02/.b03 (sra/rr -> 9.7 fixed-point scaling)
	move.b	(0x02,a2),d6                    	| [ld   l,0x02(ix)] .b00
	move.b	(0x03,a2),d5                    	| [ld   h,0x03(ix)] .b01
	clr.b	d2                               	| [ld   c,#0]
	asr.b	#1,d1                            	| [sra  b] step x coord, x offset
	roxr.b	#1,d2                           	| [rr   c]
	sub.w	d1,d5                            	| [sbc  hl,bc]
     ^^^^ TODO: review compared/subbed registers
	move.b	d6,(0x02,a2)                    	| [ld   0x02(ix),l] .b00
	move.b	d5,(0x03,a2)                    	| [ld   0x03(ix),h] .b01
	move.b	d5,d6                           	| [ld   l,h] x, .b01 (bits<8:1> of integer portion)
	move.b	d4,d5                           	| [ld   h,e] y, .b01 (bits<8:1> of integer portion)

	move.b	d3,d2                           	| [ld   c,d] C is not used?

	move.l	(sp)+,a1                        	| [pop  de] abs row pix coord & abs col pix coord >> 1
	movem.w	(sp)+,d3/d4                    	| [pop  de] abs row pix coord & abs col pix coord >> 1

	jbsr	c_0E5B                            	| [call c_0E5B] HL = mctl_rotn_hp(DE, H, L)
	lsr.b	#1,d5                            	| [srl  h]
	roxr.b	#1,d6                           	| [rr   l]
	move.b	d6,(0x04,a2)                    	| [ld   0x04(ix),l]
	move.b	d5,(0x05,a2)                    	| [ld   0x05(ix),h]
	move.b	d3,(0x06,a2)                    	| [ld   0x06(ix),d] origin home position y (bits 15:8) ... from hpos_loc_orig.x
	move.b	d4,(0x07,a2)                    	| [ld   0x07(ix),e] origin home position x (bits 15:8) ... from hpos_loc_orig.y
	bset.b	#6,(0x13,a2)                    	| [set  6,0x13(ix)] if set, flite path handler checks for home

	move.l	(sp)+,a0                        	| [pop  hl] ptr to data table
	addq.w	#1,a0                           	| [inc  hl]
	jra	j_090E_flite_path_init             	| [jp   j_090E_flite_path_init]

* attack elements that break formation to attack ship (level 3+)
case_0B16:  ; $01

	move.l	a0,-(sp)                        	| [push hl] ptr to data table
	exg	a1,a0                              	| [ex   de,hl]
	move.b	b_9215_flip_screen,d0           	| [ld   a,(b_9215_flip_screen)]
	ror.b	#1,d0                            	| [rrca]
	move.b	(0x13,a2),d1                    	| [ld   b,0x13(ix)] xor
	eor.b	d1,d0                            	| [xor  b]
	rol.b	#1,d0                            	| [rlca]
	move.b	sfr_sprite_posn+0x62,d0         	| [ld   a,(sfr_sprite_posn + 0x62)] ship1
	addq.b	#1,d0                           	| [inc  a]
	subq.b	#1,d0                           	| [dec  a]
	jne	l_0B2A                             	| [jr   nz,l_0B2A]
	move.b	#0x80,d0                        	| [ld   a,#0x80]
l_0B2A:
	jcs	l_0B30                             	| [jr   c,l_0B30]
      ^^^^^^ TODO: review cpu flags (move.b,jcs)
	neg.b	d0                               	| [neg]
	add.b	#0xF2,d0                         	| [add  a,#0xF2]
l_0B30:
	add.b	#0x0E,d0                         	| [add  a,#0x0E]
	move.b	d0,d5                           	| [ld   h,a]

	move.b	#0x1E,d0                        	| [ld   a,#0x1E]
	jbsr	c_0EAA                            	| [call c_0EAA] HL = HL / A
	move.b	d5,d0                           	| [ld   a,h]
	exg	a1,a0                              	| [ex   de,hl]
	jbsr	rst_10                            	| [rst  0x10] HL += A
	move.b	(a0),d0                         	| [ld   a,(hl)]
	move.b	d0,(0x0D,a2)                    	| [ld   0x0D(ix),a]

	move.l	(sp)+,a0                        	| [pop  hl]
	move.b	#9,d0                           	| [ld   a,#9]
	jbsr	rst_10                            	| [rst  0x10] HL += A
	jra	l_0BFF_flite_pth_skip_load         	| [jp   l_0BFF_flite_pth_skip_load] save pointer and goto _flite_pth_cont

* creatures that are returning to base: moths or bosses from top of screen,
* bees from bottom of loop-around, and "transients"
case_0B46: ; $02
l_0B46:
* ld new data ptr into de and ex into hl ... resultant de not used
	addq.w	#1,a0                           	| [inc  hl] ptr to data table
	move.b	(a0),d4                         	| [ld   e,(hl)]
	addq.w	#1,a0                           	| [inc  hl]
	move.b	(a0),d3                         	| [ld   d,(hl)]
	exg	a1,a0                              	| [ex   de,hl] new pointer to HL
	jra	j_090E_flite_path_init             	| [jp   j_090E_flite_path_init]

* bee dive and starting loopback, or boss left position and starting dive down
case_0B4E:  ; $03
	addq.w	#1,a0                           	| [inc  hl] ptr to data table
	move.b	(a0),d4                         	| [ld   e,(hl)]
	addq.w	#1,a0                           	| [inc  hl]
	move.b	d4,(0x06,a2)                    	| [ld   0x06(ix),e] origin home position y (bits 15:8)
	clr.b	(0x07,a2)                        	| [ld   0x07(ix),#0] origin home position x (bits 15:8)
	bset.b	#5,(0x13,a2)                    	| [set  5,0x13(ix)] bee or boss dive
	jra	l_0BFF_flite_pth_skip_load         	| [jp   l_0BFF_flite_pth_skip_load] save pointer and goto _flite_pth_cont

* red alien flew through bottom of screen to top, heading for home
* yellow alien flew under bottom of screen and now turns for home
case_0B5F:  ; $06
	move.b	b_9215_flip_screen,d0           	| [ld   a,(b_9215_flip_screen)]
	move.b	d0,d2                           	| [ld   c,a]

	move.b	(0x10,a2),d4                    	| [ld   e,0x10(ix)] home_posn_rc[ obj_id + 1 ]
	addq.b	#1,d4                           	| [inc  e]
	lea	sprt_fmtn_hpos(pc),a1              	| [ld   d,#>sprt_fmtn_hpos] home_posn_rc[ ix($10) + 1 ] ... column position index
	and.w	#0xFF,d4
	add.w	d4,a1
	      ^^^^ TODO: review XX value
	move.b	(a1),d0                         	| [ld   a,(de)]
	move.b	d0,d4                           	| [ld   e,a]
	lea	ds_hpos_spcoords(pc),a1            	| [ld   d,#>ds_hpos_spcoords] col pix coordinate, lsb only
	and.w	#0xFF,d4
	add.w	d4,a1
	      ^^^^ TODO: review XX value
	move.b	(a1),d0                         	| [ld   a,(de)]
	btst.b	#0,d2                           	| [bit  0,c] check if flip-screen
	jeq	l_0B76                             	| [jr   z,l_0B76]
	add.b	#0x0E,d0                         	| [add  a,#0x0E]
	neg.b	d0                               	| [neg]
l_0B76:
	lsr.b	#1,d0                            	| [srl  a]
	move.b	d0,(0x03,a2)                    	| [ld   0x03(ix),a] .cx.pair.b1

	move.b	b_92A0+0x0A,d0                  	| [ld   a,(b_92A0 + 0x0A)] if continuous bombing flag is set, trigger dive attack sound b_9AA0[0x13]
	                               	| [and  a]
	jeq	l_0B8B                             	| [jp   z,l_0B8B] inc hl and finalize

	move.b	d0,b_9AA0+0x13                  	| [ld   (b_9AA0 + 0x13),a] ~0 ... sound-fx count/enable registers, bug dive attack sound
	jra	l_0B8B                             	| [jr   l_0B8B] inc hl and finalize

* red alien flew through bottom of screen to top, heading for home
* yellow alien flew under bottom of screen and now turns for home
case_0B87:  ; $07
	move.b	0x0138>>1,(0x01,a2)             	| [ld   0x01(ix),#0x0138>>1] sY<15:8> ... $0138==312 ... $0138/2=$9C
l_0B8B:
	addq.w	#1,a0                           	| [inc  hl] data pointer
l_0B8C:
	move.b	d6,(0x08,a2)                    	| [ld   0x08(ix),l] .b00
	move.b	d5,(0x09,a2)                    	| [ld   0x09(ix),h] .b01
	addq.b	#1,(0x0D,a2)                    	| [inc  0x0D(ix)]

	jra	next__pool_idx                     	| [jp   next__pool_idx]

* in an attack convoy ... changing direction
case_0B98:  ; $08
* if (0x38 != (0x38 & ds_bug_motion_que[b_bug_que_idx].b10))  hl += 3 ...
	move.b	(0x10,a2),d0                    	| [ld   a,0x10(ix)] offset of object ...8800[L]
	and.b	#0x38,d0                         	| [and  #0x38]
	cmp.b	#0x38,d0                         	| [cp   #0x38] "transient"? ($38, $3A, $3C, $3E)

* from case_0BD1 ... if (1 == cont_bmb_flag && 0 == task_actv[0x1D]) then ... HL += 3
l_0B9F:
	jeq	l_0B46                             	| [jp   z,l_0B46] load next ptr ... _flite_path_init
* ptr to data table inc 3x ... (2 incs to skip address in table e.g. $0024?)
	addq.w	#3,a0                           	| [inc  hl] * 3
	jra	j_090E_flite_path_init             	| [jp   j_090E_flite_path_init]

* one red moth left in "free flight mode"
case_0BA8:  ; $09
	addq.w	#1,a0                           	| [inc  hl] ptr to data table
	move.b	(a0),d0                         	| [ld   a,(hl)]
	btst.b	#7,(0x13,a2)                    	| [bit  7,0x13(ix)]
	jeq	l_0BB4                             	| [jr   z,l_0BB4]
	add.b	#0x80,d0                         	| [add  a,#0x80]
	neg.b	d0                               	| [neg]
l_0BB4:
	clr.b	d2                               	| [ld   c,#0] stage 4 ...
	asl.b	#1,d0                            	| [sla  a]
	roxl.b	#1,d2                           	| [rl   c]
	asl.b	#1,d0                            	| [sla  a]
	roxl.b	#1,d2                           	| [rl   c]
	move.b	d0,(0x04,a2)                    	| [ld   0x04(ix),a]
	move.b	d2,(0x05,a2)                    	| [ld   0x05(ix),c]
	move.b	#0x1E,(0x0E,a2)                 	| [ld   0x0E(ix),#0x1E] bomb drop counter
	move.b	b_92C0+0x08,d0                  	| [ld   a,(b_92C0 + 0x08)] bomb drop enable flags
	move.b	d0,(0x0F,a2)                    	| [ld   0x0F(ix),a] b_92C0[$08] ... bomb drop enable flags
	jra	l_0B8B                             	| [jp   l_0B8B] inc hl and finalize

* homing, red transit to top, yellow from off-screen at bottom or skip if in continuous mode
case_0BD1:  ; $05
* if (1 == cont_bmb_flag && 0 == task_actv[0x1D]) then pD += 3 else pD = *(pHL)
	move.b	b_92A0+0x0A,d0                  	| [ld   a,(b_92A0 + 0x0A)] continuous bombing flag, test for reload data pointer
	move.b	d0,d2                           	| [ld   c,a]
	move.b	ds_cpu0_task_actv+0x1D,d0       	| [ld   a,(ds_cpu0_task_actv + 0x1D)] f_2000 (destroyed boss that captured ship) test for reload data pointer
	subq.b	#1,d0                           	| [dec  a]
	and.b	d2,d0                            	| [and  c]
	jra	l_0B9F                             	| [jr   l_0B9F] load next ptr or skip


* Continue in the same state, but a new data set needs to be
* initialized before continuing on to flight-path handler.
l_0BDC_flite_pth_load:

* HL == ds_flying_queue[loop_cnt].pdat
* A == *ds_flying_queue[loop_cnt].pdat
* A < $EF (current token)
	move.b	d0,d2                           	| [ld   c,a] data[ n + 0 ]
	and.b	#0x0F,d0                         	| [and  #0x0F]
	move.b	d0,(0x0A,a2)                    	| [ld   0x0A(ix),a] lo-nibble
	move.b	d2,d0                           	| [ld   a,c]
	rol.b	#4,d0                            	| [rlca] * 4
	and.b	#0x0F,d0                         	| [and  #0x0F]
	addq.w	#1,a0                           	| [inc  hl]
	move.b	d0,(0x0B,a2)                    	| [ld   0x0B(ix),a] hi-nibble (right shifted into bits<0:3>
	move.b	(a0),d0                         	| [ld   a,(hl)] data[ n + 1 ] ... to (ix)0x0C
	addq.w	#1,a0                           	| [inc  hl]
	btst.b	#7,(0x13,a2)                    	| [bit  7,0x13(ix)] if set then negate data to (ix)0x0C
	jeq	l_0BF7                             	| [jr   z,l_0BF7]
	neg.b	d0                               	| [neg]
l_0BF7:
	move.b	d0,(0x0C,a2)                    	| [ld   0x0C(ix),a]
	move.b	(a0),d0                         	| [ld   a,(hl)] data[ n + 2 ] ... to (ix)0x0D
	addq.w	#1,a0                           	| [inc  hl]
	move.b	d0,(0x0D,a2)                    	| [ld   0x0D(ix),a] expiration counter from data[ n + 2 ]

l_0BFF_flite_pth_skip_load:
	move.b	d6,(0x08,a2)                    	| [ld   0x08(ix),l] pointer.b0
	move.b	d5,(0x09,a2)                    	| [ld   0x09(ix),h] pointer.b1


* process this time-step of flite path, continue processing on this data-set
* check home positions
l_0C05_flite_pth_cont:
	btst.b	#6,(0x13,a2)                    	| [bit  6,0x13(ix)] if set, check if home
	jeq	l_0C2D_flite_pth_step              	| [jr   z,l_0C2D_flite_pth_step]

* transitions to the next segment of the flight pattern
* if (    (b01==b06                     	|| (b01-b06)==1|| (b06-b01)==1)
*      && (b03==b07                     	|| (b03-b07)==1|| (b07-b03)==1) ) ...
	move.b	(0x01,a2),d0                    	| [ld   a,0x01(ix)]
	sub.b	(0x06,a2),d0                     	| [sub  0x06(ix)] (ix)0x01 - (ix)0x06
	jeq	l_0C1B                             	| [jr   z,l_0C1B]
	jpl	l_0C18                             	| [jp   p,l_0C18] check overflow
	neg.b	d0                               	| [neg] negate if overflow (gets absolute value)
l_0C18:
	subq.b	#1,d0                           	| [dec  a]
	jne	l_0C2D_flite_pth_step              	| [jr   nz,l_0C2D_flite_pth_step]
l_0C1B:
	move.b	(0x03,a2),d0                    	| [ld   a,0x03(ix)] detection of homespot... (ix)0x03-(ix)0x07 == 0
	sub.b	(0x07,a2),d0                     	| [sub  0x07(ix)] detection of homespot... (ix)0x03-(ix)0x07 == 0
	jeq	l_0E08_imhome                      	| [jp   z,l_0E08_imhome]
	jpl	l_0C29                             	| [jp   p,l_0C29] check overflow
	neg.b	d0                               	| [neg] negate if overflow (gets absolute value)
l_0C29:
	subq.b	#1,d0                           	| [dec  a]
	jeq	l_0E08_imhome                      	| [jp   z,l_0E08_imhome]


l_0C2D_flite_pth_step:
* if ( b13 & 0x20 && ( b01 == b06       	|| (b01 - b06) == 1|| (b06 - b01) == 1 ) ...
	btst.b	#5,(0x13,a2)                    	| [bit  5,0x13(ix)] check if bee or boss dive
	jeq	l_0C46                             	| [jr   z,l_0C46]
	move.b	(0x01,a2),d0                    	| [ld   a,0x01(ix)] 0C33 boss: launched out of position, bee movement, 0x01(ix) counting down
	sub.b	(0x06,a2),d0                     	| [sub  0x06(ix)] origin home position y (bits 15:8)
	jeq	l_0C3E                             	| [jr   z,l_0C3E]
	addq.b	#1,d0                           	| [inc  a]
	jne	l_0C46                             	| [jr   nz,l_0C46]
* ... then ...
l_0C3E:
* set it up to expire on next step
	move.b	#1,(0x0D,a2)                    	| [ld   0x0D(ix),#1] bee dived down and begins loop around, boss reached position to start beam
	bclr.b	#5,(0x13,a2)                    	| [res  5,0x13(ix)] (ix)0x0D == 1

* advance the rotation angle. Step-size in .b0C and 10-bit angle in .b04+.b05
*               90          - angle in degrees
*             1                         	| 0        - quadrant derived from 10-bit angle
*          180 --+-- 0      - each tile rotation is 15 degrees (6 tiles per quadrant)
*             2                         	| 3
*               270

* load DE with local copy of rotation value and go ahead and update pool slot
l_0C46:
	move.b	(0x0C,a2),d1                    	| [ld   b,0x0C(ix)] add to (ix)0x04
	move.b	(0x04,a2),d0                    	| [ld   a,0x04(ix)]
	move.b	d0,d4                           	| [ld   e,a] need this later ...
	add.b	d1,d0                            	| [add  a,b] need this below for rra ...
	move.b	d0,(0x04,a2)                    	| [ld   0x04(ix),a] .b04 += .b0C

	move.b	(0x05,a2),d3                    	| [ld   d,0x05(ix)] need this later ...

* sign of subtrahend determines signedness of carry
	move.b	#1,d6                           	| [ld   l,#1]
	btst.b	#7,d1                           	| [bit  7,b] (ix)0x0C
	jeq	l_0C5C                             	| [jr   z,l_0C5C]
	move.b	#-1,d6                          	| [ld   l,#-1]

l_0C5C:
* check for overflow out of LSB from addition (subtraction) result, sneaky ... xor sets S flag if bit-7 is toggled hi
	roxr.b	#1,d0                           	| [rra]
      ^^^^^^ TODO: review cpu X flag
	eor.b	d1,d0                            	| [xor  b] b from (ix)0x0C
	move.b	d3,d0                           	| [ld   a,d] from (ix)0x05
	jpl	l_0C63                             	| [jp   p,l_0C63]
      ^^^^^^ TODO: review cpu flags (move.b,jpl)
	add.b	d6,d0                            	| [add  a,l]
l_0C63:
	move.b	d0,(0x05,a2)                    	| [ld   0x05(ix),a] bits <8:9>

* determine_sprite_code
	move.b	d4,d0                           	| [ld   a,e] from previous (ix)0x04
	move.b	d3,d2                           	| [ld   c,d] from previous (ix)0x05 ... need this later ...
	btst.b	#0,d2                           	| [bit  0,c]
	jeq	l_0C6D                             	| [jr   z,l_0C6D]
	not.b	d0                               	| [cpl] invert bits 7:0 in quadrant 1 and 3 ...
l_0C6D:
* ... select vertical tile if within 15 degrees of 90 or 270
	add.b	#21,d0                           	| [add  a,#21] 1024 / ( 6 * 4 ) == 42
	jcc	l_0C75                             	| [jr   nc,l_0C75]
	move.b	#6,d1                           	| [ld   b,#6] vertical orientation, wings open (7 is wings closed)
	jra	l_0C81                             	| [jr   l_0C81]
l_0C75:
* divide by 42 ...42 counts per step of rotation (with 24 steps in the circle, 1 step is 15 degrees)
* Here's the math: A * ( 1/2 + 1/4 ) * ( 1/32 )
	lsr.b	#1,d0                            	| [srl  a]
	move.b	d0,d1                           	| [ld   b,a]
	lsr.b	#1,d1                            	| [srl  b]
	add.b	d1,d0                            	| [add  a,b]
	rol.b	#3,d0                            	| [rlca] rlca * 3 ... 1/32 * 3
	and.b	#0x07,d0                         	| [and  #0x07]
	move.b	d0,d1                           	| [ld   b,a]

l_0C81:
	lea	ds_sprite_code(pc),a0              	| [ld   h,#>ds_sprite_code]
	and.w	#0xFF,d6
	add.w	d6,a0
	      ^^^^ TODO: review XX value
	move.b	(0x10,a2),d6                    	| [ld   l,0x10(ix)] mrw_sprite[L].cclr.b0
	move.b	(a0),d0                         	| [ld   a,(hl)]
	and.b	#0xF8,d0                         	| [and  #0xF8] base sprite code (multiple of 8)
	or.b	d1,d0                             	| [or   b]
	move.b	d0,(a0)                         	| [ld   (hl),a]

* determine_sprite_ctrl( C )
* 0: flipx - flip about the X axis, i.e. "up/down"
* 1: flipy - flip about the Y axis, i.e. "left/right"
	lea	ds_sprite_ctrl(pc),a0              	| [ld   h,#>ds_sprite_ctrl]
	and.w	#0xFF,d6
	add.w	d6,a0
	      ^^^^ TODO: review XX value
	move.b	d2,d0                           	| [ld   a,c] d saved from (ix)0x05 above
	ror.b	#1,d2                            	| [rrc  c]
	eor.b	d2,d0                            	| [xor  c] bit0 xor with bit1 ...
	addq.b	#1,d0                           	| [inc  a] ... add 1 ... now have bit1
	ror.b	#1,d2                            	| [rrc  c] bit <1> ...
	roxl.b	#1,d0                           	| [rla] ... into <0>
      ^^^^^^ TODO: review cpu X flag
	and.b	#0x03,d0                         	| [and  #0x03] <0> flip up/down  <1> flip l/r, double-x/double-y bits not used
	move.b	d0,(a0)                         	| [ld   (hl),a] mrw_sprite[L].ctrl.b0 = A & 0x03

* choose x or y displacement vector to apply on this update
	move.b	ds3_92A0_frame_cts+0,d0         	| [ld   a,(ds3_92A0_frame_cts + 0)]
	and.b	#0x01,d0                         	| [and  #0x01]
	jeq	l_0CA4                             	| [jr   z,l_0CA4]
	move.b	(0x0A,a2),d0                    	| [ld   a,0x0A(ix)]
	jra	l_0CA7                             	| [jr   l_0CA7]
l_0CA4:
	move.b	(0x0B,a2),d0                    	| [ld   a,0x0B(ix)]

l_0CA7:
	                               	| [and  a] if zero, start of tractor beam and we can skip this crap
	jeq	l_0D03_flite_pth_posn_set          	| [jp   z,l_0D03_flite_pth_posn_set] 2 "parameters": HL, and E (e saved from (ix)0x04)

* compute increment and update selected coordinate

	move.l	a0,-(sp)                        	| [push hl] &mrw_sprite[L].ctrl.b0

	move.l	a2,-(sp)                        	| [push ix]
	move.l	(sp)+,a0                        	| [pop  hl] &bug_motion_que[n].b00

	move.b	d0,d1                           	| [ld   b,a] (ix)0x0A or (ix)0x0B

	move.b	d3,d0                           	| [ld   a,d] saved from (ix)0x05  ( from C46 )
	and.b	#0x03,d0                         	| [and  #0x03]
	move.b	d0,d3                           	| [ld   d,a]

*         90          - angle in degrees
*       1                               	| 0        - quadrant derived from 10-bit angle
*    180 --+-- 0      - each tile rotation is 15 degrees (6 tiles per quadrant)
*       2                               	| 3
*         270
* xor bit-7 with bit-8 ... test for orientation near 0 or 180
* i.e. < xx80 in quadrant 0 & 2, and >= xx80 in quadrant 1 & 3
	rol.b	#1,d4                            	| [rlc  e] e saved from (ix)0x04   ( from C46 )
	roxl.b	#1,d3                           	| [rl   d]
      ^^^^^^ TODO: review cpu X flag
	movem.w	d3/d4,-(sp)                    	| [push de] adjusted rotation angle, restores to HL below .....
	move.l	a1,-(sp)                        	| [push de] adjusted rotation angle, restores to HL below .....
	eor.b	d3,d0                            	| [xor  d]
	ror.b	#1,d0                            	| [rrca] xor result in A<0>
	jcs	l_0CBF                             	| [jr   c,l_0CBF] check for Cy shifted into bit7 from rrca
	addq.b	#2,d6                           	| [inc  l] * 2

l_0CBF:
* .b04+.b05 is angle in 10-bits. bits<9:7> together give the quadrant and fraction of 90
* degrees, indicating whether the "primary" component of the magnitude should be negative.
* 0 1  1 - 3   Any of these would result in d<2> set after the "inc d".
* 1 0  0 - 4   Remembering they have been <<1, it means the lowest bit was
* 1 0  1 - 5   .b04<7> (degree 0-89) and the upper 2 bits were .b05<1:0> (quadrant)
* 1 1  0 - 6   Taking the quadrant and angle together, the range is 135-304 degrees.
	addq.b	#1,d3                           	| [inc  d]
	btst.b	#2,d3                           	| [bit  2,d]
	move.b	d1,d0                           	| [ld   a,b] ... restore A: 0x0A(ix) or 0x0B(ix)
	jeq	l_0CC7                             	| [jr   z,l_0CC7]
      ^^^^^^ TODO: review cpu flags (move.b,jeq)
	neg.b	d0                               	| [neg] negate primary component for 135-305 degrees
l_0CC7:
* A is actually bits<15:7> of addend (.b00/.b02 in fixed point, 9.7)
	move.b	d0,d2                           	| [ld   c,a] from 0x0A(ix) or 0x0B(ix)
	asr.b	#1,d2                            	| [sra  c] sign extend, "bit-8" into Cy
	jcc	l_0CD0                             	| [jr   nc,l_0CD0]
	move.b	(a0),d0                         	| [ld   a,(hl)] b00 or b02, depends on "jr   c,l_0CBF"
	add.b	#0x80,d0                         	| [add  a,#0x80] add carry-out from sra
	move.b	d0,(a0)                         	| [ld   (hl),a]
l_0CD0:
	addq.b	#1,d6                           	| [inc  l]
	move.b	(a0),d0                         	| [ld   a,(hl)] b01 or b03, depends on "jr   c,l_0CBF"
adc  a,c                                   ; add with carry-out from addition into lsb
	move.b	d0,(a0)                         	| [ld   (hl),a]

* stash the pointer to .b0/.b2 in DE (previous DE into HL but no longer used)
	subq.b	#1,d6                           	| [dec  l]
	exg	a1,a0                              	| [ex   de,hl]
	move.b	d4,d0                           	| [ld   a,e]
	eor.b	#0x02,d0                         	| [xor  #0x02] toggle x/y pointer, .b00 or .b02
	move.b	d0,d4                           	| [ld   e,a]

* test L<0> (pushed/popped from left-shifted DE above .. but this would be .b04<7> before left-shift?)
	move.l	(sp)+,a0                        	| [pop  hl] ..... adjusted rotation angle from push DE above
	lsr.b	#1,d6                            	| [srl  l] revert to unshifted, but did not retain bit-7
	jcc	l_0CE3                             	| [jr   nc,l_0CE3] bit<0> into Cy (which was actually bit<7>
	move.b	d6,d0                           	| [ld   a,l]
	eor.b	#0x7F,d0                         	| [xor  #0x7F] compliment bits<6:0>
	move.b	d0,d6                           	| [ld   l,a]
l_0CE3:
	move.b	d1,d0                           	| [ld   a,b] ... restore A: 0x0A(ix) or 0x0B(ix)
	move.b	d5,d1                           	| [ld   b,h] msb of adjusted angle
	clr.b	d5                               	| [ld   h,#0]
	jbsr	c_0E97                            	| [call c_0E97] HL = L * A

*             . 90          - angle in degrees
*             1                         	| 0        - quadrant derived from 10-bit angle
*          180 --+-- 0      - each tile rotation is 15 degrees (6 tiles per quadrant)
*           . 2                         	| 3 .
*             . 270
*      b9 b8  b7
*     q 0  0   0  -> 010 -> 001
*       0  0   1  -> 011 -> 010
*     q 0  1   0  -> 000 -> 111  x  .
*       0  1   1  -> 001 -> 000
*     q 1  0   0  -> 110 -> 101  x  .
*       1  0   1  -> 111 -> 110  x  .
*     q 1  1   0  -> 100 -> 011
*       1  1   1  -> 101 -> 100  x  .

	move.b	d1,d0                           	| [ld   a,b] msb of adjusted angle
	eor.b	#0x02,d0                         	| [xor  #0x02]
	subq.b	#1,d0                           	| [dec  a]
	btst.b	#2,d0                           	| [bit  2,a]
	jeq	l_0CFA                             	| [jr   z,l_0CFA]
	move.b	d5,d1                           	| [ld   b,h]
	move.b	d6,d2                           	| [ld   c,l]
	move.w	#0x0000,d5                      	| [ld   hl,#0x0000] 0
	tst.b	d0                               	| [and  a] ????
	sub.w	d1,d5                            	| [sbc  hl,bc] negate BC ... can't use "neg" since it is 16-bit
     ^^^^ TODO: review compared/subbed registers
l_0CFA:
	exg	a1,a0                              	| [ex   de,hl] reload the pointer from DE
* *HL += *DE
	move.b	d4,d0                           	| [ld   a,e] lsb of mul result
	add.b	(a0),d0                          	| [add  a,(hl)]
	move.b	d0,(a0)                         	| [ld   (hl),a]  .b00 or .b02
	addq.b	#1,d6                           	| [inc  l]
	move.b	d3,d0                           	| [ld   a,d] msb of mul result
adc  a,(hl)                                ;  .b01 or .b03
	move.b	d0,(a0)                         	| [ld   (hl),a]

	move.l	(sp)+,a0                        	| [pop  hl] &mrw_sprite.ctrl[L].b1

* almost done ... update the sprite x/y positions
l_0D03_flite_pth_posn_set:
	move.b	b_9215_flip_screen,d0           	| [ld   a,(b_9215_flip_screen)]
	move.b	d0,d2                           	| [ld   c,a]

* extract x-coord and adjust for homing if needed
* fixed point 9.7 in .b02.b03 - left shift integer portion into A ... carry in to <0> from .b02<7>
	lea	ds_sprite_posn(pc),a0              	| [ld   h,#>ds_sprite_posn]
	and.w	#0xFF,d6
	add.w	d6,a0
	      ^^^^ TODO: review XX value
	move.b	(0x03,a2),d3                    	| [ld   d,0x03(ix)] bits<1:6> of x pixel ... could load directly to A
* set Cy from .b02<7>
	move.b	#0x7F,d0                        	| [ld   a,#0x7F]
	cmp.b	(0x02,a2),d0                     	| [cp   0x02(ix)]

	move.b	d3,d0                           	| [ld   a,d] (ix)0x03
	roxl.b	#1,d0                           	| [rla] rotate Cy into A<0> (.b02<7>)
      ^^^^^^ TODO: review cpu X flag

	btst.b	#0,d2                           	| [bit  0,c] test flip screen
	jeq	l_0D1A                             	| [jr   z,l_0D1A]
	add.b	#0x0D,d0                         	| [add  a,#0x0D] flipped
	not.b	d0                               	| [cpl]
l_0D1A:
	btst.b	#6,(0x13,a2)                    	| [bit  6,0x13(ix)] if !z, add  a,(ix)0x11 ... relative offset
	jeq	l_0D23                             	| [jr   z,l_0D23]
	add.b	(0x11,a2),d0                     	| [add  a,0x11(ix)] heading home (add x-offset ... already bits<7:0>)
l_0D23:
	move.b	d0,(a0)                         	| [ld   (hl),a] &sprite[n].posn.x

* extract y-coord and adjust for homing if needed
	addq.b	#1,d6                           	| [inc  l] sprite[n].posn.sy<0:7>
	move.b	(0x01,a2),d1                    	| [ld   b,0x01(ix)]
* set Cy from .b00<7>
	move.b	#0x7F,d0                        	| [ld   a,#0x7F]
	cmp.b	(0x00,a2),d0                     	| [cp   0x00(ix)]

	roxl.b	#1,d4                           	| [rl   e] rotate Cy into E<0>
      ^^^^^^ TODO: review cpu X flag, cmp doesn't affect it!
	move.b	d1,d0                           	| [ld   a,b] (ix)0x01

	btst.b	#0,d2                           	| [bit  0,c] test flip screen
	jne	l_0D38                             	| [jr   nz,l_0D38]
	add.b	(<(-0x0160-0x02))>>1,d0          	| [add  a,#(<(-0x0160 - 0x02))>>1] not flipped ... lsb of result, right-shift 1
	not.b	d0                               	| [cpl]
	subq.b	#1,d4                           	| [dec  e] compliment bit-0 of 9-bit integer portion

l_0D38:
* E<0> <- Cy <- 7 6 5 4 3 2 1 0 <- Cy <- E<0>
	roxr.b	#1,d4                           	| [rr   e] bit-0 of 9-bit integer portion into Cy
	roxl.b	#1,d0                           	| [rla] Cy (bit0) into lsb, bit8 into Cy
	roxl.b	#1,d4                           	| [rl   e] bit8 from Cy into E<0> (bit8 of sprite_y)

	btst.b	#6,(0x13,a2)                    	| [bit  6,0x13(ix)] if !z, add  a,(ix)0x12
	jeq	l_0D50                             	| [jr   z,l_0D50]
* r16.word += mctl_mpool[mpidx].b12
	add.b	(0x12,a2),d0                     	| [add  a,0x12(ix)] heading home (step y coord)
	move.b	d0,d3                           	| [ld   d,a] stash bits<7:0> of sum
	roxr.b	#1,d0                           	| [rra] somehow the rest of this propogates bit9 of the sum into E<0>
      ^^^^^^ TODO: review cpu X flag
	move.b	(0x12,a2),d7
	eor.b	d7,d0                            	| [xor  0x12(ix)]
	rol.b	#1,d0                            	| [rlca]
	move.b	d3,d0                           	| [ld   a,d]
	jcc	l_0D50                             	| [jr   nc,l_0D50]
      ^^^^^^ TODO: review cpu flags (move.b,jcc)
	addq.b	#1,d4                           	| [inc  e]

l_0D50:
	move.b	d0,(a0)                         	| [ld   (hl),a] sprite[n].posn.sy<7:0>
	lea	ds_sprite_ctrl(pc),a0              	| [ld   h,#>ds_sprite_ctrl] sprite[n].posn.sy<8>
	and.w	#0xFF,d6
	add.w	d6,a0
	      ^^^^ TODO: review XX value
	ror.b	#1,(a0)                          	| [rrc  (hl)]
	ror.b	#1,d4                            	| [rrc  e]
	roxl.b	#1,(a0)                         	| [rl   (hl)] sprite[n].posn.sy<8>
      ^^^^^^ TODO: review cpu X flag


* Once the timer in $0E is reached, then check conditions to enable bomb drop.
* If bomb is disabled for any reason, the timer is restarted.
	subq.b	#1,(0x0E,a2)                    	| [dec  0x0E(ix)] countdown to enable a bomb
	jne	next__pool_idx                     	| [jp   nz,next__pool_idx]

	lsr.b	#1,(0x0F,a2)                     	| [srl  0x0F(ix)] these bits enable bombing
	jcc	l_0DF5_next_superloop_and_reload_0E	| [jp   nc,l_0DF5_next_superloop_and_reload_0E]

	move.b	(0x01,a2),d0                    	| [ld   a,0x01(ix)] if .cy.pair.b1 > $4C
cp   #152>>1                               ; 0x4C
	jcs	l_0DF5_next_superloop_and_reload_0E	| [jp   c,l_0DF5_next_superloop_and_reload_0E]
      ^^^^^^ TODO: review cpu flags (move.b,jcs)

	move.b	ds_cpu0_task_actv+0x15,d0       	| [ld   a,(ds_cpu0_task_actv + 0x15)] f_1F04 ...fire button input
	                               	| [and  a]
	jeq	l_0DF5_next_superloop_and_reload_0E	| [jp   z,l_0DF5_next_superloop_and_reload_0E]

	move.b	ds4_game_tmrs+1,d0              	| [ld   a,(ds4_game_tmrs + 1)]
	                               	| [and  a]
	jne	l_0DF5_next_superloop_and_reload_0E	| [jp   nz,l_0DF5_next_superloop_and_reload_0E]

* check for available bomb ... bombs are rendered inactive at l_0815
	exg	a1,a0                              	| [ex   de,hl] &sprite.ctrl[bmbr].b1 to DE ...
	lea	b_8800+0x68(pc),a0                 	| [ld   hl,#b_8800 + 0x68] bomb0 object/index
	move.b	#8,d1                           	| [ld   b,#8] check 8 positions
l_0D82:
	move.b	(a0),d0                         	| [ld   a,(hl)] _objs[BOMB0].state
	cmp.b	#0x80,d0                         	| [cp   #0x80] INACTIVE
	jeq	l_0D8D_got_a_bullet                	| [jr   z,l_0D8D_got_a_bullet]
	addq.b	#2,d6                           	| [inc  l] * 2
	subq.b	#1,d1                           	| [...]
	jne	l_0D82                             	| [djnz l_0D82]

	jra	l_0DF5_next_superloop_and_reload_0E	| [jr   l_0DF5_next_superloop_and_reload_0E]

l_0D8D_got_a_bullet:
	move.b	#6,(a0)                         	| [ld   (hl),#6] _objs[BOMB0].state = BOMB

	move.l	a0,-(sp)                        	| [push hl] &_objs[BOMB0 + n]
	lea	ds_sprite_posn(pc),a0              	| [ld   h,#>ds_sprite_posn]
	and.w	#0xFF,d6
	add.w	d6,a0
	      ^^^^ TODO: review XX value
	move.b	d5,d3                           	| [ld   d,h]
	subq.b	#1,d4                           	| [dec  e] ... E from &sprite.ctrl[L].b1
* sprite.posn[BOMB0 + n].b0 = sprite.posn[e].b0
	move.b	(a1),d0                         	| [ld   a,(de)] bomber.x
	move.b	d0,d2                           	| [ld   c,a]
	move.b	d0,(a0)                         	| [ld   (hl),a] bomb.x
* sprite.posn[BOMB0 + n].b1 = sprite.posn[e].b1 // y<7:0>
	addq.b	#1,d4                           	| [inc  e]
	addq.b	#1,d6                           	| [inc  l]
	move.b	(a1),d0                         	| [ld   a,(de)] bomber.y<7:0>
	move.b	d0,d1                           	| [ld   b,a]
	move.b	d0,(a0)                         	| [ld   (hl),a] bomb.y<7:0>
* sprite.ctrl[BOMB0 + n].b1 = sprite.ctrl[e].b1
	lea	ds_sprite_ctrl(pc),a0              	| [ld   h,#>ds_sprite_ctrl]
	and.w	#0xFF,d6
	add.w	d6,a0
	      ^^^^ TODO: review XX value
	move.b	d5,d3                           	| [ld   d,h]
	move.b	(a1),d0                         	| [ld   a,(de)] bomber.y<8> (in :0 ... ctrl in :1)
	ror.b	#1,(a0)                          	| [rrc  (hl)] bomb.ctrl.b1<0> to Cy
	ror.b	#1,d0                            	| [rrca] bomber.y<8> from A<0> to Cy
	roxl.b	#1,(a0)                         	| [rl   (hl)] sY<8> from Cy to bomb.ctrl.b1<0>
      ^^^^^^ TODO: review cpu X flag
	rol.b	#1,d0                            	| [rlca] restore A with sY<8> left in Cy
	roxr.b	#1,d1                           	| [rr   b] bomber.y<8:1>
      ^^^^^^ TODO: review cpu X flag
* if (mrw_sprite.posn[bomber_idx].b0 > sprite.posn[FGHTR].b0)
	move.b	ds_sprite_posn+0x62,d0          	| [ld   a,(ds_sprite_posn + 0x62)] fighter.x
	sub.b	d2,d0                            	| [sub  c] bomb.x
	move.w	d0,-(sp)                        	| [push af] stash fighter.x - bomber.x
	jcc	l_0DB1                             	| [jr   nc,l_0DB1] if bomber.x > fighter.x ...
      ^^^^^^ TODO: review cpu flags (move.w,jcc)
	neg.b	d0                               	| [neg] ... then dX = -dX
l_0DB1:
* dX passed to c_0EAA()in hl16 ... lsb of &bomb.ctrl.b1 remaining in L is insignificant
	move.b	d0,d5                           	| [ld   h,a]

	move.b	b_9215_flip_screen,d0           	| [ld   a,(b_9215_flip_screen)]
	                               	| [and  a]
	move.b	#298>>1,d0                      	| [ld   a,#298 >> 1] 0x95 ... 354-56
	jeq	l_0DBC                             	| [jr   z,l_0DBC]
      ^^^^^^ TODO: review cpu flags (move.b,jeq)
	move.b	#56>>1,d0                       	| [ld   a,#56 >> 1] 0x1C ... inverted
l_0DBC:
	sub.b	d1,d0                            	| [sub  b] bomber.y<8:1>
	jcc	l_0DC1                             	| [jr   nc,l_0DC1] if bomber.y > fighter.y ...
	neg.b	d0                               	| [neg]
l_0DC1:
	jbsr	c_0EAA                            	| [call c_0EAA] HL = HL / A
	move.b	d5,d1                           	| [ld   b,h]
	move.b	d6,d2                           	| [ld   c,l]
	lsr.b	#1,d5                            	| [srl  h]
	roxr.b	#1,d6                           	| [rr   l]
	lsr.b	#1,d5                            	| [srl  h]
	roxr.b	#1,d6                           	| [rr   l]
	add.w	d1,a0                            	| [add  hl,bc]
  ^^^^ TODO: review d1 computation above
	lsr.b	#1,d5                            	| [srl  h]
	roxr.b	#1,d6                           	| [rr   l]
	lsr.b	#1,d5                            	| [srl  h]
	roxr.b	#1,d6                           	| [rr   l]

	move.b	d5,d0                           	| [ld   a,h]
	                               	| [and  a]
	jne	l_0DE0                             	| [jr   nz,l_0DE0]
	move.b	d6,d0                           	| [ld   a,l]
	cmp.b	#0x60,d0                         	| [cp   #0x60]
	jcs	l_0DE2                             	| [jr   c,l_0DE2]
l_0DE0:
	move.b	#0x60,d0                        	| [ld   a,#0x60]
l_0DE2:
	move.b	d0,d1                           	| [ld   b,a]

	move.w	(sp)+,d0                        	| [pop  af] Cy from (fighter.x - bomber.x)
	roxr.b	#1,d1                           	| [rr   b]
      ^^^^^^ TODO: review cpu X flag
	move.l	(sp)+,a0                        	| [pop  hl] sprt_mctl_objs[bomb]
	move.b	d6,d0                           	| [ld   a,l]
	add.b	#8,d0                            	| [add  a,#8] IDX_BOMB will be index 0 thanks to and $0F
	and.b	#0x0F,d0                         	| [and  #0x0F]
	lea	b_92B0+0x00(pc),a0                 	| [ld   hl,#b_92B0 + 0x00] bomb x-coordinate structure ( 8 * 2 )
	add.b	d6,d0                            	| [add  a,l]
	move.b	d0,d6                           	| [ld   l,a]
	move.b	d1,(a0)                         	| [ld   (hl),b]
	addq.w	#1,a0                           	| [inc  hl]
	clr.b	(a0)                             	| [ld   (hl),#0]

l_0DF5_next_superloop_and_reload_0E:
	move.b	b_92E2+0x00,d0                  	| [ld   a,(b_92E2 + 0x00)] to $0E(ix) e.g. A==14 (set for each round ... bomb drop counter)
	move.b	d0,(0x0E,a2)                    	| [ld   0x0E(ix),a] b_92E2[0] ... bomb drop counter

next__pool_idx:
	lea	b_bug_que_idx(pc),a0               	| [ld   hl,#b_bug_que_idx] -= 1 ... counts backwards
	subq.b	#1,(a0)                         	| [dec  (hl)]
	bne.b	0f                               	| [...]
	rts                                    	| [ret  z] [...]
0:
* mctl_pool_idx += 1
	move.w	#0x0014,d3                      	| [ld   de,#0x0014] size of object-movement structure 20
	add.w	d3,a2                            	| [add  ix,de]
  ^^^^ TODO: review d3 computation above

	jra	for__pool_idx                      	| [jp   for__pool_idx]

* creature gets to home-spot
l_0E08_imhome:
	clr.b	d0                               	| [xor  a]
	bclr.b	#0,(0x13,a2)                    	| [res  0,0x13(ix)] mark the flying structure as inactive
	move.b	d0,(0x00,a2)                    	| [ld   0x00(ix),a] 0
	move.b	d0,(0x02,a2)                    	| [ld   0x02(ix),a] 0
	lea	b_8800(pc),a0                      	| [ld   h,#>b_8800]
	and.w	#0xFF,d6
	add.w	d6,a0
	      ^^^^ TODO: review XX value
	move.b	(0x10,a2),d6                    	| [ld   l,0x10(ix)] offset of object ...8800[L]
	move.b	#2,(a0)                         	| [ld   (hl),#2] disposition = 02: rotating back into position in the collective
	lea	ds_sprite_code(pc),a0              	| [ld   h,#>ds_sprite_code]
	and.w	#0xFF,d6
	add.w	d6,a0
	      ^^^^ TODO: review XX value
	addq.b	#1,d6                           	| [inc  l]
	move.b	(a0),d0                         	| [ld   a,(hl)] sprite color code
	subq.b	#1,d6                           	| [dec  l]
	addq.b	#1,d0                           	| [inc  a]
	and.b	#0x07,d0                         	| [and  #0x07]
	cmp.b	#5,d0                            	| [cp   #5]
	jcs	l_0E3A                             	| [jr   c,l_0E3A]

* A > 5 ... remaining bonus-bee returns to collective
	move.b	ds_plyr_actv+_b_bbee_clr_a,d0   	| [ld   a,(ds_plyr_actv +_b_bbee_clr_a)]
	move.b	d0,d2                           	| [ld   c,a]
	and.b	#0xF8,d0                         	| [and  #0xF8]
	addq.b	#6,d0                           	| [add  a,#6]
	move.b	d0,(a0)                         	| [ld   (hl),a]
	addq.b	#1,d6                           	| [inc  l]
	move.b	d2,d0                           	| [ld   a,c]
	and.b	#0x07,d0                         	| [and  #0x07]
	move.b	d0,(a0)                         	| [ld   (hl),a]
	subq.b	#1,d6                           	| [dec  l]
	move.b	#1,d0                           	| [ld   a,#1]
	move.b	d0,ds_plyr_actv+_b_bbee_obj     	| [ld   (ds_plyr_actv +_b_bbee_obj),a] 1 ... offset of object that spawns the bonus bee.

l_0E3A:
* these could be off by one if not already equal
	move.b	(0x06,a2),d0                    	| [ld   a,0x06(ix)] ->(ix)0x01 ... origin home position y (bits 15:8)
	move.b	d0,(0x01,a2)                    	| [ld   0x01(ix),a] (ix)0x06
	move.b	(0x07,a2),d0                    	| [ld   a,0x07(ix)] ->(ix)0x03
	move.b	d0,(0x03,a2)                    	| [ld   0x03(ix),a] (ix)0x07

	jra	l_0D03_flite_pth_posn_set          	| [jp   l_0D03_flite_pth_posn_set]

* training mode, make previous diving boss disabled
* a bonus bee (e.g. 883A) flying off screen. Sprite-Code 5B (scorpion), color 05, object status==9
* also, if status==4 (capturing boss shot while in home-position, freeing a rogue ship)
case_0E49_make_object_inactive: ; 0x0
	lea	b_8800(pc),a0                      	| [ld   h,#>b_8800]
	and.w	#0xFF,d6
	add.w	d6,a0
	      ^^^^ TODO: review XX value
	move.b	(0x10,a2),d6                    	| [ld   l,0x10(ix)] object offset ...8800[L]
	move.b	#0x80,(a0)                      	| [ld   (hl),#0x80] make inactive
	lea	ds_sprite_posn(pc),a0              	| [ld   h,#>ds_sprite_posn]
	and.w	#0xFF,d6
	add.w	d6,a0
	      ^^^^ TODO: review XX value
	clr.b	(a0)                             	| [ld   (hl),#0]
	clr.b	(0x13,a2)                        	| [ld   0x13(ix),#0x00] make inactive

	jra	next__pool_idx                     	| [jp   next__pool_idx]
* end f_08D3

*=============================================================================
* c_0E5B()
*  Description:
*    Determine rotation angle ... (ix)0x04, (ix)0x05
*    Parameters are all bits<1:8> of the integer portion (upper-byte)
* IN:
*  D - abs row pix coord
*  E - abs col pix coord
*  H - y, (ix)0x01
*  L - x, (ix)0x03
* OUT:
*  HL
* PRESERVES:
*  BC, DE
*-----------------------------------------------------------------------------
c_0E5B:
	movem.w	d1/d2,-(sp)                    	| [push bc]
	movem.w	d3/d4,-(sp)                    	| [push de]
	move.l	a1,-(sp)                        	| [push de]

* dx
	move.b	d4,d0                           	| [ld   a,e]
	sub.b	d6,d0                            	| [sub  l]
	clr.b	d1                               	| [ld   b,#0]
	jcc	l_0E67                             	| [jr   nc,l_0E67]
      ^^^^^^ TODO: review cpu flags (clr.b,jcc)
	bset.b	#0,d1                           	| [set  0,b]
	neg.b	d0                               	| [neg]
l_0E67:
	move.b	d0,d2                           	| [ld   c,a]

* dy
	move.b	d3,d0                           	| [ld   a,d]
	sub.b	d5,d0                            	| [sub  h]
	jcc	l_0E76                             	| [jr   nc,l_0E76]
	move.b	d0,d3                           	| [ld   d,a]
	move.b	d1,d0                           	| [ld   a,b] 1 if carried
	eor.b	#0x01,d0                         	| [xor  #0x01]
	or.b	#0x02,d0                          	| [or   #0x02]
	move.b	d0,d1                           	| [ld   b,a]
	move.b	d3,d0                           	| [ld   a,d]
	neg.b	d0                               	| [neg]

l_0E76:
	cmp.b	d2,d0                            	| [cp   c]
	move.w	d0,-(sp)                        	| [push af]
	roxl.b	#1,d0                           	| [rla]
      ^^^^^^ TODO: review cpu X flag
	eor.b	d1,d0                            	| [xor  b]
	roxr.b	#1,d0                           	| [rra]
      ^^^^^^ TODO: review cpu X flag

	bcs.b	0f
	clr.b	d7
	bra.b	1f
0:
	st.b	d7
1:
	cmp.b	#1,d7                            	| [ccf] complement Cy
	roxl.b	#1,d1                           	| [rl   b]
      ^^^^^^ TODO: review cpu X flag, cmp doesn't affect it!
	move.w	(sp)+,d0                        	| [pop  af]
	jcc	l_0E84                             	| [jr   nc,l_0E84]
      ^^^^^^ TODO: review cpu flags (move.w,jcc)
	move.b	d2,d3                           	| [ld   d,c]
	move.b	d0,d2                           	| [ld   c,a]
	move.b	d3,d0                           	| [ld   a,d]

l_0E84:
	move.b	d2,d5                           	| [ld   h,c]
	clr.b	d6                               	| [ld   l,#0]

* HL = HL / A
	jbsr	c_0EAA                            	| [call c_0EAA] HL = HL / A

	move.b	d5,d0                           	| [ld   a,h]
	eor.b	d1,d0                            	| [xor  b]
	and.b	#0x01,d0                         	| [and  #0x01]
	jeq	l_0E93                             	| [jr   z,l_0E93]
	move.b	d6,d0                           	| [ld   a,l]
	not.b	d0                               	| [cpl]
	move.b	d0,d6                           	| [ld   l,a]

l_0E93:
	move.b	d1,d5                           	| [ld   h,b]

	move.l	(sp)+,a1                        	| [pop  de]
	movem.w	(sp)+,d3/d4                    	| [pop  de]

	movem.w	(sp)+,d1/d2                    	| [pop  bc]

	rts                                    	| [ret]

*=============================================================================
* c_0E97()
*  Description:
*    for f_08D3
*    HL = HL * A
* IN:
*  A
*  HL (only L is significant)
* OUT:
*  H
*  L
* PRESERVES:
*  DE
*-----------------------------------------------------------------------------
c_0E97:
	movem.w	d3/d4,-(sp)                    	| [push de]
	move.l	a1,-(sp)                        	| [push de]
	exg	a1,a0                              	| [ex   de,hl]
	move.w	#0x0000,d5                      	| [ld   hl,#0x0000] 0

l_0E9C:
	lsr.b	#1,d0                            	| [srl  a]
	jcc	l_0EA1                             	| [jr   nc,l_0EA1]
	add.w	d3,a0                            	| [add  hl,de]
  ^^^^ TODO: review d3 computation above
l_0EA1:
	asl.b	#1,d4                            	| [sla  e]
	roxl.b	#1,d3                           	| [rl   d]
	tst.b	d0                               	| [and  a]
	jne	l_0E9C                             	| [jr   nz,l_0E9C]

	move.l	(sp)+,a1                        	| [pop  de]
	movem.w	(sp)+,d3/d4                    	| [pop  de]
	rts                                    	| [ret]

*=============================================================================
* c_0EAA()
*  Description:
*   HL = HL / A
* IN:
*  A, HL
* OUT:
*  HL
* PRESERVES:
*  BC
*-----------------------------------------------------------------------------
c_0EAA:
	movem.w	d1/d2,-(sp)                    	| [push bc]
	move.b	d0,d2                           	| [ld   c,a]
	clr.b	d0                               	| [xor  a] clears Cy
	move.b	#0x11,d1                        	| [ld   b,#0x11]
l_0EAF:
adc  a,a
	jcs	l_0EBD                             	| [jr   c,l_0EBD]
      ^^^^^^ TODO: review cpu flags (move.b,jcs)
	cmp.b	d2,d0                            	| [cp   c]
	jcs	l_0EB6                             	| [jr   c,l_0EB6]
	sub.b	d2,d0                            	| [sub  c]
l_0EB6:
* flip the Cy: i.e. set it if the "sub c" was done, otherwise clear it.

	bcs.b	0f
	clr.b	d7
	bra.b	1f
0:
	st.b	d7
1:
	cmp.b	#1,d7                            	| [ccf]

l_0EB7:
adc  hl,hl
	subq.b	#1,d1                           	| [...]
	jne	l_0EAF                             	| [djnz l_0EAF]


	movem.w	(sp)+,d1/d2                    	| [pop  bc]
	rts                                    	| [ret]

l_0EBD:
	sub.b	d2,d0                            	| [sub  c]
	SET_XC_FLAGS                           	| [scf]
	jra	l_0EB7                             	| [jp   l_0EB7]


.ds 0x08    ; no code at 0EC0.

*=============================================================================
* f_0ECA()
*  Description:
*   Reads dsw3 which is doesn't seem to have any function (MAME list as unused).
*   If the switch were active (0) then the section of code would be reading
*   from code space locations beyond the $1000.
* IN:
*  ...
* OUT:
*  ...
*-----------------------------------------------------------------------------
f_0ECA:
	move.b	_sfr_dsw3,d0                    	| [ld   a,(_sfr_dsw3)] DSWA ( 0x04, 0x04, "SW1:3" ) /* Listed as "Unused" */
	and.b	#0x02,d0                         	| [and  #0x02]
	beq.b	0f                               	| [...]
	rts                                    	| [ret  nz] [...]
0:

	lea	l_10FF(pc),a0                      	| [ld   hl,#0x10FF]
	move.b	(a0),d0                         	| [ld   a,(hl)]
	move.b	#0xDF,d6                        	| [ld   l,#0xDF] $10DF
	move.b	(a0),d2                         	| [ld   c,(hl)]
	move.b	(a0),d0                         	| [ld   a,(hl)]
	eor.b	d2,d0                            	| [xor  c]
	btst.b	#4,d0                           	| [bit  4,a]
	jne	l_0EDE                             	| [jr   nz,l_0EDE]
	jbsr	rst_00                            	| [rst  0x00]

l_0EDE:
	lea	ds_89E0+0x16+0x01(pc),a1           	| [ld   de,#ds_89E0 + 0x16 + 0x01]
	lea	ds_89E0+0x16(pc),a0                	| [ld   hl,#ds_89E0 + 0x16] implements a $14 byte FIFO
	move.b	#0x00,d1                        	| [ld   bc,#0x0013] 19
	move.b	#0x13,d2                        	| [ld   bc,#0x0013] 19
lddr
	lea	d_0FD5(pc),a2                      	| [ld   ix,#d_0FD5]
	move.b	#0xE0,d4                        	| [ld   e,#0xE0]
	move.b	#0x0500+0x0004_msb,d1           	| [ld   bc,#0x0500 + 0x0004] B = loop ct (5 bytes) None
	move.b	#0x0500+0x0004_lsb,d2           	| [ld   bc,#0x0500 + 0x0004] B = loop ct (5 bytes) None
l_0EF2:
	move.b	(0x00,a2),d0                    	| [ld   a,0x00(ix)]
	addq.w	#1,a2                           	| [inc  ix]
	move.b	d0,d6                           	| [ld   l,a]
	move.b	#0x10,d5                        	| [ld   h,#0x10]
	move.b	(a0),d0                         	| [ld   a,(hl)]
	move.b	d4,d0                           	| [ld   a,e] huh?
	add.b	d2,d0                            	| [add  a,c]
	move.b	d0,d4                           	| [ld   e,a]
	move.b	(a0),d0                         	| [ld   a,(hl)]
	move.b	d0,(a1)                         	| [ld   (de),a]
	subq.b	#1,d1                           	| [...]
	jne	l_0EF2                             	| [djnz l_0EF2]

	move.b	#5,d1                           	| [ld   b,#5]
	lea	ds_89E0+0x04(pc),a0                	| [ld   hl,#ds_89E0 + 0x04]
l_0F07:
	move.b	(a0),d0                         	| [ld   a,(hl)]
	addq.b	#1,d6                           	| [inc  l]
	or.b	(a0),d0                           	| [or   (hl)]
	addq.b	#1,d6                           	| [inc  l]
	not.b	d0                               	| [cpl]
	and.b	(a0),d0                          	| [and  (hl)]
	addq.b	#1,d6                           	| [inc  l]
	and.b	(a0),d0                          	| [and  (hl)]
	addq.b	#1,d6                           	| [inc  l]
	and.b	#0x0F,d0                         	| [and  #0x0F]
	jne	l_0F18                             	| [jr   nz,l_0F18]
	subq.b	#1,d1                           	| [...]
	jne	l_0F07                             	| [djnz l_0F07]

	jra	l_0F58                             	| [jr   l_0F58]
l_0F18:
	subq.b	#1,d1                           	| [dec  b]
	jeq	l_0F6A                             	| [jr   z,l_0F6A]
	subq.b	#1,d1                           	| [dec  b]
	asl.b	#2,d1                            	| [sla  b] * 2
l_0F20:
	ror.b	#1,d0                            	| [rrca]
	jcs	l_0F26                             	| [jr   c,l_0F26]
	addq.b	#1,d1                           	| [inc  b]
	jra	l_0F20                             	| [jr   l_0F20]
l_0F26:
	move.b	ds_89E0,d0                      	| [ld   a,(ds_89E0)]
	lsr.b	#1,d0                            	| [srl  a]
	move.b	d0,d4                           	| [ld   e,a]
	roxl.b	#1,d2                           	| [rl   c]
      ^^^^^^ TODO: review cpu X flag
	add.b	#0xE1,d0                         	| [add  a,#0xE1]
	move.b	d0,d6                           	| [ld   l,a]
	lea	ds_89E0(pc),a0                     	| [ld   h,#>ds_89E0]
	and.w	#0xFF,d6
	add.w	d6,a0
	      ^^^^ TODO: review XX value
	move.b	(a0),d0                         	| [ld   a,(hl)]
	btst.b	#0,d2                           	| [bit  0,c]
	jeq	l_0F3C                             	| [jr   z,l_0F3C]
	rol.b	#4,d0                            	| [rlca] * 4
l_0F3C:
	and.b	#0xF0,d0                         	| [and  #0xF0]
	or.b	d1,d0                             	| [or   b]
	btst.b	#0,d2                           	| [bit  0,c]
	jeq	l_0F47                             	| [jr   z,l_0F47]
	rol.b	#4,d0                            	| [rlca] * 4
l_0F47:
	move.b	d0,(a0)                         	| [ld   (hl),a]
	move.b	ds_89E0,d0                      	| [ld   a,(ds_89E0)]
	                               	| [and  a]
	jne	l_0F50                             	| [jr   nz,l_0F50]
	move.b	#2,d0                           	| [ld   a,#2]
l_0F50:
	subq.b	#1,d0                           	| [dec  a]
	move.b	d0,ds_89E0                      	| [ld   (ds_89E0),a]
	move.b	d4,d0                           	| [ld   a,e]
	                               	| [and  a]
	jeq	l_0F61                             	| [jr   z,l_0F61]
l_0F58:
	move.w	ds_89E0+0x02(pc),a0             	| [ld   hl,(ds_89E0 + 0x02)]
                  ^^^^^^ TODO: review move.w into address register
	move.b	(a0),d0                         	| [ld   a,(hl)]
	move.b	d0,ds_89E0+0x01                 	| [ld   (ds_89E0 + 0x01),a]
	jra	l_0FA3                             	| [jr   l_0FA3]
l_0F61:
	move.w	ds_89E0+0x02(pc),a0             	| [ld   hl,(ds_89E0 + 0x02)]
                  ^^^^^^ TODO: review move.w into address register
	move.b	ds_89E0+0x01,d0                 	| [ld   a,(ds_89E0 + 0x01)]
	move.b	d0,(a0)                         	| [ld   (hl),a]
	jra	l_0FA3                             	| [jr   l_0FA3]
l_0F6A:
	move.b	d0,d2                           	| [ld   c,a]
	lea	ds_89E0(pc),a0                     	| [ld   hl,#ds_89E0]
	btst.b	#0,d2                           	| [bit  0,c]
	jne	l_0F9F                             	| [jr   nz,l_0F9F]
	move.b	(a0),d0                         	| [ld   a,(hl)]
	lsr.b	#1,d0                            	| [srl  a]
	jeq	l_0F8A                             	| [jr   z,l_0F8A]
	btst.b	#3,d2                           	| [bit  3,c]
	jne	l_0F87                             	| [jr   nz,l_0F87]
	move.b	(a0),d0                         	| [ld   a,(hl)]
	cmp.b	#5,d0                            	| [cp   #5]
	jcc	l_0F83                             	| [jr   nc,l_0F83]
	addq.b	#1,(a0)                         	| [inc  (hl)]
	jra	l_0F58                             	| [jr   l_0F58]
l_0F83:
	move.b	#0x05,(a0)                      	| [ld   (hl),#0x05]
	jra	l_0F58                             	| [jr   l_0F58]
l_0F87:
	subq.b	#1,(a0)                         	| [dec  (hl)]
	jra	l_0F58                             	| [jr   l_0F58]
l_0F8A:
	move.w	ds_89E0+0x02(pc),a0             	| [ld   hl,(ds_89E0 + 0x02)]
                  ^^^^^^ TODO: review move.w into address register
	btst.b	#3,d2                           	| [bit  3,c]
	jne	l_0F94                             	| [jr   nz,l_0F94]
	subq.w	#1,a0                           	| [dec  hl]
	jra	l_0F95                             	| [jr   l_0F95]
l_0F94:
	addq.w	#1,a0                           	| [inc  hl]
l_0F95:
	move.b	a0,ds_89E0+0x02                 	| [ld   (ds_89E0 + 0x02),hl]
	move.b	#0x01,d0                        	| [ld   a,#0x01]
	move.b	d0,ds_89E0                      	| [ld   (ds_89E0),a]
	jra	l_0F58                             	| [jr   l_0F58]
l_0F9F:
	move.b	#0x05,(a0)                      	| [ld   (hl),#0x05]
	jra	l_0F58                             	| [jr   l_0F58]
l_0FA3:
	lea	0x8000+0x03C0+0x0A(pc),a0      	| [ld   hl,#0x8000 + 0x03C0 + 0x0A]
	lea	ds_89E0+0x01(pc),a1                	| [ld   de,#ds_89E0 + 0x01]
	move.b	#3,d1                           	| [ld   b,#3]
l_0FAB:
	move.b	(a1),d0                         	| [ld   a,(de)]
	addq.b	#1,d4                           	| [inc  e]
	jbsr	c_0FC6                            	| [call c_0FC6]
	subq.b	#1,d1                           	| [...]
	jne	l_0FAB                             	| [djnz l_0FAB]

	lea	m_color_ram+0x03CA(pc),a0          	| [ld   hl,#m_color_ram + 0x03CA]
	move.b	ds_89E0,d0                      	| [ld   a,(ds_89E0)]
	move.b	#6,d1                           	| [ld   b,#6]
l_0FBA:
	tst.b	d0                               	| [and  a]
	move.b	d0,d2                           	| [ld   c,a]
	jeq	l_0FC0                             	| [jr   z,l_0FC0]
      ^^^^^^ TODO: review cpu flags (move.b,jeq)
	move.b	#1,d2                           	| [ld   c,#1]
l_0FC0:
	move.b	d2,(a0)                         	| [ld   (hl),c]
	addq.b	#1,d6                           	| [inc  l]
	subq.b	#1,d0                           	| [dec  a]
	subq.b	#1,d1                           	| [...]
	jne	l_0FBA                             	| [djnz l_0FBA]

	rts                                    	| [ret]

*=============================================================================
* c_0FC6()
*  Description:
*    Called by f_0ECA
* IN:
*  ...
* OUT:
*  ...
*-----------------------------------------------------------------------------
c_0FC6:
	move.b	d0,d2                           	| [ld   c,a]
	and.b	#0x0F,d0                         	| [and  #0x0F]
	move.b	d0,(a0)                         	| [ld   (hl),a]
	addq.b	#1,d6                           	| [inc  l]
	move.b	d2,d0                           	| [ld   a,c]
	rol.b	#4,d0                            	| [rlca] * 4
	and.b	#0x0F,d0                         	| [and  #0x0F]
	move.b	d0,(a0)                         	| [ld   (hl),a]
	addq.b	#1,d6                           	| [inc  l]
	rts                                    	| [ret]

*=============================================================================
* data for f_0ECA
d_0FD5:
	.byte 0xFD,0xFB,0xF7,0xEF,0xFE

* additional challenge stage data (see db_2A3C)
db_flv_0fda:
	.byte 0x23,0x00,0x1B,0x23,0xF0,0x40,0x23,0x00,0x09,0x23,0x05,0x11
	.byte 0x23,0x00,0x10,0x23,0x10,0x40,0x23,0x04,0x30,0xFF
db_flv_0ff0:
	.byte 0x23,0x02,0x35,0x23,0x08,0x10
	.byte 0x23,0x10,0x3C,0x23,0x00,0xFF,0xFF

	.byte 0x32 | junk ??

* end of ROM

* input file gg1-7.s
*
* gg1-7.s
*  gg1-7.2c, CPU 'sub2' (Z80)
*
.module cpu_sub2

.include "sfrs.inc"
.include "gg1-7.dep"

.BANK cpu_sub2 (BASE=0x000000, FSFX=_sub2)
.area ROM2 (ABS,OVR,BANK=cpu_sub2)

*.org 0x0000

*=============================================================================
* RST_00()
*  Description:
* IN:
*  ...
* OUT:
*  ...
*-----------------------------------------------------------------------------
ld   sp,#_stack_cpu_sub2 + 0x20
	jra	RESET                              	| [jp   RESET]

*.org 0x0008

*=============================================================================
* RST_08()
*  Description:
*
* IN:
*  ...
* OUT:
*  ...
*-----------------------------------------------------------------------------
	add.b	d0,d0                            	| [add  a,a]
	jcc	_RST_10                            	| [jr   nc,_RST_10]
	addq.b	#1,d5                           	| [inc  h]
	jra	_RST_10                            	| [jr   _RST_10]

*.org 0x0010

*=============================================================================
* RST_10()
*  Description:
*   HL = HL + A
* IN:
*
* OUT:
*  ...
*-----------------------------------------------------------------------------
_RST_10:
	add.b	d6,d0                            	| [add  a,l]
	move.b	d0,d6                           	| [ld   l,a]
	bcs.b	0f                               	| [...]
      ^^^^^^ TODO: review cpu flags (move.b,bcs.b)
	rts                                    	| [ret  nc] [...]
0:
	addq.b	#1,d5                           	| [inc  h]
	rts                                    	| [ret]

*.org 0x0018

*=============================================================================
* RST_18()
*  Description:
*   memset((HL), A, B)
* IN:
*   HL: pointer
*   A: fill character
*   B: count
* OUT:
*  ...
*-----------------------------------------------------------------------------
_RST_18:
	move.b	d0,(a0)                         	| [ld   (hl),a]
	addq.w	#1,a0                           	| [inc  hl]
	subq.b	#1,d1                           	| [...]
	jne	_RST_18                            	| [djnz _RST_18]
	rts                                    	| [ret]

*.org  0x0066

*=============================================================================
* RST_66()
*  Description:
*   NMI
* IN:
*  ...
* OUT:
*  ...
*-----------------------------------------------------------------------------
	move.b	#1,d0                           	| [ld   a,#1]
	move.b	d0,_sfr_6822                    	| [ld   (_sfr_6822),a] 1 ...cpu #2 nmi acknowledge/enable
	clr.b	d0                               	| [xor  a]
	move.b	d0,_sfr_6822                    	| [ld   (_sfr_6822),a] 0 ...cpu #2 nmi acknowledge/enable
	jbsr	c_nmi_proc                        	| [call c_nmi_proc]
	rts                                    	| [ret]

*=============================================================================
* RESET
*  Description:
*   entry point from RST 00
*   Tests the ROM space (length $1000)
* IN:
*  ...
* OUT:
*  ...
*-----------------------------------------------------------------------------
RESET:
	move.b	#1,d0                           	| [ld   a,#1]
	move.b	d0,_sfr_6822                    	| [ld   (_sfr_6822),a] 1 ...cpu #2 nmi acknowledge/enable

	lea	ds_rom_test_status+0x01(pc),a1     	| [ld   de,#ds_rom_test_status + 0x01] pause/resume flag

* wait for master CPU to acknowledge/resume (0)
l_007B:
	move.b	(a1),d0                         	| [ld   a,(de)]
	                               	| [and  a]
	jne	l_007B                             	| [jr   nz,l_007B]

* compute ROM checksum
	move.b	d0,d5                           	| [ld   h,a]
	move.b	d0,d6                           	| [ld   l,a]
	move.b	#0x00,d1                        	| [ld   bc,#0x0010] Sets B as inner loop count ($100) and C as outer ($10) 16
	move.b	#0x10,d2                        	| [ld   bc,#0x0010] Sets B as inner loop count ($100) and C as outer ($10) 16
l_0084:
	add.b	(a0),d0                          	| [add  a,(hl)]
	addq.w	#1,a0                           	| [inc  hl]
	subq.b	#1,d1                           	| [...]
	jne	l_0084                             	| [djnz l_0084]

	subq.b	#1,d2                           	| [dec  c]
	jne	l_0084                             	| [jr   nz,l_0084]

	cmp.b	#0xFF,d0                         	| [cp   #0xFF]
	jeq	l_0091                             	| [jr   z,l_0091]
	move.b	#0x11,d0                        	| [ld   a,#0x11] set error code

l_0091:
	move.b	d0,(a1)                         	| [ld   (de),a] copy checksum result to the global variable

* wait for master to acknowledge/resume (0)
l_0092:
	move.b	(a1),d0                         	| [ld   a,(de)]
	                               	| [and  a]
	jne	l_0092                             	| [jr   nz,l_0092]

	clr.b	d0                               	| [xor  a]
	move.b	d0,_sfr_6822                    	| [ld   (_sfr_6822),a] 0 ...cpu #2 nmi acknowledge/enable (Z80_NMI_INT)

* clear all registers
	lea	b_9A00(pc),a0                      	| [ld   hl,#b_9A00] memset(b_9A00, 0, $0100)
	clr.b	(a0)                             	| [ld   (hl),#0]
	lea	b_9A00+0x01(pc),a1                 	| [ld   de,#b_9A00 + 0x01] memset(b_9A00, 0, $0100)
	move.b	#0x00,d1                        	| [ld   bc,#0x00FF] 255
	move.b	#0xff,d2                        	| [ld   bc,#0x00FF] 255
	jbsr	ldir                              	| [ldir]
     ^^^^ TODO: review special instruction inputs

l_00A7:
	jra	l_00A7                             	| [jr   l_00A7] loop forever

*=============================================================================
* c_nmi_proc()
*  Description:
*    Handler for NMI
* IN:
*  ...
* OUT:
*  ...
*-----------------------------------------------------------------------------
c_nmi_proc:
	move.b	b_9AA0+0x18,d0                  	| [ld   a,(b_9AA0 + 0x18)] sound-fx count/enable registers, unused?
	                               	| [and  a]
	jne	l_067A_reset_sfrs                  	| [jp   nz,l_067A_reset_sfrs] doesn't appear that it is ever called

* memset( b_freq_vol_sfr_bufr, 0, $10 )
	lea	b_9A60+0x00(pc),a0                 	| [ld   hl,#b_9A60 + 0x00] clear frequency and volume SFRs
	clr.b	(a0)                             	| [ld   (hl),#0]
	lea	b_9A60+0x01(pc),a1                 	| [ld   de,#b_9A60 + 0x01]
	move.b	#0x00,d1                        	| [ld   bc,#0x000F] 15
	move.b	#0x0f,d2                        	| [ld   bc,#0x000F] 15
	jbsr	ldir                              	| [ldir]
     ^^^^ TODO: review special instruction inputs

* if ( sound_mgr_reset )  ...
	move.b	b_9AA0+0x17,d0                  	| [ld   a,(b_9AA0 + 0x17)] 0 ... enable sound mgr process
	                               	| [and  a]
	jne	l_033D_clear_all                   	| [jp   nz,l_033D_clear_all]
* ... then ...

* credit-in sound is triggered for all credits counted

* if ( 0 != snd_add_credit_cnt )
	move.b	b_9A70+0x09,d0                  	| [ld   a,(b_9A70 + 0x09)] count of credits-in since last update
	                               	| [and  a]
	jeq	l_00D3                             	| [jr   z,l_00D3]
* then ...
*  _fx[$08] += snd_add_credit_cnt
	lea	b_9AA0+0x08(pc),a0                 	| [ld   hl,#b_9AA0 + 0x08] += b_9A70[9] ... sound-fx count/enable registers, credit-in sound
	add.b	(a0),d0                          	| [add  a,(hl)]
	move.b	d0,(a0)                         	| [ld   (hl),a]
*  snd_add_credit_cnt = 0
	clr.b	d0                               	| [xor  a]
	move.b	d0,b_9A70+0x09                  	| [ld   (b_9A70 + 0x09),a] 0 ... additional credit-in count
* ...

l_00D3:
* if ( 0 != register )  ...  count/enable register
	move.b	b_9AA0+0x00,d0                  	| [ld   a,(b_9AA0 + 0x00)] sound-fx count/enable registers, pulsing formation sound effect
	                               	| [and  a]
	jeq	l_0148                             	| [jr   z,l_0148]
* ... then ...
	move.b	ds_9200_glbls+0x11,d0           	| [ld   a,(ds_9200_glbls + 0x11)] formatn_mv_signage ... cp with cpu2<b_9A80 + 0x00>
	lea	b_9A80+0x00(pc),a0                 	| [ld   hl,#b_9A80 + 0x00]
	cmp.b	(a0),d0                          	| [cp   (hl)]
	jeq	l_0102                             	| [jr   z,l_0102]

	move.b	d0,b_9A80+0x00                  	| [ld   (b_9A80 + 0x00),a] = ds_9200_glbls [0x11] ... formatn_mv_signage
	addq.b	#1,d0                           	| [inc  a]
	jeq	l_00F4                             	| [jr   z,l_00F4]

* expanding formation
	lea	d_06C3(pc),a0                      	| [ld   hl,#d_06C3]
	move.b	a0,b_9A80+0x02                  	| [ld   (b_9A80 + 0x02),hl] ptmp = &d_06C3[0]

	clr.b	d0                               	| [xor  a]
	move.b	d0,b_9A00+0x00                  	| [ld   (b_9A00 + 0x00),a] 0 .. sound_fx_status
	jra	l_00FD                             	| [jr   l_00FD]

* contracting formation
l_00F4:
       * A == 0
	lea	d_06C3+8*2(pc),a0                  	| [ld   hl,#d_06C3 + 8 * 2] offset 8 words
	move.b	a0,b_9A80+0x02                  	| [ld   (b_9A80 + 0x02),hl] ptmp = &d_06D3[0]
	move.b	d0,b_9A00+0x00                  	| [ld   (b_9A00 + 0x00),a] 0 ... sound_fx_status
l_00FD:
       * A == 0
	move.b	d0,b_9A80+0x01                  	| [ld   (b_9A80 + 0x01),a] A == 0  or  A != 0 (only gets updated when b_9A80_00 == formatn_mv_signage
	jra	l_0114                             	| [jr   l_0114]

l_0102:
	lea	b_9A00+0x00(pc),a0                 	| [ld   hl,#b_9A00 + 0x00] sound_fx_status[0]++ (check for limit of 34)
	addq.b	#1,(a0)                         	| [inc  (hl)]
	move.b	(a0),d0                         	| [ld   a,(hl)]

	cmp.b	#0x22,d0                         	| [cp   #0x22]
	jne	l_0129                             	| [jr   nz,l_0129]
	clr.b	(a0)                             	| [ld   (hl),#0] sound_fx_status[0] = 0
	move.b	b_9A80+0x01,d0                  	| [ld   a,(b_9A80 + 0x01)] b_9A80[1]++
	addq.b	#1,d0                           	| [inc  a]
	move.b	d0,b_9A80+0x01                  	| [ld   (b_9A80 + 0x01),a] b_9A80[1]++

l_0114:
	move.w	b_9A80+0x02(pc),a0              	| [ld   hl,(b_9A80 + 0x02)] ptmp ... d_06C3 or d_06D3
                  ^^^^^^ TODO: review move.w into address register
	jbsr	rst_08                            	| [rst  0x08] HL += 2A
	move.b	(a0),d4                         	| [ld   e,(hl)]
	addq.w	#1,a0                           	| [inc  hl]
	move.b	(a0),d3                         	| [ld   d,(hl)]
	move.b	a1,b_9A80+0x04                  	| [ld   (b_9A80 + 0x04),de]
	move.b	#0x1F,d0                        	| [ld   a,#0x1F] $20 - $01 (1-byte increment to next word already done)
	jbsr	rst_10                            	| [rst  0x10] HL += A
	move.b	(a0),d4                         	| [ld   e,(hl)]
	addq.w	#1,a0                           	| [inc  hl]
	move.b	(a0),d3                         	| [ld   d,(hl)]
	move.b	a1,b_9A80+0x06                  	| [ld   (b_9A80 + 0x06),de]
l_0129:
	move.w	b_9A80+0x06(pc),a0              	| [ld   hl,(b_9A80 + 0x06)] b_9A80[6] += b_9A80[4]
                  ^^^^^^ TODO: review move.w into address register
	move.w	b_9A80+0x04(pc),a1              	| [ld   de,(b_9A80 + 0x04)]
                  ^^^^^^ TODO: review move.w into address register
	add.w	d3,a0                            	| [add  hl,de]
  ^^^^ TODO: review d3 computation above
	move.b	a0,b_9A80+0x06                  	| [ld   (b_9A80 + 0x06),hl]

	move.b	d5,d0                           	| [ld   a,h]
	move.b	d0,b_9A60+0x01                  	| [ld   (b_9A60 + 0x01),a] freq 0
	ror.b	#4,d0                            	| [rrca] * 4
	move.b	d0,b_9A60+0x01+1                	| [ld   (b_9A60 + 0x01 + 1),a]
	move.b	#0x0A,d0                        	| [ld   a,#0x0A]
	move.b	d0,b_9A60+0x05                  	| [ld   (b_9A60 + 0x05),a] $0A ... voice 0 volume
	clr.b	d0                               	| [xor  a]
	move.b	d0,b_9A70+0x00+0                	| [ld   (b_9A70 + 0x00 + 0),a] 0 ... voice 0 wave select

* bug dive attack sound
l_0148:
	lea	b_9A70+0x04(pc),a0                 	| [ld   hl,#b_9A70 + 0x04] $13 ... bug dive attack sound
	move.b	#0x13,(a0)                      	| [ld   (hl),#0x13]
	move.b	b_9AA0+0x13,d0                  	| [ld   a,(b_9AA0 + 0x13)] sound-fx count/enable registers, bug dive attack sound
	                               	| [and  a]
	jeq	l_015C                             	| [jr   z,l_015C]
	clr.b	d0                               	| [xor  a]
	move.b	d0,b_9AA0+0x13                  	| [ld   (b_9AA0 + 0x13),a] 0 ... sound-fx count/enable registers, bug dive attack sound
	jbsr	c_03F4                            	| [call c_03F4] initialize the sound
	jra	l_0165                             	| [jr   l_0165]
l_015C:
	move.b	b_9AC0+0x13,d0                  	| [ld   a,(b_9AC0 + 0x13)] check if sound is active
	                               	| [and  a]
	jeq	l_0165                             	| [jr   z,l_0165]
	jbsr	c_044A                            	| [call c_044A] update the sound

* shot sound
l_0165:
	lea	b_9A70+0x04(pc),a0                 	| [ld   hl,#b_9A70 + 0x04] $0F
	move.b	#0x0F,(a0)                      	| [ld   (hl),#0x0F]
	move.b	b_9AA0+0x0F,d0                  	| [ld   a,(b_9AA0 + 0x0F)] sound-fx count/enable registers, shot sound
	                               	| [and  a]
	jeq	l_0179                             	| [jr   z,l_0179]
	clr.b	d0                               	| [xor  a]
	move.b	d0,b_9AA0+0x0F                  	| [ld   (b_9AA0 + 0x0F),a] 0 ... sound-fx count/enable registers, shot sound
	jbsr	c_03F4                            	| [call c_03F4]
	jra	l_0182                             	| [jr   l_0182]
l_0179:
	move.b	b_9AC0+0x0F,d0                  	| [ld   a,(b_9AC0 + 0x0F)]
	                               	| [and  a]
	jeq	l_0182                             	| [jr   z,l_0182]
	jbsr	c_044A                            	| [call c_044A]

* yellow bug hit sound
l_0182:
	lea	b_9A70+0x04(pc),a0                 	| [ld   hl,#b_9A70 + 0x04] $03
	move.b	#3,(a0)                         	| [ld   (hl),#3]
	move.b	b_9AA0+0x03,d0                  	| [ld   a,(b_9AA0 + 0x03)] sound-fx count/enable registers, yellow bug hit sound
	                               	| [and  a]
	jeq	l_0196                             	| [jr   z,l_0196]
	clr.b	d0                               	| [xor  a]
	move.b	d0,b_9AA0+0x03                  	| [ld   (b_9AA0 + 0x03),a] 0 ... sound-fx count/enable registers, yellow bug hit sound
	jbsr	c_03F4                            	| [call c_03F4]
	jra	l_019F                             	| [jr   l_019F]
l_0196:
	move.b	b_9AC0+0x03,d0                  	| [ld   a,(b_9AC0 + 0x03)]
	                               	| [and  a]
	jeq	l_019F                             	| [jr   z,l_019F]
	jbsr	c_044A                            	| [call c_044A]

* red bug hit sound
l_019F:
	lea	b_9A70+0x04(pc),a0                 	| [ld   hl,#b_9A70 + 0x04] $02
	move.b	#2,(a0)                         	| [ld   (hl),#2]
	move.b	b_9AA0+0x02,d0                  	| [ld   a,(b_9AA0 + 0x02)] sound-fx count/enable registers, red bug hit sound
	                               	| [and  a]
	jeq	l_01B3                             	| [jr   z,l_01B3]
	clr.b	d0                               	| [xor  a]
	move.b	d0,b_9AA0+0x02                  	| [ld   (b_9AA0 + 0x02),a] 0 ... sound-fx count/enable registers, red bug hit sound
	jbsr	c_03F4                            	| [call c_03F4]
	jra	l_01BC                             	| [jr   l_01BC]
l_01B3:
	move.b	b_9AC0+0x02,d0                  	| [ld   a,(b_9AC0 + 0x02)]
	                               	| [and  a]
	jeq	l_01BC                             	| [jr   z,l_01BC]
	jbsr	c_044A                            	| [call c_044A]

* hit_green_boss
l_01BC:
	lea	b_9A70+0x04(pc),a0                 	| [ld   hl,#b_9A70 + 0x04] $04
	move.b	#4,(a0)                         	| [ld   (hl),#4]
	move.b	b_9AA0+0x04,d0                  	| [ld   a,(b_9AA0 + 0x04)] sound-fx count/enable registers, hit_green_boss
	                               	| [and  a]
	jeq	l_01D0                             	| [jr   z,l_01D0]
	clr.b	d0                               	| [xor  a]
	move.b	d0,b_9AA0+0x04                  	| [ld   (b_9AA0 + 0x04),a] 0 ... sound-fx count/enable registers, hit_green_boss
	jbsr	c_03F4                            	| [call c_03F4]
	jra	l_01D9                             	| [jr   l_01D9]
l_01D0:
	move.b	b_9AC0+0x04,d0                  	| [ld   a,(b_9AC0 + 0x04)]
	                               	| [and  a]
	jeq	l_01D9                             	| [jr   z,l_01D9]
	jbsr	c_044A                            	| [call c_044A]

* hit_blue_boss
l_01D9:
	lea	b_9A70+0x04(pc),a0                 	| [ld   hl,#b_9A70 + 0x04] $01
	move.b	#1,(a0)                         	| [ld   (hl),#1]
	move.b	b_9AA0+0x01,d0                  	| [ld   a,(b_9AA0 + 0x01)] sound-fx count/enable registers, blue-boss hit sound
	                               	| [and  a]
	jeq	l_01ED                             	| [jr   z,l_01ED]
	clr.b	d0                               	| [xor  a]
	move.b	d0,b_9AA0+0x01                  	| [ld   (b_9AA0 + 0x01),a] 0 ... sound-fx count/enable registers, blue-boss hit sound
	jbsr	c_03F4                            	| [call c_03F4]
	jra	l_01F6                             	| [jr   l_01F6]
l_01ED:
	move.b	b_9AC0+0x01,d0                  	| [ld   a,(b_9AC0 + 0x01)]
	                               	| [and  a]
	jeq	l_01F6                             	| [jr   z,l_01F6]
	jbsr	c_044A                            	| [call c_044A]

* bonus-bee sound
l_01F6:
	move.b	b_9AA0+0x12,d0                  	| [ld   a,(b_9AA0 + 0x12)] sound-fx count/enable registers, bonus-bee sound
	                               	| [and  a]
	jeq	l_0204                             	| [jr   z,l_0204]
	lea	b_9A70+0x04(pc),a0                 	| [ld   hl,#b_9A70 + 0x04] $12
	move.b	#0x12,(a0)                      	| [ld   (hl),#0x12]
	jbsr	c_04A2                            	| [call c_04A2]


* sound mgr capture beam
l_0204:
* if ( !_fx[$05] )  {  }  else { goto l_0236 }
	move.b	b_9AA0+0x05,d0                  	| [ld   a,(b_9AA0 + 0x05)] sound-fx count/enable registers, capture beam active uno
	                               	| [and  a]
	jeq	l_0236                             	| [jr   z,l_0236]

	lea	b_9A70+0x04(pc),a0                 	| [ld   hl,#b_9A70 + 0x04] $05 ... capture beam
	move.b	#5,(a0)                         	| [ld   (hl),#5]
	jbsr	c_0375                            	| [call c_0375]

*  if ( ++b_9A70[0x0E] >= 6 )  { }  else  { goto l_022E }
	lea	b_9A70+0x0E(pc),a0                 	| [ld   hl,#b_9A70 + 0x0E]
	addq.b	#1,(a0)                         	| [inc  (hl)]
	move.b	b_9A70+0x0E,d0                  	| [ld   a,(b_9A70 + 0x0E)]
	cmp.b	#6,d0                            	| [cp   #6]
	jcs	l_022E                             	| [jr   c,l_022E]

	clr.b	(a0)                             	| [ld   (hl),#0]

*  if ( b_9A70[0x0C] < 4 )  b_9A70[0x0C] = 0x0C  else  b_9A70[0x0C]--
	move.b	b_9A70+0x0C,d0                  	| [ld   a,(b_9A70 + 0x0C)]
	cmp.b	#4,d0                            	| [cp   #4]
	jcs	l_0229                             	| [jr   c,l_0229]
	subq.b	#1,d0                           	| [dec  a]
	jra	l_022B                             	| [jr   l_022B]
l_0229:
	move.b	#0x0C,d0                        	| [ld   a,#0x0C]
l_022B:
	move.b	d0,b_9A70+0x0C                  	| [ld   (b_9A70 + 0x0C),a]

l_022E:
	move.b	b_9A70+0x0C,d0                  	| [ld   a,(b_9A70 + 0x0C)] ->voice 2 volume
	move.b	d0,b_9A60+0x0F                  	| [ld   (b_9A60 + 0x0F),a] voice 2 volume
	jra	j_0239                             	| [jr   j_0239]

l_0236:
	move.b	d0,b_9AC0+0x05                  	| [ld   (b_9AC0 + 0x05),a] 0 ... capture beam count/enable uno == 0, so clear the active flag

j_0239:
* if ( sound_active )  { }  else  _fx[$06] = 0
	move.b	b_9AA0+0x06,d0                  	| [ld   a,(b_9AA0 + 0x06)] sound-fx count/enable registers, capture beam active deux
	                               	| [and  a]
	jeq	l_0263                             	| [jr   z,l_0263]

	lea	b_9A70+0x04(pc),a0                 	| [ld   hl,#b_9A70 + 0x04] $06
	move.b	#6,(a0)                         	| [ld   (hl),#6]
	jbsr	c_0375                            	| [call c_0375]

* if ( ++b_9A70[0x0F] == $1C )  b_9A70[0x0F] = 0, b_9A70[0x0D]++
	lea	b_9A70+0x0F(pc),a0                 	| [ld   hl,#b_9A70 + 0x0F]
	addq.b	#1,(a0)                         	| [inc  (hl)]
	move.b	(a0),d0                         	| [ld   a,(hl)]
	cmp.b	#0x1C,d0                         	| [cp   #0x1C]
	jne	l_025B                             	| [jr   nz,l_025B]

	clr.b	d0                               	| [xor  a]
	move.b	d0,b_9A70+0x0F                  	| [ld   (b_9A70 + 0x0F),a] 0
	move.b	b_9A70+0x0D,d0                  	| [ld   a,(b_9A70 + 0x0D)]
	addq.b	#1,d0                           	| [inc  a]
	move.b	d0,b_9A70+0x0D                  	| [ld   (b_9A70 + 0x0D),a] ++

l_025B:
	move.b	b_9A70+0x0D,d0                  	| [ld   a,(b_9A70 + 0x0D)]
	move.b	d0,b_9A70+0x00+2                	| [ld   (b_9A70 + 0x00 + 2),a] 0 ... voice 2 wave select
	jra	l_0266                             	| [jr   l_0266]

l_0263:
	move.b	d0,b_9AC0+0x06                  	| [ld   (b_9AC0 + 0x06),a] 0 ... deactivate capture beam part deux


* $9 .. $7
l_0266:
	move.b	b_9AA0+0x09,d0                  	| [ld   a,(b_9AA0 + 0x09)] sound-fx count/enable registers
	                               	| [and  a]
	jeq	l_0276                             	| [jr   z,l_0276]
	lea	b_9A70+0x04(pc),a0                 	| [ld   hl,#b_9A70 + 0x04] $09
	move.b	#9,(a0)                         	| [ld   (hl),#9]
	jbsr	c_0375                            	| [call c_0375]
	jra	l_0279                             	| [jr   l_0279]
l_0276:
	move.b	d0,b_9AC0+0x09                  	| [ld   (b_9AC0 + 0x09),a] 0 ... clear the active flag

* shot your ship!
l_0279:
	move.b	b_9AA0+0x07,d0                  	| [ld   a,(b_9AA0 + 0x07)] sound-fx count/enable registers, shot your ship!
	                               	| [and  a]
	jeq	l_0287                             	| [jr   z,l_0287]
	lea	b_9A70+0x04(pc),a0                 	| [ld   hl,#b_9A70 + 0x04] $07
	move.b	#7,(a0)                         	| [ld   (hl),#7]
	jbsr	c_04A2                            	| [call c_04A2]

* "rescued ship" theme
l_0287:
	move.b	b_9AA0+0x11,d0                  	| [ld   a,(b_9AA0 + 0x11)] sound-fx count/enable registers, "rescued ship" theme
	                               	| [and  a]
	jeq	l_0297                             	| [jr   z,l_0297]
	lea	b_9A70+0x04(pc),a0                 	| [ld   hl,#b_9A70 + 0x04] $11
	move.b	#0x11,(a0)                      	| [ld   (hl),#0x11]
	jbsr	c_0375                            	| [call c_0375]
	jra	l_029A                             	| [jr   l_029A]
l_0297:
	move.b	d0,b_9AC0+0x11                  	| [ld   (b_9AC0 + 0x11),a] clear the active flag

* challenge stage intro music
l_029A:
	move.b	b_9AA0+0x0D,d0                  	| [ld   a,(b_9AA0 + 0x0D)] sound-fx count/enable registers, start challenge stage music
	                               	| [and  a]
	jeq	l_02A8                             	| [jr   z,l_02A8]
	lea	b_9A70+0x04(pc),a0                 	| [ld   hl,#b_9A70 + 0x04] $0D
	move.b	#0x0D,(a0)                      	| [ld   (hl),#0x0D]
	jbsr	c_04A2                            	| [call c_04A2]

* challenge stage default melody
l_02A8:
	move.b	b_9AA0+0x0E,d0                  	| [ld   a,(b_9AA0 + 0x0E)] sound-fx count/enable registers, challenge stage default melody
	                               	| [and  a]
	jeq	l_02B6                             	| [jr   z,l_02B6] well this seems like a waste of time
	lea	b_9A70+0x04(pc),a0                 	| [ld   hl,#b_9A70 + 0x04] $0E
	move.b	#0x0E,(a0)                      	| [ld   (hl),#0x0E]
	jbsr	c_04A2                            	| [call c_04A2]

* challenge stage default melody
l_02B6:
	move.b	b_9AA0+0x0E,d0                  	| [ld   a,(b_9AA0 + 0x0E)] sound-fx count/enable registers, challenge stage default melody
	                               	| [and  a]
	jeq	l_02C6                             	| [jr   z,l_02C6]
	move.b	#9,d0                           	| [ld   a,#9]
	move.b	d0,b_9A60+0x0A                  	| [ld   (b_9A60 + 0x0A),a] 9 ... voice 1 volume
	move.b	#6,d0                           	| [ld   a,#6]
	move.b	d0,b_9A60+0x0F                  	| [ld   (b_9A60 + 0x0F),a] 6 ... voice 2 volume

* challenge stage perfect melody
l_02C6:
	move.b	b_9AA0+0x14,d0                  	| [ld   a,(b_9AA0 + 0x14)] sound-fx count/enable registers, challenge stage perfect melody
	                               	| [and  a]
	jeq	l_02D4                             	| [jr   z,l_02D4]
	lea	b_9A70+0x04(pc),a0                 	| [ld   hl,#b_9A70 + 0x04] $14
	move.b	#0x14,(a0)                      	| [ld   (hl),#0x14]
	jbsr	c_04A2                            	| [call c_04A2]

* stage tokens "clicks"
l_02D4:
	move.b	b_9AA0+0x15,d0                  	| [ld   a,(b_9AA0 + 0x15)] sound-fx count/enable registers, stage tokens "clicks"
	                               	| [and  a]
	jeq	l_02E2                             	| [jr   z,l_02E2]
	lea	b_9A70+0x04(pc),a0                 	| [ld   hl,#b_9A70 + 0x04] $15
	move.b	#0x15,(a0)                      	| [ld   (hl),#0x15]
	jbsr	c_04A2                            	| [call c_04A2]

* new spare ship added
l_02E2:
	move.b	b_9AA0+0x0A,d0                  	| [ld   a,(b_9AA0 + 0x0A)] sound-fx count/enable registers, new spare ship added
	                               	| [and  a]
	jeq	l_02F0                             	| [jr   z,l_02F0]
	lea	b_9A70+0x04(pc),a0                 	| [ld   hl,#b_9A70 + 0x04] $0A
	move.b	#0x0A,(a0)                      	| [ld   (hl),#0x0A]
	jbsr	c_04A2                            	| [call c_04A2]

* start of game theme
l_02F0:
	move.b	b_9AA0+0x0B,d0                  	| [ld   a,(b_9AA0 + 0x0B)] sound-fx count/enable registers, start of game theme
	                               	| [and  a]
	jeq	l_02FE                             	| [jr   z,l_02FE]
	lea	b_9A70+0x04(pc),a0                 	| [ld   hl,#b_9A70 + 0x04] $0B
	move.b	#0x0B,(a0)                      	| [ld   (hl),#0x0B]
	jbsr	c_04A2                            	| [call c_04A2]

* $10
l_02FE:
	move.b	b_9AA0+0x10,d0                  	| [ld   a,(b_9AA0 + 0x10)] sound-fx count/enable registers, hi-score dialog?
	                               	| [and  a]
	jeq	l_030E                             	| [jr   z,l_030E]
	lea	b_9A70+0x04(pc),a0                 	| [ld   hl,#b_9A70 + 0x04] $10
	move.b	#0x10,(a0)                      	| [ld   (hl),#0x10]
	jbsr	c_0375                            	| [call c_0375]
	jra	l_0311                             	| [jr   l_0311]
l_030E:
	move.b	d0,b_9AC0+0x10                  	| [ld   (b_9AC0 + 0x10),a] clear the active flag

* hi-score dialog?
l_0311:
	move.b	b_9AA0+0x0C,d0                  	| [ld   a,(b_9AA0 + 0x0C)] sound-fx count/enable registers, hi-score dialog?
	                               	| [and  a]
	jeq	l_031F                             	| [jr   z,l_031F]
	lea	b_9A70+0x04(pc),a0                 	| [ld   hl,#b_9A70 + 0x04] $0C
	move.b	#0x0C,(a0)                      	| [ld   (hl),#0x0C]
	jbsr	c_04A2                            	| [call c_04A2]

* hi-score dialog?
l_031F:
	move.b	b_9AA0+0x16,d0                  	| [ld   a,(b_9AA0 + 0x16)] sound-fx count/enable registers, hi-score dialog?
	                               	| [and  a]
	jeq	l_032D                             	| [jr   z,l_032D]
	lea	b_9A70+0x04(pc),a0                 	| [ld   hl,#b_9A70 + 0x04] $16
	move.b	#0x16,(a0)                      	| [ld   (hl),#0x16]
	jbsr	c_04A2                            	| [call c_04A2]

* coin sound
l_032D:
	move.b	b_9AA0+0x08,d0                  	| [ld   a,(b_9AA0 + 0x08)] sound-fx count/enable registers, coin sound
	                               	| [and  a]
	jeq	l_033B                             	| [jr   z,l_033B]
	lea	b_9A70+0x04(pc),a0                 	| [ld   hl,#b_9A70 + 0x04] actv_snd_idx = $08
	move.b	#0x08,(a0)                      	| [ld   (hl),#0x08] actv_snd_idx
	jbsr	c_04A2                            	| [call c_04A2] _fx[$08] will be decremented

l_033B:
	jra	j_0357_set_SFRs                    	| [jr   j_0357_set_SFRs]

l_033D_clear_all:
* memset( snd_cnt_enable, 0, $16 ) .. don't clear [$16], [$17], [$18]
	lea	b_9AA0+0x00(pc),a0                 	| [ld   hl,#b_9AA0 + 0x00] sound-fx count/enable registers ... $16 bytes 0
	clr.b	(a0)                             	| [ld   (hl),#0]
	lea	b_9AA0+0x01(pc),a1                 	| [ld   de,#b_9AA0 + 0x01] sound-fx count/enable registers ... $16 bytes 0
	move.b	#0x00,d1                        	| [ld   bc,#0x0015] 21
	move.b	#0x15,d2                        	| [ld   bc,#0x0015] 21
	jbsr	ldir                              	| [ldir]
     ^^^^ TODO: review special instruction inputs

* memset( snd_active_flag, 0, $17 ) ...  [$16] should be highest one used
	lea	b_9AC0+0x00(pc),a0                 	| [ld   hl,#b_9AC0 + 0x00] $17 bytes 0
	clr.b	(a0)                             	| [ld   (hl),#0]
	lea	b_9AC0+0x01(pc),a1                 	| [ld   de,#b_9AC0 + 0x01]
	move.b	#0x00,d1                        	| [ld   bc,#0x0016] 22
	move.b	#0x16,d2                        	| [ld   bc,#0x0016] 22
	jbsr	ldir                              	| [ldir]
     ^^^^ TODO: review special instruction inputs

j_0357_set_SFRs:
	lea	b_9A60(pc),a0                      	| [ld   hl,#b_9A60] memcpy(&sfr_6810[0], buf, $10)
	lea	_sfr_6810(pc),a1                   	| [ld   de,#_sfr_6810] base pointer to frequency and volume SFRs
	move.b	#0x00,d1                        	| [ld   bc,#0x0010] 16
	move.b	#0x10,d2                        	| [ld   bc,#0x0010] 16
	jbsr	ldir                              	| [ldir]
     ^^^^ TODO: review special instruction inputs

* set the sound voice waveforms
	move.b	b_9A70+0x00+0,d0                	| [ld   a,(b_9A70 + 0x00 + 0)]
	move.b	d0,_sfr_6805                    	| [ld   (_sfr_6805),a] voice 0 wave
	move.b	b_9A70+0x00+1,d0                	| [ld   a,(b_9A70 + 0x00 + 1)]
	move.b	d0,_sfr_680A                    	| [ld   (_sfr_680A),a] voice 1 wave
	move.b	b_9A70+0x00+2,d0                	| [ld   a,(b_9A70 + 0x00 + 2)]
	move.b	d0,_sfr_680F                    	| [ld   (_sfr_680F),a] voice 2 wave
	rts                                    	| [ret]

*=============================================================================
* c_0375()
*  Description:
* IN:
*  ...
* OUT:
*  ...
*-----------------------------------------------------------------------------
c_0375:
	lea	b_9A70+0x04(pc),a0                 	| [ld   hl,#b_9A70 + 0x04] d_0703[ actv_snd_idx * 3 ]
	move.b	(a0),d0                         	| [ld   a,(hl)]
	add.b	d0,d0                            	| [add  a,a]
	add.b	(a0),d0                          	| [add  a,(hl)]
	lea	d_0703_snd_parms(pc),a0            	| [ld   hl,#d_0703_snd_parms]
	jbsr	rst_10                            	| [rst  0x10] HL += A
	lea	b_9A70+0x05(pc),a1                 	| [ld   de,#b_9A70 + 0x05] memcpy( snd_parms_set, d_0703[ actv_snd_idx * 3 ], 3 )
	move.b	#0x00,d1                        	| [ld   bc,#0x0003] 3
	move.b	#0x03,d2                        	| [ld   bc,#0x0003] 3
	jbsr	ldir                              	| [ldir]
     ^^^^ TODO: review special instruction inputs

* if challenge stage default melody
	move.b	b_9A70+0x04,d0                  	| [ld   a,(b_9A70 + 0x04)] if ( actv_snd_idx == $0E ) ...
	cmp.b	#0x0E,d0                         	| [cp   #0x0E]
	jne	l_03A6                             	| [jr   nz,l_03A6]
* if 0 == data_index
	move.b	b_9A30+0x1C,d0                  	| [ld   a,(b_9A30 + 0x1C)]
	                               	| [and  a]
	jeq	l_03A1                             	| [jr   z,l_03A1]
* else if 1 == data_index
	subq.b	#1,d0                           	| [dec  a]
	jeq	l_039D                             	| [jr   z,l_039D]
* or if
	move.b	b_9A30+0x1D,d0                  	| [ld   a,(b_9A30 + 0x1D)]
	                               	| [and  a]
	jne	l_03A6                             	| [jr   nz,l_03A6]
l_039D:
	move.b	#2,d0                           	| [ld   a,#2]
	jra	l_03A3                             	| [jr   l_03A3]
l_03A1:
	move.b	#1,d0                           	| [ld   a,#1]
l_03A3:
	move.b	d0,b_9A70+0x05+1                	| [ld   (b_9A70 + 0x05 + 1),a] 1 or 2 .. count: number of data pairs

* now we are checking active flags for some reason,,,,
l_03A6:
	lea	b_9AC0(pc),a0                      	| [ld   hl,#b_9AC0] if ( 0 == b_9AC0[ actv_snd_idx ] )  b_9AC0[ actv_snd_idx ] = 1
	move.b	b_9A70+0x04,d0                  	| [ld   a,(b_9A70 + 0x04)] b_9AC0[ actv_snd_idx ]
	add.b	d6,d0                            	| [add  a,l]
	move.b	d0,d6                           	| [ld   l,a]
	move.b	(a0),d0                         	| [ld   a,(hl)]
	                               	| [and  a]
	jne	j_03CD                             	| [jr   nz,j_03CD]

	addq.b	#1,(a0)                         	| [inc  (hl)]

	lea	b_9A70+0x05+1(pc),a0               	| [ld   hl,#b_9A70 + 0x05 + 1] snd_parms_set.count
	move.b	(a0),d1                         	| [ld   b,(hl)]

* memset( &snd_fx_dat_idx[ snd_parms_set.idx ], 0, snd_parms_set.count )
	move.b	d1,d2                           	| [ld   c,b]
	lea	b_9A30(pc),a0                      	| [ld   hl,#b_9A30] snd_fx_dat_idx[ snd_parms_set.idx ]
	move.b	b_9A70+0x05+0,d0                	| [ld   a,(b_9A70 + 0x05 + 0)] snd_parms_set.idx
	add.b	d6,d0                            	| [add  a,l]
	move.b	d0,d6                           	| [ld   l,a]
	clr.b	d0                               	| [xor  a]
	jbsr	rst_18                            	| [rst  0x18] memset((HL), A=fill, B=ct)

* memset( &sound_fx_status[ snd_parms_set.idx ], 0, snd_parms_set.count )
	move.b	d2,d1                           	| [ld   b,c]
	lea	b_9A00(pc),a0                      	| [ld   hl,#b_9A00] sound_fx_status[ snd_parms_set.idx ]
	move.b	b_9A70+0x05+0,d0                	| [ld   a,(b_9A70 + 0x05 + 0)] snd_parms_set.idx
	add.b	d6,d0                            	| [add  a,l]
	move.b	d0,d6                           	| [ld   l,a]
	clr.b	d0                               	| [xor  a]
	jbsr	rst_18                            	| [rst  0x18] memset((HL), A=fill, B=ct)

j_03CD:
l_03CD_while:
	jbsr	c_0550                            	| [call c_0550]

* while ( snd_parms_set.count > 0 ) ...
	lea	b_9A70+0x05+1(pc),a0               	| [ld   hl,#b_9A70 + 0x05 + 1] if ( snd_parms_set.count-- > 0 ) ...
	subq.b	#1,(a0)                         	| [dec  (hl)]
	jeq	l_03E0                             	| [jr   z,l_03E0]

	lea	b_9A70+0x05+0(pc),a0               	| [ld   hl,#b_9A70 + 0x05 + 0] snd_parms_set.idx++
	addq.b	#1,(a0)                         	| [inc  (hl)]
	lea	b_9A70+0x05+2(pc),a0               	| [ld   hl,#b_9A70 + 0x05 + 2] voice_select++
	addq.b	#1,(a0)                         	| [inc  (hl)]
	jra	l_03CD_while                       	| [jr l_03CD_while]

l_03E0:
	move.b	b_9A70+0x08,d0                  	| [ld   a,(b_9A70 + 0x08)] ret z
	                               	| [and  a]
	bne.b	0f                               	| [...]
	rts                                    	| [ret  z] [...]
0:

	clr.b	d0                               	| [xor  a]
	move.b	d0,b_9A70+0x08                  	| [ld   (b_9A70 + 0x08),a] 0

* clear the sound_active flag for this one
	lea	b_9AC0(pc),a0                      	| [ld   hl,#b_9AC0] b_9AC0[ actv_snd_idx ] = 0
	move.b	b_9A70+0x04,d0                  	| [ld   a,(b_9A70 + 0x04)] b_9AC0[ actv_snd_idx ]
	add.b	d6,d0                            	| [add  a,l]
	move.b	d0,d6                           	| [ld   l,a]
	clr.b	(a0)                             	| [ld   (hl),#0]

* exactly the same as c_04A2 until here
	rts                                    	| [ret]
* end 'call _0375'

*=============================================================================
* c_03F4()
*  Description:
*   Initialize a sound effect. After this one is called once, then c_044A is
*   called to update the sound on subsequent frame updates.
* IN:
*   b_9A70[4]: index of sound to play
* OUT:
*  ...
*-----------------------------------------------------------------------------
c_03F4:
* on this one we increment the Active flag
	lea	b_9AC0(pc),a0                      	| [ld   hl,#b_9AC0] b_9AC0[ actv_snd_idx ]++
	move.b	b_9A70+0x04,d0                  	| [ld   a,(b_9A70 + 0x04)] b_9AC0[ actv_snd_idx ]
	add.b	d6,d0                            	| [add  a,l]
	move.b	d0,d6                           	| [ld   l,a]
	addq.b	#1,(a0)                         	| [inc  (hl)]

* same as c_04A2 here
	lea	b_9A70+0x04(pc),a0                 	| [ld   hl,#b_9A70 + 0x04] d_0703[ actv_snd_idx * 3 ]
	move.b	(a0),d0                         	| [ld   a,(hl)]
	add.b	d0,d0                            	| [add  a,a]
	add.b	(a0),d0                          	| [add  a,(hl)]
	lea	d_0703_snd_parms(pc),a0            	| [ld   hl,#d_0703_snd_parms]
	jbsr	rst_10                            	| [rst  0x10] HL += A
	lea	b_9A70+0x05(pc),a1                 	| [ld   de,#b_9A70 + 0x05] memcpy( snd_parms_set, d_0703[ actv_snd_idx * 3 ], 3 )
	move.b	#0x00,d1                        	| [ld   bc,#0x0003] 3
	move.b	#0x03,d2                        	| [ld   bc,#0x0003] 3
	jbsr	ldir                              	| [ldir]
     ^^^^ TODO: review special instruction inputs

* if challenge stage default melody
	move.b	b_9A70+0x04,d0                  	| [ld   a,(b_9A70 + 0x04)] if (actv_snd_idx == $0E) ...
	cmp.b	#0x0E,d0                         	| [cp   #0x0E]
	jne	l_042E                             	| [jr   nz,l_042E]
* if 0 == data_index
	move.b	b_9A30+0x1C,d0                  	| [ld   a,(b_9A30 + 0x1C)] data_index, SOUND 09
	                               	| [and  a]
	jeq	l_0429                             	| [jr   z,l_0429]
* else if 1 == data_index
	subq.b	#1,d0                           	| [dec  a]
	jeq	l_0425                             	| [jr   z,l_0425]
* or if
	move.b	b_9A30+0x1D,d0                  	| [ld   a,(b_9A30 + 0x1D)] SOUND 09
	                               	| [and  a]
	jne	l_042E                             	| [jr   nz,l_042E]
l_0425:
	move.b	#2,d0                           	| [ld   a,#2]
	jra	l_042B                             	| [jr   l_042B]

l_0429:
	move.b	#0x01,d0                        	| [ld   a,#0x01]
l_042B:
	move.b	d0,b_9A70+0x05+1                	| [ld   (b_9A70 + 0x05 + 1),a] snd_parms_set.count = 1

* here we don't check the flags...

l_042E:
	lea	b_9A70+0x05+1(pc),a0               	| [ld   hl,#b_9A70 + 0x05 + 1] snd_parms_set.count
	move.b	(a0),d1                         	| [ld   b,(hl)]

* memset( &snd_fx_dat_idx[ snd_parms_set.idx ], 0, snd_parms_set.count )
	move.b	d1,d2                           	| [ld   c,b]
	lea	b_9A30(pc),a0                      	| [ld   hl,#b_9A30] snd_fx_dat_idx[ snd_parms_set.idx ]
	move.b	b_9A70+0x05+0,d0                	| [ld   a,(b_9A70 + 0x05 + 0)] snd_parms_set.idx
	add.b	d6,d0                            	| [add  a,l]
	move.b	d0,d6                           	| [ld   l,a]
	clr.b	d0                               	| [xor  a]
	jbsr	rst_18                            	| [rst  0x18] memset((HL), A=fill, B=ct)

* memset( &sound_fx_status[ snd_parms_set.idx ], 0, snd_parms_set.count )
	move.b	d2,d1                           	| [ld   b,c]
	lea	b_9A00(pc),a0                      	| [ld   hl,#b_9A00] sound_fx_status[ snd_parms_set.idx ]
	move.b	b_9A70+0x05+0,d0                	| [ld   a,(b_9A70 + 0x05 + 0)] snd_parms_set.idx
	add.b	d6,d0                            	| [add  a,l]
	move.b	d0,d6                           	| [ld   l,a]
	clr.b	d0                               	| [xor  a]
	jbsr	rst_18                            	| [rst  0x18] memset((HL), A=fill, B=ct)

* here is where c_0550 is called....
	jra	j_047B                             	| [jr   j_047B]

*=============================================================================
* c_044A()
*  Description:
*   After c_03F4 is called once to initialize the sound, then on subsequent
*   frame updates this one is called.
* IN:
*  ...
* OUT:
*  ...
*-----------------------------------------------------------------------------
c_044A:
	lea	b_9A70+0x04(pc),a0                 	| [ld   hl,#b_9A70 + 0x04] d_0703[ actv_snd_idx * 3 ]
	move.b	(a0),d0                         	| [ld   a,(hl)]
	add.b	d0,d0                            	| [add  a,a]
	add.b	(a0),d0                          	| [add  a,(hl)]
	lea	d_0703_snd_parms(pc),a0            	| [ld   hl,#d_0703_snd_parms]
	jbsr	rst_10                            	| [rst  0x10] HL += A
	lea	b_9A70+0x05(pc),a1                 	| [ld   de,#b_9A70 + 0x05] memcpy( snd_parms_set, d_0703[ actv_snd_idx * 3 ], 3 )
	move.b	#0x00,d1                        	| [ld   bc,#0x0003] 3
	move.b	#0x03,d2                        	| [ld   bc,#0x0003] 3
	jbsr	ldir                              	| [ldir]
     ^^^^ TODO: review special instruction inputs

* if challenge stage default melody
	move.b	b_9A70+0x04,d0                  	| [ld   a,(b_9A70 + 0x04)] if (actv_snd_idx == $0E) ...
	cmp.b	#0x0E,d0                         	| [cp   #0x0E]
	jne	j_047B                             	| [jr   nz,j_047B]
* if 0 == data_index
	move.b	b_9A30+0x1C,d0                  	| [ld   a,(b_9A30 + 0x1C)]
	                               	| [and  a]
	jeq	l_0476                             	| [jr   z,l_0476]
* else if 1 == data_index
	subq.b	#1,d0                           	| [dec  a]
	jeq	l_0472                             	| [jr   z,l_0472]
* or if
	move.b	b_9A30+0x1D,d0                  	| [ld   a,(b_9A30 + 0x1D)]
	                               	| [and  a]
	jne	j_047B                             	| [jr   nz,j_047B]
l_0472:
	move.b	#2,d0                           	| [ld   a,#2]
	jra	l_0478                             	| [jr   l_0478]

l_0476:
	move.b	#1,d0                           	| [ld   a,#1]
l_0478:
	move.b	d0,b_9A70+0x05+1                	| [ld   (b_9A70 + 0x05 + 1),a] snd_parms_set.count

* doesn't do the other stuff here here....

j_047B:
l_047B:
	jbsr	c_0550                            	| [call c_0550]
	lea	b_9A70+0x05+1(pc),a0               	| [ld   hl,#b_9A70 + 0x05 + 1] if ( snd_parms_set.count-- > 0 ) ...
	subq.b	#1,(a0)                         	| [dec  (hl)]
	jeq	l_048E                             	| [jr   z,l_048E]

	lea	b_9A70+0x05+0(pc),a0               	| [ld   hl,#b_9A70 + 0x05 + 0] snd_parms_set.idx++
	addq.b	#1,(a0)                         	| [inc  (hl)]
	lea	b_9A70+0x05+2(pc),a0               	| [ld   hl,#b_9A70 + 0x05 + 2] voice_select++
	addq.b	#1,(a0)                         	| [inc  (hl)]
	jra	l_047B                             	| [jr   l_047B]

l_048E:
	move.b	b_9A70+0x08,d0                  	| [ld   a,(b_9A70 + 0x08)] ret z
	                               	| [and  a]
	bne.b	0f                               	| [...]
	rts                                    	| [ret  z] [...]
0:

	clr.b	d0                               	| [xor  a]
	move.b	d0,b_9A70+0x08                  	| [ld   (b_9A70 + 0x08),a] 0

* clear the sound_active flag for this one
	lea	b_9AC0(pc),a0                      	| [ld   hl,#b_9AC0] b_9AC0[ actv_snd_idx ] = 0
	move.b	b_9A70+0x04,d0                  	| [ld   a,(b_9A70 + 0x04)] b_9AC0[ actv_snd_idx ]
	add.b	d6,d0                            	| [add  a,l]
	move.b	d0,d6                           	| [ld   l,a]
	clr.b	(a0)                             	| [ld   (hl),#0]

	rts                                    	| [ret]
* 'end 'call _03F4, call _044A?'

*=============================================================================
* c_04A2()
*  Description:
* IN:
*  b_9A70[4] == index of sound
* OUT:
*  ...
*-----------------------------------------------------------------------------
c_04A2:
	lea	b_9A70+0x04(pc),a0                 	| [ld   hl,#b_9A70 + 0x04] d_0703[ actv_snd_idx * 3 ]
	move.b	(a0),d0                         	| [ld   a,(hl)]
	add.b	d0,d0                            	| [add  a,a]
	add.b	(a0),d0                          	| [add  a,(hl)]
	lea	d_0703_snd_parms(pc),a0            	| [ld   hl,#d_0703_snd_parms]
	jbsr	rst_10                            	| [rst  0x10] HL += A
	lea	b_9A70+0x05(pc),a1                 	| [ld   de,#b_9A70 + 0x05] memcpy( snd_parms_set, d_0703[ actv_snd_idx * 3 ], 3 )
	move.b	#0x00,d1                        	| [ld   bc,#0x0003] 3
	move.b	#0x03,d2                        	| [ld   bc,#0x0003] 3
	jbsr	ldir                              	| [ldir]
     ^^^^ TODO: review special instruction inputs

* if challenge stage default melody
	move.b	b_9A70+0x04,d0                  	| [ld   a,(b_9A70 + 0x04)] if (actv_snd_idx == $0E) ...
	cmp.b	#0x0E,d0                         	| [cp   #0x0E]
	jne	l_04D3                             	| [jr   nz,l_04D3]
* if 0 == data_index
	move.b	b_9A30+0x1C,d0                  	| [ld   a,(b_9A30 + 0x1C)] data_index, SOUND 09
	                               	| [and  a]
	jeq	l_04CE                             	| [jr   z,l_04CE]
* else if 1 == data_index
	subq.b	#1,d0                           	| [dec  a]
	jeq	l_04CA                             	| [jr   z,l_04CA]
* or if
	move.b	b_9A30+0x1D,d0                  	| [ld   a,(b_9A30 + 0x1D)] SOUND 09
	                               	| [and  a]
	jne	l_04D3                             	| [jr   nz,l_04D3]
l_04CA:
	move.b	#2,d0                           	| [ld   a,#2]
	jra	l_04D0                             	| [jr   l_04D0]

l_04CE:
	move.b	#1,d0                           	| [ld   a,#1]
l_04D0:
	move.b	d0,b_9A70+0x05+1                	| [ld   (b_9A70 + 0x05 + 1),a] snd_parms_set.count

* now we are checking active flags for some reason,,,,
l_04D3:
	lea	b_9AC0(pc),a0                      	| [ld   hl,#b_9AC0] b_9AC0[ actv_snd_idx ]
	move.b	b_9A70+0x04,d0                  	| [ld   a,(b_9A70 + 0x04)] b_9AC0[ actv_snd_idx ]
	add.b	d6,d0                            	| [add  a,l]
	move.b	d0,d6                           	| [ld   l,a]
	move.b	(a0),d0                         	| [ld   a,(hl)]
	                               	| [and  a]
	jne	j_04FA                             	| [jr   nz,j_04FA]

	addq.b	#1,(a0)                         	| [inc  (hl)]

	lea	b_9A70+0x05+1(pc),a0               	| [ld   hl,#b_9A70 + 0x05 + 1] snd_parms_set.count
	move.b	(a0),d1                         	| [ld   b,(hl)]

* memset( &snd_fx_dat_idx[ snd_parms_set.idx ], 0, snd_parms_set.count )
	move.b	d1,d2                           	| [ld   c,b]
	lea	b_9A30(pc),a0                      	| [ld   hl,#b_9A30] snd_fx_dat_idx[ snd_parms_set.idx ]
	move.b	b_9A70+0x05+0,d0                	| [ld   a,(b_9A70 + 0x05 + 0)] snd_parms_set.idx
	add.b	d6,d0                            	| [add  a,l]
	move.b	d0,d6                           	| [ld   l,a]
	clr.b	d0                               	| [xor  a]
	jbsr	rst_18                            	| [rst  0x18] memset((HL), A=fill, B=ct)

* memset( &sound_fx_status[ snd_parms_set.idx ], 0, snd_parms_set.count )
	move.b	d2,d1                           	| [ld   b,c]
	lea	b_9A00(pc),a0                      	| [ld   hl,#b_9A00] sound_fx_status[ snd_parms_set.idx ]
	move.b	b_9A70+0x05+0,d0                	| [ld   a,(b_9A70 + 0x05 + 0)] snd_parms_set.idx
	add.b	d6,d0                            	| [add  a,l]
	move.b	d0,d6                           	| [ld   l,a]
	clr.b	d0                               	| [xor  a]
	jbsr	rst_18                            	| [rst  0x18] memset((HL), A=fill, B=ct)

j_04FA:
l_04FA_while:
	jbsr	c_0550                            	| [call c_0550]

* while ( snd_parms_set.count > 0 ) ...
	lea	b_9A70+0x05+1(pc),a0               	| [ld   hl,#b_9A70 + 0x05 + 1] snd_parms_set.count--
	subq.b	#1,(a0)                         	| [dec  (hl)]
	jeq	l_050D                             	| [jr   z,l_050D]

	lea	b_9A70+0x05+0(pc),a0               	| [ld   hl,#b_9A70 + 0x05 + 0] snd_parms_set.idx++
	addq.b	#1,(a0)                         	| [inc  (hl)]
	lea	b_9A70+0x05+2(pc),a0               	| [ld   hl,#b_9A70 + 0x05 + 2] snd_parms_set.voice_select++
	addq.b	#1,(a0)                         	| [inc  (hl)]
	jra	l_04FA_while                       	| [jr   l_04FA_while]

l_050D:
	move.b	b_9A70+0x08,d0                  	| [ld   a,(b_9A70 + 0x08)] ret z
	                               	| [and  a]
	bne.b	0f                               	| [...]
	rts                                    	| [ret  z] [...]
0:

	clr.b	d0                               	| [xor  a]
	move.b	d0,b_9A70+0x08                  	| [ld   (b_9A70 + 0x08),a] 0

* clear the sound_active flag for this one
	lea	b_9AC0(pc),a0                      	| [ld   hl,#b_9AC0] b_9AC0[ actv_snd_idx ] = 0
	move.b	b_9A70+0x04,d0                  	| [ld   a,(b_9A70 + 0x04)] _fx[actv_snd_idx ]
	add.b	d6,d0                            	| [add  a,l]
	move.b	d0,d6                           	| [ld   l,a]
	clr.b	(a0)                             	| [ld   (hl),#0]

* exactly the same as c_0375 until here ...  update the count/enable register for certain sound-effects

	lea	ds_9AA0(pc),a0                     	| [ld   hl,#ds_9AA0] _fx[ actv_snd_idx ] ... count/enable register
	move.b	b_9A70+0x04,d0                  	| [ld   a,(b_9A70 + 0x04)] _fx[actv_snd_idx ]
	add.b	d6,d0                            	| [add  a,l]
	move.b	d0,d6                           	| [ld   l,a]

* switch( actv_snd_idx )
* case $08:
	move.b	b_9A70+0x04,d0                  	| [ld   a,(b_9A70 + 0x04)] if (actv_snd_idx == $08) ... count/enable register, coin sound
	cmp.b	#8,d0                            	| [cp   #8]
	jeq	l_053A_idx_8                       	| [jr   z,l_053A_idx_8]
* case $0C:
	cmp.b	#0x0C,d0                         	| [cp   #0x0C] ... && if ( actv_snd_idx != $0C )
	jeq	l_053C_idx_C                       	| [jr   z,l_053C_idx_C]
* case $14:
	cmp.b	#0x14,d0                         	| [cp   #0x14] ... && if ( actv_snd_idx != $14 )  { b_9AA0[ actv_snd_idx ] = 0 ; return }
	jeq	l_0548_idx_14                      	| [jr   z,l_0548_idx_14]
* default:
	clr.b	(a0)                             	| [ld   (hl),#0]
	rts                                    	| [ret]

l_053A_idx_8:
	subq.b	#1,(a0)                         	| [dec  (hl)] _fx[idx]--
	rts                                    	| [ret]

l_053C_idx_C:
* _fx[$0C] used as timer ... enable snd[$16] when 0 is reached
* caller would not have called this with _9AA0[$0C] == 0 ?
	subq.b	#1,(a0)                         	| [dec  (hl)]
	jeq	l_0542_enable_16                   	| [jr   z,l_0542_enable_16]
	btst.b	#0,(a0)                         	| [bit  0,(hl)] not sure significance of checking <:0>
	bne.b	0f                               	| [...]
	rts                                    	| [ret  z] [...]
0:
l_0542_enable_16:
	move.b	#0x01,d0                        	| [ld   a,#0x01]
	move.b	d0,b_9AA0+0x16                  	| [ld   (b_9AA0 + 0x16),a] 1 ... sound-fx count/enable registers, hi-score dialog?
	rts                                    	| [ret]

l_0548_idx_14:
	clr.b	(a0)                             	| [ld   (hl),#0] _fx[ actv_snd_idx ] ... count/enable register
	lea	b_9AA0+0x13(pc),a0                 	| [ld   hl,#b_9AA0 + 0x13] 1 ... sound-fx count/enable registers, bug dive attack sound
	move.b	#1,(a0)                         	| [ld   (hl),#1]
	rts                                    	| [ret]
* end 'call _04A2'

*=============================================================================
* c_0550()
*  Description:
* IN:
*  ...
* OUT:
*  ...
*-----------------------------------------------------------------------------
c_0550:
	lea	b_9A00(pc),a0                      	| [ld   hl,#b_9A00] sound_fx_status[ snd_parms_set.idx ]++
	move.b	b_9A70+0x05+0,d0                	| [ld   a,(b_9A70 + 0x05 + 0)] snd_parms_set.idx
	add.b	d6,d0                            	| [add  a,l]
	move.b	d0,d6                           	| [ld   l,a]
	addq.b	#1,(a0)                         	| [inc  (hl)]

* get a pointer to the sound effect data structure from the table
	move.b	b_9A70+0x05+0,d0                	| [ld   a,(b_9A70 + 0x05 + 0)] p_snd_fx[ 2 * snd_parms_set.idx ]
	lea	d_0748_p_snd_fx(pc),a0             	| [ld   hl,#d_0748_p_snd_fx]
	jbsr	rst_08                            	| [rst  0x08] HL += 2A
	move.b	(a0),d4                         	| [ld   e,(hl)]
	addq.w	#1,a0                           	| [inc  hl]
	move.b	(a0),d3                         	| [ld   d,(hl)]
	exg	a1,a0                              	| [ex   de,hl]
* copy first 3 bytes from the sound effect data structure (header info)
	lea	b_9A80+0x08(pc),a1                 	| [ld   de,#b_9A80 + 0x08] memcpy( sound_effect_hdr[0], p_sndfx_data[ idx ], 3 )
	move.b	#0x00,d1                        	| [ld   bc,#0x0003] 3
	move.b	#0x03,d2                        	| [ld   bc,#0x0003] 3
	jbsr	ldir                              	| [ldir]
     ^^^^ TODO: review special instruction inputs

* 9A30[snd_parms_set.idx] holds the data offset i.e. snd_fx_data[ 3 + n ]
	exg	a1,a0                              	| [ex   de,hl] DE = &snd_fx_data[ 3 ]

	lea	b_9A30(pc),a0                      	| [ld   hl,#b_9A30] snd_fx_dat_idx[ snd_parms_set.idx ]
	move.b	b_9A70+0x05+0,d0                	| [ld   a,(b_9A70 + 0x05 + 0)] snd_parms_set.idx
	add.b	d6,d0                            	| [add  a,l]
	move.b	d0,d6                           	| [ld   l,a]
	move.b	(a0),d0                         	| [ld   a,(hl)]
	exg	a1,a0                              	| [ex   de,hl] HL = &snd_fx_data[ 3 ]
	jbsr	rst_10                            	| [rst  0x10] HL += A
	move.b	a0,b_9A70+0x0A                  	| [ld   (b_9A70 + 0x0A),hl] save the pointer ... &snd_fx_data[ 3 + n ]

* if ( $FF == *p_snd_fx_data )  ... close voice && exit
	move.b	(a0),d0                         	| [ld   a,(hl)]
	addq.b	#1,d0                           	| [inc  a]
	jeq	j_068B_close_voice_and_exit        	| [jp   z,j_068B_close_voice_and_exit]

* tmp_ptr = *( b_9A70[ $0A ] )
* d_06A9_ndat[  *( tmp_ptr ) & 0x0F  * 2 ]  ... lo-nibble of sound-effect data is index into note-data
	lea	d_06A9_ndat(pc),a1                 	| [ld   de,#d_06A9_ndat]
	move.w	b_9A70+0x0A(pc),a0              	| [ld   hl,(b_9A70 + 0x0A)] reload the current pointer to sound-effect data
                  ^^^^^^ TODO: review move.w into address register
	move.b	(a0),d0                         	| [ld   a,(hl)]
	and.b	#0x0F,d0                         	| [and  #0x0F]
	exg	a1,a0                              	| [ex   de,hl]
	jbsr	rst_08                            	| [rst  0x08] HL += 2A ... word pointer into note-data
	move.b	(a0),d2                         	| [ld   c,(hl)]
	addq.w	#1,a0                           	| [inc  hl]
	move.b	(a0),d1                         	| [ld   b,(hl)]

* use the hi-nibble of sound-effect data ....
	exg	a1,a0                              	| [ex   de,hl]
	move.b	(a0),d0                         	| [ld   a,(hl)]
	ror.b	#4,d0                            	| [rrca] * 4
	and.b	#0x0F,d0                         	| [and  #0x0F]

* ... raised to power-of-two as divisor if non-zero:
* while ( 0 != A ) ...
	jeq	l_059F                             	| [jr   z,l_059F]
l_0598:
	lsr.b	#1,d1                            	| [srl  b]
	roxr.b	#1,d2                           	| [rr   c]
	subq.b	#1,d0                           	| [dec  a]
	jne	l_0598                             	| [jr   nz,l_0598]

l_059F:
* switch( voice_select )
	move.b	b_9A70+0x05+2,d0                	| [ld   a,(b_9A70 + 0x05 + 2)] snd_parms_set.voice_select
	                               	| [and  a]
	jeq	l_05B2                             	| [jr   z,l_05B2]
	subq.b	#1,d0                           	| [dec  a]
	jeq	l_05AD                             	| [jr   z,l_05AD]

	lea	b_9A60+0x0B(pc),a0                 	| [ld   hl,#b_9A60 + 0x0B] freq 2
	jra	l_05B5                             	| [jr   l_05B5]
l_05AD:
	lea	b_9A60+0x06(pc),a0                 	| [ld   hl,#b_9A60 + 0x06] freq 1
	jra	l_05B5                             	| [jr   l_05B5]
l_05B2:
	lea	b_9A60+0x01(pc),a0                 	| [ld   hl,#b_9A60 + 0x01] freq 0

* shift out 4 nibbles from lsn to msn (only low 4-bits of each register)
l_05B5:
	move.b	d2,(a0)                         	| [ld   (hl),c] lo-byte of dw_06A9_ndat divided by hi-nibble of sound-effect ^ 2
	move.b	(a0),d0                         	| [ld   a,(hl)] why not ld from C?
	ror.b	#4,d0                            	| [rrca] * 4
	addq.w	#1,a0                           	| [inc  hl]
	move.b	d0,(a0)                         	| [ld   (hl),a]
	addq.w	#1,a0                           	| [inc  hl]
	move.b	d1,(a0)                         	| [ld   (hl),b] hi-byte of dw_06A9_ndat divided by hi-nibble of sound-effect ^ 2
	move.b	(a0),d0                         	| [ld   a,(hl)] why not ld from B?
	ror.b	#4,d0                            	| [rrca] * 4
	addq.w	#1,a0                           	| [inc  hl]
	move.b	d0,(a0)                         	| [ld   (hl),a]

* switch( voice_select )
	move.b	b_9A70+0x05+2,d0                	| [ld   a,(b_9A70 + 0x05 + 2)] snd_parms_set.voice_select
	                               	| [and  a]
	jeq	l_05D9                             	| [jr   z,l_05D9]
	subq.b	#1,d0                           	| [dec  a]
	jeq	l_05D4                             	| [jr   z,l_05D4]

	lea	b_9A60+0x0F(pc),a1                 	| [ld   de,#b_9A60 + 0x0F] vol 2
	jra	l_05DC                             	| [jr   l_05DC]
l_05D4:
	lea	b_9A60+0x0A(pc),a1                 	| [ld   de,#b_9A60 + 0x0A] vol 1
	jra	l_05DC                             	| [jr   l_05DC]
l_05D9:
	lea	b_9A60+0x05(pc),a1                 	| [ld   de,#b_9A60 + 0x05] vol 0

l_05DC:
* if ( $0C != *p_snd_fx_data ) ...
	move.w	b_9A70+0x0A(pc),a0              	| [ld   hl,(b_9A70 + 0x0A)] reload the pointer ... p_snd_fx_data = b_9A70[ $0A ]
                  ^^^^^^ TODO: review move.w into address register
	move.b	(a0),d0                         	| [ld   a,(hl)]
	sub.b	#0x0C,d0                         	| [sub  #0x0C]
	jeq	l_0628                             	| [jr   z,l_0628]

	move.b	b_9A80+0x08+0,d0                	| [ld   a,(b_9A80 + 0x08 + 0)] if ( sound_effect_hdr[0] == 0 ) .. else  if ( sound_effect_hdr[0] == 1 )
	                               	| [and  a]
	jeq	l_060D                             	| [jr   z,l_060D]
	subq.b	#1,d0                           	| [dec  a]
	jeq	l_05FD_                            	| [jr   z,l_05FD_]
* 05ED
	lea	b_9A00(pc),a0                      	| [ld   hl,#b_9A00] if ( sound_fx_status[ snd_parms_set.idx ] >= 6 )
	move.b	b_9A70+0x05+0,d0                	| [ld   a,(b_9A70 + 0x05 + 0)] snd_parms_set.idx
	add.b	d6,d0                            	| [add  a,l]
	move.b	d0,d6                           	| [ld   l,a]
	move.b	(a0),d0                         	| [ld   a,(hl)]
	cmp.b	#6,d0                            	| [cp   #6]
	jcc	l_060D                             	| [jr   nc,l_060D]
	not.b	d0                               	| [cpl]
	jra	l_062D                             	| [jr   l_062D]

l_05FD_:
	lea	b_9A00(pc),a0                      	| [ld   hl,#b_9A00] if ( sound_fx_status[ snd_parms_set.idx ] >= 6 )
	move.b	b_9A70+0x05+0,d0                	| [ld   a,(b_9A70 + 0x05 + 0)] snd_parms_set.idx
	add.b	d6,d0                            	| [add  a,l]
	move.b	d0,d6                           	| [ld   l,a]
	move.b	(a0),d0                         	| [ld   a,(hl)]
	cmp.b	#6,d0                            	| [cp   #6]
	jcc	l_060D                             	| [jr   nc,l_060D]
	add.b	d0,d0                            	| [add  a,a] this is the only difference to the previous section!
	jra	l_062D                             	| [jr   l_062D]

l_060D:
	move.b	b_9A80+0x08+1,d0                	| [ld   a,(b_9A80 + 0x08 + 1)] sound_effect_hdr[1]
	                               	| [and  a]
	jeq	l_062B                             	| [jr   z,l_062B]

	move.b	d0,d1                           	| [ld   b,a] b_9A80_8[ 1 ]
	lea	b_9A00(pc),a0                      	| [ld   hl,#b_9A00] sound_fx_status[ snd_parms_set.idx ]
	move.b	b_9A70+0x05+0,d0                	| [ld   a,(b_9A70 + 0x05 + 0)] snd_parms_set.idx
	add.b	d6,d0                            	| [add  a,l]
	move.b	d0,d6                           	| [ld   l,a]
	move.b	(a0),d0                         	| [ld   a,(hl)]
	sub.b	d1,d0                            	| [sub  b]
	jcs	l_062B                             	| [jr   c,l_062B]
	sub.b	#0x0A,d0                         	| [sub  #0x0A]
	jcc	l_0628                             	| [jr   nc,l_0628]
	neg.b	d0                               	| [neg]
	jra	l_062D                             	| [jr   l_062D]

l_0628:
	clr.b	d0                               	| [xor  a]
	jra	l_062D                             	| [jr   l_062D]

l_062B:
	move.b	#0x0A,d0                        	| [ld   a,#0x0A]


l_062D:
	move.b	d0,(a1)                         	| [ld   (de),a] volume ... (9A65 etc)

	lea	b_9A70(pc),a0                      	| [ld   hl,#b_9A70] b_9A70_wave_select[ voice_select ] = b_9A80_sound_effect_parms.wave
	move.b	b_9A70+0x05+2,d0                	| [ld   a,(b_9A70 + 0x05 + 2)] snd_parms_set.voice_select
	add.b	d6,d0                            	| [add  a,l]
	move.b	d0,d6                           	| [ld   l,a]
	move.b	b_9A80+0x08+2,d0                	| [ld   a,(b_9A80 + 0x08 + 2)] sound_effect_hdr.wave
	move.b	d0,(a0)                         	| [ld   (hl),a]

 * get base multiplier
	lea	d_07A6(pc),a0                      	| [ld   hl,#d_07A6] base_multipliers[ actv_snd_idx  ]
	move.b	b_9A70+0x04,d0                  	| [ld   a,(b_9A70 + 0x04)] A = d_07A6[ actv_snd_idx ]
	jbsr	rst_10                            	| [rst  0x10] HL += A
	move.b	(a0),d0                         	| [ld   a,(hl)]

* Multiplier = second byte of sound fx data pair
	move.w	b_9A70+0x0A(pc),a0              	| [ld   hl,(b_9A70 + 0x0A)] b_9A70[ $0A  ] + 1 ... reload pointer and increment
                  ^^^^^^ TODO: review move.w into address register
	addq.w	#1,a0                           	| [inc  hl]
	move.b	(a0),d4                         	| [ld   e,(hl)]
	clr.b	d3                               	| [ld   d,#0]
	move.w	#0x0000,d5                      	| [ld   hl,#0x0000] 0

* Multiply by weighting each bit of the base by the multiplier in E and adding.
	move.b	#8,d1                           	| [ld   b,#8]
l_064E_do_while:
	lsr.b	#1,d0                            	| [srl  a]
	jcc	l_0653                             	| [jr   nc,l_0653]
	add.w	d3,a0                            	| [add  hl,de]
  ^^^^ TODO: review d3 computation above
l_0653:
	asl.b	#1,d4                            	| [sla  e]
	roxl.b	#1,d3                           	| [rl   d]
	subq.b	#1,d1                           	| [...]
	jne	l_064E_do_while                    	| [djnz l_064E_do_while]

	move.b	d6,d1                           	| [ld   b,l]

* return if count is elapsed
	lea	b_9A00(pc),a0                      	| [ld   hl,#b_9A00] sound_fx_status[ snd_parms_set.idx ]
	move.b	b_9A70+0x05+0,d0                	| [ld   a,(b_9A70 + 0x05 + 0)] snd_parms_set.idx
	add.b	d6,d0                            	| [add  a,l]
	move.b	d0,d6                           	| [ld   l,a]
	move.b	d1,d0                           	| [ld   a,b]
	cmp.b	(a0),d0                          	| [cp   (hl)]
	beq.b	0f                               	| [...]
	rts                                    	| [ret  nz] [...]
0:

* update the data pointer and count registers
	lea	b_9A30(pc),a0                      	| [ld   hl,#b_9A30] snd_fx_dat_idx[ snd_parms_set.idx ] += 2
	move.b	b_9A70+0x05+0,d0                	| [ld   a,(b_9A70 + 0x05 + 0)] snd_parms_set.idx
	add.b	d6,d0                            	| [add  a,l]
	move.b	d0,d6                           	| [ld   l,a]
	addq.b	#2,(a0)                         	| [inc  (hl)] * 2

	lea	b_9A00(pc),a0                      	| [ld   hl,#b_9A00] sound_fx_status[ snd_parms_set.idx ] = 0
	move.b	b_9A70+0x05+0,d0                	| [ld   a,(b_9A70 + 0x05 + 0)] snd_parms_set.idx
	add.b	d6,d0                            	| [add  a,l]
	move.b	d0,d6                           	| [ld   l,a]
	clr.b	(a0)                             	| [ld   (hl),#0]

	rts                                    	| [ret]

*=============================================================================
* This is just sort of stuck here. It is called by the handler for NMI
* Clears the special function registers for cpu-sub2.
* It doesn't appear that it is ever called.
*-----------------------------------------------------------------------------
l_067A_reset_sfrs:
	lea	b_9A00+0x00(pc),a0                 	| [ld   hl,#b_9A00 + 0x00] memset(b_9A00, 0, $0100)
	clr.b	(a0)                             	| [ld   (hl),#0]
	lea	b_9A00+0x01(pc),a1                 	| [ld   de,#b_9A00 + 0x01] memset(b_9A00, 0, $0100)
	move.b	#0x00,d1                        	| [ld   bc,#0x00FF] 255
	move.b	#0xff,d2                        	| [ld   bc,#0x00FF] 255
	jbsr	ldir                              	| [ldir]
     ^^^^ TODO: review special instruction inputs
ld   sp,#_stack_cpu_sub2 + 0x20
	rts                                    	| [ret]

*=============================================================================
*
* set the selected voice volume to 0
*
j_068B_close_voice_and_exit:

* switch( b_voice_select )
	move.b	b_9A70+0x05+2,d0                	| [ld   a,(b_9A70 + 0x05 + 2)] snd_parms_set.voice_select
	                               	| [and  a]
	jeq	l_069E                             	| [jr   z,l_069E]
	subq.b	#1,d0                           	| [dec  a]
	jeq	l_0699                             	| [jr   z,l_0699]
* case 2
	lea	b_9A60+0x0F(pc),a0                 	| [ld   hl,#b_9A60 + 0x0F] vol 2
	jra	l_06A1                             	| [jr   l_06A1]
* case 1
l_0699:
	lea	b_9A60+0x0A(pc),a0                 	| [ld   hl,#b_9A60 + 0x0A] vol 1
	jra	l_06A1                             	| [jr   l_06A1]
* case 0
l_069E:
	lea	b_9A60+0x05(pc),a0                 	| [ld   hl,#b_9A60 + 0x05] vol 0
l_06A1:
	clr.b	(a0)                             	| [ld   (hl),#0]

	move.b	#1,d0                           	| [ld   a,#1]
	move.b	d0,b_9A70+0x08                  	| [ld   (b_9A70 + 0x08),a] 1 ... sound is finished

	rts                                    	| [ret]


*=============================================================================
* Note frequency data:
* Base frequency values are indexed by lower-nibble of sound effect data. The
* hi-nibble of sound effect data gives the number of octaves below the base at
* which the final frequency occurs.
d_06A9_ndat:
	.long 0x8150  | $00
	.long 0x8900  | $01
	.long 0x9126  | $02
	.long 0x99C8  | $03
	.long 0xA2EC  | $04
	.long 0xAC9D  | $05
	.long 0xB6E0  | $06
	.long 0xC1C0  | $07
	.long 0xCD45  | $08
	.long 0xD97A  | $09
	.long 0xE669  | $0A
	.long 0xF41C  | $0B
	.long 0x0000  | $0C


d_06C3:
	.long 0x0130, 0x0168, 0x0136, 0x01A8
	.long 0x0168, 0x0200, 0x01AC, 0x0208
*d_06D3:
	.long 0xFE00, 0xFE58, 0xFE08, 0xFE98
	.long 0xFE58, 0xFED0, 0xFE98, 0xFED6

	.long 0x5B00, 0x6C00, 0x5B00, 0x7E00
	.long 0x6C00, 0x9700, 0x8100, 0x9900
	.long 0xD900, 0xB600, 0xD900, 0x9700
	.long 0xB600, 0x7E00, 0x9900, 0x8100

* snd_parms_dat[] : sound parameters
*     [0] ptr_idx ... offset in words to data ptr in p_snd_fx[], and also b_9A00[], b_9A00[$30]
*     [1] ... number of data pointers used by the sound effect data group (number of simultaneous voices) in that time slice
*     [2] voice_select
d_0703_snd_parms:
	.byte 0x00,0x01,0x00
	.byte 0x01,0x01,0x01
	.byte 0x02,0x01,0x01
	.byte 0x03,0x01,0x01
	.byte 0x04,0x01,0x01
	.byte 0x05,0x01,0x00
	.byte 0x06,0x01,0x00
	.byte 0x20,0x03,0x00
	.byte 0x0A,0x03,0x00
	.byte 0x0D,0x03,0x00
	.byte 0x07,0x03,0x00
	.byte 0x13,0x03,0x00
	.byte 0x16,0x03,0x00
	.byte 0x19,0x03,0x00
	.byte 0x1C,0x03,0x00
	.byte 0x1F,0x01,0x02
	.byte 0x2C,0x03,0x00
	.byte 0x10,0x03,0x00
	.byte 0x23,0x01,0x00
	.byte 0x24,0x01,0x00                        | $13
	.byte 0x25,0x03,0x00
	.byte 0x28,0x01,0x00
	.byte 0x29,0x03,0x00

* Pointers into sound effect data tables (d_07BD and beyond) loaded by c_0550
* Pointer selection by b_9A70[5] ... snd_parms_set.idx
* Ordering of these elements is used also to index byte tables at 9A00 and 9A30.
d_0748_p_snd_fx:
	.long d_07BD  | 0
	.long d_0814  | 1
	.long d_07F2  | 2
	.long d_07BE  | 3
	.long d_085E  | 4
	.long d_0878  | 5
	.long d_088C  | 6
	.long d_09D2  | 7
	.long d_09E2  | 8
	.long d_09F2  | 9
	.long d_099C  | 10
	.long d_09AE  | 11
	.long d_09C0  | 12
	.long d_0A02  | 13
	.long d_0A46  | 14
	.long d_0A8A  | 15
	.long d_0AB6  | 16
	.long d_0AFA  | 17
	.long d_0B3E  | 18
	.long d_08A0  | 19
	.long d_08EC  | 20
	.long d_0936  | 21
	.long d_0C5C  | 22
	.long d_0CEA  | 23
	.long d_0D38  | 24
	.long d_0966  | 25
	.long d_0978  | 26
	.long d_098A  | 27
	.long d_08A0  | 28
	.long d_08A0  | 29
	.long d_08A0  | 30
	.long d_0C08  | 31
	.long d_0B6A  | 32
	.long d_0BA0  | 33
	.long d_0BD6  | 34
	.long d_0BF4  | 35
	.long d_0C08  | 36
	.long d_0D6C  | 37
	.long d_0DE0  | 38
	.long d_0E5C  | 39
	.long d_0D5E  | 40
	.long d_0CE0  | 41
	.long d_0D2E  | 42
	.long d_0D54  | 43
	.long d_0E9E  | 44
	.long d_0EDA  | 45
	.long d_0F16  | 46

* indexed by active sound index, multiply by second byte of sound data pair
d_07A6:
	.byte 0x04,0x02,0x02,0x02,0x02,0x04,0x04,0x0A,0x07,0x0C,0x0B,0x04,0x0A,0x0D,0x04,0x01
	.byte 0x04,0x0C,0x02,0x06,0x05,0x02,0x0A


* sound effect data:
*  header-info, stored at 9A80_8[]
*        [0]
*        [1]
*        [2]: wave table index
*  byte_pairs * n
*        [0]: lo-nibble is index into frequency tbl
*             hi-nibble^2 = divisor to note frequency
*        [1]
*        [n] 0xFF

d_07BD:
	.byte 0xFF

d_07BE:
	.byte 0x00,0x00,0x06
	.byte 0x71,0x01,0x72,0x01,0x73,0x01,0x75,0x01
	.byte 0x74,0x01,0x73,0x01,0x72,0x01,0x71,0x01,0x70,0x01,0x8B,0x01,0x8A,0x01,0x0C,0x04
	.byte 0x86,0x01,0x87,0x01,0x88,0x01,0x89,0x01,0x8A,0x01,0x89,0x01,0x88,0x01,0x87,0x01
	.byte 0x86,0x01,0x85,0x01,0x84,0x01,0x83,0x01,0xFF
d_07F2:
	.byte 0x00,0x00,0x04,0x88,0x01,0x8A,0x01,0x70,0x01,0x71,0x01,0x73,0x01,0x75,0x01,0x77
	.byte 0x01,0x78,0x01,0x0C,0x06,0x74,0x01,0x73,0x01,0x72,0x01,0x71,0x01,0x70,0x01,0x8B
	.byte 0x01,0xFF
d_0814:
	.byte 0x00,0x00,0x07,0x89,0x01,0x8A,0x01,0x8B,0x01,0x0C,0x01,0x70,0x01,0x71,0x01,0x72,0x01,0x0C,0x01,0x73,0x01
	.byte 0x74,0x01,0x75,0x01,0x0C,0x03,0x8B,0x01,0x70,0x01,0x71,0x01,0x0C,0x01,0x72,0x01
	.byte 0x73,0x01,0x74,0x01,0x0C,0x01,0x75,0x01,0x76,0x01,0x77,0x01,0x0C,0x03,0x71,0x01
	.byte 0x72,0x01,0x73,0x01,0x0C,0x01,0x74,0x01,0x75,0x01,0x76,0x01,0x0C,0x01,0x77,0x01
	.byte 0x78,0x01,0x79,0x01,0xFF
d_085E: ;,0x03
	.byte 0x00,0x00,0x05,0x71,0x01,0x72,0x01,0x73,0x01,0x0C,0x01
	.byte 0x74,0x01,0x75,0x01,0x76,0x01,0x0C,0x01,0x77,0x01,0x78,0x01,0x79,0x01,0xFF
d_0878:
	.byte 0x00,0x00,0x04,0x61,0x01,0x7A,0x01,0x60,0x01,0x78,0x01,0x7A,0x01,0x76,0x01,0x78
	.byte 0x01,0x75,0x01,0xFF
d_088C:
	.byte 0x00,0x00,0x00,0x76,0x01,0x79,0x01,0x60,0x01,0x63,0x01,0x66,0x01
	.byte 0x63,0x01,0x60,0x01,0x79,0x01,0xFF
d_08A0:
	.byte 0x00,0x00,0x07,0x81,0x08,0x81,0x01,0x86,0x03
	.byte 0x88,0x09,0x8B,0x03,0x8A,0x09,0x86,0x03,0x88,0x09,0x73,0x03,0x71,0x09,0x86,0x03
	.byte 0x88,0x09,0x8B,0x03,0x8A,0x09,0x86,0x03,0x71,0x09,0x75,0x03,0x76,0x09,0x74,0x03
	.byte 0x72,0x09,0x71,0x03,0x8B,0x09,0x89,0x03,0x88,0x09,0x84,0x03,0x74,0x09,0x76,0x03
	.byte 0x74,0x09,0x71,0x03,0x73,0x04,0x8B,0x04,0x88,0x04,0x71,0x04,0x8A,0x04,0x88,0x04
	.byte 0x0C,0x10,0xFF
d_08EC:
	.byte 0x00,0x00,0x06,0x8A,0x09,0x81,0x03,0x88,0x09,0x83,0x03,0x86,0x09
	.byte 0x81,0x03,0x83,0x09,0x85,0x03,0x8A,0x09,0x81,0x03,0x88,0x09,0x83,0x03,0x86,0x09
	.byte 0x81,0x03,0x88,0x09,0x71,0x03,0x72,0x09,0x71,0x03,0x8B,0x09,0x89,0x03,0x88,0x09
	.byte 0x86,0x03,0x84,0x09,0x88,0x03,0x89,0x09,0x8B,0x03,0x89,0x09,0x86,0x03,0x8B,0x04
	.byte 0x88,0x04,0x83,0x04,0x88,0x04,0x85,0x04,0x83,0x04,0x0C,0x10,0xFF
d_0936:
	.byte 0x00,0x00,0x07,0x81,0x0C,0x83,0x09,0x86,0x03,0x85,0x0C,0x81,0x0C,0x86,0x0C,0x88,0x09,0x8B,0x03
	.byte 0x8A,0x0C,0x88,0x0C,0x89,0x0C,0x88,0x09,0x86,0x03,0x84,0x0C,0x89,0x0C,0x74,0x0C
	.byte 0x71,0x09,0x89,0x03,0x88,0x0C,0x71,0x09,0x8A,0x03,0x0C,0x10,0xFF
d_0966:
	.byte 0x02,0x00,0x03
	.byte 0x78,0x02,0x0C,0x01,0x78,0x01,0x79,0x01,0x7B,0x01,0x61,0x03,0x0C,0x03,0xFF
d_0978:
	.byte 0x02,0x00,0x03,0x73,0x02,0x0C,0x01,0x73,0x01,0x74,0x01,0x76,0x01,0x78,0x03,0x0C,0x02
	.byte 0xFF
d_098A:
	.byte 0x02,0x00,0x03,0x70,0x02,0x0C,0x01,0x70,0x01,0x71,0x01,0x73,0x01,0x75,0x03,0x0C,0x02,0xFF
d_099C:
	.byte 0x01,0x00,0x04,0x78,0x01,0x7A,0x01,0x63,0x01,0x78,0x01,0x7A,0x01,0x63,0x01,0x65,0x03,0xFF
d_09AE:
	.byte 0x01,0x00,0x05,0x73,0x01,0x78,0x01,0x7A,0x01,0x73,0x01,0x78,0x01,0x7A,0x01,0x60,0x03,0xFF
d_09C0:
	.byte 0x01,0x00,0x07,0x8A,0x01,0x73,0x01,0x78,0x01,0x8A,0x01,0x73,0x01,0x78,0x01,0x7A,0x03,0xFF
d_09D2: ;,0x05
	.byte 0x01,0x06,0x04,0x7A,0x01,0x78,0x01,0x7A,0x01,0x61,0x01,0x65,0x01,0x68,0x03,0xFF
d_09E2:
	.byte 0x01,0x06,0x04,0x78,0x01,0x75,0x01,0x78,0x01,0x7A,0x01,0x61,0x01,0x65,0x03,0xFF
d_09F2:
	.byte 0x01,0x06,0x04,0x75,0x01,0x71,0x01,0x75,0x01,0x78,0x01,0x7A,0x01,0x60,0x03,0xFF
d_0A02:
	.byte 0x02,0x04,0x03,0x7A,0x01,0x76,0x01,0x78,0x01,0x75,0x01,0x76,0x01,0x73,0x01,0x75,0x01,0x72,0x01,0x73,0x01,0x8A,0x01
	.byte 0x8B,0x01,0x88,0x01,0x86,0x01,0x85,0x01,0x83,0x01,0x82,0x01,0x83,0x01,0x86,0x01
	.byte 0x85,0x01,0x88,0x01,0x86,0x01,0x8A,0x01,0x88,0x01,0x8B,0x01,0x8A,0x01,0x73,0x01
	.byte 0x72,0x01,0x73,0x01,0x75,0x01,0x8A,0x01,0x70,0x01,0x72,0x01,0xFF
d_0A46:
	.byte 0x02,0x04,0x03,0x76,0x01,0x73,0x01,0x75,0x01,0x72,0x01,0x73,0x01,0x70,0x01,0x72,0x01,0x8A,0x01
	.byte 0x8B,0x01,0x86,0x01,0x88,0x01,0x85,0x01,0x83,0x01,0x82,0x01,0x80,0x01,0x9A,0x01
	.byte 0x9A,0x01,0x83,0x01,0x82,0x01,0x85,0x01,0x83,0x01,0x86,0x01,0x85,0x01,0x88,0x01
	.byte 0x86,0x01,0x8A,0x01,0x88,0x01,0x8B,0x01,0x8A,0x01,0x88,0x01,0x86,0x01,0x85,0x01
	.byte 0xFF
d_0A8A:
	.byte 0x02,0x10,0x03,0x93,0x02,0x9A,0x02,0x83,0x03,0x9A,0x01,0x98,0x01,0x96,0x01
	.byte 0x95,0x01,0x93,0x02,0x95,0x03,0x96,0x02,0x98,0x02,0x9A,0x02,0x9B,0x02,0x9A,0x02
	.byte 0x98,0x01,0x96,0x01,0x95,0x01,0x92,0x01,0x93,0x01,0x95,0x01,0xFF
d_0AB6:
	.byte 0x02,0x04,0x03,0x7A,0x01,0x77,0x01,0x78,0x01,0x75,0x01,0x77,0x01,0x73,0x01,0x75,0x01,0x72,0x01
	.byte 0x73,0x01,0x8A,0x01,0x80,0x01,0x88,0x01,0x87,0x01,0x85,0x01,0x83,0x01,0x82,0x01
	.byte 0x83,0x01,0x87,0x01,0x85,0x01,0x88,0x01,0x87,0x01,0x8A,0x01,0x88,0x01,0x80,0x01
	.byte 0x8A,0x01,0x73,0x01,0x72,0x01,0x73,0x01,0x75,0x01,0x8A,0x01,0x70,0x01,0x72,0x01
	.byte 0xFF
d_0AFA:
	.byte 0x02,0x04,0x03,0x77,0x01,0x73,0x01,0x75,0x01,0x72,0x01,0x73,0x01,0x70,0x01
	.byte 0x72,0x01,0x8A,0x01,0x80,0x01,0x87,0x01,0x88,0x01,0x85,0x01,0x83,0x01,0x82,0x01
	.byte 0x80,0x01,0x9A,0x01,0x9A,0x01,0x83,0x01,0x82,0x01,0x85,0x01,0x83,0x01,0x87,0x01
	.byte 0x85,0x01,0x88,0x01,0x87,0x01,0x8A,0x01,0x88,0x01,0x80,0x01,0x8A,0x01,0x88,0x01
	.byte 0x87,0x01,0x85,0x01,0xFF
d_0B3E:
	.byte 0x02,0x10,0x03,0x93,0x02,0x9A,0x02,0x83,0x03,0x9A,0x01
	.byte 0x98,0x01,0x97,0x01,0x95,0x01,0x93,0x02,0x95,0x03,0x97,0x02,0x98,0x02,0x9A,0x02
	.byte 0x90,0x02,0x9A,0x02,0x98,0x01,0x97,0x01,0x95,0x01,0x92,0x01,0x93,0x01,0x95,0x01
	.byte 0xFF
d_0B6A:
	.byte 0x02,0x04,0x03,0x7A,0x01,0x76,0x01,0x78,0x01,0x75,0x01,0x76,0x01,0x73,0x01
	.byte 0x75,0x01,0x72,0x01,0x73,0x01,0x8A,0x01,0x8A,0x01,0x88,0x01,0x86,0x01,0x85,0x01
	.byte 0x83,0x01,0x82,0x01,0x83,0x01,0x85,0x01,0x86,0x01,0x88,0x01,0x86,0x01,0x8A,0x01
	.byte 0x70,0x01,0x72,0x01,0x73,0x04,0xFF
d_0BA0:
	.byte 0x02,0x04,0x03,0x76,0x01,0x73,0x01,0x75,0x01
	.byte 0x72,0x01,0x73,0x01,0x70,0x01,0x72,0x01,0x8A,0x01,0x8A,0x01,0x86,0x01,0x86,0x01
	.byte 0x85,0x01,0x83,0x01,0x82,0x01,0x80,0x01,0x9A,0x01,0x9A,0x01,0x8B,0x01,0x80,0x01
	.byte 0x82,0x01,0x83,0x01,0x85,0x01,0x86,0x01,0x88,0x01,0x8A,0x04,0xFF
d_0BD6:
	.byte 0x02,0x10,0x03,0x73,0x02,0x75,0x02,0x76,0x02,0x75,0x02,0x73,0x02,0x72,0x02,0x70,0x02,0x72,0x02
	.byte 0x73,0x02,0x8B,0x02,0x8A,0x02,0x86,0x02,0x83,0x04,0xFF
d_0BF4:
	.byte 0x00,0x00,0x04,0x71,0x04,0x73,0x04,0x71,0x04,0x73,0x04,0x76,0x04,0x78,0x04,0x76,0x04,0x78,0x04,0xFF
d_0C08:
	.byte 0x00,0x00,0x06,0x56,0x01,0x55,0x01,0x54,0x01,0x53,0x01,0x52,0x01,0x51,0x01,0x50,0x01
	.byte 0x6B,0x01,0x6A,0x01,0x69,0x01,0x68,0x01,0x67,0x01,0x66,0x01,0x65,0x01,0x64,0x01
	.byte 0x63,0x01,0x62,0x01,0x61,0x01,0x60,0x01,0x7B,0x01,0x7A,0x01,0x79,0x01,0x78,0x01
	.byte 0x77,0x01,0x76,0x01,0x75,0x01,0x74,0x01,0x73,0x01,0x72,0x01,0x71,0x01,0x70,0x01
	.byte 0x8B,0x01,0x8A,0x01,0x89,0x01,0x88,0x01,0x87,0x01,0x86,0x01,0x85,0x01,0x84,0x01
	.byte 0x83,0x01,0xFF
d_0C5C:
	.byte 0x02,0x04,0x05,0x60,0x01,0x78,0x01,0x75,0x01,0x71,0x01,0x60,0x01
	.byte 0x78,0x01,0x75,0x01,0x71,0x01,0x60,0x01,0x78,0x01,0x75,0x01,0x71,0x01,0x60,0x01
	.byte 0x78,0x01,0x75,0x01,0x71,0x01,0x60,0x01,0x78,0x01,0x75,0x01,0x71,0x01,0x60,0x01
	.byte 0x78,0x01,0x75,0x01,0x71,0x01,0x60,0x01,0x0C,0x01,0x78,0x01,0x7A,0x01,0x75,0x01
	.byte 0x78,0x01,0x73,0x01,0x75,0x01,0x61,0x01,0x7A,0x01,0x76,0x01,0x73,0x01,0x61,0x01
	.byte 0x7A,0x01,0x76,0x01,0x73,0x01,0x61,0x01,0x7A,0x01,0x76,0x01,0x73,0x01,0x61,0x01
	.byte 0x7A,0x01,0x76,0x01,0x73,0x01,0x61,0x01,0x79,0x01,0x76,0x01,0x73,0x01,0x61,0x01
	.byte 0x79,0x01,0x76,0x01,0x73,0x01,0x61,0x01,0x0C,0x01,0x79,0x01,0x61,0x01,0x78,0x01
	.byte 0x79,0x01,0x75,0x01,0x78,0x01,0xFF
d_0CE0:
	.byte 0x02,0x02,0x05,0x60,0x01,0x60,0x01,0x60,0x01,0xFF
d_0CEA:
	.byte 0x02,0x04,0x05,0x61,0x02,0x78,0x02,0x78,0x02,0x61,0x02,0x78,0x02,0x78,0x02
	.byte 0x61,0x02,0x78,0x02,0x78,0x02,0x61,0x02,0x78,0x02,0x78,0x02,0x61,0x02,0x78,0x02
	.byte 0x7A,0x02,0x75,0x02,0x63,0x02,0x7A,0x02,0x7A,0x02,0x63,0x02,0x7A,0x02,0x7A,0x02
	.byte 0x63,0x02,0x7A,0x02,0x79,0x02,0x63,0x02,0x79,0x02,0x79,0x02,0x63,0x02,0x79,0x02
	.byte 0x76,0x02,0x73,0x02,0xFF
d_0D2E:
	.byte 0x02,0x02,0x05,0x78,0x01,0x78,0x01,0x78,0x01,0xFF
d_0D38:
	.byte 0x02,0x10,0x05,0x85,0x06,0x85,0x06,0x85,0x06,0x85,0x06,0x85,0x04,0x85,0x04,0x86,0x06
	.byte 0x86,0x06,0x86,0x06,0x86,0x06,0x86,0x04,0x86,0x04,0xFF
d_0D54:
	.byte 0x02,0x04,0x05,0x81,0x01,0x81,0x01,0x81,0x01,0xFF
d_0D5E: ;,0x15
	.byte 0x02,0x00,0x07,0x65,0x01,0x0C,0x01,0x61,0x01,0x0C,0x01,0x63,0x01,0xFF
d_0D6C:
	.byte 0x02,0x00,0x05,0x7A,0x05,0x0C,0x01,0x7A,0x01,0x0C,0x01,0x7A,0x03
	.byte 0x0C,0x01,0x78,0x07,0x0C,0x01,0x78,0x07,0x0C,0x01,0x78,0x03,0x0C,0x01,0x7B,0x05
	.byte 0x0C,0x01,0x7B,0x01,0x0C,0x01,0x7B,0x03,0x0C,0x01,0x7A,0x07,0x0C,0x01,0x7A,0x07
	.byte 0x0C,0x01,0x7A,0x03,0x0C,0x01,0x7B,0x01,0x0C,0x01,0x7B,0x01,0x0C,0x03,0x7B,0x01
	.byte 0x0C,0x01,0x7B,0x03,0x0C,0x01,0x61,0x01,0x0C,0x01,0x61,0x01,0x0C,0x03,0x61,0x01
	.byte 0x0C,0x01,0x61,0x03,0x0C,0x01,0x61,0x03,0x0C,0x01,0x61,0x03,0x0C,0x01,0x63,0x01
	.byte 0x0C,0x01,0x63,0x01,0x0C,0x03,0x63,0x01,0x0C,0x01,0x63,0x03,0x0C,0x01,0x63,0x03
	.byte 0x0C,0x01,0x63,0x03,0x0C,0x01,0xFF
d_0DE0:
	.byte 0x02,0x00,0x03,0x86,0x02,0x8A,0x02,0x71,0x02
	.byte 0x76,0x02,0x86,0x02,0x8A,0x02,0x71,0x02,0x76,0x02,0x86,0x02,0x8A,0x02,0x71,0x02
	.byte 0x76,0x02,0x86,0x02,0x8A,0x02,0x71,0x02,0x76,0x02,0x86,0x02,0x8A,0x02,0x71,0x02
	.byte 0x76,0x02,0x86,0x02,0x8A,0x02,0x71,0x02,0x76,0x02,0x86,0x02,0x8A,0x02,0x71,0x02
	.byte 0x76,0x02,0x86,0x02,0x8A,0x02,0x71,0x02,0x76,0x02,0x77,0x01,0x0C,0x01,0x77,0x01
	.byte 0x0C,0x03,0x77,0x01,0x0C,0x01,0x77,0x03,0x0C,0x01,0x69,0x01,0x0C,0x01,0x69,0x01
	.byte 0x0C,0x03,0x69,0x01,0x0C,0x01,0x69,0x03,0x0C,0x01,0x69,0x03,0x0C,0x01,0x69,0x03
	.byte 0x0C,0x01,0x8B,0x02,0x73,0x02,0x76,0x02,0x7B,0x02,0x7B,0x02,0x76,0x02,0x73,0x02
	.byte 0x8B,0x02,0xFF
d_0E5C:
	.byte 0x00,0x00,0x02,0x86,0x08,0x81,0x08,0x86,0x08,0x81,0x08,0x86,0x08
	.byte 0x81,0x08,0x86,0x08,0x81,0x08,0x82,0x01,0x0C,0x01,0x82,0x01,0x0C,0x03,0x82,0x01
	.byte 0x0C,0x01,0x82,0x03,0x0C,0x01,0x84,0x01,0x0C,0x01,0x84,0x01,0x0C,0x03,0x84,0x01
	.byte 0x0C,0x01,0x84,0x03,0x0C,0x01,0x84,0x03,0x0C,0x01,0x84,0x03,0x0C,0x01,0x7B,0x08
	.byte 0x76,0x04,0x8B,0x04,0xFF
d_0E9E:
	.byte 0x00,0x0C,0x05,0x75,0x0C,0x71,0x0C,0x8A,0x0C,0x86,0x0C
	.byte 0x0C,0x09,0x75,0x03,0x71,0x09,0x8A,0x03,0x86,0x04,0x8A,0x04,0x71,0x04,0x89,0x04
	.byte 0x70,0x04,0x73,0x04,0x8B,0x0C,0x73,0x0C,0x76,0x0C,0x78,0x0C,0x0C,0x09,0x79,0x03
	.byte 0x76,0x09,0x72,0x03,0x8B,0x04,0x89,0x04,0x86,0x04,0x72,0x04,0x89,0x04,0x76,0x04,0xFF
d_0EDA:
	.byte 0x00,0x0C,0x05,0x71,0x0C,0x8A,0x0C,0x86,0x0C,0x85,0x0C,0x0C,0x09,0x81,0x03
	.byte 0x8A,0x09,0x86,0x03,0x85,0x04,0x86,0x04,0x8A,0x04,0x86,0x04,0x89,0x04,0x8B,0x04
	.byte 0x88,0x0C,0x8B,0x0C,0x73,0x0C,0x76,0x0C,0x0C,0x09,0x76,0x03,0x72,0x09,0x8B,0x03
	.byte 0x8A,0x04,0x86,0x04,0x82,0x04,0x8B,0x04,0x89,0x04,0x82,0x04,0xFF
d_0F16:
	.byte 0x00,0x00,0x03,0x75,0x18,0x75,0x18,0x75,0x18,0x71,0x0C,0x75,0x0C,0x73,0x18,0x73,0x18,0x72,0x18
	.byte 0x76,0x0C,0x78,0x0C,0xFF

* not sure this one
	.byte 0xFA

*       .org 0x0FFF
*       .db 0xFF
* end of ROM
* input file int.s
*
* int.s:
*  gg1-1.3p 'maincpu' (Z80)
*
*  Z80 interrupt vectors, maincpu.
*
*
.module int0
.area INTVEC (ABS,OVR)

.include "int.dep"

*

*.org  0x0000

*=============================================================================
* RST_00()
*  Description:
*   Z80 reset
*   Reset/clear the chip command state and jump to the reset handler ($10).
*   NMI is disabled when  IO_CMD & $0F == 0
* IN:
*
* OUT:
*  ...
*-----------------------------------------------------------------------------
rst_00_cpu0:
	move.b	#0x10,d0                        	| [ld   a,#0x10]
	*move.b	d0,0x7100                       	| [ld   (0x7100),a] IO cmd ($10 -> reset/clr chip command state)
          ^^^^^^ TODO: review absolute 16-bit address write
	jra	CPU0_RESET                         	| [jp   CPU0_RESET]


*

*.org 0x0008

rst_08_cpu0:
*=============================================================================
* RST_08()
*  Description:
*   HL += 2A
* IN:
*
* OUT:
*  ...
*-----------------------------------------------------------------------------
	add.b	d0,d0                            	| [add  a,a]
	jcc	rst_HLplusA                        	| [jr   nc,rst_HLplusA]
	addq.b	#1,d5                           	| [inc  h] add carry into H
	jra	rst_HLplusA                        	| [jp   rst_HLplusA]


*

*.org 0x0010

*=============================================================================
* RST_10()
*  Description:
*   HL += A
* IN:
*   HL
*   A
* OUT:
*   HL
*   A = L + A
*-----------------------------------------------------------------------------
rst_HLplusA:
	add.b	d6,d0                            	| [add  a,l]
	move.b	d0,d6                           	| [ld   l,a]
	bcs.b	0f                               	| [...]
      ^^^^^^ TODO: review cpu flags (move.b,bcs.b)
	rts                                    	| [ret  nc] [...]
0:
	addq.b	#1,d5                           	| [inc  h] add carry into H
	rts                                    	| [ret]


*

*.org 0x0018

*=============================================================================
* RST_18()
*  Description:
*   memset((HL), A, B)
* IN:
*   HL: pointer
*   A: fill character
*   B: count
* OUT:
*  ...
*-----------------------------------------------------------------------------
l_0018:
	move.b	d0,(a0)                         	| [ld   (hl),a]
	addq.w	#1,a0                           	| [inc  hl]
	subq.b	#1,d1                           	| [...]
	jne	l_0018                             	| [djnz l_0018] while (B--)
	rts                                    	| [ret]


*

*.org 0x0020


*.org 0x0028

*=============================================================================
* RST_28()
*  Description:
*   memset(tbl, 0, $F0)
* IN:
* OUT:
*  ...
*-----------------------------------------------------------------------------
	lea	ds_bug_motion_que(pc),a0           	| [ld   hl,#ds_bug_motion_que] memset(..., 0, $F0)
	move.b	#0xF0,d1                        	| [ld   b,#0xF0]
	clr.b	d0                               	| [xor  a] A==00
	jbsr	rst_18                            	| [rst  0x18] memset((HL), A=fill, B=ct)
	rts                                    	| [ret]


*

*.org 0x0030

*=============================================================================
* RST_30()
*  Description:
*   Entry point to display string function at _139A
* IN:
*   If set Cy flag, indicates to _139A to expect a position encoded string
* OUT:
*  HL == final offset in video ram (some code actually uses this!)
*-----------------------------------------------------------------------------
rst_30:
	SET_XC_FLAGS                           	| [scf]
	scs	d7                              	| [ex   af,af']
         ^^^ TODO review: wrong if carry is needed or D7 used in between!
	jra	j_string_out_pe_13b5                    	| [jp   j_string_out_pe_13b5]


*

*.org 0x0038

*=============================================================================
*  Description:
*   RST $38 handler.
*   jp to the task manager
* IN:
*  ...
* OUT:
*  ...
*-----------------------------------------------------------------------------
	jra	jp_Task_man                        	| [jp   jp_Task_man]


*=============================================================================
* c_task_switcher()
*  Description: returns from the jp'd task.
* IN:
*  ...
* OUT:
*  ...
* PRESERVES:
*  BC
*-----------------------------------------------------------------------------
c_task_switcher:
	jra	(a0)                               	| [jp   (hl)]


*=============================================================================
* c_sctrl_sprite_ram_clr()
*  Description:
*   Initialize screen control registers.
* IN:
*  ...
* OUT:
*  ...
*-----------------------------------------------------------------------------
c_sctrl_sprite_ram_clr:
* memset($9300, 0, $80)
	lea	ds_sprite_posn(pc),a0              	| [ld   hl,#ds_sprite_posn]
	move.b	#0x80,d1                        	| [ld   b,#0x80]
	clr.b	d0                               	| [xor  a]
	jbsr	rst_18                            	| [rst  0x18] memset((HL), A=fill, B=ct)
* memset($9b00, 0, $80)
	lea	ds_sprite_ctrl(pc),a0              	| [ld   hl,#ds_sprite_ctrl]
	move.b	#0x80,d1                        	| [ld   b,#0x80]
	jbsr	rst_18                            	| [rst  0x18] memset((HL), A=fill, B=ct)
* memset($8800, $80, $80)
	lea	b_8800(pc),a0                      	| [ld   hl,#b_8800] $80 byte with sprite data buffer blocks
	move.b	#0x80,d0                        	| [ld   a,#0x80]
	move.b	#0x80,d1                        	| [ld   b,#0x80]
	jbsr	rst_18                            	| [rst  0x18] memset((HL), A=fill, B=ct)

	rts                                    	| [ret]


*

*.org 0x0066

*=============================================================================
* NMI
*  Description:
*   NMI
* IN:
* OUT:
*  ...
*-----------------------------------------------------------------------------
	jbsr	exx                               	| [exx] Load function params from aux regs
     ^^^^ TODO: review special instruction inputs
	jbsr	ldi                               	| [ldi] each nmi will move one byte, so BC--, DE++, HL++
     ^^^^ TODO: review special instruction inputs

*  if ( BC > 0 )  { goto l_008F } ... exit if still copying data
	jvc	l_008F                             	| [jp   pe,l_008F] !P/V when BC==0

	move.w	d0,-(sp)                        	| [push af] save AF, it's not part of the exx exchange

* Signal the chip that the parameter transfer is finished.
	lea	l_7100(pc),a0                      	| [ld   hl,#0x7100] $10 - command params complete.
	move.b	#0x10,(a0)                      	| [ld   (hl),#0x10] IO_CMD_DONE

*  if ( !player_hit )
	move.b	b_9AA0+0x19,d0                  	| [ld   a,(b_9AA0 + 0x19)] sound-fx count/enable registers, ship hit
	                               	| [and  a] A!=0 or maybe 02 when you get hit
	jeq	l_plyr_ok                          	| [jr   z,l_plyr_ok]
* else
	clr.b	d0                               	| [xor  a]
	move.b	d0,b_9AA0+0x19                  	| [ld   (b_9AA0 + 0x19),a] 0 ... sound-fx count/enable registers, ship hit

	lea	d_IO_ChipParms(pc),a0              	| [ld   hl,#d_IO_ChipParms]
	lea	l_7000(pc),a1                      	| [ld   de,#0x7000] IO data xfer (write)
	move.b	#0x00,d1                        	| [ld   bc,#0x0004] 4
	move.b	#0x04,d2                        	| [ld   bc,#0x0004] 4
	jbsr	exx                               	| [exx]
     ^^^^ TODO: review special instruction inputs

	move.b	#0xA8,d0                        	| [ld   a,#0xA8]
	*move.b	d0,0x7100                       	| [ld   (0x7100),a] IO cmd ($A8 -> trigger bang sound)
          ^^^^^^ TODO: review absolute 16-bit address write
	move.w	(sp)+,d0                        	| [pop  af]
retn
l_plyr_ok:
	move.w	(sp)+,d0                        	| [pop  af]
l_008F:
	jbsr	exx                               	| [exx] restore regs for the main "thread"
     ^^^^ TODO: review special instruction inputs
retn                                       ; end 'NMI'

*
*
* data for NMI sub
*
d_IO_ChipParms:
	.byte 0x10,0x10,0x20,0x20


_l_0096:
*            00000096  d_OS_TaskTable                     task_man

*
* input file mrw.s
*
*
* mrw.s:
*  defines variables in "read-write" memory.
*
*  This project provides information about the design of the software
*  programming of the original Galaga arcade game, (c) 1981 NAMCO LTD.
*  All files associated with this project are an original documentation
*  work, copyright 2012 by Glenn A. Neidermeier.
*
* Permission is granted to anyone to use the information provided here for
* any non-commerial purpose with the following restrictions:
*
* 1) You are responsible for any legal issues arising from your use of this
*    information.
* 2) If any changes are made to any files in this project, they should be
*    identified as having been modified and by whom.
*
*
*  The build requires the axXXXX assembler (asez80 variant which includes
*  support for some undocumented opcodes). Code for all 3 Z80 CPUs is
*  generated from one build by making use of the bank-switching capability of
*  asXXXX. The linker also allows most of the .org directives to be
*  eliminated, and instead module placement is controlled by .area directive
*  and located at link time.
*
*  The ROM checksums are also left as commented .db directives, but are
*  actually generated completely at link time by the remarkable srec_cat tool.
*
*
*  What follows is a catch-all for any additional information...
*
*
*  Sprite hardware SFRs ... I got this information a long long time ago from
*  MAME version 21.5 or something like that which had the first Galaga driver:
*
*   SPRCODE: sprite code/color
*   8b00-8b7f buffer  8b80-8bff
*    offset[0]: tile code
*    offset[1]: color map code
*
*   SPRPOSN: sprite position
*   9300-937f buffer  9380-93ff
*    offset[0]: sx
*    offset[1]: sy<0:7>
*
*   SPRCTRL: sprite control
*   9b00-9b7f buffer  9b80-9bff
*    offset[0]
*     0: flipx - flip about the X axis, i.e. "up/down"
*     1: flipy - flip about the Y axis, i.e. "left/right"
*     2: dblh - MAME may not do dblh unless dblw is also set... (this may not be true)
*     3: dblw
*    offset[1]
*     0: sy<8>
*     1: enable
*
*     Doubling effects seem to copy/mirror the sprite image .. but not always?
*
*

*
* Tile RAM & color RAM layout.
*    Tile rows  0-1:   $8300 - 803F
*    Playfield area:   $8040 - 83BF
*    Tile rows 32-35:  $83C0 - 83FF
*
*    In Tile rows 0,1,32,35, the length is $20 bytes, but 2 bytes at each end
*    are not visible, but it simplifies the math!
*
*    2 bytes                            	|| 2 bytes (not visible)
*   ----------------------------------------------------
*   .3DF     .3DD                              .3C2  .3C0     <- Row 2
*   .3FF     .3FD                              .3E2  .3E0     <- Row 3
*            .3A0-------------------------.060 .040
*                                       	|||
*            .3BF-------------------------.07F .05F
*   .01F     .01D                              .002  .000     <- Row 0
*   .03F     .03D                              .022  .020     <- Row 1
*

*=============================================================================
*  This module implements all the memory read-write blocks, which exist in
*  a single data address space common to all 3 Z80 CPUs.
*  The approach taken is that anything here could be moved if the code were
*  ported to a different platform.
*  There is a separate file "sfrs.inc" which provides equates for the
*  addresses of speqcial function registers which are specific to the hardware.
*  It could be argued that the sprite register blocks should be
*  handled as simple equates as well.
*
*  3 separate .areas are defined here for each of the shared RAM banks located at
*  $8800, $9000, and $9800 ($0400 bytes each).
*  Those areas could be located at link time by '-b' arguments to the linker
*  but relocatable symbols and absolute symbols can't be used in expressions together.
*-----------------------------------------------------------------------------

.module RAM


*=============================================================================
* RAM0
* Description:
*   $0400 bytes, $8800
*-----------------------------------------------------------------------------
.area RAM0
*.area MRW (abs,ovr)
*.org $8800


ds_8800_RAM0:

* Object status structure... 2 bytes per element (indexed same as sprite registers).
*  [ 0 + n ] : object state
*  [ 1 + n ] : byte-offset (index) into bug_motion_que[]

b_8800:
.ds     $40 * 2   ; $40 elements

.ds     $80       ; unused
* 8900
.ds     $20       ; unused

* Space for 5 attack wave setup tables. Each table can vary in size, because
* in each wave there are a varying number of "transients" bug (have no home
* and simply fly off the screen) so each wave has slots for up to 16
* bugs. There are always 8 bugs in each wave that fly "home".
* Each player has a private pointer initialized to offset 0 of this table at
* beginning of each new stage ... actv_plyr_state[0x02]
* Since the table size can vary, the end-of-table is indicated  by $7F.
ds_8920:
.ds     $C0       ; $56 bytes used

ds_89E0:
.ds     $20       ; data for CPU sub-1 f_0ECA (the unused mystery task)


* Temp vars for _top5_dlg_proc ... gg1-4
b_8A00:
.ds     $02       ; ptr to plyr1 score or plyr2 score on screen.
.ds     $01       ; L==2, R==8 X=A   previous controller state
.ds     $01       ; character selection counter/timer
.ds     $02       ; pointer to new name in table
.ds     $0A       ; unused
*b_8A10:
.ds     $01       ; lower byte of current input character's address in v-ram
.ds     $01       ; 1==1ST place etc.
.ds     $0E       ; unused

* Top5 Table scores
b_best5_score:

b_best5_score1:
.ds     $06
b_best5_score2:
.ds     $06
b_best5_score3:
.ds     $06
b_best5_score4:
.ds     $06
b_best5_score5:
.ds     $06

* Top5 Table names
b_best5_name1:
.ds     $03       ; 1st score initials
b_best5_name2:
.ds     $03       ; 2st score initials
b_best5_name3:
.ds     $03       ; 3st score initials
b_best5_name4:
.ds     $03       ; 4st score initials
b_best5_name5:
.ds     $03       ; 5st score initials

.ds     $03       ; unused (8A4D)
.ds     $B0       ; unused (8A50)


* origin base of sprite data block 0x8B00
ds_sprite_code:

mrw_sprite_code:
.ds     $0040     ; sprite code/color l (buffer)
.ds     $0040     ; sprite code/color h (buffer)
sfr_sprite_code:
.ds     $0040     ; sprite code/color l ("video" registers) 0x8B80
.ds     $0040     ; sprite code/color h ("video" registers) 0x8BC0


*=============================================================================
* RAM1
* Description:
*   $0400 bytes, $9000
*-----------------------------------------------------------------------------
.area RAM1
*.area MRW (abs,ovr)
*.org $9000


ds_9000_RAM1:

ds_cpu0_task_actv:
.ds     $20

ds_cpu1_task_actv:
.ds     $08

.ds     $08       ; unused

.ds     $70       ; stack_cpu_0 (about $30 bytes max)
ds_stk_cpu0_init:
.ds     $60       ; stack_cpu_1 (about %18 bytes max)
ds_stk_cpu1_init:


* temp variables that are generally outside the scope of the game proper.
ds_9100:

* temp variables for romtest mgr
ds_rom_test_status:

ds_9100_tmp:

ds_atk_wav_tmp_buf:
.ds     $10       ; temp array for c_25A2 ($0100 boundary)

* temp array for Test_menu_proc
b_svc_test_inp_buf:

* roll back the counter
. = ds_9100

* Object movement structures... cpu_sub_1:IX
* Assumes alignment on $0100 boundary.
*  00-07 writes to 92E0, see _2636
*  08-09 ptr to data in cpu-sub-1:4B
*  0D    counter
*  10    index/offset of object .... i.e. 8800 etc.
*  11
*  13
ds_bug_motion_que:
.ds     $14 * 12  ; 12 object data structures (total size $F0)

.ds     $10       ; 91F0 unused


*-----------------------------------------------------------------------------
* generic symbol is appropriate for a few references, and unused space clearly
* shown
*-----------------------------------------------------------------------------
ds_9200:
.ds     $60
.ds     $10       ; unused

. = ds_9200 ; roll back the PC

*-----------------------------------------------------------------------------
* The following motley collection of global variables are situated at
* odd addresses, apparently becuase the the clever designers didn't want to
* waste the odd-bytes at 0x9200. At the end of these globals, the instruction
* counter will be rollled-back and a new label created to define the array of
* $30 bytes and allow it to be treated as a separate structure.
*-----------------------------------------------------------------------------
ds_9200_glbls:
.ds     $01
b8_9201_game_state:
.ds     $01       ; game states (1, 2, 3, 4 from the manual)
                            * 0==Game Ended   (not described in manual)
                            * 1==ATTRACT_MODE, 2==READY_TO_PLAY_MODE, 3==PLAY_MODE
                            * ??==SELF_TEST_MODE  (doesn't have a corresponding enumeration value)
.ds     $01
*_b_9203
.ds     $01       ; jp table index demo mode
.ds     $01
*_b_9205
.ds     $01       ; index for text strings, demo
.ds     $01
*_b_9207
.ds     $01       ; counter, demo
.ds     $01
*                           ; state, once near beginning of round (demo or play) $81->$1

*_b_9209                    ; demo only
*                           ; 07DD(sub-1)
.ds     $01
.ds     $01
*_b_920B
.ds     $01       ; conditions for doing flying bug attack
.ds     $01       ; 1 at demo mode, 3 at game start (after intro),
                            * 0 at HEROES screen, 0 when ship appear on training mode, 0 when coin-in,
*_b_920D
.ds     $01
.ds     $01
*_b_920F
.ds     $01       ; flag, bug nest movement left/right
.ds     $01       ; 07DD, 1DC1 in game
*_b_9211
.ds     $01       ; cp with (b_9A80 + 0x00) in cpu2
.ds     $01
*_b_9213
.ds     $01       ; restart_stage "end of attack" (all attackers go home)
.ds     $01       ; 07DD, 1DC1
b_9215_flip_screen:
.ds     $01
.ds     $01
*_b_9217
.ds     $01

. = ds_9200 ; roll back the PC

*-----------------------------------------------------------------------------
* Object-collision notification to f_1DB3 from cpu1:c_076A (even-bytes)
*-----------------------------------------------------------------------------
b_9200_obj_collsn_notif:
.ds     $60       ; even bytes ($30 elements)

.ds     $10       ; unused


b_svc_test_snd_slctn:
.ds     $01
b_svc_eastregg_keyprs_cnt:
.ds     $01
w_svc_15sec_tmr:
.ds     $02

.ds     $0C       ; unused


b_9280:

*-----------------------------------------------------------------------------
* first take care of temp variables

ds8_9280_tmp_IO_parms:
.ds     $08       ; unused
ds3_9288_tmp_IO_data:
.ds     $01

*-----------------------------------------------------------------------------

* roll back the instruction counter
. = b_9280

*-----------------------------------------------------------------------------
p_attrmode_sptiles:
.ds     $02       ; persistent pointer to static sprite tile data for demo (parameter to _sprite_tiles_displ)
pdb_demo_fghtrvctrs:
.ds     $02       ; f_1700, tracks state of demo mode by setting an offset to the data table
ds2_stg_chllg_rnd_attrib:   ; attributes selected for hit all 8 bonus on challenge round convoy i.e. score, sprite tile
.ds     $01       ; hit-count, add to collsn_hit_mult[0x0F]
.ds     $01       ; sprite code and collision flag, ld to obj_collsn_notif[L]
b_bugs_flying_cnt:
.ds     $01       ; count of flying pests in flite-q (current frame)
b_bugs_flying_nbr:
.ds     $01       ; nbr of flying pests in flite-q (previous frame)

b_bug_flyng_hits_p_round:
.ds     $01
b_bug_que_idx:
.ds     $01       ; cpu1:f_08D3 local loop counter

ds5_928A_captr_status:
.ds     $05       ; [0] status of tractor beam
                            * [1] status of rescued ship (counter while ship is positioned into collective)
                            * [2] status of rescued ship
                            * [3] status of boss that captured ship
                            * [4] if 1 fighter is captured (show fighter captured text)
.ds     $01       ; unused

ds_bug_collsn_hit_mult:
.ds     $10       ; hit-count/multiplier from collision manager, see d_scoreman_inc_lut

b_92A0:

ds3_92A0_frame_cts:
.ds     $03       ; 3 bytes .... sub1:l_0537
* b8_92A3:
.ds     $01       ; ship.dX_flag
* b16_92A4
.ds     $02       ; each byte tracks a shot from the ship

* this group all related to tracking number of attackers during a stage
b_bugs_actv_cnt:
.ds     $01       ; counts number of active bugs at each frame update (c_23E0)
b_bugs_actv_nbr:
.ds     $01       ; total number of active bugs (global)
w_bug_flying_hit_cnt:
.ds     $02       ; count down each flying bug hit (only relevant on challenge stg) only the lsb is used.
* b16_92AA
.ds     $01       ; flag determines continuous bombing

.ds     $01       ; unnused


* global game timer array
ds4_game_tmrs:
.ds     $04

b_92B0:
.ds     $02 * 8   ; bomb X-rate
                            * accumulator for division remainder (f_1EA4)

b_92C0:
* bomber activation timers (3 bytes) and init values (3 bytes)
.ds     $03
.ds     $01  ; unused (force even alignment of following member)
.ds     $03
.ds     $01  ; unused
.ds     $01
.ds     $01  ; ?

bmbr_boss_pool:
* 12 bytes in 4 groups of 3 ... slots for boss+wing missions
.ds     $0C

b_CPU1_in_progress:
.ds     $01
b_CPU2_in_progress:
.ds     $01

.ds     $08       ; unused

pb_attk_wav_IDs:
.ds     $02       ; tmp ptr in c_25A2
b_92E2:
.ds     $01       ; _stg_dat[0] e.g. *(26F4) ... c_25A2
.ds     $01       ; _stg_dat[1] e.g. *(26F5) ... c_25A2, ld to 0x0f(ix)

.ds     $1C       ; unused


* sprite position buffer and SFRs: 0x9300
ds_sprite_posn:

mrw_sprite_posn:
.ds     $40       ; sprite position l (buffer)
.ds     $40       ; sprite position h (buffer)
sfr_sprite_posn:
.ds     $40       ; sprite position l ("video" registers)
.ds     $40       ; sprite position h ("video" registers)


*=============================================================================
* RAM2
* Description:
*   $0400 bytes, $9800
*-----------------------------------------------------------------------------
.area RAM2
*.area MRW (abs,ovr)
*.org $9800

ds_9800_RAM2:


* Pixel coordinates for object origin positions in the cylon fleet.
ds_hpos_spcoords:

* 10 column coordinates, 6 row coordinates, 16-bits per coordinate.
.ds     $20


* see definitions in structs.inc
ds_plyr_data:

ds_plyr_actv:
.ds     $40
ds_plyr_susp:
.ds     $40

.ds     $10       ; unused

ds_susp_plyr_obj_data:
.ds     $30       ; resv player game object status tokens (copied from 8800)

ds_cpu0_task_resrv:
.ds     $20


* home position locations for objects in the cylon fleet.
* 10 column coordinates, 6 row coordinates, 2-bytes per coordinate.

* even-bytes: offset of home-position coordinate relative to origin
ds_hpos_loc_offs:

* odd-bytes: copy of origin data for access in CPU1 address space (i.e. bits <8:1> of precision coordinate)
ds_hpos_loc_orig:

* struct for home position locations
ds_hpos_loc_t:
.ds     $20


* bitmaps for setting up expand/contract motion of group (from defaults at 1E64)
ds10_9920:
.ds     $10

.ds     $50       ; unused

ds_mchn_cfg:

w_mchn_cfg_bonus:
.ds     $02
b_mchn_cfg_nships:
.ds     $01
b_mchn_cfg_cab_type:
.ds     $01
b_mchn_cfg_rank:
.ds     $01

.ds     $2B       ; 9985-8F unused
                            * 9990-AF unused

* 2 bytes temp in hit-miss ratio calc
b16_99B0_tmp:

ds3_99B0_X3attackcfg:

b8_99B0_X3attackcfg_ct:
.ds     1          ; 3 count for X3 attacker
b8_99B1_X3attackcfg_parm0:
.ds     1
b8_99B2_X3attackcfg_parm1:
.ds     1
b8_99B3_two_plyr_game:
.ds     1          ; 0 for 1P, 1 for 2P
b8_99B4_bugnest_onoff_scrn_tmr:
.ds     1
ds3_99B5_io_input:
.ds     3          ; see info in j_Test_menu_proc

b8_99B8_credit_cnt:
.ds     1

ds_99B9_star_ctrl:
* 99B9: scroll_enable (1 when ship on screen, 0 if stop_scroll)
*_b_99BA
*_b_99BB

* 99BE: star_ctrl_state : value that gets passed to the h/w
.ds     6

b8_ship_collsn_detectd_status:
.ds     1

ds_new_stage_parms:
.ds     $0A       ; each byte stores 1 nibble of bytes $0 thru $A of table dw_2C65[] (new stage)
.ds     $01       ; bonus-bee when bug count reaches $0A (0 for challenge stage)

.ds     $15       ; unused

ds20_99E0:
ds10_99E0_mchn_data:
b16_99E0_ttl_plays_bcd:
.ds     $02       ; ttl plays bcd
b32_99E2_sum_score_bcd:
.ds     $04
b32_99E6_gametime_secs_bcd:
.ds     $04
b16_99EA_bonus_ct_bcd:
.ds     $02
.ds     $14       ; unused


* cpu sub2 memory block ($100 bytes)

* one byte for every sound-effect structure ... sound_fx_status or count?
b_9A00:
.ds     $30
* one byte for every sound-effect structure... saves the current data index: sound_fx_idx
b_9A30:
.ds     $30
* tmp buffer for copy out values to sound hardware SFRs, frequency and volume SFRs
b_9A60:
.ds     $10       ; $10 bytes copied to 6810 (frequency & volume SFRs)
b_9A70:
.ds     $03       ; 00: voice 0 wave select
                            * 01: voice 1 wave select
                            * 02: voice 2 wave select
.ds     $01
.ds     $01       ; 04: actv_snd_idx... index of sound currently being processed

.ds     $03       ; 05: snd_parms_set[] ... current set of sound parameters copied from snd_parms_dat
                            *     [0] idx: sound effect index i.e. b_9A00[], b_9A00[$30] and selects pointer to p_snd_fx[] etc
                            *     [1] count: number of data pairs used by the sound effect data group in this time slice
                            *     [2] voice_select:
.ds     $01       ; 08:
.ds     $01       ; 09: global copy of count of additional credits-in since last update for triggering coiin-in sound
.ds     $02       ; 0A: tmp pointer to sound-effect data in c_0550
.ds     $01       ; 0C: voice 2 volume for capture beam
.ds     $01       ; 0D: counter for wave-select (tractor beam)
.ds     $01       ; 0E: counter, tracks voice 2 volume change ... capture beam
.ds     $01       ; 0F: counter for wave-select (tractor beam)
b_9A80:
.ds     $01       ; 00:
.ds     $01       ; 01:
.ds     $02       ; 02:
.ds     $02       ; 04:
.ds     $02       ; 06:
.ds     $03       ; 08: sound_effect_parms ... 3 bytes from p_snd_fx[ 2 * snd_parms_set.idx ]
                            *  [0]:
                            *  [1]:
                            *  [2]: wave
.ds     $05       ; unused
.ds     $10       ; unused

ds_9AA0: ; label for pointer+index operations
b_9AA0:
* Most of these registers function as a count/enable for individual sound effects
.ds     $01       ; 00:  diving-attacks sound effects
.ds     $01       ; 01:  blue-boss hit sound
.ds     $01       ; 02:
.ds     $01       ; 03:
.ds     $01       ; 04:
.ds     $01       ; 05:  capture beam sound active uno
.ds     $01       ; 06:  capture beam sound active deux
.ds     $01       ; 07:
.ds     $01       ; 08:  count/enable register ... coin sound
.ds     $01       ; 09:  ?
.ds     $01       ; 0A:
.ds     $01       ; 0B:
.ds     $01       ; 0C:
.ds     $01       ; 0D:
.ds     $01       ; 0R:
.ds     $01       ; 0F:
.ds     $01       ; 10:
.ds     $01       ; 11:  count/enable register ... rescued ship theme
.ds     $01       ; 12:
.ds     $01       ; 13:
.ds     $01       ; 14:
.ds     $01       ; 15: clicks for stage tokens
.ds     $01       ; 16: sound mgr, hi-score dialog
.ds     $01       ; 17: 0 ... enable CPU-sub2 process
.ds     $01       ; 18: 1 ... skips CPUsub2 NMI if set (test variable?)
.ds     $01       ; 19: !0 ... trigger "bang" sound
.ds     $06       ; unused

* Many of these will correspond to _9AA0[] ... indicating if a particular sound is in process.
b_9AC0:
.ds     $20       ; Active flags of each sound effect


_stack_cpu_sub2:
.ds     $20       ; 9AE0
*_stack_cpu_sub2_init:


* sprite control buffer and SFRs
ds_sprite_ctrl:

mrw_sprite_ctrl:
.ds     $40       ; sprite control l (buffer)
.ds     $40       ; sprite control h (buffer)
sfr_sprite_ctrl:
.ds     $40       ; sprite control l ("video" registers)
.ds     $40       ; sprite control h ("video" registers)
*

* input file new_stage.s
*
* new_stage.s:
*  gg1-3.2m, 'maincpu' (Z80)
*
* loads the new parameters for the game stages
*
*
.module new_stage

.include "structs.inc"
.include "new_stage.dep"

*.area ROM (ABS,OVR)
* .org 0x2C00
.area CSEG2C

*=============================================================================
* stg_bombr_setparms()
*  Description:
*   new stage setup
*   selects table based on level and difficulty setting, loads the new
*   parameters for the stage
* IN:
*  ...
* OUT:
*  ...
*-----------------------------------------------------------------------------
c_2C00:
	move.b	ds_plyr_actv+_b_stgctr,d0       	| [ld   a,(ds_plyr_actv +_b_stgctr)] new stage setup
l_2C03:
* while (A > 0x1B)  A -= 4
	cmp.b	#0x1B,d0                         	| [cp   #0x1B]
	jcs	l_2C0B                             	| [jr   c,l_2C0B] goto 2C0B
	subq.b	#4,d0                           	| [sub  #4]
	jra	l_2C03                             	| [jr   l_2C03]

* E = ( adj_stg_cnt - 1 ) + adj_stg_cnt * 4  ... multiply by 5
l_2C0B:
	subq.b	#1,d0                           	| [dec  a]
	move.b	d0,d6                           	| [ld   l,a]
	rol.b	#2,d0                            	| [rlca] * 2
	add.b	d6,d0                            	| [add  a,l]
	move.b	d0,d4                           	| [ld   e,a]

* pTbl = bmbr_stg_cfg_lut[mchn_cfg.rank]
	move.b	b_mchn_cfg_rank,d0              	| [ld   a,(b_mchn_cfg_rank)]
	lea	bmbr_stg_cfg_lut(pc),a0            	| [ld   hl,#bmbr_stg_cfg_lut] ld the table of ptrs
	jbsr	rst_08                            	| [rst  0x08] HL += 2A
	move.b	(a0),d0                         	| [ld   a,(hl)]
	addq.w	#1,a0                           	| [inc  hl]
	move.b	(a0),d5                         	| [ld   h,(hl)]
	move.b	d0,d6                           	| [ld   l,a]

* pTbl[E];
	move.b	d4,d0                           	| [ld   a,e] adj_stg_cnt * 5
	jbsr	rst_10                            	| [rst  0x10] HL += A ... ofset into lut

	lea	ds_new_stage_parms(pc),a1          	| [ld   de,#ds_new_stage_parms]
	move.b	#5,d1                           	| [ld   b,#5]
l_2C23:
	move.b	(a0),d0                         	| [ld   a,(hl)]
	move.b	d0,d2                           	| [ld   c,a] stash data byte
* new_stage_parms[L * 2 + 0] = upper nibble
	rol.b	#4,d0                            	| [rlca] * 4
	and.b	#0x0F,d0                         	| [and  #0x0F]
	move.b	d0,(a1)                         	| [ld   (de),a]
* new_stage_parms[L * 2 + 1] = lower nibble
	addq.b	#1,d4                           	| [inc  e]
	move.b	d2,d0                           	| [ld   a,c] retrieve data byte
	and.b	#0x0F,d0                         	| [and  #0x0F]
	move.b	d0,(a1)                         	| [ld   (de),a]
* increment pointers
	addq.b	#1,d4                           	| [inc  e]
	addq.w	#1,a0                           	| [inc  hl]
	subq.b	#1,d1                           	| [...]
	jne	l_2C23                             	| [djnz l_2C23]

* set ds_new_stage_parms[0x0A] ... number of remaining aliens for enable clone-attack
	move.b	ds_plyr_actv+_b_stgctr,d0       	| [ld   a,(ds_plyr_actv +_b_stgctr)] new stage setup
* if ( stage_ctr < 3 )  A = 0 ...
	cmp.b	#3,d0                            	| [cp   #3]
	jcc	l_2C3F                             	| [jr   nc,l_2C3F]
* ... then
	clr.b	d0                               	| [xor  a]
	jra	l_2C46                             	| [jr   l_2C46]
l_2C3F:
* else if 0xFF == (plyr_state_actv.stage_ctr	| 0x0FC)
	or.b	~0x03,d0                          	| [or   #~0x03] challenge stages numbered so that bit_0 + bit_1 == 11b
	addq.b	#1,d0                           	| [inc  a]
	jeq	l_2C46                             	| [jr   z,l_2C46]
* ... then
	move.b	#0x0A,d0                        	| [ld   a,#0x0A] non-challenge stage

l_2C46:
	move.b	d0,(a1)                         	| [ld   (de),a] ds_new_stage_parms[$A]

* 16 02 02 i.e. start of round defaults for yellow, red, boss bomber timers
	move.b	#0x02,d1                        	| [ld   bc,#0x0216] 534
	move.b	#0x16,d2                        	| [ld   bc,#0x0216] 534
	move.b	a4,b_92C0+0x01                  	| [ld   (b_92C0 + 0x01),bc] = $0216 (int values for ready timers of each bomber type)
	move.b	a4,b_92C0+0x00                  	| [ld   (b_92C0 + 0x00),bc] = $0216 (int values for ready timers of each bomber type)

* adjust star speed

*  A = (stage_ctr < $10) : stage_ctr ? $10
	move.b	ds_plyr_actv+_b_stgctr,d0       	| [ld   a,(ds_plyr_actv +_b_stgctr)] limit is 10
	cmp.b	#0x10,d0                         	| [cp   #0x10]
	jcs	l_2C5B                             	| [jr   c,l_2C5B]
	move.b	#0x10,d0                        	| [ld   a,#0x10]
l_2C5B:
	rol.b	#2,d0                            	| [rlca] * 2
	and.b	#0x70,d0                         	| [and  #0x70]
	add.b	#0x40,d0                         	| [add  a,#0x40]
	move.b	d0,ds_99B9_star_ctrl+0x02       	| [ld   (ds_99B9_star_ctrl + 0x02),a]

	rts                                    	| [ret]

*=============================================================================
* selected table is by difficulty (rank) configured by dip switch setting
*-----------------------------------------------------------------------------
bmbr_stg_cfg_lut:
	.long bmbr_stg_cfg_dat + 0x82 * 1
	.long bmbr_stg_cfg_dat + 0x82 * 2
	.long bmbr_stg_cfg_dat + 0x82 * 3
	.long bmbr_stg_cfg_dat + 0x82 * 0

* 26 stages of data: 4 sub-tables for the ranks, 5-bytes per stage (1 parameter per nibble)

* 0: parameter for set bomb drop enable flags
* 1: parameter for setting launch counter, bomber-type 0
* 2: parameter for setting launch counter, bomber-type 1
* 3: parameter for setting launch counter, bomber-type 2
* 4: allowable max_bombers
* 5: increases allowable max_bombers after a time
* 6: ds_plyr_actv +_b_captr_flag
* 7: number of aliens left when continous bombing can start
* 8: flag for reload attack-wave flite vector table pointer after stage-8
* 9: flag for reload bombing flite vector table pointer after stage-8

bmbr_stg_cfg_dat:
	.byte 0x00,0x00,0x22,0xC6,0x00, 0x00,0x11,0x23,0xC7,0x00
	.byte 0x00,0x00,0x00,0xC0,0x00, 0x11,0x12,0x23,0x97,0x00
	.byte 0x11,0x23,0x23,0x98,0x00, 0x21,0x24,0x33,0x98,0x00
	.byte 0x00,0x00,0x00,0x90,0x00, 0x22,0x25,0x33,0x99,0x10
	.byte 0x22,0x36,0x34,0x69,0x10, 0x10,0x11,0x23,0x97,0x00
	.byte 0x00,0x00,0x00,0x60,0x00, 0x32,0x46,0x34,0x67,0x11
	.byte 0x32,0x67,0x44,0x68,0x11, 0x32,0x67,0x45,0x68,0x11
	.byte 0x00,0x00,0x00,0x60,0x00, 0x42,0x78,0x45,0x69,0x11
	.byte 0x42,0x78,0x45,0x69,0x11, 0x11,0x22,0x23,0x97,0x11
	.byte 0x00,0x00,0x00,0x60,0x00, 0x52,0x88,0x46,0x3A,0x11
	.byte 0x52,0x88,0x56,0x3A,0x11, 0x52,0x88,0x56,0x3C,0x11
	.byte 0x00,0x00,0x00,0x30,0x00, 0x62,0x89,0x57,0x3C,0x11
	.byte 0x62,0x99,0x57,0x3C,0x11, 0x62,0x99,0x57,0x3C,0x11

	.byte 0x00,0x00,0x12,0xC6,0x00, 0x00,0x11,0x22,0xC6,0x00
	.byte 0x00,0x00,0x00,0xC0,0x00, 0x11,0x12,0x23,0x97,0x00
	.byte 0x11,0x12,0x23,0x97,0x00, 0x00,0x11,0x23,0xC7,0x00
	.byte 0x00,0x00,0x00,0x90,0x00, 0x21,0x23,0x33,0x98,0x10
	.byte 0x21,0x24,0x33,0x98,0x10, 0x21,0x25,0x34,0x98,0x10
	.byte 0x00,0x00,0x00,0x60,0x00, 0x22,0x25,0x34,0x68,0x11
	.byte 0x32,0x36,0x44,0x68,0x11, 0x11,0x11,0x23,0x67,0x01
	.byte 0x00,0x00,0x00,0x60,0x00, 0x32,0x36,0x45,0x68,0x11
	.byte 0x32,0x46,0x45,0x69,0x11, 0x32,0x67,0x45,0x69,0x11
	.byte 0x00,0x00,0x00,0x60,0x00, 0x42,0x67,0x46,0x3A,0x11
	.byte 0x42,0x78,0x56,0x3A,0x11, 0x52,0x78,0x56,0x3A,0x11
	.byte 0x00,0x00,0x00,0x30,0x00, 0x52,0x88,0x56,0x3C,0x11
	.byte 0x62,0x99,0x57,0x3C,0x11, 0x62,0x99,0x57,0x3C,0x11

	.byte 0x00,0x00,0x23,0xC6,0x00, 0x10,0x11,0x23,0x97,0x00
	.byte 0x00,0x00,0x00,0xC0,0x00, 0x11,0x12,0x33,0x98,0x00
	.byte 0x21,0x23,0x34,0x68,0x00, 0x21,0x24,0x34,0x68,0x00
	.byte 0x00,0x00,0x00,0x90,0x00, 0x32,0x36,0x34,0x67,0x10
	.byte 0x32,0x46,0x44,0x68,0x10, 0x11,0x11,0x23,0x97,0x10
	.byte 0x00,0x00,0x00,0x60,0x00, 0x42,0x67,0x45,0x68,0x11
	.byte 0x42,0x67,0x45,0x69,0x11, 0x42,0x78,0x46,0x69,0x11
	.byte 0x00,0x00,0x00,0x60,0x00, 0x52,0x78,0x46,0x3A,0x11
	.byte 0x52,0x88,0x56,0x3A,0x11, 0x52,0x88,0x56,0x3A,0x11
	.byte 0x00,0x00,0x00,0x60,0x00, 0x62,0x88,0x56,0x3C,0x11
	.byte 0x62,0x89,0x57,0x3C,0x11, 0x62,0x89,0x57,0x3E,0x11
	.byte 0x00,0x00,0x00,0x30,0x00, 0x72,0x99,0x57,0x3E,0x11
	.byte 0x72,0x99,0x68,0x3E,0x11, 0x72,0x99,0x68,0x3E,0x11

	.byte 0x00,0x00,0x23,0xC6,0x00, 0x10,0x11,0x23,0x97,0x00
	.byte 0x00,0x00,0x00,0xC0,0x00, 0x11,0x12,0x34,0x98,0x00
	.byte 0x21,0x23,0x34,0x68,0x00, 0x21,0x24,0x34,0x68,0x00
	.byte 0x00,0x00,0x00,0x90,0x00, 0x32,0x36,0x45,0x67,0x11
	.byte 0x32,0x46,0x46,0x68,0x11, 0x32,0x56,0x46,0x69,0x11
	.byte 0x00,0x00,0x00,0x60,0x00, 0x42,0x67,0x56,0x6A,0x11
	.byte 0x42,0x67,0x56,0x6A,0x11, 0x42,0x78,0x57,0x6A,0x11
	.byte 0x00,0x00,0x00,0x60,0x00, 0x52,0x78,0x57,0x3A,0x11
	.byte 0x52,0x88,0x57,0x3A,0x11, 0x52,0x88,0x68,0x3C,0x11
	.byte 0x00,0x00,0x00,0x60,0x00, 0x62,0x88,0x68,0x3C,0x11
	.byte 0x62,0x89,0x68,0x3C,0x11, 0x62,0x89,0x68,0x3E,0x11
	.byte 0x00,0x00,0x00,0x30,0x00, 0x72,0x99,0x68,0x3E,0x11
	.byte 0x72,0x99,0x68,0x3E,0x11, 0x72,0x99,0x68,0x3E,0x11


_l_2E75:
*           00003000  _top5_dlg_proc

*

* input file task_man.s
*
* task_man.s
*  gg1-1.3p 'maincpu' (Z80)
*
*  The "task manager" is triggered by the v-blank interrupt (RST 38)
*  thus the base execution rate is 60Hz. Some tasks will implement
*  their own sub-rates (e.g. 1 Hz, 4 Hz etc) by checking a global timer.
*
*  ds_cpu0_task_actv ($20 bytes) is indexed by order of the
*  function pointers in d_cpu0_task_table. Periodic tasks can be prioritized,
*  enabled and disabled by changing the appropriate index in the table.
*  The task enable table is accessed globally allowing one task to enable or
*  disable another task. At startup, actv_task_tbl ($20 bytes) is loaded with
*  a default configuration from ROM.
*
*  In ds_cpu0_task_actv the following values are used:
*   $00 - will skip first entry ($0873) but continue with second
*   $01
*   $1f - execute first then skip to last? (but it sets to $00 again?)
*   $20 - will execute $0873 (empty task) then immediately exit scheduler
*
*
.module task_man

.include "sfrs.inc"
.include "structs.inc"
.include "task_man.dep"

*           00000096  _l_0096                            int0
*.area ROM (ABS,OVR)
*       .org 0x0096
.area CSEG00


*=============================================================================
* d_cpu0_task_table
*  Description:
*   Function pointers to periodic tasks (dispatch table for scheduler)
*   void (* const d_cpu0_task_table[32])(void)
*-----------------------------------------------------------------------------
d_cpu0_task_table:
	.long f_0827
	.long f_0828
	.long f_17B2
	.long f_1700
	.long f_1A80
	.long f_0857
	.long f_0827
	.long f_0827

	.long f_2916
	.long f_1DE6
	.long f_2A90
	.long f_1DB3
	.long f_23DD
	.long f_1EA4
	.long f_1D32
	.long f_0935

	.long f_1B65
	.long f_19B2
	.long f_1D76
	.long f_0827
	.long f_1F85
	.long f_1F04
	.long f_0827
	.long f_1DD2

	.long f_2222
	.long f_21CB
	.long f_0827
	.long f_0827
	.long f_20F2
	.long f_2000
	.long f_0827
	.long f_0977

*=============================================================================
* c_textout_1uphighscore_onetime()
*  Description:
*   display score text top of screen (1 time only after boot)
* IN:
*  ...
* OUT:
*  ...
*-----------------------------------------------------------------------------
c_textout_1uphighscore_onetime:
	lea	0x8000+0x03E0+0x0D(pc),a1      	| [ld   de,#0x8000 + 0x03E0 + 0x0D]
	lea	d_str20000(pc),a0                  	| [ld   hl,#d_str20000] source of string "20000" (stored backwards)
	move.b	#0x00,d1                        	| [ld   bc,#0x0005] strlen 5
	move.b	#0x05,d2                        	| [ld   bc,#0x0005] strlen 5
	jbsr	ldir                              	| [ldir]
     ^^^^ TODO: review special instruction inputs
	move.b	#<<0x03C0+0x0B,d4               	| [ld   e,#<<0x03C0 + 0x0B] $83CB
	lea	d_TxtScore(pc),a0                  	| [ld   hl,#d_TxtScore] source of string "1UP    HIGH SCORE"
	move.b	#0x11,d2                        	| [ld   c,#0x11] strlen
	jbsr	ldir                              	| [ldir]
     ^^^^ TODO: review special instruction inputs
	rts                                    	| [ret]

*=============================================================================
* string "1UP    HIGH SCORE"  (reversed)
d_TxtScore:
	.byte 0x0E,0x1B,0x18,0x0C,0x1C,0x24,0x11,0x10,0x12,0x11,0x24,0x24,0x24,0x24,0x19,0x1E,0x01


*=============================================================================

.ds 0x04                                   ; pad

*=============================================================================
* Home positions of objects in the cylon fleet. Replicated in gg1-5.s
* Refer to diagram:
*
* object[] {
*  location.row    ...index to row pixel LUTs
*  location.column ...index to col pixel LUTs
* }
*                  00 02 04 06 08 0A 0C 0E 10 12
*
*     14                    00 04 06 02            ; captured vipers
*     16                    30 34 36 32            ; base stars
*     18              40 48 50 58 5A 52 4A 42      ; raiders
*     1A              44 4C 54 5C 5E 56 4E 46
*     1C           08 10 18 20 28 2A 22 1A 12 0A
*     1E           0C 14 1C 24 2C 2E 26 1E 16 0E
*
*  organization of row and column pixel position LUTs (fmtn_hpos):
*
*                                       	|<-------------- COLUMNS --------------------->|<---------- ROWS ---------->|
*
*      00   02   04   06   08   0A   0C   0E   10   12   14   16   18   1A   1C   1E
*
*-----------------------------------------------------------------------------
db_obj_home_posn_rc:
	.byte 0x14,0x06,0x14,0x0C,0x14,0x08,0x14,0x0A,0x1C,0x00,0x1C,0x12,0x1E,0x00,0x1E,0x12
	.byte 0x1C,0x02,0x1C,0x10,0x1E,0x02,0x1E,0x10,0x1C,0x04,0x1C,0x0E,0x1E,0x04,0x1E,0x0E
	.byte 0x1C,0x06,0x1C,0x0C,0x1E,0x06,0x1E,0x0C,0x1C,0x08,0x1C,0x0A,0x1E,0x08,0x1E,0x0A
	.byte 0x16,0x06,0x16,0x0C,0x16,0x08,0x16,0x0A,0x18,0x00,0x18,0x12,0x1A,0x00,0x1A,0x12
	.byte 0x18,0x02,0x18,0x10,0x1A,0x02,0x1A,0x10,0x18,0x04,0x18,0x0E,0x1A,0x04,0x1A,0x0E
	.byte 0x18,0x06,0x18,0x0C,0x1A,0x06,0x1A,0x0C,0x18,0x08,0x18,0x0A,0x1A,0x08,0x1A,0x0A


*=============================================================================
* c_sctrl_playfld_clr()
*  Description:
*    clears playfield tileram (not the score and credit texts at top & bottom).
* IN:
*  ...
* OUT:
*  ...
*-----------------------------------------------------------------------------
c_sctrl_playfld_clr:
	lea	0x8000+0x0040(pc),a0           	| [ld   hl,#0x8000 + 0x0040]
	lea	0x8000+0x0041(pc),a1           	| [ld   de,#0x8000 + 0x0041]
	move.b	#0x03,d1                        	| [ld   bc,#0x037F] 895
	move.b	#0x7f,d2                        	| [ld   bc,#0x037F] 895
	move.b	#0x24,(a0)                      	| [ld   (hl),#0x24] clear Tile RAM with $24 (space)
	jbsr	ldir                              	| [ldir]
     ^^^^ TODO: review special instruction inputs
	lea	m_color_ram+0x0040(pc),a0          	| [ld   hl,#m_color_ram + 0x0040] clear Color RAM with $00
	lea	m_color_ram+0x0041(pc),a1          	| [ld   de,#m_color_ram + 0x0041]
	move.b	#0x03,d1                        	| [ld   bc,#0x037F] 895
	move.b	#0x7f,d2                        	| [ld   bc,#0x037F] 895
	clr.b	(a0)                             	| [ld   (hl),#0]
	jbsr	ldir                              	| [ldir]
     ^^^^ TODO: review special instruction inputs

* HL==87bf
* Set the color (red) of the topmost row: let the pointer in HL wrap
* around to the top row fom where it left off from the loop above.
	move.b	#0x04,d0                        	| [ld   a,#0x04]
	move.b	#0x20,d1                        	| [ld   b,#0x20]
	jbsr	rst_18                            	| [rst  0x18] memset((HL), A=fill, B=ct)

* HL==87df
* Set color of 2nd row from top, again retaining pointer value from.
* previous loop. Why $4E? I don't know but it ends up white.
	move.b	#0x4E,d0                        	| [ld   a,#0x4E]
	move.b	#0x20,d1                        	| [ld   b,#0x20]
	jbsr	rst_18                            	| [rst  0x18] memset((HL), A=fill, B=ct)

	rts                                    	| [ret]
* end

*=============================================================================
* stg_splash_scrn()
*  Description:
*   clears a stage (on two-player game, runs at the first turn of each player)
*   Increments stage_ctr (and dedicated challenge stage %4 indicator)
* IN:
*  ...
* OUT:
*  ...
*-----------------------------------------------------------------------------
stg_init_splash:

* plyr_state_active.stage_ctr++
	lea	ds_plyr_actv+_b_stgctr(pc),a0      	| [ld   hl,#ds_plyr_actv +_b_stgctr] ++
	addq.b	#1,(a0)                         	| [inc  (hl)]

* plyr_state_active.not_chllng_stg = *HL & 0x03  ... gives 0 for challenge stage
	move.b	(a0),d0                         	| [ld   a,(hl)]
	addq.b	#1,d0                           	| [inc  a]
	and.b	#0x03,d0                         	| [and  #0x03]
	move.b	d0,ds_plyr_actv+_b_not_chllg_stg	| [ld   (ds_plyr_actv +_b_not_chllg_stg),a] ==(stg_ctr+1)%4 ...i.e. 0 if challenge stage

*  if ( 0 != plyr_state_active.not_chllng_stg ) ...
	jeq	l_01A2_set_challeng_stg            	| [jr   z,l_01A2_set_challeng_stg]
* then {
	move.b	#0x06,d2                        	| [ld   c,#0x06] C=string_out_pe_index
	jbsr	rst_30                            	| [rst  0x30] string_out_pe "STAGE "
* HL == $81B0 ... "X" of STAGE X.
	exg	a1,a0                              	| [ex   de,hl] DE now 81B0 (points to X in "STAGE X")
	move.b	ds_plyr_actv+_b_stgctr,d0       	| [ld   a,(ds_plyr_actv +_b_stgctr)] show score
	move.b	d0,d6                           	| [ld   l,a]
	clr.b	d5                               	| [ld   h,#0]
	jbsr	c_text_out_i_to_d_0A53                 	| [call c_text_out_i_to_d_0A53] Print "X" of STAGE X.
	clr.b	d0                               	| [xor  a] 0 ... start value for wave_bonus_ctr (irrelevant if !challenge)
	jra	l_01AC                             	| [jr   l_01AC]
* } else {
l_01A2_set_challeng_stg:
	move.b	#0x07,d2                        	| [ld   c,#0x07] C=string_out_pe_index
	jbsr	rst_30                            	| [rst  0x30] string_out_pe "CHALLENGING STAGE"
	move.b	#1,d0                           	| [ld   a,#1]
	move.b	d0,b_9AA0+0x0D                  	| [ld   (b_9AA0 + 0x0D),a] 1 ... sound-fx count/enable registers, start challenge stage
	move.b	#8,d0                           	| [ld   a,#8] start value for wave_bonus_ctr (decremented by cpu-b when bug destroyed)
* }

l_01AC:
	move.b	d0,w_bug_flying_hit_cnt         	| [ld   (w_bug_flying_hit_cnt),a] 8 for challenge stage (else 0 i.e. don't care)

* set the timer to synchronize finish of c_new_level_tokens
	move.b	#3,d0                           	| [ld   a,#3]
	move.b	d0,ds4_game_tmrs+2              	| [ld   (ds4_game_tmrs + 2),a] 3

	move.b	d0,ds_9200_glbls+0x0B           	| [ld   (ds_9200_glbls + 0x0B),a] 3: enemy_enable, begin round, needs to be !0 (use 3 for optimization)

* if ( 0 != plyr_actv.b_not_chllg_stg ) Cy' = 0 ... set Cy to inhibit sound clicks for level tokens at challenge stage (1211)
	move.b	ds_plyr_actv+_b_not_chllg_stg,d0	| [ld   a,(ds_plyr_actv +_b_not_chllg_stg)] parameter to sound manager passed through to c_build_token_1
	                               	| [and  a] clear Cy if A != 0
	scs	d7                              	| [ex   af,af']
         ^^^ TODO review: wrong if carry is needed or D7 used in between!
	jbsr	c_new_level_tokens                	| [call c_new_level_tokens] A' == 0 if challenge stg, else non-zero (stage_ct + 1)

* while ( game_tmrs[2] ){}
l_01BF:
	move.b	ds4_game_tmrs+2,d0              	| [ld   a,(ds4_game_tmrs + 2)]
	                               	| [and  a]
	jne	l_01BF                             	| [jr   nz,l_01BF]

* _init_env();

*=============================================================================
* stg_init_env()
*  Description:
*   Initialize new stage environment and handle rack-advance if enabled.
*   This section is broken out so that splash screen can be skipped in demo.
* IN:
*  ...
* OUT:
*  ...
*-----------------------------------------------------------------------------
stg_init_env:
	move.b	#120,d0                         	| [ld   a,#120]
	move.b	d0,ds4_game_tmrs+2              	| [ld   (ds4_game_tmrs + 2),a] load the timer ($78 - new stage)
	jbsr	c_2896                            	| [call c_2896] Initializes each creature by position
	jbsr	c_25A2                            	| [call c_25A2] mob setup

* set game_tmrs[0] (attack formation timing)
	move.b	#2,d0                           	| [ld   a,#2]
	move.b	d0,ds4_game_tmrs+0              	| [ld   (ds4_game_tmrs + 0),a] 2

	clr.b	d0                               	| [xor  a]
	jbsr	c_12C3                            	| [call c_12C3] A == 0 .... set MOB coordinates, new stage

* initialize array (even-bytes)
	clr.b	d0                               	| [xor  a]
	move.b	#0x30,d1                        	| [ld   b,#0x30]
	lea	b_9200_obj_collsn_notif(pc),a0     	| [ld   hl,#b_9200_obj_collsn_notif] 00-5F, even-bytes = 0
l_01DF:
	move.b	d0,(a0)                         	| [ld   (hl),a]
	addq.b	#2,d6                           	| [inc  l] * 2
	subq.b	#1,d1                           	| [...]
	jne	l_01DF                             	| [djnz l_01DF]

	move.b	d0,ds_cpu0_task_actv+0x09       	| [ld   (ds_cpu0_task_actv + 0x09),a] 0  (f_1DE6 ... collective bug movement)
	move.b	d0,ds_cpu0_task_actv+0x10       	| [ld   (ds_cpu0_task_actv + 0x10),a] 0  (f_1B65 ... manage bomber attack )
	move.b	d0,ds_cpu0_task_actv+0x04       	| [ld   (ds_cpu0_task_actv + 0x04),a] 0  (f_1A80 ... bonus-bee manager)

	move.b	d0,b_bug_flyng_hits_p_round     	| [ld   (b_bug_flyng_hits_p_round),a] 0

	move.b	d0,ds_plyr_actv+_b_bmbr_boss_wingm	| [ld   (ds_plyr_actv +_b_bmbr_boss_wingm),a] 0: bomber boss wingman-enable will toggle to 1 on first boss-bomber launch
	move.b	d0,ds_plyr_actv+_b_bbee_tmr     	| [ld   (ds_plyr_actv +_b_bbee_tmr),a] 0: bonus bee launch timer
	move.b	d0,ds_plyr_actv+_b_atk_wv_enbl  	| [ld   (ds_plyr_actv +_b_atk_wv_enbl),a] 0: attack_wave_enable
	move.b	d0,ds_plyr_actv+_b_attkwv_ctr   	| [ld   (ds_plyr_actv +_b_attkwv_ctr),a] 0: atack_wave_ctr

	move.b	d0,b8_99B0_X3attackcfg_ct       	| [ld   (b8_99B0_X3attackcfg_ct),a] 0
	move.b	d0,ds_plyr_actv+_b_nestlr_inh   	| [ld   (ds_plyr_actv +_b_nestlr_inh),a] 0: nest_lr_flag
	addq.b	#1,d0                           	| [inc  a]
	move.b	d0,ds_plyr_actv+_b_bbee_obj     	| [ld   (ds_plyr_actv +_b_bbee_obj),a] 1: bonus_bee_obj_offs
	move.b	d0,ds_plyr_susp+_b_bbee_obj     	| [ld   (ds_plyr_susp +_b_bbee_obj),a] 1
	move.b	d0,ds_plyr_actv+_b_bmbr_boss_cobj	| [ld   (ds_plyr_actv +_b_bmbr_boss_cobj),a] 1: invalidate the capture boss object

	move.b	d0,ds_cpu0_task_actv+0x0B       	| [ld   (ds_cpu0_task_actv + 0x0B),a] 1: f_1DB3 ... Update enemy status.
	move.b	d0,ds_cpu0_task_actv+0x08       	| [ld   (ds_cpu0_task_actv + 0x08),a] 1: f_2916 ... Launches the attack formations
	move.b	d0,ds_cpu0_task_actv+0x0A       	| [ld   (ds_cpu0_task_actv + 0x0A),a] 1: f_2A90 ... left/right movement of collective while attack waves coming
	jbsr	c_2C00                            	| [call c_2C00] new stage setup

	lea	ds_plyr_actv+_ds_bmbr_boss_scode(pc),a0	| [ld   hl,#ds_plyr_actv +_ds_bmbr_boss_scode] set 8 bytes "01B501B501B501B5"
	lea	l_0100+0x80+0x35(pc),a1            	| [ld   de,#0x0100 + 0x80 + 0x35] 400 sprite (d = $04 - $03)
	move.b	#4,d1                           	| [ld   b,#4]
l_0220:
	move.b	d3,(a0)                         	| [ld   (hl),d]
	addq.b	#1,d6                           	| [inc  l]
	move.b	d4,(a0)                         	| [ld   (hl),e]
	addq.b	#1,d6                           	| [inc  l]
	subq.b	#1,d1                           	| [...]
	jne	l_0220                             	| [djnz l_0220]

*  if ( !RackAdvance ) return (active low)
	move.b	_sfr_dsw6,d0                    	| [ld   a,(_sfr_dsw6)] DSWA rack advance operation
	btst.b	#1,d0                           	| [bit  1,a]
	beq.b	0f                               	| [...]
	rts                                    	| [ret  nz] _plyr_startup [...]
0:
*  else handle rack advance operation
	move.b	#0x0B,d2                        	| [ld   c,#0x0B]
	lea	0x8000+0x03A0+0x10(pc),a0      	| [ld   hl,#0x8000 + 0x03A0 + 0x10]
	jbsr	c_string_out                      	| [call c_string_out] erase "stage X" text"

	jra	stg_init_splash                    	| [jp   stg_init_splash] start over again


*=============================================================================
* jp_Task_man()
*  Description:
*   handler for rst $38
*   Updates star control registers.
*   Executes the Scheduler.
*   Sets IO chip for control input.
*   The task enable table is composed of 1-byte entries corresponding to each
*   of $20 tasks. Each cycle starts at task[0] and advances an index for each
*   entry in the table. The increment value is actually obtained from the
*   task_enable table entry itself, which is normally 1, but other values are
*   also used, such as $20. The "while" logic exits at >$20, so this is used
*   to exit the task loop without iterating through all $20 entries. Tthe
*   possible enable values are:
*     $00 - disables task
*     $01 - enables task_man
*     $0A -
*     $1F -   1F + 0A = $29     (where else could $0A be used?)
*     $20 - exit current task man step after the currently executed task.
* IN:
*  ...
* OUT:
*  ...
*-----------------------------------------------------------------------------
jp_Task_man:
	move.w	d0,-(sp)                        	| [push af]
	scs	d7                              	| [ex   af,af']
         ^^^ TODO review: wrong if carry is needed or D7 used in between!
	move.w	d0,-(sp)                        	| [push af]
	movem.w	d1/d2,-(sp)                    	| [push bc]
	movem.w	d3/d4,-(sp)                    	| [push de]
	move.l	a1,-(sp)                        	| [push de]

	move.l	a0,-(sp)                        	| [push hl]

	move.l	a2,-(sp)                        	| [push ix]

	move.l	a3,-(sp)                        	| [push iy]

* determine star_ctrl param bits based on some modulus of frame timer?
* $A000-$A005 starfield scroll speed (only bit 0 is significant)
	move.b	_sfr_dsw5,d0                    	| [ld   a,(_sfr_dsw5)] DSWA: freeze video
	move.b	d0,d3                           	| [ld   d,a]
	move.b	ds3_92A0_frame_cts+0,d0         	| [ld   a,(ds3_92A0_frame_cts + 0)]
	and.b	#0x1C,d0                         	| [and  #0x1C] 0000XXX0
	move.b	d0,d2                           	| [ld   c,a]
	ror.b	#1,d0                            	| [rrca] 00000XXX
	eor.b	d2,d0                            	| [xor  c] A ^ C
	and.b	#0x18,d0                         	| [and  #0x18] 000XX000
	move.b	d0,d2                           	| [ld   c,a]

*  if ( ! freezed_dsw set )
	move.b	ds_99B9_star_ctrl+0x05,d0       	| [ld   a,(ds_99B9_star_ctrl + 0x05)]
	btst.b	#1,d3                           	| [bit  1,d] freeze_ctrl_dsw
	jne	l_0259                             	| [jr   nz,l_0259]
*  else
	move.b	#7,d0                           	| [ld   a,#7] 7==star_ctrl_bits=freezed

l_0259:
	and.b	#0x07,d0                         	| [and  #0x07]
	or.b	d2,d0                             	| [or   c]

	move.b	#5,d1                           	| [ld   b,#5]
	lea	l_A000(pc),a0                      	| [ld   hl,#0xA000] star_ctrl_port

l_0261:
	move.b	d0,(a0)                         	| [ld   (hl),a] A==star_ctrl_bits
	addq.b	#1,d6                           	| [inc  l]
	ror.b	#1,d0                            	| [rrca] star_ctrl_bits >>= 1
	subq.b	#1,d1                           	| [...]
	jne	l_0261                             	| [djnz l_0261]

	move.b	d0,_sfr_watchdog                	| [ld   (_sfr_watchdog),a]

	clr.b	d0                               	| [xor  a]
	move.b	d0,_sfr_6820                    	| [ld   (_sfr_6820),a] 0 ... disable IRQ1

*  if ( freezed )  exit
	btst.b	#1,d3                           	| [bit  1,d]
	jeq	l_02A8_pop_regs_and_exit           	| [jp   z,l_02A8_pop_regs_and_exit]

*
* Execute the Scheduler
*
	move.b	d0,d2                           	| [ld   c,a] A == 0 ... initialize index into Task Enable Table

l_while_index:
l_while_zero:
* while ( 0 == A = *(task_activ_tbl + C) )  C++   ... loop until non-zero: assumes we will find a valid entry in the table!
	lea	ds_cpu0_task_actv(pc),a0           	| [ld   hl,#ds_cpu0_task_actv]
	move.b	d2,d0                           	| [ld   a,c]
	add.b	d6,d0                            	| [add  a,l]
	move.b	d0,d6                           	| [ld   l,a]
	move.b	(a0),d0                         	| [ld   a,(hl)] task_activ_tbl[index]
	                               	| [and  a]
	jne	l_0280_nonzero_tbl_entry           	| [jr   nz,l_0280_nonzero_tbl_entry]
	addq.b	#1,d2                           	| [inc  c]
	jra	l_while_zero                       	| [jr   l_while_zero]

l_0280_nonzero_tbl_entry:
* save the table entry for later...
	move.b	d0,d1                           	| [ld   b,a] *(task_activ_tbl + C)
* multiply index 'C' by 2 to form a 16-bit function pointer
* p_taskfn = d_cpu0_task_table[C]
	lea	d_cpu0_task_table(pc),a0           	| [ld   hl,#d_cpu0_task_table]
	move.b	d2,d0                           	| [ld   a,c] index
	asl.b	#1,d0                            	| [sla  a] <<=2 ... sizeof 16-bit function pointer
	add.b	d6,d0                            	| [add  a,l]
	move.b	d0,d6                           	| [ld   l,a]
	move.b	(a0),d4                         	| [ld   e,(hl)] lo-byte of pointer
	addq.w	#1,a0                           	| [inc  hl]
	move.b	(a0),d3                         	| [ld   d,(hl)] hi-byte of pointer
	exg	a1,a0                              	| [ex   de,hl] jp address in HL

	movem.w	d1/d2,-(sp)                    	| [push bc]
	jbsr	c_task_switcher                   	| [call c_task_switcher] p_taskfn()

	movem.w	(sp)+,d1/d2                    	| [pop  bc]

*    index+=task_activ_tbl[index]
	move.b	d1,d0                           	| [ld   a,b] *(task_activ_tbl + C)
	add.b	d2,d0                            	| [add  a,c] +=index
	move.b	d0,d2                           	| [ld   c,a]

* while (index < $20)
	and.b	#0xE0,d0                         	| [and  #0xE0] control values are $00, $01, $20, $1f
	jeq	l_while_index                      	| [jr   z,l_while_index]

* setup regs for input from IO chip
	lea	l_7000(pc),a0                      	| [ld   hl,#0x7000] IO data xfer (read)
	lea	ds3_99B5_io_input+0x00(pc),a1      	| [ld   de,#ds3_99B5_io_input + 0x00] read 3 bytes
	move.b	#0x00,d1                        	| [ld   bc,#0x0003] 3
	move.b	#0x03,d2                        	| [ld   bc,#0x0003] 3
	jbsr	exx                               	| [exx]
     ^^^^ TODO: review special instruction inputs

* send command to IO chip
	move.b	#0x71,d0                        	| [ld   a,#0x71] cmd==read ctrl inputs
	*move.b	d0,0x7100                       	| [ld   (0x7100),a] IO cmd ($71 -> enable NMI to trigger when data is available)
          ^^^^^^ TODO: review absolute 16-bit address write

l_02A8_pop_regs_and_exit:
	move.b	#1,d0                           	| [ld   a,#1]
	move.b	d0,_sfr_6820                    	| [ld   (_sfr_6820),a] 1 ... enable IRQ1

	move.l	(sp)+,a3                        	| [pop  iy]
	move.l	(sp)+,a2                        	| [pop  ix]
	move.l	(sp)+,a0                        	| [pop  hl]
	move.l	(sp)+,a1                        	| [pop  de]
	movem.w	(sp)+,d3/d4                    	| [pop  de]

	movem.w	(sp)+,d1/d2                    	| [pop  bc]
	move.w	(sp)+,d0                        	| [pop  af]
	scs	d7                              	| [ex   af,af']
	move.w	(sp)+,d0                        	| [pop  af]
ei
	rts                                    	| [ret]
* } end 'rst  $0038' handler

*=============================================================================
d_str20000:
	.byte 0x00,0x00,0x00,0x00,0x02,0x24  || "20000" (reversed)
d_strScore:
	.byte 0x17,0x0A,0x16,0x0C,0x18       || "SCORE" (reversed)

*=============================================================================
* RESET()
*  Description:
*   jp here from z80 reset vector
* IN:
*  ...
* OUT:
*  ...
*-----------------------------------------------------------------------------
CPU0_RESET:
* set interrupt mode
im   1

* memset(mchn_data,0,$10)
	clr.b	d0                               	| [xor  a]
	lea	ds10_99E0_mchn_data(pc),a0         	| [ld   hl,#ds10_99E0_mchn_data] clear $10 bytes
	move.b	#0x10,d1                        	| [ld   b,#0x10]
l_02CC:
	move.b	d0,(a0)                         	| [ld   (hl),a]
	addq.w	#1,a0                           	| [inc  hl]
	subq.b	#1,d1                           	| [...]
	jne	l_02CC                             	| [djnz l_02CC]

* let the fun begin!
	jra	jp_RAM_test                        	| [jp   jp_RAM_test]


_l_02D3:
*           000002D3  j_Game_init_02d3                        game_ctrl

*

* < A0 (HL)
* < D0 (A)
rld:
    movem.w    d1/d2,-(a7)
    move.b    d0,d1        | backup A
    clr.w    d2            | make sure high bits of D2 are clear
    move.b    (a0),d2       | read (HL)
    and.b #0xF,d1        | keep 4 lower bits of A
    lsl.w    #4,d2       | make room for 4 lower bits
    or.b    d1,d2        | insert bits
    move.b    d2,(a0)        | update (HL)
    lsr.w    #8,d2        | get 4 shifted bits of (HL)
    and.b    #0xF0,d0    | keep only the 4 highest bits of A
    or.b    d2,d0        | insert high bits from (HL) into first bits of A
    movem.w    (a7)+,d1/d2
    rts


* < A0: source (HL)
* < A1: destination (DE)
* < D1: decremented (16 bit)
ldd:
    move.b    (a0),(a1)
    subq.w  #1,a0
    subq.w  #1,a1
    subq.w    #1,d1
    rts

* < A0: source (HL)
* < A1: destination (DE)
* < D1: decremented (16 bit)
ldi:
    move.b    (a0)+,(a1)+
    subq.w    #1,d1
    rts

* < A0: source (HL)
* < A1: destination (DE)
* < D1: length (16 bit)
ldir:
    subq.w    #1,d1
0:
    move.b    (a0)+,(a1)+
    dbf        d1,0b
    clr.w    d1
    rts

* < A0: source (HL)
* < D1: decremented
* > D0.B value searched for (A)
* > Z flag if found
* careful: d1 overflow not emulated
cpi:
    subq.w    #1,d1
    cmp.b    (a0)+,d0
    rts

* < all registers d1-d4/a0/a1/a4
* > all registers swapped
*: note regscopy must be defined somewhere in RAM
*: with a size of 56
exx:
    lea     regscopy+28,a6
    * save current regs in region 1
    movem.l d1-d4/a0/a1/a4,-(a6)
    * restore old regs from region 2
    lea     regscopy+28,a6
    movem.l (a6),d1-d4/a0/a1/a4
    * now copy region 1 to region 2
    movem.l d1-d4/a0/a1/a4,-(a7)
    lea     regscopy,a6
    movem.l (a6)+,d1-d4/a0/a1/a4
    movem.l d1-d4/a0/a1/a4,(a6)
    movem.l (a7)+,d1-d4/a0/a1/a4
    rts
