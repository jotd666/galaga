	.include	"m68k_macros.inc"
	.include	"galaga.inc"
	
* input file game_ctrl.s
*
* game_ctrl.s:
*  gg1-1.3p 'maincpu' (Z80)
*
*  Manage high-level game control.
*
*  j_Game_init_02d3:
*      One time entry from power-up routines.
*  g_main_035a:
*      Initializes game state. Starts with Title Screen, or "Press Start"
*      screen if credit available.
*  plyr_respawn_splsh:
*      Sets up each new stage.
*  jp_045E_While_Game_Run:
*      Continous loop once the game is started, until gameover.
*
*  The possible modes of operation are (from the Bally Manual):
*    ATTRACT, READY-TO-PLAY, PLAY, HIGH SCORE INITIAL, and SELF-TEST."
*
*
* video:
* status screen (2 first rows)
* 0x83DD: top leftmost visible character (line 0)
* 0x83C2: top rightmost visible character (83C0 & 83C1 are not visible) (line 0)
* 0x83FD: leftmost visible character (line 1)
* 0x83E2: rightmost visible character (83E0 & 83E1 are not visible) (line 1)
*
* playfield
*
*
* 
* status screen (2 last rows)
* 0x803D: bottom left visible character (line 35)
* 0x8022: bottom right visible character (8020 & 8021 are not visible) (line 35)

	.global		galaga_reset
	.global		galaga_irq


*=============================================================================
* por_inits()
*  Description:
*   Once per poweron/reset (following hardware inits) do inits for screen and
*   etc. prior to invoking "main".
* IN:
*  ...
* OUT:
*  ...
*-----------------------------------------------------------------------------
j_Game_init_02d3:
	*lea	ds_stk_cpu0_init,a7  | [ld   sp,#ds_stk_cpu0_init]

	
*  memset(ds4_game_tmrs_92ac,0,4)
	clr.b	d0                               	| [xor  a]
	lea	ds4_game_tmrs_92ac,a0             	    | [ld   hl,#ds4_game_tmrs_92ac + 0] memset(...,0,4)
	move.b	#4,d1                           	| [ld   b,#4]
	jbsr	rst_18                            	| [rst  0x18] memset((HL), A=fill, B=ct)

*  memset($9aa0,0,$20)
	lea	ds_9AA0,a0                     	        | [ld   hl,#ds_9AA0] memset(...,0,$20) ... count/enable registers for sound effects
	move.b	#0x20,d1                        	| [ld   b,#0x20]
	jbsr	rst_18                            	| [rst  0x18] memset((HL), A=fill, B=ct)

	*move.b	d0,0xA007                       	| [$02E3: ld   (0xA007),a] 0 (not_flipped)
	move.b	d0,b_9215_flip_screen           	| [$02E6: ld   (b_9215_flip_screen),a] 0 (not_flipped)
	move.b	d0,ds_99B9_star_ctrl+0          	| [$02E9: ld   (ds_99B9_star_ctrl + 0),a] 0 ...1 when ship on screen

* memset($92ca,$ff,$10) ... bmbr_boss_slots[] is only 12 bytes, so this initialization would
* include b_CPU1_in_progress + b_CPU2_in_progress + 2 unused bytes
	subq.b	#1,d0                           	| [$02EC: dec  a] = $FF
	lea	bmbr_boss_pool_92ca,a0              	| [$02ED: ld   hl,#bmbr_boss_pool_92ca] memset( ... , $FF, $10 )
	move.b	#0x10,d1                        	| [$02F0: ld   b,#0x10]
	jbsr	rst_18                            	| [$02F2: rst  0x18] memset((HL), A=fill, B=ct)

* galaga_interrupt_enable_1_w  seems to already be set, but we make sure anyway.
* JOTD: let's NOT enable it for now, wait for task table to be initialized
	*move.b	#1,d0                           	| [ld   a,#1]
	*jbsr	osd_interrupt_control                    	| [ld   (_sfr_6820),a] 1 ,,,enable IRQ1

* The test grid is now cleared from screen. Due to odd organization of tile ram
* it is done in 3 steps. 1 grid row is cleared from top and bottom (each grid
* row is 2 tile rows). Then, there is a utility function to clear the actual
* playfield area.

*  memset($83c0,$24,$40)
	move.w	#0x83C0,a0           	| $02F8: [ld   hl,#0x8000 + 0x03C0] clear top 2 tile rows ($40 bytes)
	move.b	#0x40,d1                        	| [ld   b,#0x40]
	move.b	#0x24,d0                        	| [ld   a,#0x24] "space" character
	jbsr	rst_18_video                            	| [rst  0x18] memset((HL), A=fill, B=ct)

*  memset($8000,$24,$40)
	move.w	#0x8000,a0                   	| [ld   h,#>0x8000] clear bottom 2 tile rows ($40 bytes)
	move.b	#0x40,d1                        	| [ld   b,#0x40]
	jbsr	rst_18_video                            	| [rst  0x18] memset((HL), A=fill, B=ct)

*  memset($8400,$03,$40)
	move.w	#0x8400,a0                 	| [ld   hl,#m_color_ram] $40 bytes (code 03)
	move.b	#0x40,d1                        	| [ld   b,#0x40]
	move.b	#0x03,d0                        	| [ld   a,#0x03]
	jbsr	rst_18_color                            	| [rst  0x18] memset((HL), A=fill, B=ct)


	jbsr	c_sctrl_playfld_clr_0160               	| [call c_sctrl_playfld_clr_0160] clear remainder of grid pattern from the playfield tiles (14x16)
* all tile ram is now wiped

* Sets up "Heroes" screen
	lea	b_best5_score,a1               	|  [$0313: ld   de,#b_best5_score] 1st score (100000's)
	move.b	#5,d0                           	| [ld   a,#5]
	                              	| [ld   b,#0]
l_0317:
	lea	d_str20000,a0                  	| [ld   hl,#d_str20000] "00002 " (20000 reversed)
	move.w	#0x06,d1                        	| [ld   c,#0x06]
	jbsr	ldir                              	| [ldir]
 	subq.b	#1,d0                           	| [dec  a]
	jne	l_0317                             	| [jr   nz,l_0317]


	lea	d_strScore,a0                  	| [ld   hl,#d_strScore] "SCORE" (reversed)
	move.b	#0x2A,d0                        	| [ld   a,#0x2A] period character '.'
	move.w	#0x05FF,d1                        	| [ld   b,#0x05]
	move.w	#5-1,d2											| [ld   c,#0xFF]
* de==8a3e
l_032A:
	jbsr	ldi                               	| [ldi]
	subq.w	#1,a0                           	| [dec  hl]
	move.b	d0,(a1)+                         	| [ld   (de),a]
												| [inc  e]
	jbsr	ldi                               	| [ldi]
	                           	| [...]
	dbf		d2,l_032A                             	| [djnz l_032A]

	
* initialize game state
	move.b	#0x01,d0                        	| [$0333: ld   a,#0x01]
	move.b	d0,b8_game_state_9201           	| [ld   (b8_game_state_9201),a] 1 == ATTRACT_MODE

	*lea	l_A005,a0                      	| [ld   hl,#0xA005] star_ctrl_port_bit6 -> 0, then 1
	*clr.b	(a0)                             	| [ld   (hl),#0]
	*move.b	d0,(a0)                         	| [ld   (hl),a]

	jbsr	c_sctrl_sprite_ram_clr_003c            	| [call c_sctrl_sprite_ram_clr_003c]

* display 1UP HIGH SCORE 20000 (1 time only after boot)
	jbsr	c_textout_1uphighscore_onetime    	| [call c_textout_1uphighscore_onetime]


	
	jbsr	c_init_taskman_structs_1230       	| [call c_init_taskman_structs_1230]

* data structures for 12 objects
	jbsr	rst_28                            	| [rst  0x28] memset(mctl_mpool,0,$$14 * 12)


* Not sure here...
* this would have the effect of disabling/skipping the task at 0x1F (f_credit_game_state_management_0977)
* which happens to relate to updating the credit count (although, there is no
* RST 38 to actually trigger the task from now until setting this to 0 below.)

* cpu0_task_activ[0x1E] = 0x20
	move.b	#0x20,d0                        	| [ld   a,#0x20]
	move.b	d0,ds_cpu0_task_actv_9000+0x1E       	| [ld   (ds_cpu0_task_actv_9000 + 0x1E),a] $20

* credit_cnt = io_input[0]
	move.b	ds3_io_input_99b5,d0       			| [ld   a,(ds3_io_input_99b5 + 0x00)] credit_count
	move.b	d0,b8_99B8_credit_cnt           	| [ld   (b8_99B8_credit_cnt),a] credit_cnt = io_input[credit_count]

* cpu0_task_activ[0x1E] = 0
	clr.b	d0                               	| [xor  a]
	move.b	d0,ds_cpu0_task_actv_9000+0x1E       	| [ld   (ds_cpu0_task_actv_9000 + 0x1E),a] 0 ... just wrote $20 here see above
	move.b	d0,ds_cpu1_task_actv+0x00       	| [ld   (ds_cpu1_task_actv + 0x00),a] 0 ... CPU1:f_05BE (empty task)

	* JOTD: enable interrupts only now, as else there seems to exist a race condition
	* between interrupt and this code, and interrupt may scan the tasks before they're initialized
	* and crash or lockup the game
	moveq	#1,d0
	jbsr	osd_interrupt_control

*=============================================================================
* g_main_035a()
*  Description:
*    Performs initialization, and does a one-time check for credits
*    (monitoring credit count and updating "GameState" is otherwise handled
*    by a 16mS task). If credits available at startup, it updates "GameState"
*    and skips directly to "Ready" state, otherwise it
*    stays in Attract mode state.
*
*    Resumes here following completion of a game.
* IN:
*  ...
* OUT:
*  ...
*-----------------------------------------------------------------------------
g_main_035a:
	clr.b	d0                               	| [xor  a]
	*move.b	d0,0xA007                       	| [ld   (0xA007),a] 0 (not_flipped)
	move.b	d0,b_9215_flip_screen           	| [ld   (b_9215_flip_screen),a] 0 (not_flipped)

* disable f_star_control_1d76 - star control ... why? ... should be taken care of by init_taskman_structs ...below
* task_activ_tbl[0x12] = 0
	move.b	d0,ds_cpu0_task_actv_9000+0x12       	| [ld   (ds_cpu0_task_actv_9000 + 0x12),a] 0 ... f_star_control_1d76

* The object-collision notification structures are cleared
* at every beginning of round (and demo), so I am guessing the intent here is to
* clear the globals that share the $80 byte block

* memset($9200,0,$80) ... object-collision notification  and other
	move.b	#0x80,d1                        	| [ld   b,#0x80]
	lea	ds_9200,a0                     	| [ld   hl,#ds_9200] memset(...,0,$80)
	jbsr	rst_18                            	| [rst  0x18] memset((HL), A=fill, B=ct)

* star_ctrl_param=6
	move.b	#6,d0                           	| [ld   a,#6]
	move.b	d0,ds_99B9_star_ctrl+0x05       	| [ld   (ds_99B9_star_ctrl + 0x05),a] 6

* array of object movement structures etc.
	jbsr	rst_28                            	| [rst  0x28] memset(mctl_mpool,0,$$14 * 12)
	jbsr	c_sctrl_sprite_ram_clr_003c            	| [$0370: call c_sctrl_sprite_ram_clr_003c] clear sprite mem etc.
	jbsr	c_init_taskman_structs_1230       	| [$0373: call c_init_taskman_structs_1230]
* allow attract-mode festivities to be skipped if credit available
* if ( credit_cnt == 0 )  game_state = ATTRACT_MODE
	                               	| 
	move.b	#1,d0                           	| [ld   a,#1] 1 == ATTRACT_MODE
	tst.b	b8_99B8_credit_cnt           	| [ld   a,(b8_99B8_credit_cnt)]+[and  a]
	jeq	l_0380                             	| [jr   z,l_0380]
* else  game_state = READY_TO_PLAY_MODE
	move.b	#2,d0                           	| [ld   a,#2] 2 == READY_TO_PLAY_MODE
l_0380:
	move.b	d0,b8_game_state_9201           	| [ld   (b8_game_state_9201),a] = (credit_cnt==0 ? ATTRACT : READY) ... (m/c start, game_state init)

* if ( credit_cnt == 0 ) ...
	tst.b	b8_99B8_credit_cnt
	jne	l_game_state_ready_039d                 	| [jr   nz,l_game_state_ready_039d]

* ... do attract mode stuff
	clr.b	d0                               	| [xor  a]
	move.b	d0,ds_9200_glbls+0x03           	| [ld   (ds_9200_glbls + 0x03),a] demo_idx = 0

* task_activ_tbl[F_ATTRMODECTRL] = 1
	addq.b	#1,d0                           	| [inc  a]
	move.b	d0,ds_cpu0_task_actv_9000+0x02       	| [ld   (ds_cpu0_task_actv_9000 + 0x02),a] 1 ... f_manage_attract_mode_17B2 (attract-mode control)

	lea		ds_cpu0_task_actv_9000,a0
	
* while (game_state == ATTRACT_MODE) { | }
l_038D_while:
	move.b	b8_game_state_9201,d0           	| [$038D: ld   a,(b8_game_state_9201)] while (ATTRACT_MODE)
	subq.b	#1,d0                           	| [dec  a]
	jeq	l_038D_while                       	    | [jr   z,l_038D_while]

* JOTD: game start!!

* GameState == Ready ... reinitialize everthing
	jbsr	c_init_taskman_structs_1230       	| [$0393: call c_init_taskman_structs_1230]
	jbsr	c_sctrl_playfld_clr_0160           	| [$0396: call c_sctrl_playfld_clr_0160]
	jbsr	rst_28                            	| [$0399: rst  0x28] memset(mctl_mpool,0,$$14 * 12)
	jbsr	c_sctrl_sprite_ram_clr_003c        	| [$039A: call c_sctrl_sprite_ram_clr_003c]

* game_state == READY

l_game_state_ready_039d:
	clr.b	d0                               	| [$039D: xor  a]
	move.b	d0,ds_9200_glbls+0x0B           	| [$039E: ld   (ds_9200_glbls + 0x0B),a] 0 ... glbl_enemy_enbl: cleared in case demo was running
	move.b	#0x13,d2                        	| [$03A1: ld   c,#0x13] C = string_out_pe_index
	jbsr	string_out_pe_30                    | [$03A3: rst  0x30] string_out_pe "(c) 1981 NAMCO LTD"
	move.b	#1,d2                           	| [$03A4: ld   c,#1] C = string_out_pe_index
	jbsr	string_out_pe_30                    | [$03A6: rst  0x30] string_out_pe "PUSH START BUTTON"
	lea	d_attrmode_sptiles_ships,a0    	        | [$03A7: ld   hl,#d_attrmode_sptiles_ships]
	move.l	a0,p_attrmode_sptiles_9280          | [$03AA: ld   (p_attrmode_sptiles_9280),hl] &_attrmode_sptiles[0] ... parameter to _sprite_tiles_displ()

* if ( 0xFF == mchn_cfg_bonus[0] ) goto l_While_Ready
	move.b	w_mchn_cfg_bonus_9980+0,d0          | [$03AD: ld   a,(w_mchn_cfg_bonus_9980 + 0)]
	cmp.b	#0xFF,d0                         	| [$03B0: cp   #0xFF]
	jeq	j_0003D8_wrdy                      	    | [$03B2: jr   z,j_0003D8_wrdy]
	move.b	d0,d4                           	| [$03B4: ld   e,a] E=bonus score digit
	move.b	#0x1B,d2                        	| [$03B5: ld   c,#0x1B] C=string_out_pe_index
	jbsr	c_game_bonus_info_show_line_043d 	| [$03B7: call c_game_bonus_info_show_line_043d]

* if ( 0xFF == mchn_cfg_bonus[1] ) goto l_While_Ready
	move.b	w_mchn_cfg_bonus_9980+1,d0          | [$03BA: ld   a,(w_mchn_cfg_bonus_9980 + 1)]
	cmp.b	#0xFF,d0                         	| [$03BD: cp   #0xFF]
	jeq	j_0003D8_wrdy                      	    | [$03BF: jr   z,j_0003D8_wrdy]
	and.b	#0x7F,d0                         	| [$03C1: and  #0x7F]
	move.b	d0,d4                           	| [$03C3: ld   e,a] E=bonus score digit
	move.b	#0x1C,d2                        	| [$03C4: ld   c,#0x1C] C=string_out_pe_index
	jbsr	c_game_bonus_info_show_line_043d  	| [$03C6: call c_game_bonus_info_show_line_043d] bugs from demo mode have disappeared!

* if bit 7 is set, the third bonus award does not apply
	move.b	w_mchn_cfg_bonus_9980+1,d0          | [$03C9: ld   a,(w_mchn_cfg_bonus_9980 + 1)]
	btst.b	#7,d0                           	| [$03CC: bit  7,a]
	jne	j_0003D8_wrdy                      	    | [$03CE: jr   nz,j_0003D8_wrdy]
	and.b	#0x7F,d0                         	| [$03D0: and  #0x7F]
	move.b	d0,d4                           	| [$03D2: ld   e,a] E=bonus score digit
	move.b	#0x1D,d2                        	| [$03D3: ld   c,#0x1D] C=string_out_pe_index
	jbsr	c_game_bonus_info_show_line_043d    | [$03D5: call c_game_bonus_info_show_line_043d]

* while (game_state == READY_TO_PLAY_MODE)
j_0003D8_wrdy:
	move.b	b8_game_state_9201,d0           	| [ld   a,(b8_game_state_9201)] while (READY)
	cmp.b	#2,d0                            	| [cp   #2] READY_TO_PLAY_MODE
	jeq	j_0003D8_wrdy                     	    | [jr   z,l_0003D8]

* /****  start button was hit ******************/

	**move.b	d0,b_9AA0+0x17                  	| [ld   (b_9AA0 + 0x17),a] sound_mgr_reset: non-zero causes re-initialization of sound mgr process

* clear sprite mem etc.
	jbsr	c_sctrl_playfld_clr_0160               	| [call c_sctrl_playfld_clr_0160]
	jbsr	c_sctrl_sprite_ram_clr_003c            	| [call c_sctrl_sprite_ram_clr_003c]

* stars paused
	*lea	l_A005,a0                      	| [ld   hl,#0xA005] star_ctrl_port_bit6 -> 0, then 1
	*clr.b	(a0)                             	| [ld   (hl),#0]
	*move.b	#1,(a0)                         	| [ld   (hl),#1]

* Not sure about the intent of clearing $A0 bytes.. player data and resv data are only $80 bytes.
* The structure at 98B0 is $30 bytes so it would not all be cleared (only $10 bytes)
*  memset( player_data, 0, $a0 )
	lea	ds_plyr_data,a0                	| [ld   hl,#ds_plyr_data] memset( ..., 0, $a0 )
	clr.b	d0                               	| [xor  a]
	move.b	#0xA0,d1                        	| [ld   b,#0xA0]
	jbsr	rst_18                            	| [rst  0x18] memset((HL), A=fill, B=ct)

*ld hl, ds_plyr_actv +_b_stgctr   | HELP_ME_DEBUG
*ld (hl), #6

	*move.b	d0,b_9AA0+0x17                  	| [ld   (b_9AA0 + 0x17),a] 0 ... do not reset sound mgr process?

	*move.b	d0,ds_99B9_star_ctrl+0x00       	| [ld   (ds_99B9_star_ctrl + 0x00),a] 0 ... star ctrl stop (1 when ship on screen)

	*addq.b	#1,d0                           	| [inc  a]
	*move.b	d0,b_9AA0+0x0B                  	| [ld   (b_9AA0 + 0x0B),a] 1 ... sound-fx count/enable registers, start of game theme
	move.w	#GAME_START_SND,d0
	jbsr	osd_sound_start
	
	moveq	#1,d0
	move.b	d0,ds_cpu0_task_actv_9000+0x12       	| [ld   (ds_cpu0_task_actv_9000 + 0x12),a] 1 ... f_star_control_1d76, star ctrl
	move.b	d0,ds_cpu0_task_resrv+0x12      	| [ld   (ds_cpu0_task_resrv + 0x12),a] 1 ... f_star_control_1d76, star ctrl

* do one-time inits
	jbsr	gctl_game_init                    	| [call gctl_game_init] setup number of lives and show player score(s) '00'
	jbsr	c_game_or_demo_init               	| [call c_game_or_demo_init]

	move.b	#4,d2                           	| [ld   c,#4] C=string_out_pe_index
	jbsr	string_out_pe_30                            	| [rst  0x30] string_out_pe "PLAYER 1" (always starts with P1 no matter what!)

* busy loop -leaves "Player 1" text showing while some of the opening theme music plays out
* game_tmr_3 = 8|
	lea	ds4_game_tmrs_92ac+3,a0             	| [ld   hl,#ds4_game_tmrs_92ac + 3] = 8 ... while ! 0
	move.b	#8,(a0)                         	| [ld   (hl),#8]
l_0414_while_tmr_3:
	move.b	(a0),d0                         	| [ld   a,(hl)]
	                               	| [and  a]
	jne	l_0414_while_tmr_3                 	| [jr   nz,l_0414_while_tmr_3]

* memset($9290,$10,0)
	lea	ds_bug_collsn_hit_mult,a0      	| [ld   hl,#ds_bug_collsn_hit_mult] memset(...,$10,0)
	move.b	#0x10,d1                        	| [ld   b,#0x10]
	jbsr	rst_18                            	| [rst  0x18] memset((HL), A=fill, B=ct)

* memset($98B0,$30,0)
	move.b	#0x30,d1                        	| [ld   b,#0x30]
	lea	ds_susp_plyr_obj_data,a0       	| [ld   hl,#ds_susp_plyr_obj_data] memset(...,$30,0)
	jbsr	rst_18                            	| [rst  0x18] memset((HL), A=fill, B=ct)

* settext($0b, $83b0)
	lea	0x8000+0x03B0,a0           	| [ld   hl,#0x8000 + 0x03B0]
	move.b	#0x0B,d2                        	| [ld   c,#0x0B] index into string table
	jbsr	c_string_out_1398                      	| [call c_string_out_1398] erase PLAYER 1 text

	move.b	#1,d0                           	| [ld   a,#1]
	move.b	d0,ds_plyr_susp+_b_plyr_nbr     	| [ld   (ds_plyr_susp +_b_plyr_nbr),a] 1==plyr2

	move.b	w_mchn_cfg_bonus_9980,d0             	| [ld   a,(w_mchn_cfg_bonus_9980)]
	move.b	d0,ds_plyr_actv+_b_mcfg_bonus   	| [ld   (ds_plyr_actv +_b_mcfg_bonus),a]
	move.b	d0,ds_plyr_susp+_b_mcfg_bonus   	| [ld   (ds_plyr_susp +_b_mcfg_bonus),a]

	jra	plyr_respawn_splsh                 	| [jp   plyr_respawn_splsh] does not return, jp's to _game_runner

* end

*=============================================================================
* c_game_bonus_info_show_line_043d()
*  Description:
*   coinup... displays each line of "1st BONUS, 2ND BONUS, AND FOR EVERY".
*   Successive calls to this are made depending upon machine config, e.g.
*  'XXX BONUS FOR XXXXXX PTS'
*  'AND FOR EVERY XXXXXX PTS'
* IN:
*  D2 = string_out_pe_index
*  D4 = first digit of score i.e. X of Xxxxx.
* OUT:
*  ...
*-----------------------------------------------------------------------------
c_game_bonus_info_show_line_043d:
	jbsr	string_out_pe_30                | [$043D: rst  0x30] string_out_pe ('XXX BONUS FOR   ', 'AND FOR EVERY   ' )
* set next position to append 'X0000 PTS'
	exg	d4,d5
	exg	a1,a0                               | [$043E: ex   de,hl] get position of final character from string_out (digit now in L)
	                        	            | [$043F: ld   a,e]
	add.w	#0x40,a1                        | [$0440: add  a,#0x40] Offset position by 2 characters to the left.
	                        	            | [$0442: ld   e,a]								            
	and.w	#0xFF,d5                        | [$0443: ld   h,#0]
	jbsr	c_text_out_i_to_d_0A53          | [$0445: call c_text_out_i_to_d_0A53] HL contains number to display, returns updated destination in DE								            
	exg	a1,a0                               | [$0448: ex   de,hl]
	move.b	#0x1E,d2                        | [$0449: ld   c,#0x1E]
	jbsr	c_string_out_1398               | [$044B: call c_string_out_1398] DE=dest, C=string_out_pe_index
	jbsr	c_sprite_tiles_displ_128C     	| [$044E: call c_sprite_tiles_displ_128C]
	rts                                    	| [$0451: ret]


*=============================================================================
*  attributes for ship-sprites in bonus info screen ... 4-bytes each:
*  0: offset/index of object to use
*  1: color/code
*      ccode<3:6>==code
*      ccode<0:2,7>==color
*  2: X coordinate
*  3: Y coordinate
*
d_attrmode_sptiles_ships:
	.byte 0x00, 0x81, 0x19, 0x56
	.byte 0x02, 0x81, 0x19, 0x62
	.byte 0x04, 0x81, 0x19, 0x6E


*=============================================================================
* gctl_game_runner()
*  Description:
*   background super-loop following game-start
* IN:
*  ...
* OUT:
*  ...
*-----------------------------------------------------------------------------
gctl_game_runner:
l_045E_while:
	jbsr	gctl_supv_score_072B                   	| [call gctl_supv_score_072B]
	jbsr	gctl_supv_stage                   	| [call gctl_supv_stage]
	jra	l_045E_while                       	    | [jr   l_045E_while]


*=============================================================================
* _plyr_init()
*  Description:
*   One-time setup for new game cycle.
*   Reset score displays etc. for 1 player and/or 2 player.
* IN:
*  ...
* OUT:
*  ...
*
*-----------------------------------------------------------------------------
gctl_game_init:
*  get nbr of fighters from machine config
	move.b	b_mchn_cfg_nships,d0            	| [ld   a,(b_mchn_cfg_nships)]
	move.b	d0,ds_plyr_actv+_b_nships       	| [ld   (ds_plyr_actv +_b_nships),a] mchn_cfg_nships
	move.b	d0,ds_plyr_susp+_b_nships       	| [ld   (ds_plyr_susp +_b_nships),a] mchn_cfg_nships

*  tiles drawn right to left ... top row layout:
*     2 bytes                           	|| 2 bytes (not visible)
*    ----------------------------------------------------
*    .3DF     .3DD                              .3C2  .3C0     <- Row 0
*    .3FF     .3FD                              .3E2  .3E0     <- Row 1

* Two 0's + 4 spaces + 1 non-visible space on the left
	lea	0x8000+0x03E0+0x18,a1      	| [ld   de,#0x8000 + 0x03E0 + 0x18] player 1 score, rightmost of "00"
	lea	d_0495,a0                      	| [ld   hl,#d_0495] "00"
	jbsr	gctl_init_puts                    	| [call gctl_init_puts]

	lea	0x8000+0x03E0+0x03,a1      	| [ld   de,#0x8000 + 0x03E0 + 0x03] player 2 score (rightmost column is .3C2)
	lea	d_0495,a0                      	| [ld   hl,#d_0495] "00"

* if ( two_plyr_game )  _putc ... draw 2 0's and 5 spaces in plyr 2 score
	move.b	b8_99B3_two_plyr_game,d0        	| [ld   a,(b8_99B3_two_plyr_game)]
	                               	| [and  a]
	jne	gctl_init_puts                     	| [jr   nz,gctl_init_puts]
* else  hl+=2  ... advance src pointer past "00", draw 7 spaces and erase player 2 score
	addq.w	#2,a0                           	| [inc  hl] * 2

*=============================================================================
* _score_init
*  Description:
*   we saved 4 bytes of code space by factoring out the part that copies 7
*   characters. Then we wasted about 50 uSec by repeating the erase 2UP!
* IN:
*  HL: src tbl pointer ... either 0495 or 0497
*  DE: dest pointer (offset)
* OUT:
*
*-----------------------------------------------------------------------------
gctl_init_puts:

* erase score
	move.w	#7,d1                           	| [ld   c,#7] doesn't initialize B but maybe it should!
	jbsr	ldir_video                         	| [ldir]

* erase "2UP" ...start at '_' of '2UP_'  (gets re-drawn momentarily)
	lea	d_0495+2,a0                    	| [ld   hl,#d_0495 + 2]
	lea	0x8000+0x03C0+3,a1         	| [ld   de,#0x8000 + 0x03C0 + 3] rightmost column is .3C2
	move.w	#4,d1                           	| [ld   c,#4]
	jbsr	ldir_video                          | [ldir]

	rts                                    	| [ret]

*=============================================================================
d_0495:
* "00" characters for initial score display
	.byte 0x00,0x00
* "space" characters
	.byte 0x24,0x24,0x24,0x24,0x24,0x24,0x24
	.align	2

*=============================================================================
* gctl_stg_restart_hdlr()
*  Description:
*   Starting a new round or re-starting a round due to one of the following events:
*   - single ship destroyed
*   - second ship of duo destroyed
*   - ship captured
*   - cleared the level.
* IN:
*  ...
* OUT:
*  ...
*-----------------------------------------------------------------------------
gctl_stg_restart_hdlr:
* return is by jp ... pop the push'd return address of call c_080B_monitor_stage_start_
	move.l	(sp)+,a0                        	| [pop  hl]
	lea	ds4_game_tmrs_92ac+3,a0             	| [ld   hl,#ds4_game_tmrs_92ac + 3] = 4 (set a time to wait while ship exploding)
	move.b	#4,(a0)                         	| [ld   (hl),#4]

* wait for ship explosion or bug explosion or for a landing captured ship
l_04A4_wait:

*  if ( captured_ship_landing_task_en ) ...
	move.b	ds_cpu0_task_actv_9000+0x1D,d0      | [ld   a,(ds_cpu0_task_actv_9000 + 0x1D)] f_boss_capturing_ship_killed_2000 (destroyed boss that captured ship)
	                               	            | [and  a]
	jeq	l_04C1_while                       	    | [jr   z,l_04C1_while]
*  ... then ...
*      ship in play is destroyed, but the "landing" ship remains in play.
	clr.b	d0                               	| [xor  a]
	move.b	d0,ds_9200_glbls+0x13           	| [ld   (ds_9200_glbls + 0x13),a] 0 ... restart stage flag
	addq.b	#1,d0                           	| [inc  a]
	move.b	d0,ds_cpu1_task_actv+0x05       	| [ld   (ds_cpu1_task_actv + 0x05),a] 1  (f_05EE: fighter collision detection task)

*    if ( num_bugs > 0 ) return
	move.b	b_bugs_actv_nbr,d0              	| [ld   a,(b_bugs_actv_nbr)]
	                               	            | [and  a]
	jne	gctl_game_runner                   	    | [jp   nz,gctl_game_runner] continue round w/ second (docked) ship... return to Game Runner Loop

*      bug_ct == 0... last bug destroyed by collision w active ship
*      ... wait for captured ship to land before starting new stage

l_04B9_while:
* while ( task active )
	move.b	ds_cpu0_task_actv_9000+0x1D,d0     | [ld   a,(ds_cpu0_task_actv_9000 + 0x1D)] f_boss_capturing_ship_killed_2000 (destroyed boss that captured ship)
	                               	           | [and  a]
	jne	l_04B9_while                       	   | [jr   nz,l_04B9_while]
	jra	l_04DC_break                       	   | [jr   l_04DC_break]

l_04C1_while:
*  if ( timer_3 > 0 )
	move.b	(a0),d0                            | [ld   a,(hl)] hl==_game_tmr_3? waiting on 4 count delay time for explosion
	                               	           | [and  a]
	jne	l_04A4_wait                        	   | [jr   nz,l_04A4_wait]

	jbsr	gctl_supv_score_072B                    | [call gctl_supv_score_072B]

* plyr_state_actv.b_nbugs = b_bugs_actv_nbr
	move.b	b_bugs_actv_nbr,d0                 | [ld   a,(b_bugs_actv_nbr)]
	move.b	d0,ds_plyr_actv+_b_enmy_ct_actv    | [ld   (ds_plyr_actv +_b_enmy_ct_actv),a]

* check for "not (normal) end of stage conditions":

* if ( restart stage flag || bugs_actv_nbr>0 )
	move.b	d0,d2                              | [ld   c,a] remaining enemies, could be 0 if fighter hit last one
	move.b	ds_9200_glbls+0x13,d0              | [ld   a,(ds_9200_glbls + 0x13)] restart stage flag (could not be here if nbr_bugs > 0 && flag==0 )
	or.b	d2,d0                              | [or   c]
	jne	gctl_plyr_terminate_04E2               | [jr   nz,gctl_plyr_terminate_04E2]

	move.b	ds_plyr_actv+_b_not_chllg_stg,d0   | [ld   a,(ds_plyr_actv +_b_not_chllg_stg)] 0 if challenge stage
	                               	           | [and  a]
	jeq	gctl_chllng_stg_end                    | [jp   z,gctl_chllng_stg_end] jp's back to 04DC_

l_04DC_break:

* end of stage ... "normal"
	jbsr	stg_init_splash_0185               | [call stg_init_splash_0185]
	jra	plyr_respawn_rdy                   	   | [jp   plyr_respawn_rdy]


*=============================================================================
* gctl_plyr_terminate_04E2()
*  Description:
*   Handle terminated player
*   Bramch off to GameOver or TerminateActivePlayer and change player.
* IN:
*  ...
* OUT:
*  ...
*-----------------------------------------------------------------------------
gctl_plyr_terminate_04E2:
* if ( active_plyr_state.num_resv_ships-- == 0 )
	lea	ds_plyr_actv+_b_nships,a0      	        | [$04E2: ld   hl,#ds_plyr_actv +_b_nships]
	move.b	(a0),d0                         	| [$04E5: ld   a,(hl)]
	tst.b	infinite_lives_flag
	bne.b	0f
	subq.b	#1,(a0)                         	| [$04E6: dec  (hl)]
0:
	tst.b	d0                               	| [$04E7: and  a]
	jne	j_0579_terminate                   	    | [$04E8: jp   nz,j_0579_terminate] active ship terminated but not game over
*  if  ( two_plyr_game ) ...
	move.b	b8_99B3_two_plyr_game,d0        	| [$04EB: ld   a,(b8_99B3_two_plyr_game)]
	                               	            | [$04EE: and  a]
	jeq	l_04FD_end_of_game                 	    | [$04EF: jr   z,l_04FD_end_of_game]
*  then ... adjust message text for two player game-over
	lea	0x8000+0x0240+0x0E,a0      	            | [$04F1: ld   hl,#0x8000 + 0x0240 + 0x0E]
	move.b	ds_plyr_actv+_b_plyr_nbr,d0     	| [$04F4: ld   a,(ds_plyr_actv +_b_plyr_nbr)] 0==plyr1, 1==plyr2
	addq.b	#4,d0                           	| [$04F7: add  a,#4]
	move.b	d0,d2                           	| [$04F9: ld   c,a] string index
	jbsr	c_string_out_1398                   | [$04FA: call c_string_out_1398] "PLAYER X" (for "PLAYER X GAME OVER")

l_04FD_end_of_game:
	move.b	#0x02,d2                        	| [$04FD: ld   c,#0x02] string index
	jbsr	string_out_pe_30                    | [$04FF: rst  0x30] string_out_pe "GAME OVER"
	jbsr	c_tdelay_3                        	| [$0500: call c_tdelay_3]
	jbsr	c_tdelay_3                        	| [$0503: call c_tdelay_3]

*  while (0 != task_actv_tbl_0[0x18]){|} ... block if tractor beam completing
	lea	ds_cpu0_task_actv_9000+0x18,a0      	| [$0506: ld   hl,#ds_cpu0_task_actv_9000 + 0x18] f_boss_starts_tractor_beam_2222 (Boss starts tractor beam) wait for task inactive
l_0509_while:
	move.b	(a0),d0                         	| [$0509: ld   a,(hl)]
	                               	            | [$050A: and  a]
	jne	l_0509_while                       	    | [$050B: jr   nz,l_0509_while]
	jbsr	rst_28                            	| [$050D: rst  0x28] memset(mctl_mpool,0,$$14 * 12)
	jbsr	c_sctrl_sprite_ram_clr_003c         | [$050E: call c_sctrl_sprite_ram_clr_003c]
	jbsr	c_sctrl_playfld_clr_0160            | [$0511: call c_sctrl_playfld_clr_0160]
	move.b	#0x15,d2                        	| [$0514: ld   c,#0x15] string index
	jbsr	string_out_pe_30                    | [$0516: rst  0x30] string_out_pe ("-RESULTS-")
	move.b	#0x16,d2                        	| [$0517: ld   c,#0x16] string index
	jbsr	string_out_pe_30                    | [$0519: rst  0x30] string_out_pe ("SHOTS FIRED")
	lea	0x8000+0x0120+0x12,a1      	            | [$051A: ld   de,#0x8000 + 0x0120 + 0x12]
	MOVE_TO_REG	ds_plyr_actv+_w_shot_ct,d5  	| [$051D: ld   hl,(ds_plyr_actv +_w_shot_ct)] puts game shots fired count
	jbsr	c_text_out_i_to_d_0A53              | [$0520: call c_text_out_i_to_d_0A53] puts game shots fired count
	move.b	#0x18,d2                        	| [$0523: ld   c,#0x18] string index
	jbsr	string_out_pe_30                    | [$0525: rst  0x30] string_out_pe ("NUMBER OF HITS")
	lea	0x8000+0x0120+0x15,a1      	            | [$0526: ld   de,#0x8000 + 0x0120 + 0x15]
	MOVE_TO_REG	ds_plyr_actv+_w_hit_ct,d5   	| [$0529: ld   hl,(ds_plyr_actv +_w_hit_ct)] puts game number of hits
	jbsr	c_text_out_i_to_d_0A53              | [$052C: call c_text_out_i_to_d_0A53] puts game number of hits
	move.b	#0x19,d2                        	| [$052F: ld   c,#0x19] string index
	jbsr	string_out_pe_30                    | [$0531: rst  0x30] string_out_pe ("HIT-MISS RATIO")
	jbsr	c_puts_hitmiss_ratio_0A72         	| [$0532: call c_puts_hitmiss_ratio_0A72]
	exg	a1,a0                              	    | [$0535: ex   de,hl] HL becomes c_string_out_1398<IN:position in tile RAM>
	move.b	#0x1A,d2                        	| [$0536: ld   c,#0x1A] string index
	jbsr	c_string_out_1398                   | [$0538: call c_string_out_1398] "%" after hit-miss number
       * wait for the timer
	lea	ds4_game_tmrs_92ac+2,a0             	| [$053B: ld   hl,#ds4_game_tmrs_92ac + 2]
	move.b	#0x0E,(a0)                      	| [$053E: ld   (hl),#0x0E]
l_0540_while:
	move.b	(a0),d0                         	| [$0540: ld   a,(hl)]
	                               	            | [$0541: and  a]
	jne	l_0540_while                       	    | [$0542: jr   nz,l_0540_while]
	jbsr	c_sctrl_playfld_clr_0160            | [$0544: call c_sctrl_playfld_clr_0160]
	jbsr	c_top5_dlg_proc                   	| [$0547: call c_top5_dlg_proc] returns immediately if not in top-5
	clr.b	d0                               	| [$054A: xor  a]
	move.b	d0,b_9AA0+0x10                  	| [$054B: ld   (b_9AA0 + 0x10),a] 0 ... sound-fx count/enable registers, hi-score dialog?

* while (_fx[0x0C] || _fx[0x16]) ... (finished when both 0)
	lea	b_9AA0+0x0C,a0                         	| [$054E: ld   hl,#b_9AA0 + 0x0C] sound-fx count/enable registers, hi-score dialog
	lea	b_9AA0+0x16,a1                         	| [$0551: ld   de,#b_9AA0 + 0x16] sound-fx count/enable registers, hi-score dialog
l_0554_while:
	move.b	(a1),d0                         	| [$0554: ld   a,(de)] sound_fx[0x16] ... probably 0
	move.b	(a0),d1                         	| [$0555: ld   b,(hl)] sound_fx[0x0C] ... probably still running
	or.b	d1,d0                             	| [$0556: or   b]
	jeq	l_0562                             	    | [$0557: jr   z,l_0562]
* if (0 != _fx[0x0C]) then _fx[0x0C] = 1 ... snd[$0C] used as timer, enable snd[$16] when 0 is reached
	                                        	| [$0559: inc  b]
	tst.b	d1                                	| [$055A: dec  b]
	jeq	l_055F                             	    | [$055B: jr   z,l_055F]
	move.b	#1,(a0)                         	| [$055D: ld   (hl),#1]
l_055F:
* On halt, processor wakes at maskable or nonmaskable interrupt providing
* something like a busy-wait with sleep(n) where n is the interrupt period.
	ILLEGAL										| hi-score, finished name entry (wait for music to stop)
	jra	l_0554_while                       	| [jr   l_0554_while]

l_0562:
	jbsr	c_sctrl_playfld_clr_0160               	| [call c_sctrl_playfld_clr_0160] clear screen at end of game

* done game over stuff for active player, so if 1P game or
* plyr_susp.resv_fghtrs exhausted then halt

* if ( !two_plyr_game || -1 == plyr_susp.resv_fghtrs ) then halt
	move.b	b8_99B3_two_plyr_game,d0        | [ld   a,(b8_99B3_two_plyr_game)]
	                               	        | [and  a]
	jeq	g_halt                             	| [jp   z,g_halt] jp   g_main_035a
	move.b	ds_plyr_susp+_b_nships,d0       | [ld   a,(ds_plyr_susp +_b_nships)] -1 if no resv ships remain
	addq.b	#1,d0                           | [inc  a]
	jeq	g_halt                             	| [jp   z,g_halt] jp   g_main_035a

* else if ( stage_rst_flag != 1 ) ... _plyr_chg()
*   indicates fighter-capture event
	move.b	ds_9200_glbls+0x13,d0           | [ld   a,(ds_9200_glbls + 0x13)] restart stage flag
	subq.b	#1,d0                           | [dec  a]
	jne	j_058E_plyr_chg                    	| [jr   nz,j_058E_plyr_chg]

j_0579_terminate:
* if ( !two_plyr_game ) {
	move.b	b8_99B3_two_plyr_game,d0        | [ld   a,(b8_99B3_two_plyr_game)]
	                               	        | [and  a]
	jeq	plyr_respawn_1up                   	| [jp   z,plyr_respawn_1up] plyr_respawn_1P < plyr_respawn_wait < fghtr_rdy < game_runner

* } else if ( plyr_susp.resv_fghtrs == -1	|| stage_rst_flag != 0 )
	move.b	ds_plyr_susp+_b_nships,d0       | [ld   a,(ds_plyr_susp +_b_nships)] -1 when .resv_fghtrs exhausted
	addq.b	#1,d0                           | [inc  a]
	jeq	plyr_respawn_plyrup                	| [jp   z,plyr_respawn_plyrup] allow actv plyr respawn if susp plyr out of ships
* note: stage_rst_flag == 0 would also test true but that would make no sense here
	move.b	ds_9200_glbls+0x13,d0           | [ld   a,(ds_9200_glbls + 0x13)] restart_stage
	subq.b	#1,d0                           | [dec  a]
	jne	plyr_respawn_plyrup                	| [jp   nz,plyr_respawn_plyrup] allows active plyr to respawn on capture ship event
* }
* else { do player change }


*=============================================================================

j_058E_plyr_chg:
* if ( nr of bugs == 0 ) {{
	move.b	b_bugs_actv_nbr,d0              	| [ld   a,(b_bugs_actv_nbr)]
	                               	| [and  a]
	jeq	l_059A_prep                        	| [jr   z,l_059A_prep]
* }} else {{
*    while ( nbr_flying_bugs > 0 ) {
l_0594:
	move.b	b_bugs_flying_nbr_9287,d0            	| [ld   a,(b_bugs_flying_nbr_9287)] check if !=0 (ship destroyed, wait for bugs return to nest)
	                               	| [and  a]
	jne	l_0594                             	| [jr   nz,l_0594]
*    }
* }}

* set up for active player nest to retreat
l_059A_prep:
	clr.b	d0                               	| [xor  a]
	move.b	d0,b8_99B4_bugnest_onoff_scrn_tmr	| [ld   (b8_99B4_bugnest_onoff_scrn_tmr),a] 0 ( timer/counter while nest retreating)
	addq.b	#1,d0                           	| [inc  a]
	lea	ds_cpu0_task_actv_9000+0x0E,a0      	| [ld   hl,#ds_cpu0_task_actv_9000 + 0x0E] 1 ... f_move_swarm_when_player_changes_1d32
	move.b	d0,(a0)                         	| [ld   (hl),a]

* wait for formation to exit ... completion of f_move_swarm_when_player_changes_1d32 (status actv_task_tbl[$0E])
l_05A3_while:
	move.b	(a0),d0                         	| [ld   a,(hl)]
	                               	            | [and  a]
	jne	l_05A3_while                       	    | [jr   nz,l_05A3_while]

* exchange player data
	move.b	b_9AA0+0x00,d0                  	| [ld   a,(b_9AA0 + 0x00)] plyr_actv.b_sndflag
	move.b	d0,ds_plyr_actv+_b_sndflag      	| [ld   (ds_plyr_actv +_b_sndflag),a] _fx[0] ... enable for pulsing_sound
	move.b	ds4_game_tmrs_92ac+2,d0             | [ld   a,(ds4_game_tmrs_92ac + 2)]
	move.b	d0,ds_plyr_actv+_b_plyr_swap_tmr	| [ld   (ds_plyr_actv +_b_plyr_swap_tmr),a] game_tmr[2]
	jbsr	c_player_active_switch            	| [call c_player_active_switch]
	jbsr	new_stage_setup_2c00                | [call new_stage_setup_2c00] new stage setup
	move.b	ds_plyr_actv+_b_plyr_swap_tmr,d0	| [ld   a,(ds_plyr_actv +_b_plyr_swap_tmr)] game_tmr[2]
	move.b	d0,ds4_game_tmrs_92ac+2             | [ld   (ds4_game_tmrs_92ac + 2),a] actv_plyr_state[0x1F]
	move.b	ds_plyr_actv+_b_sndflag,d0      	| [ld   a,(ds_plyr_actv +_b_sndflag)] _fx[0] ... enable for pulsing_sound
	move.b	d0,b_9AA0+0x00                  	| [ld   (b_9AA0 + 0x00),a] enable for pulsing_sound
	jbsr	draw_resv_ships_136c                | [call draw_resv_ships_136c]

* if ( _enmy_ct_actv != 0 ) ...
	move.b	ds_plyr_actv+_b_enmy_ct_actv,d0 	| [ld   a,(ds_plyr_actv +_b_enmy_ct_actv)]
	                               	            | [and  a]
	jeq	l_05D1                             	    | [jr   z,l_05D1]
* ... then ... player was previously destroyed by collision with last enemy in the round
	jbsr	gctl_stg_new_atk_wavs_init_25a2                            	| [call gctl_stg_new_atk_wavs_init_25a2] gctl_stg_new_atk_wavs_init()

* setting up a new screen (changing players)
l_05D1:
*  screen_is_flipped = (cab_type==Table & Plyr2up )
	move.b	ds_plyr_actv+_b_plyr_nbr,d0     	| [ld   a,(ds_plyr_actv +_b_plyr_nbr)] 0==plyr1, 1==plyr2
	move.b	d0,d2                           	| [ld   c,a]
	move.b	b_mchn_cfg_cab_type,d0          	| [ld   a,(b_mchn_cfg_cab_type)] 0==UPRIGHT, 1==TABLE
	and.b	d2,d0                            	| [and  c]
	*move.b	d0,0xA007                       	| [ld   (0xA007),a] sfr_flip_screen
	move.b	d0,b_9215_flip_screen           	| [ld   (b_9215_flip_screen),a]

* gctl_stg_fmtn_hpos_init
	move.b	#0x3F,d0                        	| [ld   a,#0x3F]
	jbsr	c_12C3                            	| [call c_12C3] A==$3F ... set MOB coordinates, player changeover

* set Cy to disable sound clicks for level tokens on player change (value of A is irrelevant)
	SET_XC_FLAGS                           	| [scf]
	scs	d7                              	| [ex   af,af']
	jbsr	c_new_level_tokens_117f                	| [call c_new_level_tokens_117f] Cy' == 1, A == don't care

* if ( _enmy_ct_actv == 0 )  ... then _stg_init ... player was previously destroyed by collision with last enemy in the round
	move.b	ds_plyr_actv+_b_enmy_ct_actv,d0 	| [ld   a,(ds_plyr_actv +_b_enmy_ct_actv)]
	                               	| [and  a]
	jeq	plyr_respawn_splsh                 	| [jr   z,plyr_respawn_splsh] _plyr_startup > _new_stg_ <-  _plyr_startup

* else ...
	move.b	#3,d2                           	| [ld   c,#3] C=string_out_pe_index
	jbsr	string_out_pe_30                            	| [rst  0x30] string_out_pe "READY"

* set wait-time for bug nest retreat. The count is masked with $7F in f_move_swarm_when_player_changes_1d32, so I
* don't see why it starts at $80 here instead of 0. Shouldn't make any difference tho'...
	move.b	#0x80,d0                        	| [ld   a,#0x80]
	move.b	d0,b8_99B4_bugnest_onoff_scrn_tmr	| [ld   (b8_99B4_bugnest_onoff_scrn_tmr),a] $80

* wait for bug nest to reappear.
	lea	ds_cpu0_task_actv_9000+0x0E,a0      	| [ld   hl,#ds_cpu0_task_actv_9000 + 0x0E] 1 ... f_move_swarm_when_player_changes_1d32
	move.b	#1,d0                           	| [ld   a,#1]
	move.b	d0,(a0)                         	| [ld   (hl),a]

* while ( cpu0_task_actv[$0E] ) ... wait for the task to timeout
l_05FD:
	move.b	(a0),d0                         | [$05FD: ld   a,(hl)]
	                               	        | [$05FE: and  a]
	jne	l_05FD                             	| [$05FF: jr   nz,l_05FD]
	jra	plyr_respawn_plyrup                	| [$0601: jp   plyr_respawn_plyrup] reloaded suspended plyr, bug nest reloaded... ready!


*=============================================================================
* "respawn" for 1 player game.
* If fighter terminated by last enemy of the stage, then init new stage.
* Only reference is from _terminate() so it should be "inlined" there.
plyr_respawn_1up:
* if (0 == plyr_state_actv.b_nbugs) ...
	move.b	ds_plyr_actv+_b_enmy_ct_actv,d0 	| [$0604: ld   a,(ds_plyr_actv +_b_enmy_ct_actv)]
	                               	            | [$0607: and  a]
	jne	gctl_plyr_respawn_wait             	    | [$0608: jr   nz,gctl_plyr_respawn_wait]
* ... then ...
	jbsr	stg_init_splash_0185                | [$060A: call stg_init_splash_0185] new stage setup, shows "STAGE X"
	jra	gctl_plyr_respawn_wait             	    | [$060D: jr   gctl_plyr_respawn_wait]


*=============================================================================
* Player respawn with stage setup (i.e. when plyr.enemys = 0, i.e. player
* change, or at start of new game loop.
* If on a new game, PLAYER 1 text has been erased.
plyr_respawn_splsh:
	jbsr	stg_init_splash_0185                   	| [call stg_init_splash_0185] shows "STAGE X" and does setup

       * plyr_respawn_plyrup()

*-----------------------------------------------------------------------------
* Setup a new player... every time the player is changed on a 2P game or once
* at first fighter of new 1P game. Player X text shown, stage restart.
plyr_respawn_plyrup:
	move.b	ds_plyr_actv+_b_plyr_nbr,d0     	| [ld   a,(ds_plyr_actv +_b_plyr_nbr)] 0==plyr1, 1==plyr2
	addq.b	#4,d0                           	| [add  a,#4] P1 text is index 4, P2 is index 5
	move.b	d0,d2                           	| [ld   c,a] index into string table
	lea	0x8000+0x0260+0x0E,a0      	| [ld   hl,#0x8000 + 0x0260 + 0x0E] not position encoded, this one is 1C left and 2R up
	jbsr	c_string_out_1398                      	| [call c_string_out_1398] puts PLAYER X ("1" or "2") .

*-----------------------------------------------------------------------------
* _fghtr_rdy + wait ... 1 player skips previous stuff
gctl_plyr_respawn_wait:
	jbsr	c_player_respawn                  	| [call c_player_respawn] "credit X" is wiped and reserve ships appear on lower left of screen

* ds4_game_tmrs_92ac[2] was set to 120 by new_stg_game_or_demo

* if tmr > $5A then reset to $78
	move.b	ds4_game_tmrs_92ac+2,d0              	| [ld   a,(ds4_game_tmrs_92ac + 2)]
	add.b	#0x1E,d0                         	| [add  a,#0x1E]
	cmp.b	#0x78,d0                         	| [cp   #0x78]
	jcs	l_062C                             	| [jr   c,l_062C]
	move.b	#0x78,d0                        	| [ld   a,#0x78]
l_062C:
	move.b	d0,ds4_game_tmrs_92ac+2              	| [ld   (ds4_game_tmrs_92ac + 2),a] $78

* new ship appears on screen and stars start moving ... should about take care of the music
	jbsr	c_tdelay_3                        	| [call c_tdelay_3]

*-----------------------------------------------------------------------------
* new round starting or round re-starting after active player switch.
plyr_respawn_rdy:
	move.b	#1,d0                           	| [ld   a,#1]
	move.b	d0,ds_cpu0_task_actv_9000+0x15       	| [ld   (ds_cpu0_task_actv_9000 + 0x15),a] 1 ... f_read_fire_button_1f04 (fire button input)
	move.b	d0,ds_cpu1_task_actv+0x05       	| [ld   (ds_cpu1_task_actv + 0x05),a] 1 ... cpu1:f_05EE (hit-detection)
	move.b	d0,ds_plyr_actv+_b_atk_wv_enbl  	| [ld   (ds_plyr_actv +_b_atk_wv_enbl),a] 1  (0 when respawning player ship)

	move.b	#0x0B,d2                        	| [ld   c,#0x0B] index into string table
	lea	0x8000+0x03B0,a0           	| [ld   hl,#0x8000 + 0x03B0]
	jbsr	c_string_out_1398                      	| [call c_string_out_1398] erase "READY" or "STAGE X"

	move.b	#0x0B,d2                        	| [ld   c,#0x0B] index into string table
	lea	0x8000+0x03A0+0x0E,a0      	| [ld   hl,#0x8000 + 0x03A0 + 0x0E]
	jbsr	c_string_out_1398                      	| [call c_string_out_1398] erase "PLAYER 1"

	jra	gctl_game_runner                   	| [jp   gctl_game_runner] resume background super loop


*=============================================================================
* gctl_chllng_stg_end()
*  Description:
*    Handle challenge stage book-keeping prior to doing the "normal"
*    new_stage_setup.
*    Entry and Exit are both by jp.
* IN:
*  ...
* OUT:
*  ...
*-----------------------------------------------------------------------------
gctl_chllng_stg_end:

	move.b	b_bug_flyng_hits_p_round_9288,d0     	| [ld   a,(b_bug_flyng_hits_p_round_9288)]
	tst.b	perfect_challenge_stage_flag
	jeq		0f
	move.b	#40,d0
0:
	move.b	d0,d4                           	| [ld   e,a]

	move.w	#END_CHALLENGE_SND,d0
	lea	b_9AA0+0x0E,a0                 	        | [ld   hl,#b_9AA0 + 0x0E] sound-fx count/enable registers, default melody for challenge stage
	cmp.b	#40,d0                           	| [cp   #40] nbr of bugs in challenge round
	jne	l_065E                                  | [jr   nz,l_065E]
	move.w	#PERFECT_SND,d0
	lea	b_9AA0+0x14,a0                 	        | [ld   hl,#b_9AA0 + 0x14] sound effect count/enable registers, "perfect!" melody, challenge stg
l_065E:
	move.b	#1,(a0)                         	| [ld   (hl),#1]
	jbsr	osd_sound_start
	jbsr	c_tdelay_3                        	| [call c_tdelay_3]
	move.b	#0x08,d2                        	| [ld   c,#0x08]
	jbsr	string_out_pe_30                    | [rst  0x30] string_out_pe ("NUMBER OF HITS")
	jbsr	c_tdelay_3                        	| [call c_tdelay_3]

* DE = adjusted offset into tile ram on return
	clr.w	d5                               	| [ld   h,#0]
	move.b	d4,d5                           	| [ld   l,e] E==nbr of flying bugs hit this round
	lea	0x8000+0x0100+0x10,a1      	            | [ld   de,#0x8000 + 0x0100 + 0x10]
	jbsr	c_text_out_i_to_d_0A53              | [call c_text_out_i_to_d_0A53] HL contains number to display (number of hits)
	jbsr	c_tdelay_3                        	| [call c_tdelay_3]

* if (0x40 != b_bug_flyng_hits_p_round_9288) ...
	move.b	b_bug_flyng_hits_p_round_9288,d0     	| [ld   a,(b_bug_flyng_hits_p_round_9288)] if 40
	cmp.b	#40,d0                           	| [cp   #40]
	jeq	l_0699_special_bonus               	| [jr   z,l_0699_special_bonus]
* then ...
	move.b	#9,d2                           	| [ld   c,#9]
	jbsr	string_out_pe_30                            	| [rst  0x30] string_out_pe ("BONUS")

	jbsr	c_tdelay_3                        	| [call c_tdelay_3]

	exg	a1,a0                              	| [ex   de,hl] DE = HL

* if (0 != b_bug_flyng_hits_p_round_9288) ...
	move.b	b_bug_flyng_hits_p_round_9288,d0     	| [ld   a,(b_bug_flyng_hits_p_round_9288)] if !0
	                               	| [and  a]
	jeq	l_0693_put_ones                    	| [jr   z,l_0693_put_ones]
* then ...
	clr.w	d5                               	| [ld   h,#0]
	move.b	d0,d5                           	| [ld   l,a]
	jbsr	c_text_out_i_to_d_0A53                 	| [call c_text_out_i_to_d_0A53] HL contains number to display (1000's,100's place of bonus pts awarded)
	clr.b	d0                               	| [xor  a]
	jbsr	write_videoram_to_a1					| [ld   (de),a] putc(0) ... 10's place of bonus pts awarded
	sub.w	#0x20,a1                            	| [rst  0x20] DE-=$20
	clr.b	d0                               	| [xor  a]

l_0693_put_ones:
	jbsr	write_videoram_to_a1                         	| [ld   (de),a] putc(0) ... 1's place of bonus pts awarded
	move.b	b_bug_flyng_hits_p_round_9288,d0     	| [ld   a,(b_bug_flyng_hits_p_round_9288)]
	jra	l_06BA                             	| [jr   l_06BA]

l_0699_special_bonus:
* blink the "PERFECT !" text
	move.b	#7,d1                           	| [ld   b,#7]
l_069B_while_b:
l_069B_while_fcnt:
	move.b	ds3_frame_cts_92A0+0,d0         	| [ld   a,(ds3_frame_cts_92A0 + 0)]
	and.b	#0x0F,d0                         	| [and  #0x0F]
	jne	l_069B_while_fcnt                  	| [jr   nz,l_069B_while_fcnt]

	move.b	#0x0B,d2                        	| [ld   c,#0x0B] index into string table (27 spaces)
	btst.b	#0,d1                           	| [bit  0,b]
	jeq	l_06A9                             	| [jr   z,l_06A9]
	addq.b	#1,d2                           	| [inc  c] C = 0x0C| // index into string table "PERFECT !"
l_06A9:
	movem.w	d1/d2,-(sp)                    	| [push bc]
	jbsr	string_out_pe_30                            	| [rst  0x30] string_out_pe ( C == $0B or C == $0C ... "PERFECT !" or spaces)

	movem.w	(sp)+,d1/d2                    	| [pop  bc]

l_06AC_while_fcnt:
	move.b	ds3_frame_cts_92A0+0,d0         	| [ld   a,(ds3_frame_cts_92A0 + 0)]
	and.b	#0x0F,d0                         	| [and  #0x0F]
	jeq	l_06AC_while_fcnt                  	| [jr   z,l_06AC_while_fcnt]

	subq.b	#1,d1                           	| [...]
	jne	l_069B_while_b                     	| [djnz l_069B_while_b]

	move.b	#0x0D,d2                        	| [ld   c,#0x0D] index into string table
	jbsr	string_out_pe_30                            	| [rst  0x30] string_out_pe ("SPECIAL BONUS 10000 PTS")

	move.b	#100,d0                         	| [ld   a,#100] 100 * 10 ... special bonus (d_scoreman_inc_lut[0] == $10)
l_06BA:
	lea	ds_bug_collsn_hit_mult+0x0F,a0 	        | [ld   hl,#ds_bug_collsn_hit_mult + 0x0F] challenge bonus score += 10000
	add.b	(a0),d0                          	| [add  a,(hl)]
	move.b	d0,(a0)                         	| [ld   (hl),a]
	jbsr	gctl_supv_score_072B                | [call gctl_supv_score_072B] add bonus to player score
	jbsr	c_tdelay_3                        	| [call c_tdelay_3]
	jbsr	c_tdelay_3                        	| [call c_tdelay_3]

	lea	0x8000+0x03A0+0x10,a0      	| [ld   hl,#0x8000 + 0x03A0 + 0x10]
	move.b	#0x0B,d2                        	| [ld   c,#0x0B] index into string table
	jbsr	c_string_out_1398                      	| [call c_string_out_1398] erase "Number of hits XX" (line below Perfect)

	lea	0x8000+0x03A0+0x13,a0      	| [ld   hl,#0x8000 + 0x03A0 + 0x13]
	move.b	#0x0B,d2                        	| [ld   c,#0x0B] index into string table
	jbsr	c_string_out_1398                      	| [call c_string_out_1398] erase "Special Bonus 10000 Pts" (or Bonus xxxx)

	move.b	#0x0B,d2                        	| [ld   c,#0x0B] index into string table
	jbsr	string_out_pe_30                            	| [rst  0x30] string_out_pe (erase "PERFECT !")

	jra	l_04DC_break                       	| [jp   l_04DC_break]


*=============================================================================
* g_halt()
*  Description:
*    Restarts machine when one (or both) players exhausted supply of fighters.
*    Resumes at g_main_035a.
* IN:
*  ...
* OUT:
*  ...
*-----------------------------------------------------------------------------
g_halt:
	
*	illegal		 | halt                                       | screen is now cleared at end of game
	moveq	#0,d0
	jbsr	osd_interrupt_control
*
*l_06E0_while_wait_io_ackrdy:
*	*move.b	0x7100,d0                       	| [ld   a,(0x7100)] read IO status
*	cmp.b	#0x10,d0                         	| [cp   #0x10] if (IO_ACKRDY) ... "command executed"
*	jne	l_06E0_while_wait_io_ackrdy        	| [jr   nz,l_06E0_while_wait_io_ackrdy]
*
*	lea	d_0725,a0                      	| [ld   hl,#d_0725] set data src ($02,$02,$02)
*	lea	l_7000,a1                      	| [ld   de,#0x7000] IO data xfer (write)
*	move.b	#0x00,d1                        	| [ld   bc,#0x0003] 3
*	move.b	#0x03,d2                        	| [ld   bc,#0x0003] 3
*	jbsr	exx                               	| [exx]
*
*	move.b	#0x61,d0                        	| [ld   a,#0x61] Reset IO chip? (not in Mame36 - check newer).
*	*move.b	d0,0x7100                       	| [ld   (0x7100),a] IO cmd ($61 -> disable IO chip?)
*	illegal		 |  halt                                       | stops until interrupt

* allow blinking of Player2 text to be inhibited on the intro screen when the
* game recycles (Player1 text shown anyway)
	clr.b	d0                               	| [xor  a]
	jbsr	c_093C                            	| [call c_093C] A == 0 ... blinking off
	moveq	#1,d0
	jbsr	osd_interrupt_control

*  memset($9AA0,0,$20)
	clr.b	d0                               	| [xor  a]
	move.b	#0x20,d1                        	| [ld   b,#0x20]
	lea	ds_9AA0,a0                     	| [ld   hl,#ds_9AA0] count/enable registers for sound effects, $20 bytes cleared
	jbsr	rst_18                            	| [rst  0x18] memset((HL), A=fill, B=ct)

	lea	0x8000+0x03E0+0x19,a1      	| [ld   de,#0x8000 + 0x03E0 + 0x19] 83f9 is 10's place score digit, below P of '1UP'
	jbsr	c_mach_info_add_score             	| [call c_mach_info_add_score]
	lea	0x8000+0x03E0+0x04,a1      	| [ld   de,#0x8000 + 0x03E0 + 0x04] 83e4 is 10's place score digit, below P of '2UP'
	jbsr	c_mach_info_add_score             	| [call c_mach_info_add_score]

*  Update total plays (up to 9999 bcd)
*  total_plays_bcd = (two_plyr_game==1) + 1  ... 0 for 1P, 1 for 2P
	move.b	b8_99B3_two_plyr_game,d0        	| [ld   a,(b8_99B3_two_plyr_game)]
	addq.b	#1,d0                           	| [inc  a]
	lea	b16_99E0_ttl_plays_bcd+1,a0    	| [ld   hl,#b16_99E0_ttl_plays_bcd + 1] get lsb (1s,10s place)
	move.b	(a0),d7
	abcd	d7,d0                          	| [add  a,(hl)]+daa
	jcc	0f                             	| [jp   nc,g_main_035a] finished update total_plays_bcd
	move.b	d0,(a0)                         	| [ld   (hl),a]
											| [dec  hl] w_total_plays_bcd (get msb ...100s,1000s place)
	move.b	-(a0),d0                         	| [ld   a,(hl)]
	moveq	#1,d7
	abcd	d7,d0                        	| [add  a,#0x01]+daa
	move.b	d0,(a0)                         	| [ld   (hl),a]
	jra	g_main_035a                             	| [jp   g_main_035a] from g_halt
0:
	move.b	d0,(a0)                         	| [ld   (hl),a]
	jra	g_main_035a
*=============================================================================
* const data for g_halt()
d_0725:
	.byte 0x02,0x02,0x02
	.align	2
*=============================================================================
* gctl_supv_score_072B()
*  Description:
*
* IN:
*  ix
* OUT:
*  ...
*-----------------------------------------------------------------------------
gctl_supv_score_072B:
*  if ( activ_plyr_state.plyr_1or2 == plyr1 )
	                               	            | [$072B: and  a]
*    tmp = $f9
	move.b	#0xF9,d0                        	| [$072C: ld   a,#0xF9] offset to 10's place from _tile_ram + 0x0300 (plyr 1)
	tst.b	ds_plyr_actv+_b_plyr_nbr     	    | [$072E: ld   a,(ds_plyr_actv +_b_plyr_nbr)] 0==plyr1, 1==plyr2
	jeq	l_0732                             	    | [$0730: jr   z,l_0732]
*  else tmp = $E4
	move.b	#0xE4,d0                        	| [$0730: ld   a,#0xE4] offset to 10's place from _tile_ram + 0x0300 (plyr 2)
l_0732:
	move.b	d0,ixl							    | [$0732: ld   ixl,a]   parameter to c_scoreman_incr_add (tile ram offset)
	move.b	#0x10,d1                        	| [$0734: ld   b,#0x10] sizeof scoreman_inc_lut[]
	lea	ds_bug_collsn_hit_mult,a0 	            | [$0736: ld   hl,#ds_bug_collsn_hit_mult + 0x00]
l_0739_while_B:
	exg	a1,a0                              	    | [$0739: ex   de,hl] DE := &bug_collsn[hl]
	lea	d_scoreman_inc_lut-1,a0        	        | [$073A: ld   hl,#d_scoreman_inc_lut - 1] effective start index is $10 - 1
	move.b	d1,d0                           	| [$073D: ld   a,b]
	jbsr	add_d0_to_a0_0010                   | [$073E: rst  0x10] HL += A
	move.b	(a0),d2                         	| [$073F: ld   c,(hl)] scoreman_inc_lut[B-1]
* bug_collsn[hl] * scoreman_inc_lut[B-1]
l_0740:
	exg	a1,a0                              	    | [$0740: ex   de,hl]
	move.b	(a0),d0                         	| [$0741: ld   a,(hl)] bug_collsn[hl]
	                               	            | [$0742: and  a]
	jeq	l_0762                             	    | [$0743: jr   z,l_0762] while ( 0 != bug_collsn[HL] )
	subq.b	#1,(a0)                         	| [$0745: dec  (hl)] bug_collsn[HL] decrement accumulated hit count
	exg	a1,a0                              	    | [$0746: ex   de,hl] DE := &bug_collsn[0x00]

	lea		0x8300,a0        	                | [$0747: ld   h,#>(0x8000 + 0x0300)] tile rows 32-35:  $83C0 - 83FF	
	jbsr	read_ixl_into_d0                    | [$0749: ld   a,ixl] offset to 10's place in tile ram
	add.w	d0,a0                           	| [$074B: ld   l,a]
	move.b	d2,d0                           	| [$074C: ld   a,c] scoreman_inc_lut[B-1]
	and.b	#0x0F,d0                         	| [$074D: and  #0x0F]
	jbsr	c_scoreman_incr_add               	| [$074F: call c_scoreman_incr_add] add to 10's
	lea		0x8300,a0
	jbsr	read_ixl_into_d0                    | [$0752: ld   a,ixl] increment offset to 10's place in tile ram
	addq.b	#1,d0                           	| [$0754: inc  a]
	add.w	d0,a0                           	| [$0755: ld   l,a]
	move.b	d2,d0                           	| [$0756: ld   a,c] scoreman_inc_lut[B-1]
	rol.b	#4,d0                            	| [$0757: rlca] upper nibble of "score increment" * 4
	and.b	#0x0F,d0                         	| [$075B: and  #0x0F]
	jbsr	c_scoreman_incr_add               	| [$075D: call c_scoreman_incr_add] add to 100's
	jra	l_0740                             	    | [$0760: jr   l_0740]

l_0762:
	addq.w	#1,a0                           	| [$0762: inc  l] index of bug_collsn[]
	subq.b	#1,d1                           	| [...]
	jne	l_0739_while_B                     	    | [$0763: djnz l_0739_while_B]
	jbsr	read_ixl_into_d0                    | [$0765: ld   a,ixl]
	addq.b	#4,d0                           	| [$0767: add  a,#4]						
	lea	0x8000+0x03E0+0x12,a0      	            | [$0769: ld   hl,#0x8000 + 0x03E0 + 0x12] 100000's digit of HIGH SCORE (83ED-83F2)
	lea	0x8000+0x0300,a1        	            | [$076A: ld   d,#>(0x8000 + 0x0300)]
	add.w	d0,a1					            | [$076D: ld   e,a]
	move.b	#6,d1                           	| [$076F: ld   b,#6]
l_0771:
	jbsr	read_videoram_from_a1               | [$0771: ld   a,(de)]
	exg		d0,d7
	jbsr	read_videoram_from_a0
	exg		d0,d7
	sub.b	d7,d0                          	    | [$0772: sub  (hl)]
	add.b	#9,d0                            	| [$0773: add  a,#9]
	cmp.b	#0xE5,d0                         	| [$0775: cp   #0xE5]
	jcc	l_0788                             	    | [$0777: jr   nc,l_0788]
	sub.b	#0x0A,d0                         	| [$0779: sub  #0x0A]
	cmp.b	#9,d0                            	| [$077B: cp   #9]
	jcs	l_0788                             	    | [$077D: jr   c,l_0788]
	addq.b	#1,d0                           	| [$077F: inc  a]
	jne	l_078E                             	    | [$0780: jr   nz,l_078E]
	subq.w	#1,a0                           	| [$0782: dec  l]
	subq.w	#1,a1                           	| [$0783: dec  e]
	subq.b	#1,d1                           	| [...]
	jne	l_0771                             	    | [$0784: djnz l_0771]
* else ... break
	jra	l_078E                             	    | [$0786: jr   l_078E]

l_0788:
	jbsr	read_videoram_from_a1               | [$0788: ld   a,(de)] hi score
	jbsr	write_videoram_to_a0                | [$0789: ld   (hl),a]
	subq.w	#1,a0                           	| [$078A: dec  l]
	subq.w	#1,a1                           	| [$078B: dec  e]
	subq.b	#1,d1                           	| [...]
	jne	l_0788                             	    | [$078C: djnz l_0788]

l_078E:
	jbsr	read_ixl_into_d0                    | [$078E: ld   a,ixl]
	addq.b	#4,d0                           	| [$0790: add  a,#4]
	* replace a0 lower nibble
	move.w	a0,d6
	move.b	d0,d6                           	| [$0792: ld   l,a] 
	move.w	d6,a0
	
	jbsr	read_videoram_from_a0               | [$0793: ld   a,(hl)]
	cmp.b	#0x24,d0                         	| [$0794: cp   #0x24]
	jne	l_0799                             	    | [$0796: jr   nz,l_0799]
	clr.b	d0                               	| [$0798: xor  a]
l_0799:
	and.b	#0x3F,d0                         	| [$0799: and  #0x3F]
	rol.b	#1,d0                            	| [$079B: rlca]
	move.b	d0,d2                           	| [$079C: ld   c,a]
	rol.b	#2,d0                            	| [$079D: rlca] * 2
	add.b	d2,d0                            	| [$079F: add  a,c]
	move.b	d0,d2                           	| [$07A0: ld   c,a]
	subq.w	#1,a0                           	| [$07A1: dec  l]
	jbsr	read_videoram_from_a0               | [$07A2: ld   a,(hl)]
	cmp.b	#0x24,d0                         	| [$07A3: cp   #0x24]
	jne	l_07A8                             	    | [$07A5: jr   nz,l_07A8]
	clr.b	d0                               	| [$07A7: xor  a]
l_07A8:
	add.b	d2,d0                            	| [$07A8: add  a,c]
	lea	ds_plyr_actv+_b_mcfg_bonus,a0  	        | [$07A9: ld   hl,#ds_plyr_actv +_b_mcfg_bonus] &actv_plyr_state[0x1E] ... load at game start from $9980
	cmp.b	(a0),d0                          	| [$07AC: cp   (hl)]
	beq.b	0f                               	| [...]
	rts                                    	    | [$07AD: ret  nz] [...]
0:
	move.b	w_mchn_cfg_bonus_9980+0x01,d0       | [$07AE: ld   a,(w_mchn_cfg_bonus_9980 + 0x01)] looks like a bonus may be awarded.
	move.b	d0,d1                           	| [$07B1: ld   b,a]
	and.b	#0x7F,d0                         	| [$07B2: and  #0x7F]
	move.b	d0,d2                           	| [$07B4: ld   c,a]
	move.b	(a0),d0                         	| [$07B5: ld   a,(hl)] &actv_plyr_state[0x1E]
	cmp.b	d2,d0                            	| [$07B6: cp   c]
	jcc	l_07BC                             	    | [$07B7: jr   nc,l_07BC]
	move.b	d2,d0                           	| [$07B9: ld   a,c]
	jra	l_07BD                             	    | [$07BA: jr   l_07BD]

l_07BC:
	add.b	d1,d0                            	| [$07BC: add  a,b] actv_plyr_state[0x1E] += mchn_cfg_bonus[1]
l_07BD:
	move.b	d0,(a0)                         	| [$07BD: ld   (hl),a]
	*move.b	d0,b_9AA0+0x0A                  	| [$07BE: ld   (b_9AA0 + 0x0A),a] sound-fx count/enable registers, bonus ship awarded sound (set non-zero)
	lea	ds_plyr_actv+_b_nships,a0      	        | [$07C1: ld   hl,#ds_plyr_actv +_b_nships]
	addq.b	#1,(a0)                         	| [$07C4: inc  (hl)]
	jbsr	draw_resv_ships_136c                | [$07C5: call draw_resv_ships_136c] new spare ship added
	lea	b16_99EA_bonus_ct_bcd+1,a0     	        | [$07C8: ld   hl,#b16_99EA_bonus_ct_bcd + 1]
	move.b	(a0),d0                         	| [$07CB: ld   a,(hl)]
	moveq	#1,d7
	abcd	d7,d0                           	| [$07CC: add  a,#1]+daa
	bcs.b	0f                               	| [...]
	move.b	d0,(a0)                         	| [$07CF: ld   (hl),a]
	rts                                    	    | [$07D0: ret  nc] [...]
0:
	move.b	d0,(a0)                         	| [$07CF: ld   (hl),a]
			                           	        | [$07D1: dec  l]
	move.b	-(a0),d0                         	| [$07D2: ld   a,(hl)]
	moveq	#1,d7
	abcd	d7,d0                           	| [$07D3: add  a,#1]+daa
	move.b	d0,(a0)                         	| [$07D6: ld   (hl),a]
	rts                                    	    | [$07D7: ret]
* end call $0728

*=============================================================================
* c_scoreman_incr_add()
*  Description:
*   Handle score increment (score manager)
*   Score is not stored other than in character ram, so this function is
*   specific to the layout of decimal digits in the character map.
* IN:
*  A == scoreman_inc_lut[B-1]
*  HL== destination address ... _tile_ram + 0x0300
* OUT:
*
* PRESERVES:
*  HL
*-----------------------------------------------------------------------------
c_scoreman_incr_add:
	tst.b	d0                               	| [and  a]
	bne.b	0f                               	| [...]
	rts                                    	    | [ret  z] [...]
0:

	add.b	(a0),d0                          	| [add  a,(hl)] a += _tile_ram[hl]
	cmp.b	#0x24,d0                         	| [cp   #0x24] $23=='Z', $24==' '
	jcs	l_07E1                             	    | [jr   c,l_07E1]
	sub.b	#0x24,d0                         	| [sub  #0x24] when is jr not taken?

l_07E1:
	cmp.b	#0x0A,d0                         	| [cp   #0x0A] $0A='A'
	jcc	l_07E7                             	    | [jr   nc,l_07E7]
	move.b	d0,(a0)                         	| [ld   (hl),a]
	rts                                    	    | [ret]

l_07E7:
	sub.b	#0x0A,d0                         	| [sub  #0x0A]

l_07E9_while_1:
	move.b	d0,(a0)+                         	| [ld   (hl),a] 0x8000[hl] = a
	                           	                | [inc  l]
	move.b	(a0),d0                         	| [ld   a,(hl)] a = 0x8000[hl + 1]
	cmp.b	#0x24,d0                         	| [cp   #0x24] $24==' '
	jne	l_07F1                             	    | [jr   nz,l_07F1]
	clr.b	d0                               	| [xor  a]
l_07F1:
	cmp.b	#0x09,d0                         	| [cp   #0x09]
	jeq	l_07F8_while                       	    | [jr   z,l_07F8_while]
	addq.b	#1,d0                           	| [inc  a]
	move.b	d0,(a0)                         	| [ld   (hl),a] 0x8000[hl] = a
	rts                                    	    | [ret] end call 07d8

l_07F8_while:
	clr.b	d0                               	| [xor  a]
	jra	l_07E9_while_1                     	    | [jr   l_07E9_while_1]

*=============================================================================
* Base-factors of points awarded for enemy hits, applied to multiples
* reported via _bug_collsn[]. Values are BCD-encoded, and ordered by object
* color group, i.e. as per _bug_collsn.
* Indexing is reversed, probably to take advantage of djnz.
* Index $00 is a base factor of 10 for challenge-stage bonuses to which a
* variable bonus-multiplier is applied (_bug_collsn[$0F]).
d_scoreman_inc_lut:
	.byte 0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00
	.byte 0x50,0x08,0x08,0x08,0x05,0x08,0x15,0x00

*=============================================================================
* gctl_supv_stage()
*  Description:
*   from _0461 game runner inf loop.
*   Checks for conditions indicating start of new stage or restart of
*   stage-in-progress.
*   0 bugs remaining indicates that a new-stage start is in order. (also 9008?)
*   Otherwise, the "restart_stage_flag" may indicate that the players active
*   ship has been terminated or captured requiring a stage re-start.
* IN:
*  ...
* OUT:
*  ...
*-----------------------------------------------------------------------------
gctl_supv_stage:

*  if ( num_bugs == 0  &&  !f_insert_attackers_2916 active ) ...
	move.b	ds_cpu0_task_actv_9000+0x08,d0       	| [ld   a,(ds_cpu0_task_actv_9000 + 0x08)] f_insert_attackers_2916 (supervises attack waves)
	move.b	d0,d1                           	| [ld   b,a]
	move.b	b_bugs_actv_nbr,d0              	| [ld   a,(b_bugs_actv_nbr)]
	or.b	d1,d0                             	| [or   b]
	jne	l_081B                             	| [jr   nz,l_081B]
* then ...
	move.b	d0,b_9AA0+0x00                  	| [ld   (b_9AA0 + 0x00),a] 0 ... sound-fx count/enable registers, pulsing formation sound effect

	jra	gctl_stg_restart_hdlr              	| [jp   gctl_stg_restart_hdlr] cleared the round ... num_bugs_on_screen ==0|| !f_insert_attackers_2916_active

l_081B:
* else if ( rst_stage_flag ) ...
	move.b	ds_9200_glbls+0x13,d0           	| [ld   a,(ds_9200_glbls + 0x13)] restart stage flag
	                               	| [and  a]
	bne.b	0f                               	| [...]
	rts                                    	| [ret  z] not the end of the stage, and not restart_stage event [...]
0:
* then ...
	clr.b	d0                               	| [xor  a]
	move.b	d0,ds_plyr_actv+_b_atk_wv_enbl  	| [ld   (ds_plyr_actv +_b_atk_wv_enbl),a] 0 ... restart_stage_flag has been set

	jra	gctl_stg_restart_hdlr              	| [jp   gctl_stg_restart_hdlr] restart_stage_flag has been set


*=============================================================================
* f_rts_0827()
*  Description:
*   empty task
* IN:
*  ...
* OUT:
*  ...
*-----------------------------------------------------------------------------
f_rts_0827:
	rts                                    	| [ret]

*=============================================================================
* f_update_sprites_0828()
*  Description:
*   Copies from sprite "buffer" to sprite RAM...
*   works in conjunction with CPU-sub1:_05BF to update sprite RAM
* IN:
*  ...
* OUT:
*  ...
*-----------------------------------------------------------------------------
f_update_sprites_0828:
	move.b	#1,d0                           	| [$0828: ld   a,#1]
	move.b	d0,b_CPU1_in_progress           	| [$082A: ld   (b_CPU1_in_progress),a] 1
	
	* update all sprite registers at the same time
	* (it was done in cooperation with the other cpu)
		
	lea	mrw_sprite_code_8B00,a0             	| [$082D: ld   hl,#mrw_sprite_code_8B00]
	lea	sfr_sprite_code_8B80,a1             	| [$0830: ld   de,#sfr_sprite_code_8B80]
	move.w	#0x80,d1                        	| [$0833: ld   bc,#0x0040] 64
	jbsr	ldir                              	| [$0836: ldir]
	lea	mrw_sprite_posn_9300,a0             	| [$0838: ld   hl,#mrw_sprite_posn_9300]
	lea	sfr_sprite_posn_9380,a1             	| [$083B: ld   de,#sfr_sprite_posn_9380]
	move.w	#0x80,d1                        	| [$083E: ld   c,#0x40]
	jbsr	ldir                              	| [$0840: ldir]
	lea	mrw_sprite_ctrl_9B00,a0             	| [$0842: ld   hl,#mrw_sprite_ctrl_9B00]
	lea	sfr_sprite_ctrl_9B80,a1             	| [$0845: ld   de,#sfr_sprite_ctrl_9B80]
	move.w	#0x80,d1                        	| [$0848: ld   c,#0x40]
	jbsr	ldir                              	| [$084A: ldir]

	* host side uses the sfr_sprite_code_8B80 address directly, no need to
	* call any OSD shit
	
*	lea	mrw_sprite_code_8B00+0x40,a0        	| [ld   hl,#mrw_sprite_code_8B00 + 0x40]
*	lea	sfr_sprite_code_8B80+0x40,a1        	| [ld   de,#sfr_sprite_code_8B80 + 0x40]
*	move.b	#0x00,d1                        	| [ld   bc,#0x0040] 64
*	move.b	#0x40,d2                        	| [ld   bc,#0x0040] 64
*	jbsr	ldir                              	| [ldir]
*	lea	mrw_sprite_posn_9300+0x40,a0        	| [ld   hl,#mrw_sprite_posn_9300 + 0x40]
*	lea	sfr_sprite_posn_9380+0x40,a1        	| [ld   de,#sfr_sprite_posn_9380 + 0x40]
*	move.b	#0x40,d2                        	| [ld   c,#0x40]
*	jbsr	ldir                              	| [ldir]
*	lea	mrw_sprite_ctrl_9B00+0x40,a0        	| [ld   hl,#mrw_sprite_ctrl_9B00 + 0x40]
*	lea	sfr_sprite_ctrl_9B80+0x40,a1        	| [ld   de,#sfr_sprite_ctrl_9B80 + 0x40]
*	move.b	#0x40,d2                        	| [ld   c,#0x40]
*	jbsr	ldir                              	| [ldir]
	
	clr.b	d0                               	| [xor  a]
	move.b	d0,b_CPU1_in_progress           	| [ld   (b_CPU1_in_progress),a] 0
l_0850:
	move.b	b_CPU2_in_progress,d0           	| [ld   a,(b_CPU2_in_progress)] check status of other CPU... while (b_CPU2_in_progress) == $01 ...
	subq.b	#1,d0                           	| [dec  a]
	jeq	l_0850                             	    | [jr   z,l_0850] wait
	rts                                    	    | [ret]
* end task $0828

*=============================================================================
* f_misc_gameplay_events_0857()
*  Description:
*    triggers various parts of gameplay based on parameters
* IN:
*  ...
* OUT:
*  ...
*-----------------------------------------------------------------------------
f_misc_gameplay_events_0857:
	move.b	ds4_game_tmrs_92ac+2,d0             | [$0857: ld   a,(ds4_game_tmrs_92ac + 2)]
	move.b	d0,d1                           	| [$085A: ld   b,a] parameter to c_08AD
	cmp.b	#0x3C,d0                         	| [$085B: cp   #0x3C]
	jcc	l_0865                             	    | [$085D: jr   nc,l_0865]
* increases allowable max_bombers after a time
	move.b	ds_new_stage_parms_99c0+0x05,d0     | [$085F: ld   a,(ds_new_stage_parms_99c0 + 0x05)]
	move.b	d0,ds_new_stage_parms_99c0+0x04     | [$0862: ld   (ds_new_stage_parms_99c0 + 0x04),a] new_stage_parms[4] = new_stage_parms[5] ... max bombers

* set bomb drop enable flags
l_0865:
	move.b	b_bugs_actv_nbr,d0              	| [$0865: ld   a,(b_bugs_actv_nbr)]
	move.b	d0,d2                           	| [$0868: ld   c,a] parameter to c_08BE
	move.b	ds_new_stage_parms_99c0+0x00,d0     | [$0869: ld   a,(ds_new_stage_parms_99c0 + 0x00)] set bomb drop enable flags
	lea	d_0909+0*4,a0                  	        | [$086C: ld   hl,#d_0909 + 0 * 4]
	jbsr	c_08BE                            	| [$086F: call c_08BE] A==new_stage_parms[0], HL==d_0909, C==num_bugs_on_scrn
	move.b	d0,b_92C0+0x08                  	| [$0872: ld   (b_92C0 + 0x08),a] = c_08BE() ... bomb drop enable flags

* flag indicates number of flying aliens is less than new_stage_parm[7]
* if flag is set by sub-CPU tasking kernel ...
	move.b	b_92A0+0x0A,d0                  	| [$0875: ld   a,(b_92A0 + 0x0A)] continuous bombing when flag set
	                               	            | [$0878: and  a]
	jeq	l_0888                             	    | [$0879: jr   z,l_0888]

* then ... set default start values for bomber launch timers in continuous bombing state
* this will also happen momentarily at start of round until bugs_actv_nbr exceeds ds_new_stage_parms_99c0[0x07]
	lea	b_92C0+0x04,a0                 	        | [$087B: ld   hl,#b_92C0 + 0x04] memset( b_92C0_4, 2, 3 )
	move.b	#2,d0                           	| [$087E: ld   a,#2]
	move.b	#3,d1                           	| [$0880: ld   b,#3]
	jbsr	rst_18                            	| [$0882: rst  0x18] memset((HL), A=fill, B=ct)
	clr.b	d0                               	| [$0883: xor  a]
	move.b	d0,b_9AA0+0x00                  	| [$0884: ld   (b_9AA0 + 0x00),a] 0 ... sound-fx count/enable registers, kill pulsing sound effect (free-fly)
	rts                                    	    | [$0887: ret]

l_0888:
* ... else after bugs_actv_nbr exceeds parameter_7 until continous bombing begins
	move.b	ds_new_stage_parms_99c0+0x01,d0     | [$0888: ld   a,(ds_new_stage_parms_99c0 + 0x01)]
	lea	d_0909+8*4,a0                  	        | [$088B: ld   hl,#d_0909 + 8 * 4] offset the data pointer
	jbsr	c_08BE                            	| [$088E: call c_08BE] A==new_stage_parms[1], HL==d_0929, C==num_bugs_on_scrn
	move.b	d0,b_92C0+0x04                  	| [$0891: ld   (b_92C0 + 0x04),a] c_08BE() ... boss alien default bomber timer
	move.b	ds_new_stage_parms_99c0+0x02,d0     | [$0894: ld   a,(ds_new_stage_parms_99c0 + 0x02)]
	lea	d_08CD,a0                      	        | [$0897: ld   hl,#d_08CD]
	jbsr	c_08AD                            	| [$089A: call c_08AD] A==new_stage_parms[2], HL==d_08CD
	move.b	d0,b_92C0+0x05                  	| [$089D: ld   (b_92C0 + 0x05),a] c_08AD() ... red alien default bomber timer
	move.b	ds_new_stage_parms_99c0+0x03,d0     | [$08A0: ld   a,(ds_new_stage_parms_99c0 + 0x03)]
	lea	d_08EB,a0                      	        | [$08A3: ld   hl,#d_08EB]
	jbsr	c_08AD                            	| [$08A6: call c_08AD] A==new_stage_parms[3], HL==d_08EB
	move.b	d0,b_92C0+0x06                  	| [$08A9: ld   (b_92C0 + 0x06),a] c_08AD() ... yellow alien default bomber timer
	rts                                    	    | [$08AC: ret]

*=============================================================================
* c_08AD()
*  Description:
*  for f_misc_gameplay_events_0857
* IN:
*  A == ds_new_stage_parms_99c0[2] or [3]
*  B == ds4_game_tmrs_92ac[2]
*  HL == d_08CD or d_08EB
* OUT:
*  A == (hl)
*-----------------------------------------------------------------------------
c_08AD:
* HL += 3 * A ... index into groups of 3 bytes
	move.b	d0,d4                           	| [ld   e,a]
	asl.b	#1,d0                            	| [sla  a]
	add.b	d4,d0                            	| [add  a,e]
	jbsr	add_d0_to_a0_0010                            	| [rst  0x10] HL += A

	move.b	d1,d0                           	| [ld   a,b] ds4_game_tmrs_92ac[2] from f_misc_gameplay_events_0857
	cmp.b	#0x28,d0                         	| [cp   #0x28]
	jcc	l_08B8                             	| [jr   nc,l_08B8]
	addq.w	#1,a0                           	| [inc  hl]
l_08B8:
	tst.b	d0                               	| [and  a]
	jne	l_08BC                             	| [jr   nz,l_08BC]
	addq.w	#1,a0                           	| [inc  hl]
l_08BC:
	move.b	(a0),d0                         	| [ld   a,(hl)]
	rts                                    	| [ret]
* end 'call _08AD'

*=============================================================================
* c_08BE()
*  Description:
*   for f_misc_gameplay_events_0857
* IN:
*  D0==ds_new_stage_parms_99c0 + 0x00 or ds_new_stage_parms_99c0 + 0x01
*  D2==bugs_actv_nbr
*  A0== pointer _0909, _0929
* OUT:
*  D0==(A0)
*-----------------------------------------------------------------------------
c_08BE:
* A used as index into sets of 4
* 16-bit division not needed here, but slightly more efficient to load the
* dividend into upper byte of HL and take quotient from H
* the quotient is ranged 0-4, so in the case the A max out at 7 and number
* of creatures is 40, the selected byte would be at $0929, so d_0909 and
* d_0929 should be one contiguous table.
	asl.b	#1,d0                            	| [sla  a]
	jbsr	add_2_times_d0_to_a0_0008           | [rst  0x08] HL += 2A
	movem.w	d5/d6,-(a7)                         | [ex   de,hl]
	move.b	d2,d5                           	| [ld   h,c]
	move.b	#0x0A,d0                        	| [ld   a,#0x0A]
	jbsr	c_divmod                          	| [call c_divmod] HL=HL/10
	move.b	d5,d3
	movem.w	(a7)+,d5/d6                         | [ex   de,hl] 8-bit quotient into d ...
	move.b	d3,d0                           	| [ld   a,d] ... quotient into a
	jbsr	add_d0_to_a0_0010                   | [rst  0x10] HL += A

	move.b	(a0),d0                         	| [ld   a,(hl)]
	rts                                    	    | [ret]

*=============================================================================
* sets of 3 bytes indexed by stage parameters 2 and 3 (max value 9)
d_08CD:
	.byte 0x09,0x07,0x05
	.byte 0x08,0x06,0x04
	.byte 0x07,0x05,0x04
	.byte 0x06,0x04,0x03
	.byte 0x05,0x03,0x03
	.byte 0x04,0x03,0x03
	.byte 0x04,0x02,0x02
	.byte 0x03,0x03,0x02
	.byte 0x03,0x02,0x02
	.byte 0x02,0x02,0x02
d_08EB:
	.byte 0x06,0x05,0x04
	.byte 0x05,0x04,0x03
	.byte 0x05,0x03,0x03
	.byte 0x04,0x03,0x02
	.byte 0x04,0x02,0x02
	.byte 0x03,0x03,0x02
	.byte 0x03,0x02,0x01
	.byte 0x02,0x02,0x01
	.byte 0x02,0x01,0x01
	.byte 0x01,0x01,0x01

* sets of 4 bytes indexed by stage parameters 0 and 1 (max value 7)
d_0909:
	.byte 0x03,0x03,0x01,0x01
	.byte 0x03,0x03,0x03,0x01
	.byte 0x07,0x03,0x03,0x01
	.byte 0x07,0x03,0x03,0x03
	.byte 0x07,0x07,0x03,0x03
	.byte 0x0F,0x07,0x03,0x03
	.byte 0x0F,0x07,0x07,0x03
	.byte 0x0F,0x07,0x07,0x07
*d_0929:
	.byte 0x06,0x0A,0x0F,0x0F
	.byte 0x04,0x08,0x0D,0x0D
	.byte 0x04,0x06,0x0A,0x0A

*=============================================================================
* f_blink_players_text_0935()
*  Description:
*    handle "blink" of Player1/Player2 texts.
*    Toggles the "UP" text on multiples of 16 frame counts.
*    With frame counter being about 60hz, we should get a blink of
*    about twice per second.
* IN:
*  ...
* OUT:
*  ...
*-----------------------------------------------------------------------------
f_blink_players_text_0935:
*  A = ds3_frame_cts_92A0[0] / 16
	move.b	ds3_frame_cts_92A0+0,d0         	| [ld   a,(ds3_frame_cts_92A0 + 0)]
	rol.b	#4,d0                            	| [rlca] * 4

*=============================================================================
* gctl_1up2up_displ()
*  Description:
*   Blink 1UP/2UP
* IN:
*   A==0 ... called by game_halt()
*   A==frame_cnts/16 ...continued from f_blink_players_text_0935()
* OUT:
*  ...
*-----------------------------------------------------------------------------
c_093C:
	move.b	d0,d2                           	| [ld   c,a] stash counter in C

* if ( game_state != IN_GAME_MODE )  return
	move.b	b8_game_state_9201,d0           	| [ld   a,(b8_game_state_9201)] if ( ! IN_GAME )
	cmp.b	#3,d0                            	| [cp   #3]
	beq.b	0f                               	| [...]
	rts                                    	| [ret  nz] [...]
0:

* B = ds_plyr_actv.p1or2
* (9820[] has not cleared yet so plyr_state.p1or2 may be invalid at first game start after powerup.)
	move.b	ds_plyr_actv+_b_plyr_nbr,d0     	| [ld   a,(ds_plyr_actv +_b_plyr_nbr)] 0==plyr1, 1==plyr2
	move.b	d0,d1                           	| [ld   b,a] stash it in B

* do 1UP
	not.b	d0                               	| [cpl] toggle to 1 if 1UP

	and.b	d2,d0                            	| [and  c] C == 1 if wipe
	lea	str_1UP,a0                     	| [ld   hl,#str_1UP]
	lea	0x8000+0x03C0+0x19,a1      	| [ld   de,#0x8000 + 0x03C0 + 0x19] 'P' of 1UP
	jbsr	draw_3_characters_095f                            	| [call draw_3_characters_095f] wipe if A != 0

* if ( two_plyr_game ) then ...
	move.b	b8_99B3_two_plyr_game,d0        	| [ld   a,(b8_99B3_two_plyr_game)]
	                               	| [and  a]
	bne.b	0f                               	| [...]
	rts                                    	| [ret  z] [...]
0:

* ... do 2UP
	move.b	d1,d0                           	| [ld   a,b] 1 if 2UP
	and.b	d2,d0                            	| [and  c] C == 1 if wipe
	lea	str_2UP,a0                     	| [ld   hl,#str_2UP]
	lea	0x8000+0x03C0+0x04,a1      	| [ld   de,#0x8000 + 0x03C0 + 0x04] 'P' of 2UP
*       call draw_3_characters_095f

*=============================================================================
* draw_3_characters_095f()
*  Description:
*   draw 3 characters
* IN:
*  A==1 ...  wipe text
*  A==0 ...  show text at HL
*  HL == src pointer, xUP text
*  DL == dest pointer
* OUT:
* PRESERVES:
*  BC
*-----------------------------------------------------------------------------
draw_3_characters_095f:
	exg		a1,d7
	move.w	d0,-(sp)                    | [$095F: push bc]
	and.b	#0x01,d0                    | [$0960: and  #0x01]
	jeq	l_0967                          | [$0962: jr   z,l_0967]
	lea	str_0974,a0                    	| [$0964: ld   hl,#str_0974] wipe
l_0967:
						                | [$0967: ld   bc,#0x0003] 3
	move.b	(a0)+,d0					| [$096A: ldir]
	jbsr	osd_w_videoram
	addq.w	#1,d7
	move.b	(a0)+,d0					| [$096A: ldir]
	jbsr	osd_w_videoram
	addq.w	#1,d7
	move.b	(a0)+,d0					| [$096A: ldir]
	jbsr	osd_w_videoram
	addq.w	#1,d7
	move.w	(sp)+,d0                    | [$096C: pop  bc]
	exg		a1,d7
	rts                                 | [$096D: ret]

*=============================================================================
str_1UP:
	.byte 0x19,0x1E,0x01                          | "PU1"
str_2UP:
	.byte 0x19,0x1E,0x02                          | "PU2"
str_0974:
	.byte 0x24,0x24,0x24                         | "spaces"
	.align	2
	
*=============================================================================
* f_credit_game_state_management_0977()
*  Description:
*   Polls the test switch, updates game-time counter, updates credit count.
*   Handles coinage and changes in game-state.
*
*    If credit > 0, change _game_state to Push_start ($02)
*     (causes 38d loop to transition out of the Attract Mode, if it's not already in PUSH_START mode)
*
*    Check Service Switch - in "credit mode", the 51xx is apparently programmed
*      to set io_buffer[0]=$bb to indicate "Self-Test switch ON position" .
*      So, ignore the credit count and jump back to the init.
*      Bally manual states that "may begin a Self-Test at any time by sliding the
*      ... switch to the "ON" position...the game will react as follow: ... there is
*     an explosion sound...upside down test display which lasts for about 1/2 second"
*    However MAME may not handle this correctly - after the jump to Machine_init, the
*    system hangs up on the info screen, all that is shown is "RAM OK". (This is
*    true even if the switch is turned off again prior to that point).
*
*    Note mapping of character cells on bottom (and top) rows differs from
*    that of the rest of the screen|
*      801D-<<<<<<<<<<<<<<<<<<<<<<<<<<<<-8002
*      803d-<CREDIT __<<<<<<<<<<<<<<<<<<-8022
*
*    99E6-9 implements a count in seconds of total accumulated game-playing time.
*    counter (low digit increments 1/60th of second)
*
*    Credits available count (from HW IO) is transferred to the IO input
*    buffer (in BCD) in the NMI, and represent actual credits awarded (not
*    coin-in count). The HW count is decremented by the HW. The game logic
*    then must keep its own count to compare to the HW to determine if the
*    HW count has been added or decremented and thus determine game-start
*    condition and number of player credits debited from the HW count.
* IN:
*  ...
* OUT:
*  ...
*-----------------------------------------------------------------------------
f_credit_game_state_management_0977:
* if ( io_input[0] == $bb )
	move.b	ds3_io_input_99b5,d0       	        | [$0977: ld   a,(ds3_io_input_99b5 + 0x00)] check for bb ... Service Switch On indication in credit mode
	cmp.b	#0xBB,d0                         	| [$097A: cp   #0xBB]
	jeq	jp_RAM_test                        	    | [$097C: jp   z,jp_RAM_test]

* if ( game_state != IN_GAME_MODE )  // goto update freeplay_or_credit
	move.b	b8_game_state_9201,d0           	| [$097F: ld   a,(b8_game_state_9201)] if ( IN_GAME )
	cmp.b	#3,d0                            	| [$0982: cp   #3] game_state==IN_GAME
	jne	l_099F_update_freeplay_or_credit   	    | [$0984: jr   nz,l_099F_update_freeplay_or_credit]

* else // update timer
	lea	b32_99E6_gametime_secs_bcd+3,a0	        | [$0986: ld   hl,#b32_99E6_gametime_secs_bcd + 3] least-sig. digit increments 1/60th of second
	move.b	(a0),d0                         	| [$0989: ld   a,(hl)]
	move.b	#1,d7                           	| [$098A: add  a,#1]
	CLEAR_XC_FLAGS
	abcd	d7,d0								| add+daa
       * if ( ct == $60 ) ct=0
	cmp.b	#0x60,d0                         	| [$098D: cp   #0x60] if A==60, Cy is not set...
	jne	l_0992_update_counter              	    | [$098F: jr   nz,l_0992_update_counter]
	clr.b	d0                               	| [$0991: xor  a]

      * update 4 bytes of the timer (BCD count 0 - 99.99.99.60)
l_0992_update_counter:
	move.b	#4,d1                           	| [$0992: ld   b,#4]
	INVERT_XC_FLAGS                        	    | [$0994: ccf] ... compliment Cy (provides Cy into 1's place if A==60...
l_0995:
	move.b	d0,(a0)                         	| [$0995: ld   (hl),a] Update 60'ths digit.
	                           	                | [$0996: dec  l]
 	move.b	-(a0),d0                         	| [$0997: ld   a,(hl)] note, last iteration, reads from 99e5, but then exits the loop.
	moveq	#0,d7
	abcd	d7,d0						        | adc  a,#0 + daa ...carry into 1's, 10's, or 100's place.

	subq.b	#1,d1                           	| [...]
	jne	l_0995                             	    | [djnz l_0995]

	jra	l_09E1_update_game_state           	    | [jr  l_09E1_update_game_state] skip display of "CREDIT" when in Game Mode

l_099F_update_freeplay_or_credit:

	move.b	b8_99B8_credit_cnt,d0           	| [ld   a,(b8_99B8_credit_cnt)] if free-play == $A0  i.e. > 99 (BCD)
	cmp.b	#0xA0,d0                         	| [cp   #0xA0]

	lea	0x8000+0x0000+0x3C,a1      	| [$09A4: ld   de,#0x8000 + 0x0000 + 0x3C] dest of "C" of "CREDIT"

* if (credit_cnt == 0xA0 )  // goto puts_freeplay ...  i.e. > 99 (BCD)
	jeq	l_09D9_puts_freeplay               	    | [$09A7: jr   z,l_09D9_puts_freeplay] skip credits status
* else if (credit_cnt < 0xA0 )  // do credit update display
	move.b	ds3_io_input_99b5,d0       	        | [$09A9: ld   a,(ds3_io_input_99b5 + 0x00)] io_input[credit_count]
       * puts "CREDIT"
	lea	str_09CA+6-1,a0                	        | [$09AC: ld   hl,#str_09CA + 6 - 1] source of 'C' in reversed string
	move.w	#0x06,d1                        	| [$09AF: ld   bc,#0x0006] strlen(strCredit) 6
	jbsr		lddr_video                            | [$09B2: lddr]
       * leave the "space" following the 'T'
	subq.w	#1,a1                           	| [dec  e] de-- advances one cell to the right (note: bottom row, so not de-20!)
	move.l	a1,d7
	
       * if bcd_credit_ct > 9, then rotate "10's" nibble into lower nibble and display it.
	move.b	d0,d2                           	| [ld   c,a] save temp hw credit count
	rol.b	#4,d0                            	| [rlca] * 4
	and.b	#0x0F,d0                         	| [and  #0x0F] only upper digit of BCD credit cnt
	jeq	l_09C0_putc_ones_place_digit       	| [jr   z,l_09C0_putc_ones_place_digit]

	jbsr	osd_w_videoram                  	| [ld   (de),a] putc 10's place digit.
	subq.w	#1,d7                           	| [dec  e] next character position to the right ... 1's place digit

l_09C0_putc_ones_place_digit:
	move.b	d2,d0                           	| [ld   a,c] reload saved hw count
	and.b	#0x0F,d0                         	| [and  #0x0F] only lower digit of BCD credit cnt
	jbsr	osd_w_videoram                         	| [ld   (de),a] putc 1's place digit.
       * one more space to be sure two cells are covered.
	                           	| [dec  e]
	move.b	#0x24,d0                        	| [ld   a,#0x24]
	subq.w	#1,d7
	jbsr	osd_w_videoram                         	| [ld   (de),a]

	jra	l_09E1_update_game_state           	| [jr   l_09E1_update_game_state]

*=============================================================================

str_09CA:
* "CREDIT" (reversed)
	.byte 0x1D,0x12,0x0D,0x0E,0x1B,0x0C
str_09D0:
* "FREE PLAY" (reversed)
	.byte 0x22,0x0A,0x15,0x19,0x24,0x0E,0x0E,0x1B,0x0F
	.align	2

l_09D9_puts_freeplay:
	lea	str_09D0+9-1,a0                	    | [$09D9: ld   hl,#str_09D0 + 9 - 1] load src (last byte) of string "FREE PLAY"
	move.w	#0x09,d1                        | [$09DC: ld   bc,#0x0009] 9
	jbsr	lddr_video                      | [$09DF: lddr]

l_09E1_update_game_state:

* if ( game_state == GAME_ENDED ) return
	move.b	b8_game_state_9201,d0           | [$09E1: ld   a,(b8_game_state_9201)] if Game Ended
	                               	        | [$09E4: and  a]
	bne.b	0f                              | [...]
	rts                                    	| [$09E5: ret  z] 0==GAME_ENDED [...]
0:

* else if ( game_state == ATTRACT_MODE && io_input[credit_count] > 0 )
	subq.b	#1,d0                           | [$09E6: dec  a] ATTRACT_MODE - 1 ==0
	jne	l_09FF_check_credits_used          	| [$09E7: jr   nz,l_09FF_check_credits_used] if (!ATTRACT_MODE)
	move.b	ds3_io_input_99b5,d0       | [$09E9: ld   a,(ds3_io_input_99b5 + 0x00)] io_input[credit_count]
	                               	        | [$09EC: and  a]
	jeq	l_09FF_check_credits_used          	| [$09ED: jr   z,l_09FF_check_credits_used] if io_credit_count == 0

* then {
*   game_state = READY_TO_PLAY_MODE
	move.b	#2,d0                           | [$09EF: ld   a,#2]
	move.b	d0,b8_game_state_9201           | [$09F1: ld   (b8_game_state_9201),a] READY_TO_PLAY ...push start to begin!

       * memset($9AA0,0,8)
	clr.b	d0                               | [$09F4: xor  a]
	lea	ds_9AA0+0x00,a0                	     | [$09F5: ld   hl,#ds_9AA0 + 0x00] clear sound-fx count/enable registers (9AA0...9AA7)
	move.b	#8,d1                            | [$09F8: ld   b,#8]
	jbsr	rst_18                           | [$09FA: rst  0x18] memset((HL), A=fill, B=ct)
       * memset($9AA0+8+1,0,15)              
	addq.w	#1,a0                            | [$09FB: inc  l] hl = $9AA0+9, sound-fx cnt/enable regs, 15 bytes, skipped 9AA0[8] (coin-in)
	move.b	#0x0F,d1                         | [$09FC: ld   b,#0x0F]
	jbsr	rst_18                           | [$09FE: rst  0x18] memset((HL), A=fill, B=ct)
* }

l_09FF_check_credits_used:

* A = credits_counted - io_input[credit_count]  ... credits_used
* if ( A == 0 )  return
	move.b	ds3_io_input_99b5,d0            	| [$09FF: ld   a,(ds3_io_input_99b5 + 0x00)] io_input[credit_count] ... in BCD!
	move.b	d0,d2                           	| [$0A02: ld   c,a]
	move.b	b8_99B8_credit_cnt,d0           	| [$0A03: ld   a,(b8_99B8_credit_cnt)] BCD
	move.b	d0,d1                           	| [$0A06: ld   b,a] stash the previous credit count
	CLEAR_XC_FLAGS
	sbcd	d2,d0                            	| [$0A07: sub  c] (see daa below)
	bne.b	0f                               	| [...]
	rts                                    		| [$0A08: ret  z] return if no change of game state [...]
0:

* else  if (io_input[credit_count] > credit_cnt)  goto _update_credit_ct ...
	jcs	l_0A1A_update_credit_ct            	    | [$0A09: jr   c,l_0A1A_update_credit_ct] Cy is set (credit_hw > credit_ct)

* else  ... if (io_input[credit_count] < credit_cnt) {

*   two_plyr_game = credits_used - 1            | A == credits_used ... corrected for arithmentic with BCD operands
	                                            | [$0A0B: daa]
	subq.b	#1,d0                           	| [$0A0C: dec  a]
	move.b	d0,b8_99B3_two_plyr_game        	| [$0A0D: ld   (b8_99B3_two_plyr_game),a] 0 for 1P, 1 for 2P

*   credit_cnt = io_input[credit_count]
	move.b	d2,d0                           	| [$0A10: ld   a,c]
	move.b	d0,b8_99B8_credit_cnt           	| [$0A11: ld   (b8_99B8_credit_cnt),a] io_input[credit_count]

*   game_state = IN_GAME_MODE
	move.b	#3,d0                           	| [$0A14: ld   a,#3]
	move.b	d0,b8_game_state_9201           	| [$0A16: ld   (b8_game_state_9201),a] 3 (IN_GAME)
	rts                                    	    | [$0A19: ret]
* }

* ...  credits_countd_hw > credit_count_sw
l_0A1A_update_credit_ct:
* credit_cnt = io_input[credit_count]
	move.b	d2,d0                           	| [$0A1A: ld   a,c] C==credits_countd_hw (from above)
	move.b	d0,b8_99B8_credit_cnt           	| [$0A1B: ld   (b8_99B8_credit_cnt),a] credits_countd_hw

* no coin_in sound for free-play
* if ( credit_cnt == $A0 )  return
	cmp.b	#0xA0,d0                         	| [$0A1E: cp   #0xA0]
	bne.b	0f                               	| [...]
	rts                                    	    | [$0A20: ret  z] [...]
0:
* else ... set global credit count for sound-manager
	CLEAR_XC_FLAGS
	sbcd	d1,d0                            	| [$0A21: sub  b]+daa B==credit_ct_previous (from above)
	move.b	d0,b_9A70+0x09                  	| [$0A23: ld   (b_9A70 + 0x09),a] sndmgr, count of credits-in since last update (triggering coin-in sound)
	rts                                    	    | [$0A26: ret]


*=============================================================================
* c_mach_info_add_score()
*  Description:
*   Add player score(s) to total at end of game (called once for each player).
* IN:
*  DE = ptr to 10's place digit of score in tile RAM.
* OUT:
*  ...
*-----------------------------------------------------------------------------
c_mach_info_add_score:
*  first part packs the 5 digits of the score into BCD using 4 bytes (ones omitted)
	lea	ds_9100_tmp+0x03,a0            	| [ld   hl,#ds_9100_tmp + 0x03] 3 bytes, workspace for converting score to BCD (temporary)
	move.b	#5,d1                           	| [ld   b,#5]
l_0A2C:
	move.b	(a1)+,d0                         	| [ld   a,(de)]
	                           	| [inc  e]
*  if ( char != $24 ) goto 0a33  // if space, then a:=0
	cmp.b	#0x24,d0                         	| [cp   #0x24] space character
	jne	l_0A33                             	    | [jr   nz,l_0A33]
	clr.b	d0                               	| [xor  a]
l_0A33:
	jbsr	rrd                               	| [rrd]
	btst.b	#0,d1                           	| [bit  0,b]
	jne	l_0A3A                             	    | [jr   nz,l_0A3A]
	subq.w	#1,a0                           	| [dec  l]
l_0A3A:
	subq.b	#1,d1                           	| [...]
	jne	l_0A2C                             	    | [djnz l_0A2C]

	clr.b	d0                               	| [xor  a]
	jbsr	rrd                               	| [rrd] one more rrd to fix the last digit
	                           	                | [dec  l]
	clr.b	-(a0)                             	| [ld   (hl),#0] *9100:=0 (score is now "00054321")
	lea	ds_9100_tmp+0x03,a0                     | [ld   l,#3] HL:=9103
	lea	b32_99E2_sum_score_bcd+3,a1    	        | [ld   de,#b32_99E2_sum_score_bcd + 3]
	move.b	#0x04,d1                        	| [ld   b,#0x04]
	CLEAR_XC_FLAGS	                            	| [and  a] clear the carry flag?
l_0A4A:
	move.b	(a1),d0                         	| [ld   a,(de)]
	move.b	(a0),d7
	abcd	d7,d0   | [adc  a,(hl)+daa]
	move.b	d0,(a1)                         	| [ld   (de),a]
	subq.w	#1,a1                           	| [dec  e]
	subq.w	#1,a0                           	| [dec  l]
	subq.b	#1,d1                           	| [...]
	jne	l_0A4A                             	    | [djnz l_0A4A]
	rts                                    	    | [ret]

*=============================================================================
* c_text_out_i_to_d_0A53()
*  Description:
*   Display an integer value as decimal.
* IN:
*   D5: input value (max $FFFF)
*   A1.W: points to destination.
* OUT:
*   A1.W: points to (destination - count * 0x40)
*-----------------------------------------------------------------------------
c_text_out_i_to_d_0A53:
	exg		d7,a1
	move.b	#1,d1                           	| [ld   b,#1] there is at least 1 digit ... (but maybe more)
	LOAD_D5D6_FROM_D5_16
l_0A55:
* check HL > 10 ... but we can only cp 8 bits in A, so we have to break HL into 2 bytes.
* while ( ( H > 0 )  ...
											| [dec  h]
	tst.b	d5                           	| [inc  h]
	jne	l_0A5E                             	| [jr   nz,l_0A5E]
* ... || ( L > $0A ) )
	move.b	d6,d0                           	| [ld   a,l]
	cmp.b	#0x0A,d0                         	| [cp   #0x0A] CY is set if A < $0A

	jcs	l_0A68                             	| [jr   c,l_0A68]

* do: Convert next digit to the "left" (next higher power of 10).
l_0A5E:
	move.b	#0x0A,d0                        	| [ld   a,#0x0A]
	jbsr	c_divmod                          	| [call c_divmod] A=HL%10 (gets a "printable" decimal digit)
	move.w	d0,-(sp)                        	| [push af] converted digit returned in A and stacked.
	addq.b	#1,d1                           	| [inc  b] count of digits in converted decimal number.
	jra	l_0A55                             	    | [jr   l_0A55]

* while ( b > 0 ) ... show digits from left to right
l_0A67:
	move.w	(sp)+,d0                        	| [pop  af]

l_0A68:
* display the value in A as a single decimal digit .. each DE-=$20 advances 1 character to the right
	jbsr	c_0A6E                            	| [call c_0A6E]
	subq.b	#1,d1                           	| [...]
	jne	l_0A67                             	| [djnz l_0A67]
	exg		d7,a1
	rts                                    	| [ret]

c_0A6E:
	jbsr	osd_w_videoram	             	| [ld   (de),a]
	sub.w	#0x20,d7
	rts
	
	                      	| [jp   rst_DEminus20] it will 'ret' from the jp.
* end 0a53

* aux function to exchange registers with stack contents
exg_sp_d5d6:
	movem.w	d3/d4,-(a7)
	movem.w	(8,a7),d3/d4	| return address + D3/D4: 8 bytes to skip
	movem.w	d5/d6,(8,a7)
	move.w	d3,d5
	move.w	d4,d6
	movem.w	(A7)+,d3/d4
	rts

*=============================================================================
* hit_ratio()
*  Description:
*   Calculate and display hit/shot ratio.
* IN:
*  ...
* OUT:
*  A1 == resultant pointer to screen ram to be used by caller
*-----------------------------------------------------------------------------
c_puts_hitmiss_ratio_0A72:
	MOVE_TO_REG	ds_plyr_actv+_w_hit_ct,d5   | [ld   hl,(ds_plyr_actv +_w_hit_ct)]

* if ( shots fired  == 0 )
	MOVE_TO_REG	ds_plyr_actv+_w_shot_ct,d3  | [ld   de,(ds_plyr_actv +_w_shot_ct)]
											| [ld   a,d]
	tst.w	d3								| [or   e]
	jne	l_0A82                             	| [jr   nz,l_0A82]
* then
								            | [ld   de,#0x0000] uhh...isn't DE already 0? 0
	jra	l_0AD3                             	| [jr   l_0AD3]
* else
*   determine ratio: first, use left-shifts to up-scale the dividend and divisor
l_0A82:
l_0A82_while:
* while !(0x80 & d) && !(0x80 & h) de <<= 1, hl <<= 1
	btst.b	#15,d3                          | [bit  7,d]
	jne	l_0A90                             	| [jr   nz,l_0A90]
	btst.b	#15,d5                          | [bit  7,h]
	jne	l_0A90                             	| [jr   nz,l_0A90]
	add.w	d5,d5                           | [add  hl,hl]
	exg	d3,d5                              	| [ex   de,hl]
	add.w	d5,d5                           | [add  hl,hl]
	exg	d3,d5                              	| [ex   de,hl]
	jra	l_0A82_while                       	| [jr   l_0A82_while]

	
* do the actual division with resultant quotient scaled up by factor of 0x0100 to keep precision
l_0A90:
* HL = hl_adjusted_hits / (de_adjusted_shots / 0x0100)
	LOAD_D5D6_FROM_D5_16
	move.w	d3,d0                           	| [ld   a,d] divisor in A
	ror.w	#8,d0
	jbsr	c_divmod                          	| [call c_divmod] HL=HL/A (preserves DE)
	movem.w D5/D6,-(sp)                        	| [push hl]

* HL = modulus / (de_adjusted_shots / 0x0100)
	move.b	d0,d5                           	| [ld   h,a] result of HL%A
	clr.b	d6                               	| [ld   l,#0]
	move.w	d3,d0                           	| [ld   a,d] divisor in A
	ror.w	#8,d0
	jbsr	c_divmod                          	| [call c_divmod] HL=HL/A (preserves DE)

* SP points to lsb of 1st quotient (msb)
	bsr		exg_sp_d5d6                         | [ex   (sp),hl] restore msw (1st quotient) into HL, lsw (2nd quotient) to (SP), (SP+1)
	lea	b16_99B0_tmp,a1                	        | [ld   de,#b16_99B0_tmp] pointer to hit-miss ratio calc.
	move.b	#4,d1                           	| [ld   b,#4] loop counter to calculate percentage to 2 decimal places
	move.b	d5,d0                           	| [ld   a,h] msb of msw (first quotient), only low 4 bits significant (would be 0 or 1)
	clr.b	d5                               	| [ld   h,#0] done with this byte
l_0AA5_while:
	exg	a1,a0                              	    | [ex   de,hl] pointer->HL, lsb of HL+A -> DE
* 4-bit leftward rotation of the 12-bit number whose 4 most signigifcant bits
* are the 4 least significant bits of A, and its 8 least significant bits are at (HL)
	jbsr	rld                               	| [rld] rld (hl) ... 1st product msb + sum msb in A (hl in ram)
* advance the byte pointer when b==3 (case of b==1 not significant)
	btst.b	#0,d1                           	| [bit  0,b]
	jeq	l_0AAD                             	    | [jr   z,l_0AAD]
	addq.w	#1,a0                           	| [inc  l]
l_0AAD:
	exg	a1,a0                              	    | [ex   de,hl] lsb of HL+A -> HL, pointer to DE
	jbsr	c_0B06                            	| [call c_0B06] HL *= 10 ... MSB->A
	exg	d0,d7                              	    | [ex   af,af'] stash 1st product msb
	bsr		exg_sp_d5d6                         | [ex   (sp),hl] 2nd product to HL, 1st product to (SP)
	jbsr	c_0B06                            	| [call c_0B06] HL *= 10 ... MSB->A
	bsr		exg_sp_d5d6                         | [ex   (sp),hl] 1st product to HL, 2nd product to (SP)
	jbsr	add_d0_to_a0_0010                   | [rst  0x10] HL += A ... 1st product + 2nd product (msb)
	exg		d0,d7                              	| [ex   af,af'] 1st product msb -> A, stash sum lsb
	add.b	d5,d0                            	| [add  a,h] 1st product msb + sum msb
	clr.b	d5                               	| [ld   h,#0] done with this byte
	subq.b	#1,d1                           	| [...]
	jne	l_0AA5_while                       	    | [djnz l_0AA5_while]
	movem.w	(sp)+,d3/d4                    	    | [pop  de] restore SP

* if (A >= 5)
	cmp.b	#5,d0                            	| [cp   #5]
	jcs	l_0AD7                             	    | [jr   c,l_0AD7]
* then
	MOVE_TO_REG	b16_99B0_tmp,d3             	| [ld   de,(b16_99B0_tmp)] temp register for hit-miss ratio calc.
	LOAD_D3D4_FROM_D3_16
	                           	                | [ld   a,d] msb (99B1) ... but its really LSB
	CLEAR_XC_FLAGS
	moveq	#1,d7
	abcd	d7,d3                           	| [add  a,#1]+daa
	                           	                | [ld   d,a]
*  if
	jcc	l_0AD3                             	    | [jr   nc,l_0AD3]
*  then
	                           	                | [ld   a,e]
	abcd	d7,d4                           	| [add  a,#1]+daa
	                           	                | [ld   e,a]
*  fi

l_0AD3:
	LOAD_D3_16_FROM_D3D4
	MOVE_TO_VAR	d3,b16_99B0_tmp                 | [$0AD3: ld   (b16_99B0_tmp),de] tmp computed hit-miss ratio (BCD)
* setup for display of computed ratio
l_0AD7:
	move.b	#4,d1                           	| [$0AD7: ld   b,#4]
	clr.b	d2                               	| [$0AD9: ld   c,#0] use <:1> as flag
	lea	b16_99B0_tmp,a0                	        | [$0ADB: ld   hl,#b16_99B0_tmp] &hitratio.b0 (BCD)
	lea	0x8000+0x0120+0x18,a1      	            | [$0ADE: ld   de,#0x8000 + 0x0120 + 0x18]

* loop to putc 4 characters (XXX.X)
l_0AE1_while:
* if ( b==1 ) then ...
	subq.b	#1,d1                           	| [$0AE1: dec  b]
	jne	l_0AE8                             	    | [$0AE2: jr   nz,l_0AE8]
* ... show dot character left of to 10ths place
	move.b	#0x2A,d0                        	| [$0AE4: ld   a,#0x2A] '.' (dot) character.
	jbsr	write_videoram_to_a1                | [$0AE6: ld   (de),a]
	sub.w	#0x20,a1                            | [$0AE7: rst  0x20] DE-=$20 (next column)

l_0AE8:
	addq.b	#1,d1                           	| [$0AE8: inc  b] restore B from test at l_0AE1
	clr.b	d0                               	| [$0AE9: xor  a] clear A before rotating H<7:4> into it
	jbsr	rld                               	| [$0AEA: rld] rld (hl) ... (HL<7:4>) to A<3:0> ... HL used as pointer, is in RAM
* if (b == 3 || b==1) advance pointer to .b1  ... b==1 irrelevant
	btst.b	#0,d1                           	| [$0AEC: bit  0,b] even count of b
	jeq	l_0AF1                             	    | [$0AEE: jr   z,l_0AF1]
	addq.w	#1,a0                           	| [$0AF0: inc  l] HL++
 
l_0AF1:
* line up the shots/hits/ratio on the left - once we have A!=0, latch the
* state and keep going
* if ( A != 0 )
	tst.b	d0                               	| [$0AF1: and  a]
	jne	l_0AF8                             	    | [$0AF2: jr   nz,l_0AF8]
* || (0 != C & 0x01) ...
	btst.b	#0,d2                           	| [$0AF4: bit  0,c] check flag
	jeq	l_0AFC                             	    | [$0AF6: jr   z,l_0AFC]
* ... then
l_0AF8:
	bset.b	#0,d2                           	| [$0AF8: set  0,c] set flag
	jbsr	write_videoram_to_a1               	| [$0AFA: ld   (de),a]
	sub.w	#0x20,a1                          	| [$0AFB: rst  0x20] DE-=$20 (next column)

l_0AFC:
* b==3 is first digit left of decimal (10's place) so it has to start here regardless
* if ( B != 3 )
	move.b	d1,d0                           	| [ld   a,b]
	cmp.b	#3,d0                            	| [cp   #3]
	jne	l_0B03                             	    | [jr   nz,l_0B03]
* else
	bset.b	#0,d2                           	| [set  0,c]
l_0B03:
	subq.b	#1,d1                           	| [...]
	jne	l_0AE1_while                       	    | [djnz l_0AE1_while]
	rts                                    	    | [ret]

*=============================================================================
* c_0B06()
*  Description:
*   multiply by 10
* IN:
*   HL = 16-bit factor
*   A  = 8-bit factor
* OUT:
*   HL = (HL * $0A) & 0x00FF
*    A = (HL * $0A) >> 8 ... MSB
*
*-----------------------------------------------------------------------------
c_0B06:
	move.b	#0x0A,d0                        	| [ld   a,#0x0A]
	jbsr	c_104E_mul_16_8                   	| [call c_104E_mul_16_8] HL = HL * A
	move.b	d5,d0                           	| [ld   a,h]
	clr.b	d5                               	| [ld   h,#0x00] %256
	rts                                    	    | [ret]


_l_0B0F:
*          1000  c_1000

*
* input file gg1-2.s
*
* gg1-2.s
*  gg1-2.3m, 'maincpu' (Z80)
*
*  Utility functions, player and stage setup, text display.
*
*
*.module borg


.include "structs.inc"


**.area ROM (ABS,OVR)
*       .org 0x0FFF
*       .db 0x93                                   | checksum
*       .org 0x1000
*.area CSEG10


*=============================================================================
* c_1000()
*  Description:
*   for gctl_stg_new_atk_wavs_init_25a2
*   R register used as a randomizer?
* IN:
*  ...
* OUT:
*   A==random value
* PRESERVES:
*   HL
*-----------------------------------------------------------------------------
c_1000:

	move.l	a0,-(sp)                        	| [push hl]
	jbsr	osd_get_random                      | [ld   a,r]
	move.b	d0,d5                           	| [ld   h,a]
	move.b	ds3_frame_cts_92A0+0,d0         	| [ld   a,(ds3_frame_cts_92A0 + 0)]
	add.b	d5,d0                            	| [add  a,h]
	move.b	d0,d6                           	| [ld   l,a]
	lea	db_obj_home_posn_rc,a0         	        | [ld   h,#>db_obj_home_posn_rc]
	and.w	#0xFF,d6
	add.w	d6,a0
	move.b	(a0),d0                         	| [ld   a,(hl)]
	move.b	d0,d5                           	| [ld   h,a]
	jbsr	osd_get_random                      | [ld   a,r]
	add.b	d5,d0                            	| [add  a,h]
	move.l	(sp)+,a0                        	| [pop  hl]
	rts                                    	    | [ret]

**=============================================================================
** dead_code
**  Description:
**   Assuming this is dead code. There are no references to this anywhere as
**   either code or data.
**-----------------------------------------------------------------------------
** _1012
*	movem.w	d1/d2,-(sp)                    	| [push bc]
*	movem.w	d3/d4,-(sp)                    	| [push de]
*	move.l	a1,-(sp)                        	| [push de]
*	move.b	d4,d0                           	| [ld   a,e]
*	clr.b	d1                               	| [ld   b,#0]
*	sub.b	d6,d0                            	| [sub  l]
*	jcc	l_101E                             	| [jr   nc,l_101E]
*	bset.b	#0,d1                           	| [set  0,b]
*	neg.b	d0                               	| [neg]
*l_101E:
*	move.b	d0,d2                           	| [ld   c,a]
*	move.b	d3,d0                           	| [ld   a,d]
*	sub.b	d5,d0                            	| [sub  h]
*	jcc	l_102D                             	| [jr   nc,l_102D]
*	move.b	d0,d3                           	| [ld   d,a]
*	move.b	d1,d0                           	| [ld   a,b]
*	eor.b	#0x01,d0                         	| [xor  #0x01]
*	or.b	#0x02,d0                          	| [or   #0x02]
*	move.b	d0,d1                           	| [ld   b,a]
*	move.b	d3,d0                           	| [ld   a,d]
*	neg.b	d0                               	| [neg]
*l_102D:
*	cmp.b	d2,d0                            	| [cp   c]
*	scs		d6
*	move.w	d0,-(sp)                        	| [push af]
*	roxl.b	#1,d0                           	| [rla]
*      ^^^^^^ review cpu X flag
*	eor.b	d1,d0                            	| [xor  b]
*	roxr.b	#1,d0                           	| [rra]
*      ^^^^^^ review cpu X flag
*
*	bcs.b	0f
*	clr.b	d7
*	bra.b	1f
*0:
*	st.b	d7
*1:
*	cmp.b	#1,d7                            	| [ccf]
*	SET_X_FROM_C
*	roxl.b	#1,d1                           	| [rl   b]
*	move.w	(sp)+,d0                        	| [pop  af]
*	tst.b	d6
*	jeql_103B                             	| [jr   nc,l_103B]
* 
*	move.b	d2,d3                           	| [ld   d,c]
*	move.b	d0,d2                           	| [ld   c,a]
*	move.b	d3,d0                           	| [ld   a,d]
*l_103B:
*	move.b	d2,d5                           	| [ld   h,c]
*	clr.b	d6                               	| [ld   l,#0]
*	jbsr	c_divmod                          	| [call c_divmod] HL=HL/D
*	move.b	d5,d0                           	| [ld   a,h]
*	eor.b	d1,d0                            	| [xor  b]
*	and.b	#0x01,d0                         	| [and  #0x01]
*	jeq	l_104A                             	| [jr   z,l_104A]
*	move.b	d6,d0                           	| [ld   a,l]
*	not.b	d0                               	| [cpl]
*	move.b	d0,d6                           	| [ld   l,a]
*l_104A:
*	move.b	d1,d5                           	| [ld   h,b]
*	move.l	(sp)+,a1                        	| [pop  de]
*	movem.w	(sp)+,d3/d4                    	| [pop  de]
*
*	movem.w	(sp)+,d1/d2                    	| [pop  bc]
*	rts                                    	| [ret]

*=============================================================================
* c_104E_mul_16_8()
*  Description:
*   HL := b16 * b8
* IN:
*   HL==16 bit factor
*   A==8 bit factor
* OUT:
*   HL=16 bit product
* SAVES:
*   DE
*-----------------------------------------------------------------------------
c_104E_mul_16_8:
	* completely replaced by MULU
	LOAD_D5_16_FROM_D5D6
	and.w	#0xFF,D0
	mulu	d0,d5
	LOAD_D5D6_FROM_D5_16
	rts                                    	| [ret]

*=============================================================================
* c_1061()
*  Description:
*   Integer division and modulus operation. NOTE input value is NOT preserved.
*   HL = HL / A
*    A = HL % A
*   Uses ADC to sort of left-rotate the Dividend bitwise, linking through Cy
*   Flag into A and from A through Cy back into HL.
* IN:
*  D0 = Divisor
*  D5/D6 = Dividend
* OUT:
*  D5/D6 = Quotient
*  D0 =  Modulus
* PRESERVES: BC, DE
*-----------------------------------------------------------------------------
c_divmod:
	LOAD_D5_16_FROM_D5D6
	* completely rewritten using 68000 divu for faster op & bugfree code :)
	.ifndef	RELEASE
	tst.w	d0
	bne.b	0f
	jbsr	osd_break
0:
	.endif
	divu	d0,d5
	swap	d5
	move.w	d5,d0
	swap	d5
	LOAD_D5D6_FROM_D5_16
	rts

* overflow doesn't seem to happen or to be tested in that game	
*
*l_1074:                                           | handle overflow out of A
*	sub.b	d2,d0                            	| [sub  c]
*	SET_XC_FLAGS                           	| [scf] need to explicitly set Cy so overflow of A will be summed with result in HL
*	jra	l_106E                             	| [jp   l_106E]

*=============================================================================
* c_1079()
*  Description:
*   Called once for each of boss + 1 or 2 wingmen.
* IN:
*   A0 == &b_8800[n] ... bits 0:6 ... loaded at l_launch_boss_wing_mission_1b8b from boss_wing_slots[n + 0]
*         if bit-7 set then negate rotation angle to (ix)0x0C
*         (creature originating on right side)
*   D3.W == pointer to object data (in cpu-sub1 code space)
* OUT:
*  ...
*-----------------------------------------------------------------------------
c_1079:
	COMPUTE_LSB_A0_D6	b_8800
	move.b	d6,d0                           	| [ld   a,l]
	and.b	#0x80,d0                         	| [and  #0x80] if set then negate rotation angle to (ix)0x0C
	addq.b	#1,d0                           	| [inc  a] set bit-0, .b13<0> makes object slot active
	exg		d0,d7                              	| [ex   af,af']
	bclr.b	#7,d6                           	| [res  7,l]
	lea		b_8800,a0
	add.w	d6,a0
	jra	setup_motion_for_attackers_108a         | [jp   setup_motion_for_attackers_108a]

*=============================================================================
* c_diving_movement_1083()
*  Description:
*   Diving movement of red alien, yellow alien, clone-attacker, and rogue fighter.
* IN:
*   HL == &b_8800[n]
*   DE == pointer to object data (in cpu-sub1 code space)
* OUT:
*  ...
*-----------------------------------------------------------------------------
c_diving_movement_1083:
* set A:bit-7 if L:bit-1 != 0 ... creature originating on right side
	move.b	d6,d0                           	| [$1083: ld   a,l]
	ror.b	#2,d0                            	| [$1084: rrca] * 2
	and.b	#0x80,d0                         	| [$1086: and  #0x80] if set then negate rotation angle to (ix)0x0C
	addq.b	#1,d0                            	| [$1088: inc  a] set bit-0, .b13<0> makes object slot active
	exg		d0,d7                              	| [$1089: ex   af,af'] stash d0

*=============================================================================
* setup_motion_for_attackers_108a()
*  Description:
*   Setup motion for diving attackers.
* IN:
*   HL == &b_8800[n]
*   DE == pointer to table in cpu-sub1 code space (D3/D4)
*   A' ==
*        bit-0: set by c_diving_movement_1083 and c_1079
*        bit-7: flag set for negative rotation angle
* OUT:
*
*-----------------------------------------------------------------------------
setup_motion_for_attackers_108a:
	movem.w	d3/d4,-(sp)                    	    | [$108a: push de]

* find an available data structure or quit
	move.w	#0x0014,d3                      	| [ld   de,#0x0014] size of 1 data structure 20
	move.b	#0x0C,d1                        	| [ld   b,#0x0C] number of structures in array
	lea	ds_bug_motion_que_9100,a2           	| [ld   ix,#ds_bug_motion_que_9100]
l_1094:
	btst.b	#0,(mq_state_13,a2)                 | [bit  0,0x13(ix)] check for activated state
	jeq	l_10A0_got_one                     	    | [jr   z,l_10A0_got_one]
	add.w	d3,a2                            	| [add  ix,de]
	subq.b	#1,d1                           	| [...]
	jne	l_1094                             	    | [djnz l_1094]
	movem.w	(sp)+,d3/d4                      	| [pop  de]
	rts                                      	| [ret]

l_10A0_got_one:
	movem.w	(sp)+,d3/d4                    	    | [$10A0: pop  de] pointer to table
	LOAD_D3D4_FROM_D3_16
	move.b	d4,(mq_fp_lsb_08,a2)                | [$10A1: ld   0x08(ix),e] data pointer lsb
	move.b	d3,(mq_fp_msb_09,a2)                | [$10A4: ld   0x09(ix),d] data pointer msb
	move.b	#1,(mq_timeout_0d,a2)               | [$10A7: ld   0x0D(ix),#1] expiration counter
	move.b	#0x00,(mq_angle_lsb_04,a2)          | [$10AB: ld   0x04(ix),#<0x0100] msb, 0x0100 (90 degrees)
	move.b	#0x01,(mq_angle_msb_05,a2)          | [$10AF: ld   0x05(ix),#>0x0100] lsb
	move.b	d6,d2                           	| [$10B3: ld   c,l] stash index to obj_status[], sprite etc.
	move.b	d2,(mq_object_id_10,a2)            	| [$10B4: ld   0x10(ix),c] index of object, sprite etc.
	exg		d0,d7                              	| [$10B7: ex   af,af'] unstash d0
	move.b	d0,d3                           	| [$10B8: ld   d,a] function parameter from A' to 0x13(ix)
	move.b	#9,(a0)+                         	| [$10B9: ld   (hl),#9] obj_status[l].state ... disposition = diving attack
	COMPUTE_LSB_A2_D0	ds_bug_motion_que_9100  | [$10BB: ld   a,ixl]
	*addq.b	#1,d6								| [$10BD: inc  l] [a0 coherence]
	move.b	d0,(a0)                         	| [$10BE: ld   (hl),a] obj_status[L].idx ... index into flying que
	move.b	b_9215_flip_screen,d0           	| [$10BF: ld   a,(b_9215_flip_screen)]
	move.b	d0,d4                           	| [$10C2: ld   e,a]

* insert sprite Y coord into pool structure
	move.b	d2,d6                           	| [$10C3: ld   l,c] restore index to obj_status[], sprite etc. (dec l just as good, no?)
	lea	ds_sprite_posn_9300,a0              	| [$10C4: ld   h,#>ds_sprite_posn_9300]
	and.w	#0xFF,d6
	add.w	d6,a0
	move.b	(a0)+,d2                         	| [$10C6: ld   c,(hl)] sprite_x
	addq.b	#1,d6								| [$10C7: inc  l] [a0 coherence]
	move.b	(a0),d1                         	| [$10C8: ld   b,(hl)] sprite_y<7:0>
	lea	ds_sprite_ctrl_9B00,a0              	| [$10C9: ld   h,#>ds_sprite_ctrl_9B00]
	add.w	d6,a0
	move.b	(a0),d0                         	| [$10CB: ld   a,(hl)] sprite_y<8>
	ror.b	#1,d0                            	| [$10CC: rrca] sY<8> into Cy
	SET_X_FROM_C
	roxr.b	#1,d1                           	| [$10CD: rr   b] sY<8> from Cy to b<7> and sY<0> to Cy
	btst.b	#0,d4                           	| [$10CF: bit  0,e] test flipped screen
	jne	l_10DC                             		| [$10D1: jr   nz,l_10DC]
* not flipped screen
* 160 - sprite_y + 1 ... backwards math since sY<8:1> already loaded in B, and this is only for flipped screen
	scs	d7                              		| [$10D3: ex   af,af'] stash Cy ... sY<:0>
	move.b	d1,d0                           	| [$10D4: ld   a,b]
	add.b	#0x50,d0                 			| [$10D5: add  a,#<(-0x0160 >> 1)] adjust addend for scale factor 2
	neg.b	d0                               	| [$10D7: neg]
	move.b	d0,d1                           	| [$10D9: ld   b,a]
	tst.b	d7                              	| [$10DA: ex   af,af'] un-stash Cy
	* re-set X flag from d7 stashed value, then set opposite X flag
	bne.b	0f							  		| [$10DB: ccf] sY<:0> = Cy ^ 1
	SET_XC_FLAGS
	bra.b	2f
0:
	CLEAR_XC_FLAGS
2:
* insert sprite X coord into pool structure
l_10DC:
* rescale sY<8:0> to fixed-point 9.7
	move.b	d1,(0x01,a2)                    	| [$10DC: ld   0x01(ix),b] sY<8:1> ... fixed point 9.7
* sY<:0> from Cy into A<7> ... fixed point 9.7 (LSB)
	roxr.b	#1,d0                           	| [$10DF: rra]
	and.b	#0x80,d0                         	| [$10E0: and  #0x80]
	move.b	d0,(mq_fine_y_00,a2)                    			| [$10E2: ld   0x00(ix),a] sY<0> ... fixed point 9.7
	move.b	d2,d0                           	| [$10E5: ld   a,c] sprite_x
	btst.b	#0,d4                           	| [$10E6: bit  0,e] test flipped screen
	jeq	l_10ED                             		| [$10E8: jr   z,l_10ED]
* flipped screen
	add.b	#0x0D,d0                         	| [add  a,#0x0D] if flipped screen
	not.b	d0                               	| [cpl]

l_10ED:
	lsr.b	#1,d0                            	| [$10ED: srl  a]
	move.b	d0,(mq_x_03,a2)                    	| [$10EF: ld   0x03(ix),a] sX<8:1>
	roxr.b	#1,d0                           	| [$10F2: rra] Cy into A<8:>
	and.b	#0x80,d0                         	| [$10F3: and  #0x80]
	move.b	d0,(mq_fine_x_02,a2)                | [$10F5: ld   0x02(ix),a] sX<:0> ... now scaled fixed point 9.7
	move.b	d3,(mq_state_13,a2)                 | [$10F8: ld   0x13(ix),d] function argument (A') sets bit-0 and bit-7
	move.b	#0x1E,(mq_drop_bomb_counter_0e,a2) 	| [$10FB: ld   0x0E(ix),#0x1E] bomb drop counter

* if (flying_bug_attck_condtn)  bug_motion_que[n].b0F = bomb_drop_enbl_flags
	move.b	ds_9200_glbls+0x0B,d0           	| [$10FF: ld   a,(ds_9200_glbls + 0x0B)] if ( !0 ), load  b_92C0[0x08] ... bomb drop enable flags
												| [$1102: and  a]
	jeq	l_1108                             		| [$1103: jr   z,l_1108]
	move.b	b_92C0+0x08,d0                  	| [$1105: ld   a,(b_92C0 + 0x08)] bomb drop enable flags
* else bug_motion_que[n].b0F = 0                    
l_1108:
	move.b	d0,(mq_drop_bomb_enable_0f,a2)      | [$1108: ld   0x0F(ix),a] 0 or b_92C0[$08] ... bomb drop enable flags for this attacker
	rts                                    		| [$110B: ret]

*=============================================================================
* c_player_active_switch()
*  Description:
*   End a player's turn and/or prep for next player.
*   Called when bug nest has already retreated.
*   Never on single player game and not at and of player 2's final ship.
* IN:
*  ...
* OUT:
*  ...
*-----------------------------------------------------------------------------
c_player_active_switch:
*  active_plyr_task_tbl[0] = reserve_plyr_task_tbl[0] = $1F
	move.b	#0x1F,d0                        	| [ld   a,#0x1F]
	move.b	d0,ds_cpu0_task_actv_9000+0          	| [ld   (ds_cpu0_task_actv_9000 + 0),a] $1F
	move.b	d0,ds_cpu0_task_resrv+0         	| [ld   (ds_cpu0_task_resrv + 0),a] $1F

* swap active player and waiting player state data structures
	lea	ds_plyr_actv,a0                	| [ld   hl,#ds_plyr_actv] $40 bytes
	lea	ds_plyr_susp,a1                	| [ld   de,#ds_plyr_susp] $40 bytes
	move.b	#0x40,d1                        	| [ld   b,#0x40]
l_111C:
	move.b	(a0),d2                         	| [ld   c,(hl)]
	move.b	(a1),d0                         	| [ld   a,(de)]
	move.b	d0,(a0)+                         	| [ld   (hl),a]
	move.b	d2,d0                           	| [ld   a,c]
	move.b	d0,(a1)+                         	| [ld   (de),a]
	                           	| [inc  l]
	                           	| [inc  e]
	subq.b	#1,d1                           	| [...]
	jne	l_111C                             	| [djnz l_111C]

* swap active player and waiting player game object data
	lea	b_8800,a0                      	| [ld   hl,#b_8800] $30 bytes to 98B0
	lea	ds_susp_plyr_obj_data,a1       	| [ld   de,#ds_susp_plyr_obj_data]
	move.b	#0x30,d1                        	| [ld   b,#0x30]
l_112D:
	* compute d6 offset from 8800 base (applied on ds_sprite_code_8B00 too)
	COMPUTE_LSB_A0_D6		b_8800
		
	move.b	(a0),d0                         	| [ld   a,(hl)] &sprt_mctl_objs[n]
	move.b	d0,d2                           	| [ld   c,a]
	
	lea	ds_sprite_code_8B00,a0              	| [ld   h,#>ds_sprite_code_8B00]
	add.w	d6,a0
	move.b	(a0),d0                         	| [ld   a,(hl)]
	and.b	#0x7F,d0                         	| [and  #0x7F]
	subq.b	#1,d2                           	| [dec  c]
	jne	l_1142                             	| [jr   nz,l_1142] starts at $80?
	and.b	#0x78,d0                         	| [and  #0x78] sprite[n].cclr.code
	move.b	d0,d2                           	| [ld   c,a]
												| [inc  l]
	move.b	(1,a0),d0                         	| [ld   a,(hl)] sprite[n].cclr.colr
												| [dec  l]
	and.b	#0x07,d0                         	| [and  #0x07]
	or.b	d2,d0                             	| [or   c]
	or.b	#0x80,d0                          	| [or   #0x80]
l_1142:
	exg	a1,a0                              	| [ex   de,hl] hl := &susp_plyr_obj_data[n]
	move.b	(a0),d2                         	| [ld   c,(hl)] hl==98b0, de==8b00
	move.b	d0,(a0)                         	| [ld   (hl),a]
	exg	a1,a0                              	| [ex   de,hl] hl := sprite[n].cclr.code
	btst.b	#7,d2                           	| [bit  7,c]
	jeq	l_115A                             	| [jr   z,l_115A]
	move.b	d2,d0                           	| [ld   a,c] 114a, player 2->plyr 1
	and.b	#0x78,d0                         	| [and  #0x78]
	addq.b	#6,d0                           	| [add  a,#6]
	move.b	d0,(a0)                         	| [ld   (hl),a]
												| [inc  l]
	move.b	d2,d0                           	| [ld   a,c]
	and.b	#0x07,d0                         	| [and  #0x07]
	move.b	d0,(1,a0)                         	| [ld   (hl),a]
												| [dec  l]
 	move.b	#1,d0                           	| [ld   a,#1]
	COMPUTE_LSB_A0_D6	ds_sprite_code_8B00
	jra	l_1161                             	| [jr   l_1161]

l_115A:
	COMPUTE_LSB_A0_D6	ds_sprite_code_8B00
	move.b	d2,(a0)                         	| [ld   (hl),c] hl==8b00
	lea	ds_sprite_posn_9300,a0              	| [ld   h,#>ds_sprite_posn_9300]
	add.w	d6,a0
	clr.b	(a0)                             	| [ld   (hl),#0] hl==9300
	move.b	#0x80,d0                        	| [ld   a,#0x80]
l_1161:
	lea	b_8800,a0                      	| [ld   h,#>b_8800]
	add.w	d6,a0
	move.b	d0,(a0)                         	| [ld   (hl),a]
	addq.w	#1,a1                           	| [inc  de] de==98b0
	addq.w	#2,a0                           	| [inc  l]
	subq.b	#1,d1                           	| [...]
	jne	l_112D                             	| [djnz l_112D]

	lea	ds_cpu0_task_actv_9000,a0           	| [ld   hl,#ds_cpu0_task_actv_9000] cp $20 bytes to reserve task tbl
	lea	ds_cpu0_task_resrv,a1          	| [ld   de,#ds_cpu0_task_resrv] cp $20 bytes from active task tbl
	move.b	#0x20,d1                        	| [ld   b,#0x20]
l_1171:
	move.b	(a0),d2                         	| [ld   c,(hl)]
	move.b	(a1),d0                         	| [ld   a,(de)]
	move.b	d0,(a0)+                         	| [ld   (hl),a]
	move.b	d2,d0                           	| [ld   a,c]
	move.b	d0,(a1)+                         	| [ld   (de),a]
	                          	| [inc  l]
	                           	| [inc  e]
 	subq.b	#1,d1                           	| [...]
	jne	l_1171                             	| [djnz l_1171]

	clr.b	d0                               	| [xor  a]
	move.b	d0,ds_cpu0_task_actv_9000+0          	| [ld   (ds_cpu0_task_actv_9000 + 0),a] 0
	rts                                    	| [ret]

*=============================================================================
* gctl_stg_tokens()
*  Description:
*   new stage setup (c_new_stage_, plyr_changeover)
* IN:
*  A': non-zero if sound-clicks for stage tokens (passed to sound manager)
*  Cy': set if inhibit sound-clicks for stage tokens
*
* OUT:
*  ...
*-----------------------------------------------------------------------------
c_new_level_tokens_117f:
*  memset($8002,$24,$12)
	lea	0x8000+2,a0                	            | [$117F: ld   hl,#0x8000 + 2] second row from bottom at right
	move.b	#0x12,d1                        	| [$1182: ld   b,#0x12]
	move.b	#0x24,d0                        	| [$1184: ld   a,#0x24]
	jbsr	rst_18_video                        | [$1186: rst  0x18] memset((HL), A=fill, B=ct)
*  memset($8022,$24,$12)                          | bottom row at right
	move.b	#0x22,d6                        	| [$1187: ld   l,#0x22]
	move.b	#0x12,d1                        	| [$1189: ld   b,#0x12]
	jbsr	rst_18_video                        | [$118B: rst  0x18] memset((HL), A=fill, B=ct)

	move.b	ds_plyr_actv+_b_stgctr,d0       	| [$118C: ld   a,(ds_plyr_actv +_b_stgctr)] c_new_level_tokens_117f
	clr.b	d1                               	| [$118F: ld   b,#0] tmp_quotient 50
	lea	0x8000+1,a0                	            | [$1191: ld   hl,#0x8000 + 1] offset into tile ram


* stage_ctr/50 and stage_ctr%50 (by brute force!)

*  while ( tmp_stage_ctr >= 50 ) {
l_1194_while:
	cmp.b	#50,d0                           	| [$1194: cp   #50]
	jcs	l_119F                             	    | [$1196: jr   c,l_119F]
	sub.b	#50,d0                           	| [$1198: sub  #50] tmp_modulus
	addq.b	#1,d1                           	| [$119A: inc  b] tmp_quotient
* offset tileram ptr 2 columns to the left... *50 icons are 2 tiles wide
	addq.w	#2,a0                           	| [$119C: inc  l]*2
	jra	l_1194_while                       	    | [$119D: jr   l_1194_while]

l_119F:
	exg	a1,a0                              	    | [$119F: ex   de,hl] stash the tileram offset in DE
	move.b	d0,d6                           	| [$11A0: ld   l,a] stage_ctr % 50

	clr.b	d5                               	| [$11A1: ld   h,#0]
	move.b	#10,d0                          	| [$11A3: ld   a,#10]
	jbsr	c_divmod                          	| [$11A5: call c_divmod] HL = HL / 10
	move.b	d0,d5                           	| [$11A8: ld   h,a] A = HL % 10 ... (still have L==HL/10)


	movem.w	d5/d6,-(sp)                        	| [$11A9: push hl] stack the quotient and mod10 result
	exg	a1,a0                              		| [$11AA: ex   de,hl]
	exg	d6,d4
	exg	d3,d5

* now HL == tile_ram address  and  DE == div10 and mod10 result

* offset base pointer in HL by the nbr of tile columns needed:

* if ( A >= 5 )  { C = A = A - 4 }  ... if mod10 > 5 then only 1 tile for the 5, plus nbr of 1's
	cmp.b	#5,d0                            	| [$11AB: cp   #5]
	jcs	l_11B1_add_total                   	    | [$11AD: jr   c,l_11B1_add_total]
	subq.b	#4,d0                           	| [$11AF: sub  #4]

l_11B1_add_total:
	move.b	d0,d2                           	| [$11B1: ld   c,a] nbr of columns for 5's and 1's (not including 50's)

* Add up the total additional columns needed for 10, 10, 20, 30, 40 in A.
* 'bit 0' catches the odd div10 result and sets A=2. Noteing the 40 needs 4 columns,
* the div10 result does the right thing for 0, 20, and 40.
	move.b	d4,d0                           	| [$11B2: ld   a,e] div10result
	btst.b	#0,d0                           	| [$11B3: bit  0,a] even or odd
	jeq	l_11B9                             	    | [$11B5: jr   z,l_11B9]
	move.b	#2,d0                           	| [$11B7: ld   a,#2]
l_11B9:
	add.b	d2,d0                            	| [$11B9: add  a,c] nbr of additional tile columns
	jbsr	add_d0_to_a0_0010                   | [$11BA: rst  0x10] HL += A

* B == count of 50's markers, if any
	addq.b	#1,d1                           	| [$11BB: inc  b] pre-increment for djnz ... B is at least 1

l_11BC_loop:
	subq.b	#1,d1                           	| [...]
	jne	l_11DC_show_50s_tokens             	    | [$11BC: djnz l_11DC_show_50s_tokens]

	movem.w	(sp)+,d1/d2                    	    | [$11BE: pop  bc] pop the quotient and mod10 result
	move.b	d2,d0                           	| [$11BF: ld   a,c] div10 result
	jbsr	c_11E3_show_tokens_1              	| [$11C0: call c_11E3_show_tokens_1]

* if ( mod10result < 5 )
	move.b	d1,d0                           	| [$11C3: ld   a,b] mod10 result
	cmp.b	#5,d0                            	| [$11C4: cp   #5]
	jcs	l_11D0_do_1s_tokens                	    | [$11C6: jr   c,l_11D0_do_1s_tokens]
* else
	move.b	#0x36+2,d3                      	| [$11C8: ld   d,#0x36 + 2] tile nbr of top of '5' token ... bottom tile of token is next tile nbr
	jbsr	c_build_token_1                   	| [$11CA: call c_build_token_1] show the 5 token

* do 1's ... mod10result -= 5
	move.b	d1,d0                           	| [$11CD: ld   a,b]
	subq.b	#5,d0                           	| [$11CE: sub  #5]

l_11D0_do_1s_tokens:
	move.b	d0,d1                           	| [$11D0: 4ld   b,a] nbr of 1's tokens
	addq.b	#1,d1                           	| [$11D1: 0inc  b] pre-increment for djnz

l_11D2_show_1s_loop:
	subq.b	#1,d1                           	| [...]
	jne	l_11D5_while                       	    | [$11D2: djnz l_11D5_while]
	rts                                    	    | [$11D4: ret]

l_11D5_while:
	move.b	#0x36,d3                            | [$11D5: ld   d,#0x36] tile nbr of top of '1' token ... bottom tile of token is next tile nbr
	jbsr	c_build_token_1                     | [$11D7: call c_build_token_1] show the token
	jra	l_11D2_show_1s_loop                	    | [$11DA: jr   l_11D2_show_1s_loop]

l_11DC_show_50s_tokens:
	move.b	#4,d0                               | [$11DC: ld   a,#4]
	jbsr	c_11E9                              | [$11DE: call c_11E9] show the token
	jra	l_11BC_loop                        	    | [$11E1: jr   l_11BC_loop]


*=============================================================================
* c_11E3_show_tokens_1()
*  Description:
*   Setup c_11E9 to display the 10's tokens.
* IN:
*   A = count of 10's tiles to show, i.e. stage % 50 / 10
* OUT:
*  ...
*-----------------------------------------------------------------------------
c_11E3_show_tokens_1:

* branch off depending on div10result ... do nothing for 0
	tst.b	d0                               	| [$11E3: and  a] A==div10 result
	bne.b	0f                               	| [...]
	rts                                    	    | [$11E4:ret  z] [...]
0:
* handle 40's separately
	cmp.b	#4,d0                            	| [$11E5: cp   #4]
	jeq	l_11F0_do_40s                      	    | [$11E7: jr   z,l_11F0_do_40s]

c_11E9:
* get offset of of start of tiles for 10, 20, and 30 ... div10result * 4
	rol.b	#2,d0                            	| [$11EA: rlca] * 2
	add.b	#0x36,d0                         	| [$11EB: add  a,#0x36] base offset of icon tiles
	move.b	d0,d3                           	| [$11ED: ld   d,a]
	jra	l_11FA_show_10s_20s_30s_50s        	    | [$11EE: jr   l_11FA_show_10s_20s_30s_50s]

l_11F0_do_40s:
	move.b	#0x36+4*3,d3                    	| [$11F0: ld   d,#0x36 + 4 * 3] offset to 30's tiles group
	jbsr	c_build_token_1                   	| [$11F2: call c_build_token_1]
	jbsr	c_build_token_2                   	| [$11F5: call c_build_token_2]

	move.b	#0x36+4,d3                      	| [$11F8: ld   d,#0x36 + 4] offset to 10's tiles group

l_11FA_show_10s_20s_30s_50s:
	jbsr	c_build_token_1                   	| [$11FA: call c_build_token_1]
	jbsr	c_build_token_2                   	| [$11FD: call c_build_token_2]

	rts                                    	    | [$1200: ret]

*=============================================================================
* c_build_token()
*  Description:
*   wrapper for c_build_token_2 that handles timing and sound-effect
* IN:
*   D = offset of start of tile group for the token to display
*   HL = base address in tileram
* OUT:
*   HL -= 1
*-----------------------------------------------------------------------------
c_build_token_1:

* check sound_disable_flag
	exg	d0,d7                              	| [ex   af,af']
	tst.b	d0
	jeq	l_1215_restore_A_and_continue      	| [jr   c,l_1215_restore_A_and_continue]
* put it back
	exg	d0,d7                              	| [ex   af,af']
* set the delay count 8 ... preserve frame count
	move.b	ds3_frame_cts_92A0+0,d0         	| [ld   a,(ds3_frame_cts_92A0 + 0)]
	add.b	#8,d0                            	| [add  a,#8]
	move.b	d0,d4                           	| [ld   e,a]
l_120B:
	move.b	ds3_frame_cts_92A0+0,d0         	| [ld   a,(ds3_frame_cts_92A0 + 0)]
	sub.b	d4,d0                            	| [sub  e]
	jne	l_120B                             	| [jr   nz,l_120B]

* actv_plyr_state[0x05]==0 for challenge stage ... 0 count/enable for stage tokens clicks
	exg	d7,d0                              	| [ex   af,af']
	
	move.w	#TICK_SND,d0
	jbsr	osd_sound_start
	*move.b	d0,b_9AA0+0x15                  	| [ld   (b_9AA0 + 0x15),a] 2 ... sound-fx count/enable registers, clicks for stage tokens

l_1215_restore_A_and_continue:
	exg	d7,d0                              	| [ex   af,af']
 

*=============================================================================
* c_build_token_2()
*  Description:
*   Display 2 tiles comprising a stage token icon.
*
*   Each call to this displays a top and bottom tile. 4 tile tokens require
*   this function to be called twice. HL is decremented in order to leave the
*   pointer at the next column to the left.
*   Use color table 1 for 1's, 5's and 50's.
*   These are situated in the tile order such that the $0C mask leaves the 8,
*   thereby setting the Z flag.
*   Use color table 2 for the others.
*   This is a bit roundabout and slightly confusing, here is a table of the
*   tile numbers to help visualize it:
*
*    1's   36 37         38 & 0C = 08
*    5's   38 39         3A & 0C = 08
*    10's  3A 3B 3C 3D   3C & 0C = 0C  ... 3E & 0C = 0C
*    20's  3E 3F 40 41   40 & 0C = 00  ... 42 & 0C = 00
*    30's  42 43 44 45   44 & 0C = 00  ... 46 & 0C = 00
*    50's  46 47 48 49   48 & 0C = 08  ... 5A & 0C = 08
*
* IN:
*   D = offset of start of tile group for the token to display
*   HL = base address in tileram
* OUT:
*   HL -= 1
*
*-----------------------------------------------------------------------------
c_build_token_2:
	move.l	a0,d7
	exg		d0,d3
	jbsr	osd_w_videoram			            | [$1216: ld   (hl),d]
	exg		d0,d3
                         	
	addq.b	#1,d3                           	| [$1217: inc  d] next tile
	bset.b	#5,d7                           	| [$1218: set  5,l] +=32 ... advance one row down
	exg		d0,d3
	jbsr	osd_w_videoram			            | [$121A: ld   (hl),d]
	exg		d0,d3

	addq.b	#1,d3                           	| [$121B: inc  d]
	add.w	#0x400,d7                           | [$121C: set  2,h] +=$0400 ... colorram

* if ( D & $0C  > 8 ) { A = 2  else A = 1 }
	move.b	d3,d0                           	| [$121E: ld   a,d]
	and.b	#0x0C,d0                         	| [$121F: and  #0x0C]
	cmp.b	#8,d0                            	| [$1221: cp   #8]
	jeq	l_1228                             	    | [$1223: jr   z,l_1228]
	move.b	#2,d0                           	| [$1225: ld   a,#1]
	                                         	| [$1227: inc  a]
	bra.b	0f
* set the color codes, resetting the bits and updating HL as we go
l_1228:
	move.b	#1,d0                           	| [ld   a,#1]
0:
	jbsr	osd_w_colorram                      | [$1228: ld   (hl),a]
	bclr.b	#5,d7                           	| [$1229: res  5,l]
	jbsr	osd_w_colorram                      | [$122B: ld   (hl),a]
	sub.w	#0x400,d7                           | [$122C: res  2,h]
	subq.w	#1,d7                           	| [$122E: dec  l] offset tileram pointer 1 column to the right

	move.l	d7,a0
	rts                                    	    | [$122F: ret]

*=============================================================================
* c_init_taskman_structs_1230()
*  Description:
*   Initialize active player and reserve player kernel tables from defaults:
*   - At reset
*   - Immediately following end of "demo game (just prior to "heroes" shown)
*   - After "results" or "HIGH SCORE INITIAL"
*   - New game (credit==0 -> credit==1)
* IN:
*  ...
* OUT:
*  ...
*-----------------------------------------------------------------------------
c_init_taskman_structs_1230:
* memcpy(_task_activ, task_enable_tbl_def, 0x20)
	lea	task_enable_tbl_def_1249,a0         	| [$1230: ld   hl,#task_enable_tbl_def]
	lea	ds_cpu0_task_actv_9000,a1           	| [$1233: ld   de,#ds_cpu0_task_actv_9000] $20 bytes copied from task_enable_tbl_def
	move.w	#0x20,d1                        	| [$1236: ld   bc,#0x0020] 32
	movem.w	d1/d2,-(sp)                    	    | [$1239: push bc]
	move.l	a0,-(sp)                        	| [$123A: push hl]
	jbsr	ldir                              	| [$123B: ldir]

* memcpy(_task_resrv, task_enable_tbl_def, 0x20)|
*  for ( de = 98e0, hl = 1249| bc++ | bc < 0$20 ) de[bc] = hl[bc]|
	move.l	(sp)+,a0                        	| [$123D: pop  hl]
	movem.w	(sp)+,d1/d2                      	| [$123E: pop  bc]
	lea	ds_cpu0_task_resrv,a1          	        | [$123F: ld   de,#ds_cpu0_task_resrv] $20 bytes copied from task_enable_tbl_def
	jbsr	ldir                              	| [$1242: ldir]

* kill the idle task at [0]
*  task_tbl_9000[0] = 0
	clr.b	d0                               	| [$1244: xor  a]
	move.b	d0,ds_cpu0_task_actv_9000           | [$1245: ld   (ds_cpu0_task_actv_9000),a] 0
	rts                                    	    | [$1248: ret]


*=============================================================================
* kernel task-enable table defaults

task_enable_tbl_def_1249:
	.byte  0x1F | 00 f_rts_0827
	.byte  0x01 | 01 f_update_sprites_0828  | Copies from sprite "buffer" to sprite RAM
	.byte  0x00 | 02 f_manage_attract_mode_17B2
	.byte  0x00 | 03 f_ship_demo_controls_1700  | Ship-update in training/demo mode.
	.byte  0x00 | 04 f_clone_attack_manager_1A80
	.byte  0x01 | 05 f_misc_gameplay_events_0857  | triggers various parts of gameplay based on parameters
	.byte  0x00 | 06 f_rts_0827
	.byte  0x00 | 07 f_rts_0827

	.byte  0x00 | 08 f_insert_attackers_2916
	.byte  0x00 | 09 f_pulsating_swarm_movement_1de6
	.byte  0x00 | 0A f_lateral_movement_at_round_start_2a90
	.byte  0x00 | 0B f_update_enemy_status_1db3
	.byte  0x01 | 0C f_update_objects_23dd  | Updates each object in the table at 8800
	.byte  0x01 | 0D f_bomb_position_updater_1ea4  | Bomb position updater
	.byte  0x00 | 0E f_move_swarm_when_player_changes_1d32
	.byte  0x01 | 0F f_blink_players_text_0935  | handle "blink" of Player1/Player2 texts

	.byte  0x00 | 10 f_manage_bomber_attacks_1b65
	.byte  0x00 | 11 f_manage_ship_capture_movement_19b2
	.byte  0x00 | 12 f_star_control_1d76  | star control
	.byte  0x00 | 13 f_rts_0827
	.byte  0x00 | 14 f_controller_io_and_ship_movement_1f85
	.byte  0x00 | 15 f_read_fire_button_1f04
	.byte  0x00 | 16 f_rts_0827
	.byte  0x01 | 17 f_update_timers_1dd2  | Updates array of 4 timers

	.byte  0x00 | 18 f_boss_starts_tractor_beam_2222
	.byte  0x00 | 19 f_boss_diving_down_to_capture_ship_21cb
	.byte  0x00 | 1A f_rts_0827
	.byte  0x00 | 1B f_rts_0827
	.byte  0x00 | 1C f_tractor_beam_captures_ship_20f2
	.byte  0x00 | 1D f_boss_capturing_ship_killed_2000
	.byte  0x00 | 1E f_rts_0827
	.byte  0x0A | 1F f_credit_game_state_management_0977  | Handles coinage and changes in game-state

*=============================================================================
* g_mssl_init()
*  Description:
*   For game or "demo-mode" (f_manage_attract_mode_17B2) setup
*   Initialize "missile" objects (bombs and/or rockets).
*   One-time init for codes, colors and tiles.
* IN:
*  ...
* OUT:
*  ...
*-----------------------------------------------------------------------------
c_game_or_demo_init:
	lea	ds_sprite_code_8B00+0x64,a0         	| [$1268: ld   hl,#ds_sprite_code_8B00 + 0x64] rocket object
	move.b	#0x09,d3               				| [$1269: ld   de,#0x0900 + 0x0030] temp store two 8-bit values ... $30 is a rocket
	move.b	#0x30,d4               				| [$126C: ld   de,#0x0900 + 0x0030] temp store two 8-bit values ... $30 is a rocket
	clr.b	d2                               	| [$126F: ld   c,#0]
	move.b	#10,d1                          	| [$1271: ld   b,#10]

l_1273_while:
	COMPUTE_LSB_A0_D6	ds_sprite_code_8B00
	move.b	d4,(a0)                         	| [$1273: ld   (hl),e] e.g. (8B64):=$30
	lea	ds_sprite_posn_9300,a0              	| [$1274: ld   h,#>ds_sprite_posn_9300]
	add.w	d6,a0
	clr.b	(a0)                             	| [$1276: ld   (hl),#0]
	lea	ds_sprite_ctrl_9B00,a0              	| [$1278: ld   h,#>ds_sprite_ctrl_9B00]
	add.w	d6,a0
	move.b	d2,(a0)                         	| [$127A: ld   (hl),c]
	lea	ds_sprite_code_8B00,a0              	| [$127B: ld   h,#>ds_sprite_code_8B00]
	add.w	d6,a0
	addq.w	#1,a0                           	| [$127D: inc  l]
 	move.b	d3,(a0)+                         	| [$127E: ld   (hl),d] e.g. (8B65):=$09
												| [$127F: inc  l]
* if ( B == 9 )
	move.b	d1,d0                           	| [$1280: ld   a,b]
	cmp.b	#9,d0                            	| [$1281: cp   #9]
	jne	l_1289                             		| [$1283: jr   nz,l_1289]
	move.b	#1,d2                           	| [$1285: ld   c,#1]
	move.b	#0x0B,d3                        	| [$1287: ld   d,#0x0B] bomb color code

l_1289:
	subq.b	#1,d1                           	| [...]
	jne	l_1273_while                       		| [$1289: djnz l_1273_while] B--

	rts                                    		| [$128B: ret]

*=============================================================================
* sprite_tiles_display()
*  Description:
*   Display sprite tiles in specific arrangements loaded from table data.
*   This is for demo or game-start (bonus-info ) screen but not gameplay.
* IN:
*  _attrmode_sptiles: ptr to sprite tiles data
* OUT:
*  _attrmode_sptiles: advanced to next data group
*-----------------------------------------------------------------------------
c_sprite_tiles_displ_128C:


	lea	ds_sprite_code_8B00,a0              	| [$128C: ld   h,#>ds_sprite_code_8B00]

* L = p_sptiles_displ[idx*4 + 0] ... index/offset of object to use
	move.l	p_attrmode_sptiles_9280,a1       	| [$128E: ld   de,(p_attrmode_sptiles_9280)] load the persistent pointer (not always needed)
	moveq	#0,d0
	move.b	(a1),d0                         	| [$1292: ld   a,(de)] _attrmode_sptiles[ E + 0 ]
	add.w	d0,a0                           	| [$1293: ld   l,a]

* C = p_sptiles_displ[E+1] ... color/code
	addq.w	#1,a1                           	| [$1294: inc  de] _attrmode_sptiles[DE].b01  ... color/code
	move.b	(a1),d0                         	| [$1295: ld   a,(de)]
	move.b	d0,d2                           	| [$1296: ld   c,a]

* sprite_code<3:6>	

* tile 0+6 in each set of 8 is the "upright" orientation (wings spread for bug)
	and.b	#0x78,d0                         	| [$1297: and  #0x78]
	addq.b	#6,d0                           	| [$1299: add  a,#6]
	move.b	d0,(a0)                         	| [$129B: ld   (hl),a] sprite_code_base[ object + 0 ] ... sprite tile code

* advance pointer, i.e. sprite_code_base[ index + 1 ] ... color code
												| [inc  l]

* get color bits from original color/code value
	move.b	d2,d0                           	| [ld   a,c]
	and.b	#0x07,d0                         	| [and  #0x07]

* Apparently bit-7 of the color/code provides color bit-3
*     if (C & 0x80)  A |= 0x08
	btst.b	#7,d2                           	| [bit  7,c]
	jeq	l_12A6                             		| [jr   z,l_12A6]
	or.b	#0x08,d0                          	| [or   #0x08]
l_12A6:
	move.b	d0,(1,a0)                         	| [ld   (hl),a] sprite_code_base
	addq.w	#1,a1                           	| [inc  de] &table[ n + 2 ]  ... L/R offset
												| [dec  l] object_data[ n + 0 ] ... object state

	COMPUTE_LSB_A0_D6	ds_sprite_code_8B00

 	lea	b_8800,a0                      			| [ld   h,#>b_8800]
	add.w	d6,a0
	move.b	#1,(a0)                         	| [ld   (hl),#1] disposition = ACTIVE

	lea	ds_sprite_posn_9300,a0              	| [ld   h,#>ds_sprite_posn_9300]
	add.w	d6,a0
	move.b	(a1)+,d0                         	| [ld   a,(de)] L/R offset
	move.b	d0,(a0)+                         	| [ld   (hl),a] sprite_posn.X

* Y coordinate: the table value is actually sprite.posn.Y<8..1> and the sla
* causes the Cy flag to pick up sprite.posn<8> ...
												| [inc  de] &table[ n + 3 ]  ... T/B offset
												| [inc  l] sprite_posn.Y<0..7>
	move.b	(a1),d0                         	| [ld   a,(de)]
	asl.b	#1,d0                            	| [sla  a]
	move.b	d0,(a0)                         	| [ld   (hl),a] sprite_posn.Y

* and sprite.posn<8> is handled here, i.e. ctrl[n + 1]<0>
	clr.b	d0                               	| [ld   a,#0] set the sprite with no additional control attributes
	roxl.b	#1,d0                           	| [rla]
	lea	ds_sprite_ctrl_9B00,a0              	| [ld   h,#>ds_sprite_ctrl_9B00]
	add.w	d6,a0
	move.b	d0,(a0)                         	| [ld   (hl),a]

* advance the pointer
	addq.w	#1,a1                           	| [inc  de] e.g., DE:=$1960
	move.l	a1,p_attrmode_sptiles_9280           	| [ld   (p_attrmode_sptiles_9280),de] += 1

	rts                                    	| [ret]

*=============================================================================
* gctl_stg_fmtn_hpos_init()
*  Description:
*   plyr_changeover or new_stg_setup, also for start of demo "stage"....after
*   the rank icons are shown and the text is shown i.e. "game over" or "stage x"
* IN:
*   A == offset ... 0 on new-screen, $3F on player changeover
* OUT:
*  ...
*-----------------------------------------------------------------------------
c_12C3:
	jbsr	read_ixl_into_d0			| [ld   ixl,a]
	move.b	b_9215_flip_screen,d0       | [ld   a,(b_9215_flip_screen)]
	move.b	d0,d2                       | [ld   c,a]

* init formation location tracking structure: relative (offset) initialize to 0
* and origin coordinate bits<8:1> from data (copy of origin coordinate from
* CPU0 data as it would be outside of address space of CPU1)
	lea	ds_hpos_loc_t,a0               	| [ld   hl,#ds_hpos_loc_t] init home_posn_loc[]
	lea	db_fmtn_hpos_orig,a1           	| [ld   de,#db_fmtn_hpos_orig]
	move.w	#16-1,d1                    | [ld   b,#16] table size
l_12D1:
	clr.b	(a0)+                       | [ld   (hl),#0] fmtn_hpos.offs[]
	                                    | [inc  l]
 	move.b	(a1)+,d0                    | [ld   a,(de)]
	                                    | [inc  de]
	move.b	d0,(a0)+                    | [ld   (hl),a] pair.b1 i.e. ds_hpos_loc_orig_9900 ... copy data for reference in CPU1
	                                    | [inc  l]
	dbf		d1,l_12D1                   | [djnz l_12D1]

* X coordinates at origin (10 bytes) to even offsets, adjusted for flip-screen.
	lea	ds_hpos_spcoords_9800,a0        | [ld   hl,#ds_hpos_spcoords_9800] init origin x-coords (10 columns)
	lea	db_fmtn_hpos_orig,a1           	| [ld   de,#db_fmtn_hpos_orig]
	move.b	#10,d1                      | [ld   b,#10]
l_12E2:
	move.b	(a1)+,d0                    | [ld   a,(de)] home_posn_ini[B]
	                                    | [inc  de]

	btst.b	#0,d2                       | [bit  0,c] test if flip_screen
	jeq	l_12EB                          | [jr   z,l_12EB]
	add.b	#0x0D,d0                    | [add  a,#0x0D] flipped
	not.b	d0                          | [cpl]

l_12EB:
	move.b	d0,(a0)                     | [ld   (hl),a] store lsb
	addq.w	#2,a0                       | [inc  l]
	subq.b	#1,d1                       | [...]
	jne	l_12E2                          | [djnz l_12E2]

* Y coordinates at origin (6 bytes) to even offsets. Offset argument (in ixl)
* is added and result adjusted for flip-screen. Only bits <8:1> are stored.
* For non-inverted screen, equivalent of "$0160 - n" is implemented.
	move.w	#6-1,d1                     | [ld   b,#6]
l_12F2:
	move.b	(a1)+,d0                    | [ld   a,(de)] db_fmtn_hpos_orig[B]
	add.b	ixl,d0                      | [add  a,ixl]
	                           	        | [inc  de]
	btst.b	#0,d2                       | [bit  0,c] test if flip_screen
	jne	l_12FD                          | [jr   nz,l_12FD]
	add.b	#0x4F,d0                    | [add  a,#0x4F] add offset
	not.b	d0                          | [cpl] negate
l_12FD:
	asl.b	#1,d0                       | [sla  a] Cy now contains bit-8
	move.b	d0,(a0)+                    | [ld   (hl),a]
	                           	        | [inc  l]
	clr.b	d0                          | [ld   a,#0]
	roxl.b	#1,d0                       | [rla] bit-8 from Cy into bit-0 of MSB
	move.b	d0,(a0)+                    | [ld   (hl),a]
	                           	        | [inc  l]
	dbf	d1,l_12F2                       | [djnz l_12F2]
	move.b	b_9215_flip_screen,d0       | [ld   a,(b_9215_flip_screen)]
	move.b	d0,ds_9200_glbls+0x0F       | [ld   (ds_9200_glbls + 0x0F),a] = _flip_screen (nest direction... 1:left, 0:right)
	rts                                 | [ret]

*=============================================================================
* Initial pixel coordinates of cylon attackers are copied to odd-offsets of home_posn_loc[].
*
*                                       	|<-------------- COLUMNS ------------------------>|<---------- ROWS ----------->|
*
*     00   02   04   06   08   0A   0C   0E   10   12   14   16   18   1A   1C   1E
*
*-----------------------------------------------------------------------------
db_fmtn_hpos_orig:
	.byte 0x31,0x41,0x51,0x61,0x71,0x81,0x91,0xA1,0xB1,0xC1,0x92,0x8A,0x82,0x7C,0x76,0x70

*=============================================================================
* c_tdelay_3()
*  Description:
*   used in game_ctrl
*   delay 3 count on .5 second timer used various places (in game_ctrl)
* IN:
*  ...
* OUT:
*  ...
* PRESERVES:
*  HL
*-----------------------------------------------------------------------------
c_tdelay_3:

	move.l	a0,-(sp)                        	| [push hl]
*  game_tmrs[3] = 3
	lea	ds4_game_tmrs_92ac+3,a0             	| [ld   hl,#ds4_game_tmrs_92ac + 3] =3 ... while ! 0
	move.b	#3,(a0)                         	| [ld   (hl),#3]
*  while ( game_tmrs[3] != 0 ) {}
l_1325:
	move.b	(a0),d0                         	| [ld   a,(hl)]
	                               	            | [and  a]
	jne	l_1325                             	    | [jr   nz,l_1325]
	move.l	(sp)+,a0                        	| [pop  hl]
	rts                                    	    | [ret]


*=============================================================================
* c_player_respawn()
*  Description:
*    Single player, shows "player 1", then overwrite w/ "stage 1" and show "player 1" above
*
*                                       	|       PLAYER 1
*               PLAYER 1                	|       STAGE 1
*
*                                    PLAYER 1
*                                    STAGE 1     (S @ 8270)
*
*                                    PLAYER 1
*                                    READY       (R @ 8270)
*
*    Get READY to start a new ship, after destroying or capturing the one in play.
*    ("Player X" text already is shown).
*    Format is different one plyr vs two.
*    One Plyr:
*     Updates "Ready" game message text (except for on new stage...
*     ..."STAGE X" already shown in that position).
*    Two Plyr:
*      Next players nest has already descended onto screen w/ "PLAYER X" text shown.
*     "Ready" is already shown from somewhere else (05f1).
*
*    Removes one ship from reserve. (p_136c)
*    (used in game_ctrl)
* IN:
*  ...
* OUT:
*  ...
*-----------------------------------------------------------------------------
c_player_respawn:
	move.b	#1,d0                           	| [ld   a,#1]
	move.b	d0,ds_cpu0_task_actv_9000+0x14      | [ld   (ds_cpu0_task_actv_9000 + 0x14),a] 1  (f_controller_io_and_ship_movement_1f85 ... control stick input)

* check if "STAGE X" text shown and if so skip showing "READY"
*  if ( *(8270) ) == ' ' ) ...
	move.w	#0x8000+0x0260+0x10,d7
	jbsr	osd_r_videoram	  	                | [ld   a,(0x8000 + 0x0260 + 0x10)]
	cmp.b	#0x24,d0                         	| [cp   #0x24]
	jne	l_133A                             	    | [jr   nz,l_133A]
* ... else
	move.b	#3,d2                           	| [ld   c,#3] string_out_pe  index
	jbsr	string_out_pe_30                    | [rst  0x30] string_out_pe "READY" (at 8270)
l_133A:

*=============================================================================
* c_fighter_onscreen_133A()
*  Description:
*   Demo mode (f_manage_attract_mode_17B2) ...
*   ...while (bug/bee flys home) ...ship hit, waiting for flying bug to re-nest
*   Label provided for code reuse (jr from c_player_respawn)
* IN:
*  ...
* OUT:
*  ...
*-----------------------------------------------------------------------------
c_fighter_onscreen_133A:

l_133A_while:
	move.b	b_bugs_flying_nbr_9287,d0           | [$133A: ld   a,(b_bugs_flying_nbr_9287)]
										        | [$133D: and  a]
	jne	l_133A_while                            | [$133E: jr   nz,l_133A_while] wait for all bugs to stop flying								        
	jbsr	draw_resv_ships_136c                | [$1340: call draw_resv_ships_136c] updates reserve ships in lower left corner (wipes CREDIT X)

* put the ship out there
												| [$1343: ld   hl,#0x0900 + 0x0006] two bytes, code 6, color 9
	move.b	#6,ds_sprite_code_8B00+0x62         | [$1346: ld   (ds_sprite_code_8B00 + 0x62),hl] = $0906 ... ship-1 code 6, color 9 (load 16-bits)
	move.b	#9,ds_sprite_code_8B00+0x62+1       | [$1349: ld   (ds_sprite_code_8B00 + 0x62),hl] = $0906 ... ship-1 code 6, color 9 (load 16-bits)
	lea	ds_sprite_posn_9300+0x62,a0         	| [$134C: ld   hl,#ds_sprite_posn_9300 + 0x62] ship (1) position

*  if ( !_flip_screen )  A = $29,  C = 1
	         	                                | [ld   a,(b_9215_flip_screen)]
	          	                                | [and  #1]
	move.b	#0x29,d0                        	| [ld   a,#0x29]
	move.b	#1,d2                           	| [ld   c,#1]
	btst.b	#0,b_9215_flip_screen
	jeq	l_135A                             	    | [jr   z,l_135A]
*  else  A = $37,  C = 0
	add.b	#0x0E,d0                         	| [add  a,#0x0E] screen is flipped in demo?????
	subq.b	#1,d2                           	| [dec  c]
l_135A:
	move.b	#0x7A,(a0)+                      	| [$135A: ld   (hl),#0x7A] SPRPOSN.0[$62] ... sx
	                           	                | [$135C: inc  l]
	move.b	d0,(a0)                         	| [$135D: ld   (hl),a] SPRPOSN.1[$62] ... sy<0:7>
	COMPUTE_LSB_A0_D6		ds_sprite_posn_9300

	lea	ds_sprite_ctrl_9B00,a0              	| [$135E: ld   h,#>ds_sprite_ctrl_9B00]
	add.w	d6,a0
	move.b	d2,(a0)                         	| [ld   (hl),c] SPRCTRL.1[n]:0 ... sy<8>
	                           	                | [dec  l]
 	clr.b	d0                               	| [xor  a]
	move.b	d0,-(a0)                         	| [ld   (hl),a] 0 ... SPRCTRL.0[n] (no flip/double attribute)

	move.b	d0,ds_9200_glbls+0x13           	| [ld   (ds_9200_glbls + 0x13),a] 0 ... stage restart flag
	addq.b	#1,d0                           	| [inc  a]
	move.b	d0,ds_99B9_star_ctrl+0          	| [ld   (ds_99B9_star_ctrl + 0),a] 1 ... when ship on screen

	rts                                    	| [ret]

*=============================================================================
* fghtr_resv_draw()
*  Description:
*   Draws up to 6 reserve ships in the status area of the screen, calling
*   the subroutine 4 times to build the ship icons from 4 tiles.
* IN:
*  ...
* OUT:
*  ...
*-----------------------------------------------------------------------------
draw_resv_ships_136c:
	move.b	ds_plyr_actv+_b_nships,d0       	| [$136C: ld   a,(ds_plyr_actv +_b_nships)]
	not.b	d0                               	| [$136F: cpl]
	addq.b	#6,d0                           	| [$1370: add  a,#6] max nr of icons
	move.b	d0,d4                           	| [$1372: ld   e,a]
	move.b	#0x49,d3                        	| [$1373: ld   d,#0x49] $4A,$4B,$4C,$4D ... / \ [ ]
	move.w	#0x8000+0x1D,d7      	            | [$1375: ld   hl,#0x8000 + 0x0000 + 0x1D]
	jbsr	draw_resv_ship_tile               	| [$1378: call draw_resv_ship_tile]
	subq.w	#1,d7                           	| [$137B: dec  l] advance 1 column right
	jbsr	draw_resv_ship_tile               	| [$137C: call draw_resv_ship_tile]
	bset.b	#5,d7                           	| [$137F: set  5,l] +=32 (down 1 row)
	addq.w	#1,d7                           	| [$1381: inc  l] 1 column to the left
	jbsr	draw_resv_ship_tile               	| [$1382: call draw_resv_ship_tile]
	subq.w	#1,d7                           	| [$1385: dec  l] advance 1 column right
*       call draw_resv_ship_tile

*=============================================================================
* draw_resv_ship_tile()
*  Description:
*   Each ship is composed of 4 tiles. This is called once for each tile.
*   Each tile is replicated at the correct screem offset, allowing up to 6
*   reserve ship indicators to be shown. Unused locations are filled with
*   the "space" character tile.
* IN:
*   HL: offset in tile ram
*    D: tile character
*    E: nr of reserve ships
* OUT:
*    D: tile character (increment)
* PRESERVES:
*    HL: current offset in tile ram
*
*-----------------------------------------------------------------------------
draw_resv_ship_tile:

	move.w	d7,-(sp)                        	| [$1386: push hl]
	addq.b	#1,d3                           	| [$1387: inc  d] next ship tile
	move.b	d3,d1                           	| [$1388: ld   b,d]
	move.b	#6-1,d0                         	| [$1389: ld   a,#6 - 1] max nr of resv ship icon
l_138B:
	cmp.b	d4,d0                            	| [$138B: cp   e]
	jne	l_1390                             	    | [$138C: jr   nz,l_1390]
	move.b	#0x24,d1                        	| [$138E: ld   b,#0x24] space character tile
l_1390:
	exg		d0,d1
	jbsr	osd_w_videoram					    | [$1390: ld   (hl),b]
	exg		d0,d1                        	
	subq.w	#2,d7                           	| [$1392: dec  l]*2
	subq.b	#1,d0                           	| [$1393: dec  a]
	jne	l_138B                             	    | [$1394: jr   nz,l_138B]

	move.w	(sp)+,d7                        	| [$1396: pop  hl]
	rts                                    	    | [$1397: ret]

*=============================================================================
* c_string_out_1398()
*  Description:
*    Copy a series of characters to tile-ram (see d_cstring_tbl).
*    Converts characters strings from ASCII to corresponding character tiles.
*    Machine character set:
*     $00 - $09 : decimal digit characters.
*     $0A - $23 : A-Z
*     $24       : <space>
*    String length is variant - the termination token is $2F (ascii "/").
*    Can be called two ways:
*    CALL:
*      Destination position address is passed in HL and swapped into DE.
*    RST $30:
*      RST $30 sets the CY flag and JPs to string_out_pe.
*      The string pointer is then offset (-2) i.e. sizeof(ptr) to get
*      the destination position address, which winds up in DE.
*      With the position address in DE, the rest of the routine is the same.
*  IN:
*    HL: position in tile RAM.
*    C: index into table of string pointers (d_cstring_tbl)
*    CY: "set" if jumped to j_string_out_pe_139a
*  OUT:
*    HL contains final string character display position.
*
*    PRESERVES :   DE
*-----------------------------------------------------------------------------
c_string_out_1398:
											| [and  a] clear CY flag.
	clr.b		d7                          | [ex   af,af'] save CY flag.
j_string_out_pe_139a:
	movem.w	d3/d4,-(sp)                    	| [push de] preserves DE
	move.l	a1,-(sp)                        | [push de] preserves DE
	exg	a1,a0                              	| [ex   de,hl] DE := position in tile RAM

* Get address of string pointer using index in C ...
* p_sptr = ( ptr_tbl - sizeof(ptr) ) + sizeof(ptr) * index
	move.b	d2,d0                           	| [ld   a,c] C = index into table string pointers (d_cstring_tbl)
	lea	d_cstring_tbl-4,a0             			| [ld   hl,#d_cstring_tbl - 2] index is ordered from 1 !!
	jbsr	add_4_times_d0_to_a0_0008           | [rst  0x08] HL += 2A

* De-reference the string pointer
* sptr = *(p_sptr)
	move.l	(a0),a0
											| [ld   a,(hl)] lsb
											| [inc  hl]
											| [ld   h,(hl)] msb
											| [ld   l,a] lsb
					
* Restore flags and check CY
	tst.b	d7                              | [ex   af,af']
* if ( CY ) ...
	jeq	l_13AE                             	| [jr   nc,l_13AE]
* ... do PE stuff: get position into DE ... HL-=2, DE:=*(HL)
	                                     	| [dec  hl] * 2
	* jotd: the macro generates big endian words, code needs adaptation
	moveq	#0,d3
	move.b	(-2,a0),d3                      | [ld   e,(hl)] MSB
	                           	            | [inc  hl]
	move.b	(-1,a0),d4                      | [ld   d,(hl)] LSB
	                           	            | [inc  hl] HL now pointing to "color".
	LOAD_D3_16_FROM_D3D4
	move.l	d3,a1				            | screen address
	
* now DE == position, so the rest is the same...
l_13AE:
	move.b	(a0)+,d2                         	| [$13AE: ld   c,(hl)] C := color byte ($00 == "cyan")
	                           	                | [$13AF: inc  hl] ptr++ (first byte of "text")
	exg	a0,a1                           	    | [$13B0: ex   de,hl] position address in HL, src address in DE
	move.l	a0,d7
l_13B1:
* if ( TERMINATION ) then exit
	move.b	(a1),d0                         	| [$13B1: ld   a,(de)]
	cmp.b	#0x2F,d0                         	| [$13B2: cp   #0x2F] string terminator (/)
	jeq	l_13D4_out                         	    | [$13B4: jr   z,l_13D4_out]
       *
* only a <space> character ($20) should be < $30
	sub.b	#0x30,d0                         	| [$13B6: sub  #0x30] e.g. ASCII "0" ... ($30 - $30 ) = 0, "1" ... ($31 - $30 ) = 1 ... etc.
	jcc	l_13BE                             	    | [$13B8: jr   nc,l_13BE]
	move.b	#0x24,d0                        	| [$13BA: ld   a,#0x24] generate a <space> character.
	jra	l_13C4_putc                        	    | [$13BC: jr   l_13C4_putc]
l_13BE:
* if ( A >= $11 )
	cmp.b	#0x11,d0                         	| [$13BE: cp   #0x11] e.g. ASCII "A" ... ($41 - $30) = $11
	jcs	l_13C4_putc                        	    | [$13C0: jr   c,l_13C4_putc]
* then A-=7
	subq.b	#7,d0                           	| [$13C2: sub  #7] e.g. ASCII "A" ... ($41 - $30 - $07) = $0A

l_13C4_putc:
	jbsr	osd_w_videoram                      | [$13C4: ld   (hl),a] display the character
	bset.b	#10,d7                           	| [$13C5: set  2,h] H|= $04  (HL:+=$0400)  offset HL into color RAM $8400-$87FF
	exg		d2,d0
	jbsr	osd_w_colorram                      | [$13C7: ld   (hl),c] color code in C
	exg		d2,d0
	bclr.b	#10,d7                           	| [$13C8: res  2,h] HL:-=$0400
	addq.w	#1,a1                           	| [$13CA: inc  de] psrc++

* HL-=$20 (advance destination position one tile to the "right")
	                           	                | [$13CB: ld   a,l]
	sub.w	#0x20,d7                         	| [$13CC: sub  #0x20]
	                           	                | [$13CE: ld   l,a]
	                             	            | [$13CF: jr   nc,l_13B1]
	                           	                | [$13D1: dec  h]
	jra	l_13B1                             	    | [$13D2: jr   l_13B1]
l_13D4_out:
	move.l	d7,a0				| re-transfer to a0
	move.l	(sp)+,a1                            | [pop  de]
	movem.w	(sp)+,d3/d4                    	    | [$13D4: pop  de]
	rts                                    	    | [$13D5: ret]

*=============================================================================
* strings for c_string_out_1398
d_cstring_tbl:
  * 0x00
	.long s_1414,s_1429,s_1436,s_1441,s_144B,s_1457,s_1461,s_1476,s_1488,s_1493
  * 0x0A
	.long s_14A7,s_14C6,s_14D3,s_14EE,s_14F8,s_1507,s_1514,s_1521,s_1525,s_153A
  * 0x14
	.long s_1545,s_1552,s_1569,s_1577,s_1590,s_15A7,s_15AD,s_15C1,s_15D5,s_15E7


* "Declare Effective Address" macro (idfk)
* Generates offsets in Playfield Tile RAM from given row/column ordinates. _R
* and _C are 0 based, and this is reflected in the additional "-1" term. The
* coordinate system applies only to the "Playfield" area and is independent of
* the top two rows and bottom two rows of tiles.
* (See tile RAM & color RAM layout ascii art diagram in mrw.s).
	.macro  _dea  _R _C
	.word    0x8000 + 0x40 + ( 0x1C - \_C - 1 ) * 0x20 + \_R
	.endm


* Terminated strings (2f). First byte is color-code (1-byte ), unless the string is
* position-encoded, in which case the address word will precede string label.

* $01
	_dea 11 6                                 | 02EB
s_1414:
	.byte 0x00
	.ascii "PUSH START BUTTON/"

* $02
	_dea 16 10                                | 0270
s_1429:
	.byte 0x00
	.ascii "GAME OVER/"

* $03
	_dea 16 10                                | 0270
s_1436:
	.byte 0x00
	.ascii "READY !/"                         | '!' displays as <space>

* $04
	_dea 16 11                                | 0250
s_1441:
	.byte 0x00
	.ascii "PLAYER 1/"

* $05
s_144B:
	.byte 0x00
	.ascii "PLAYER 2/"

* %06
	_dea 16 10                                | 0270
s_1457:
	.byte 0x00
	.ascii "STAGE /"

* $07
	_dea 16 5                                 | 0310
s_1461:
	.byte 0x00
	.ascii "CHALLENGING STAGE/"

* $08
	_dea 16 5                                 | 0310
s_1476:
	.byte 0x00
	.ascii "NUMBER OF HITS/"

* $09
	_dea 19 8                                 | 02B3
s_1488:
	.byte 0x00
	.ascii "BONUS  /"

* $0A
	_dea 17 6                                 | 02F1
s_1493:
	.byte 0x04
	.ascii "FIGHTER CAPTURED/"

* $0B
	_dea 13 0                                 | 03AD
s_14A7:
	.byte 0x00
	.ascii "                           /"     | 27 spaces

* $0C
	_dea 13 10                                | 026D
s_14C6:
	.byte 0x04
	.ascii "PERFECT c/"

* $0D
	_dea 19 2                                 | 0373
s_14D3:
	.byte 0x05
	.ascii "SPECIAL BONUS 10000 PTS/"

* $0E
	_dea 2 11                                 | 0242
s_14EE:
	.byte 0x00
	.ascii "GALAGA/"

* $0F
	_dea 5 8                                  | 02A5
s_14F8:
	.byte 0x00
	.ascii "]] SCORE ]]/"

* $10
	_dea 8 12                                 | 0228
s_1507:
	.byte 0x00
	.ascii "50    100/"

* $11
	_dea 10 12                                | 022A
s_1514:
	.byte 0x00
	.ascii "80    160/"

* $12
	_dea 11 12                                | 022B
s_1521:
	.byte 0x00
	.ascii "/"

* $13
	_dea 27 6                                 | 02FB
s_1525:
	.byte 0x03                                  | "(C) 1981 NAMCO LTD."
	.ascii "e 1981 NAMCO LTDa/"

* $14
_dea 30 11                                | 025E
s_153A:
	.byte 0x04                                  | "NAMCO" (in styled font)
	.byte 0x66,0x67,0x68,0x69,0x6A,0x6B,0x6C,0x2F

* $15
	_dea 15 9                                 | 028F
s_1545:
	.byte 0x04
	.ascii "]RESULTS]/"

* $16
	_dea 18 4                                 | 0332
s_1552:
	.byte 0x05
	.ascii "SHOTS FIRED          /"

* $17
s_1569:
	.byte 0x05
	.ascii "  MISSILES/"

* $18
	_dea 21 4                                 | 0335
s_1577:
	.byte 0x05
	.ascii "NUMBER OF HITS       /"

* $19
	_dea 24 4                                 | 0338
s_1590:
	.byte 0x03
	.ascii "HIT]MISS RATIO       /"

* $1A
s_15A7:
	.byte 0x03
	.ascii "$`/"                              | '`' displays as "%" ("$" displays as <space>)

* $1B
	_dea 15 4                                 | 032F
s_15AD:
	.byte 0x05
	.ascii "1ST BONUS FOR   /"

* $1C
	_dea 18 4                                 | 0332
s_15C1:
	.byte 0x05
	.ascii "2ND BONUS FOR   /"

* $1D
	_dea 21 4                                 | 0335
s_15D5:
	.byte 0x05
	.ascii "AND FOR EVERY   /"

* $1E
s_15E7:
	.byte 0x05
	.ascii "0000 PTS/"


_l_15f1: | end area
*           00001700  f_ship_demo_controls_1700
	.align	2
*
* input file gg1-2_fx.s
*
* gg1-2_fx.s:
*  gg1-2.3m, 'maincpu' (Z80)
*
*  step function execution from gg1-2
*  ship movement, control inputs, flying bugs, flying bombs
*
*
*.module ga0
**.area ROM (ABS,OVR)




*       .org  0x1700
*.area CSEG17


*=============================================================================
* f_ship_demo_controls_1700()
*  Description:
*   Fighter control, only called in training/demo mode.
* IN:
*  ...
* OUT:
*  ...
*-----------------------------------------------------------------------------
f_ship_demo_controls_1700:
* labels for "case" blocks in _1713
* switch( *_demo_fghtrvctrs >> 5) & 0x07 )
	move.l	pdb_demo_fghtrvctrs_9282,a1      	    | [$1700: ld   de,(pdb_demo_fghtrvctrs_9282)] cases for switch
	move.b	(a1),d0                     			| [$1704: ld   a,(de)]
	rol.b	#3,d0                       			| [$1705: rlca] * 3
	and.b	#0x07,d0                    			| [$1708: and  #0x07]
	CHECK_D0W_UPPER_BOUND	6
	lea	d_1713,a0                      				| [$170A: ld   hl,#d_1713] &table
	jbsr	add_4_times_d0_to_a0_0008   			| [$170D: rst  0x08] HL += 2A
													| [$170E: ld   a,(hl)]
													| [$170F: inc  hl]
													| [$1710: ld   h,(hl)]
	move.l	(a0),a0         						| [$1711: ld   l,a]
	jra	(a0)                						| [$1712: jp   (hl)]
d_1713:
	.long case_demo_1766
	.long case_demo_1766
	.long case_boss_wingmen_near_171F
	.long case_demo_1766
	.long case_drives_sim_inputs_1734
	.long case_172D


* boss+wingmen nearly to fighter
case_boss_wingmen_near_171F:  | 0x02
	move.b	ds3_frame_cts_92A0+0,d0         	| [$171F: ld   a,(ds3_frame_cts_92A0 + 0)]
	and.b	#0x0F,d0                         	| [$1722: and  #0x0F]
	beq.b	0f                               	| [...]
	rts                                    		| [$1724: ret  nz] [...]
0:
	lea	ds_9200_glbls+0x07,a0          			| [$1725: ld   hl,#ds_9200_glbls + 0x07] timer, training mode, far-right boss turned blue
	subq.b	#1,(a0)                         	| [$1728: dec  (hl)]
	beq.b	0f                               	| [...]
	rts                                    		| [$1729: ret  nz] [...]
0:
	jra	case_demo_1766                          | [$172A: jp   case_demo_1766] training mode, far-right boss exploding

* appearance of first enemy formation in Demo
case_172D:  | 0x05
	jbsr	c_init_rocket_sprites_1F0F      	| [$172D: call c_init_rocket_sprites_1F0F] init sprite objects for rockets
	move.l	pdb_demo_fghtrvctrs_9282,a1         | [$1730: ld   de,(pdb_demo_fghtrvctrs_9282)] trampled DE so reload it

* drives the simulated inputs to the fighter in training mode
case_drives_sim_inputs_1734:  | 0x04
	move.b	(a1),d0                             | [$1734: ld   a,(de)] *pdb_demo_fghtrvctrs_9282
	lea	ds_plyr_actv+_b_2ship,a0       		    | [$1735: ld   hl,#ds_plyr_actv +_b_2ship]
	move.b	(a0),d4                             | [$1738: ld   e,(hl)] setup E for c_skip_real_io_input_1F92
	btst.b	#0,d0                               | [$1739: bit  0,a]
	jne	l_1741                             	    | [$173B: jr   nz,l_1741]
	and.b	#0x0A,d0                            | [$173D: and  #0x0A]
	jra	l_1755                             	    | [$173F: jr   l_1755]

l_1741:
	move.b	ds_9200_glbls+0x09,d0           	| [$1741: ld   a,(ds_9200_glbls + 0x09)] object/index of targeted alien
	move.b	d0,d6                           	| [$1744: ld   l,a]
	lea	ds_sprite_posn_9300,a0              	| [$1745: ld   h,#>ds_sprite_posn_9300]
	and.w	#0xFF,d6
	add.w	d6,a0
	move.b	ds_sprite_posn_9300+0x62,d0         | [$1747: ld   a,(ds_sprite_posn_9300 + 0x62)] ship (1) position
	addq.b	#1,d0                               | jotd hack: adding 1 fixes the bug in the intro where the ship misses the first boss
	sub.b	(a0),d0                          	| [$174A: sub  (hl)]
	* jotd: had to handle Z and C flags separately as there are some "ld" instructions in between
	jne		0f
	move.b	#0x0A,d0                        	| [$174B: ld   a,#0x0A]
	jra	l_1755                             		| [$174D: jr   z,l_1755]
0:
	jcc		0f
	move.b	#0x08,d0                        	| [$174F: ld   a,#0x08] right
	jra	l_1755                             		| [$1751: jr   c,l_1755]
0:
	move.b	#2,d0                           	| [$1753: ld   a,#2] left
l_1755:
	jbsr	c_skip_real_io_input_1F92           | [$1755: call c_skip_real_io_input_1F92]
	move.b	ds3_frame_cts_92A0+0,d0         	| [$1758: ld   a,(ds3_frame_cts_92A0 + 0)]
	and.b	#0x03,d0                         	| [$175B: and  #0x03]
	beq.b	0f                               	| [...]
	rts                                    		| [$175D: ret  nz] [...]
0:
	lea	ds_9200_glbls+0x07,a0          			| [$175E: ld   hl,#ds_9200_glbls + 0x07] timer, training mode, far-right boss exploding
	subq.b	#1,(a0)                         	| [$1761: dec  (hl)]
	beq.b	0f                               	| [...]
	rts                                    		| [$1762: ret  nz] [...]
0:
	jbsr	c_init_rocket_sprites_1F0F          | [$1763: call c_init_rocket_sprites_1F0F] init sprite objects for rockets ...training mode, ship about to shoot?

* here shoot during demo (real game demo and intro)
case_demo_1766:  | 0x00, 0x01, 0x03
	move.l	pdb_demo_fghtrvctrs_9282,a1    		| [$1766: ld   de,(pdb_demo_fghtrvctrs_9282)]
	move.b	(a1),d0                         	| [$176A: ld   a,(de)]
	and.b	#0xC0,d0                         	| [$176B: and  #0xC0] 0x80 fires shot ... 0xC0 is end of sequence
	cmp.b	#0x80,d0                         	| [$176D: cp   #0x80]
	jne	l_1772                             		| [$176F: jr   nz,l_1772]
	addq.w	#1,a1                           	| [$1771: inc  de] firing shot ... advance to next token
l_1772:
	addq.w	#1,a1                           	| [$1772: inc  de]
	move.b	(a1),d0                         	| [$1773: ld   a,(de)]
	move.l	a1,pdb_demo_fghtrvctrs_9282    		| [$1774: ld   (pdb_demo_fghtrvctrs_9282),de] += 1
* A = (*_demo_fghtrvctrs >> 5) & 0x07|
	rol.b	#3,d0                            	| [$1778: rlca] * 3
	and.w	#0x07,d0                         	| [$177B: and  #0x07]
* switch(...)
	CHECK_D0W_UPPER_BOUND	7
	lea	d_1786,a0                      			| [$177D: ld   hl,#d_1786]
	jbsr	add_4_times_d0_to_a0_0008           | [$1780: rst  0x08] HL += 2A (pointer from index)
	move.l	(a0),a0                       		| [$1781: ld   a,(hl)]
												| [$1782: inc  hl]
												| [$1783: ld   h,(hl)]
												| [$1784: ld   l,a]
	jra	(a0)          					        | [$1785: jp   (hl)] 1784

d_1786:
	.long case_load_pos_of_target_1794  | 0
	.long case_load_pos_of_target_1794  | 1 -> $2x
	.long case_ship_shoots_demo_17A1  | 2 -> $4x
	.long case_17A8  | 3
	.long case_17AE  | 4 -> $8x
	.long case_17AE  | 5
	.long case_179C  | 6 -> $Cx

	
* load index/position of target alien
case_load_pos_of_target_1794:
* ds_9200_glbls[0x09] = *_demo_fghtrvctrs << 1 & 0x7E
	move.b	(a1),d0                         	| [$1794: ld   a,(de)]
	rol.b	#1,d0                            	| [$1795: rlca] rotate bits<6:1> into place
	and.b	#0x7E,d0                         	| [$1796: and  #0x7E] mask out Cy rlca'd into <:0>
	move.b	d0,ds_9200_glbls+0x09           	| [$1798: ld   (ds_9200_glbls + 0x09),a] index/position of of target alien
	rts                                    		| [$179B: ret]

* $C0: last token, shot-and-hit far-left boss in training mode (second hit)
case_179C:
	clr.b	d0                               	| [$179C: xor  a]
	move.b	d0,ds_cpu0_task_actv_9000+0x03      | [$179D: ld (ds_cpu0_task_actv_9000 + 0x03),a] 0 ... f_ship_demo_controls_1700() end of fighter control sequence
	rts                                    		| [$17A0: ret]

* $4x: shoot-and-hit far-right or far-left boss (once) in training mode
case_ship_shoots_demo_17A1:
	move.b	(a1),d0                         	| [$17A1: ld   a,(de)]
	and.b	#0x1F,d0                         	| [$17A2: and  #0x1F]
l_17A4:
	move.b	d0,ds_9200_glbls+0x07           	| [$17A4: ld   (ds_9200_glbls + 0x07),a] demo timer
	rts                                    		| [$17A7: ret]

* when? seems not reached. maybe used at some point to print a message?
* prints "AND FOR EVERY", seems bogus!
case_17A8:
*	move.b	(a1),d0                         	| [$17A8: ld   a,(de)]
*	and.b	#0x1F,d0                         	| [$17A9: and  #0x1F]
*	move.b	d0,d2                           	| [$17AB: ld   c,a]
*	jbsr	string_out_pe_30                    | [$17AC: rst  0x30] string_out_pe
	rts                                    		| [$17AD: ret]

* $8x: prior to each fighter shot in training mode
case_17AE:
	addq.w	#1,a1                           	| [$17AE: inc  de]
	move.b	(a1),d0                         	| [$17AF: ld   a,(de)]
	jra	l_17A4                             		| [$17B0: jr   l_17A4]

*=============================================================================
* f_manage_attract_mode_17B2()
*  Description:
*   Manage attract mode, control sequence for training and demo screens.
*   The state progression is always the same, ordered by the state-index
*   (switch variable).
*
* IN:
*  ...
* OUT:
*  ...
*-----------------------------------------------------------------------------
f_manage_attract_mode_17B2:
* if ( game_state != ATTRACT_MODE ) return
	move.b	b8_game_state_9201,d0           	| [ld   a,(b8_game_state_9201)]
	subq.b	#1,d0                           	| [dec  a]
	beq.b	0f                               	| [...]
	rts                                    	| [ret  nz] [...]
0:

* switch( demo_idx )
	move.b	ds_9200_glbls+0x03,d0           	| [ld   a,(ds_9200_glbls + 0x03)] demo state variable (jp to "switch-case")
	lea	d_demo_jump_table_17C3,a0                	| [ld   hl,#d_demo_jump_table_17C3] table_base
	CHECK_D0W_UPPER_BOUND	0xF
	jbsr	add_4_times_d0_to_a0_0008                            	| [rst  0x08] HL += 2A
	move.l	(a0),a0                        	| [ld   e,(hl)]
	                        	| [inc  hl]
	                        	| [ld   d,(hl)]
	                              	| [ex   de,hl]
	jra	(a0)                               	| [jp   (hl)]

* state 0x04 is the main state where aliens attack in the demo and fighter shoots them to show various scoring
d_demo_jump_table_17C3:
	.long case_clear_video_ram_1940                   | 0x00 . clear tile and sprite ram
	.ifeq	OPT_START_WITH_HIGH_SCORE_TABLE
	.long case_setup_info_screen_1948                 | 0x01   setup info-screen: sprite tbl index, text index, preload tmr[2]==2
	.else
	.long	case_end_of_demo_17E1  | show hiscore table directly
	.endif
	.long case_info_screen_sequencer_1984             | 0x02   tmr[2]=2,  sequence info-text and sprite tiles indices 1 sec intervals
	.long case_init_7_aliens_for_training_mode_18D9   | 0x03   task[F_demo_fghter_ctrl]==1  init 7 aliens for training mode
	.long case_wait_for_fighter_task_18D1             | 0x04 ~ wait for task[F_demo_fghter_ctrl]==0 training-mode runs before advance state
	.long case_copyright_text_sync_18AC               | 0x05   synchronize copyright text with completion of explosion of last boss
	.long case_clear_video_ram_1940                   | 0x06 . clear tile and sprite ram
	.long case_delay_before_game_over_17F5            | 0x07   delay ~1 sec before puts("GAME OVER")
	.ifeq	OPT_SKIP_GAME_DEMO
	.long case_init_demo_1852                         | 0x08   init demo   task[F_demo_fghter_ctrl]==1
	.else
	.long case_end_of_demo_17E1   | show hiscore table directly
	.endif
	.long case_wait_for_fighter_task_18D1             | 0x09 ~ wait for task[F_demo_fghter_ctrl]==0 demo-mode runs before advance state
	.long case_enable_fighter_control_demo_1808       | 0x0A   task[F_demo_fghter_ctrl]==1
	.long case_wait_for_fighter_task_18D1             | 0x0B ~ wait for task[F_demo_fghter_ctrl]==0 boss-capture before advance state
	.long case_init_taskman_disable_bugs_1840         | 0x0C   end of Demo - init taskman, disable flying_bug_ctrl(), global enemy ct 0,
	.long case_clear_video_ram_1940                   | 0x0D . clear tile and sprite ram
	.long case_end_of_demo_17E1                       | 0x0E   end of Demo ... delay, then show GALACTIC HERO screen

* 0E: end of Demo ...  delay, then show GALACTIC HERO screen
case_end_of_demo_17E1:
* if ( game_timers[3] == 0 ) then l_17EC
	move.b	ds4_game_tmrs_92ac+3,d0              	| [ld   a,(ds4_game_tmrs_92ac + 3)] if 0, display hi-score tbl
	                               	| [and  a]
	jeq	l_17EC                             	| [jr   z,l_17EC]
* else if ( game_timers[3] == 1 )  advance state
	subq.b	#1,d0                           	| [dec  a]
	jeq	l_attmode_state_step_19a7               	| [jp   z,l_attmode_state_step_19a7]
* else break
	rts                                    	| [ret]
l_17EC:
	jbsr	c_mach_hiscore_show_3214               	| [call c_mach_hiscore_show_3214]
	move.b	#0x0A,d0                        	| [ld   a,#0x0A]
	move.b	d0,ds4_game_tmrs_92ac+3              	| [ld   (ds4_game_tmrs_92ac + 3),a] $0A ... after displ hi-score tbl
	rts                                    	| [ret]

* 07: just cleared screen from training mode, delay ~1 sec before puts("game over")
case_delay_before_game_over_17F5:
* if ( ( ds3_frame_cts_92A0[0] & 0x1F ) == 0x1F )
	move.b	ds3_frame_cts_92A0+0,d0         	| [ld   a,(ds3_frame_cts_92A0 + 0)]
	and.b	#0x1F,d0                         	| [and  #0x1F]
	cmp.b	#0x1F,d0                         	| [cp   #0x1F]
	beq.b	0f                               	| [...]
	rts                                    	| [ret  nz] [...]
0:
* then ...
	move.b	#1,d0                           	| [ld   a,#1]
	move.b	d0,ds_cpu0_task_actv_9000+0x05       	| [ld   (ds_cpu0_task_actv_9000 + 0x05),a] 1 ... f_misc_gameplay_events_0857
	move.b	#2,d2                           	| [ld   c,#2] index of string
	jbsr	string_out_pe_30                            	| [rst  0x30] string_out_pe ("GAME OVER")
	jra	l_attmode_state_step_19a7               	| [jp   l_attmode_state_step_19a7]

* 10: enable fighter control demo
case_enable_fighter_control_demo_1808:
	jbsr	c_fighter_onscreen_133A           | [call c_fighter_onscreen_133A]
	lea	d_181F,a0                      	      | [ld   hl,#d_181F]
	move.l	a0,pdb_demo_fghtrvctrs_9282       | [ld   (pdb_demo_fghtrvctrs_9282),hl] &d_181F[0]

	move.b	#1,d0                             | [ld   a,#1]
	move.b	d0,ds_cpu0_task_actv_9000+0x03    | [ld   (ds_cpu0_task_actv_9000 + 0x03),a] 1  (f_ship_demo_controls_1700 ... fighter control in training/demo mode)
	move.b	d0,ds_cpu0_task_actv_9000+0x15    | [ld   (ds_cpu0_task_actv_9000 + 0x15),a] 1  (f_read_fire_button_1f04 ... fire button input))
	move.b	d0,ds_cpu1_task_actv+0x05         | [ld   (ds_cpu1_task_actv + 0x05),a] 1  (cpu1:f_05EE ... fighter collision detection)
	jra	l_attmode_state_step_19a7             | [jp   l_attmode_state_step_19a7]

* demo fighter vectors demo level after capture
d_181F:
	.byte 0x08,0x18,0x8A,0x08,0x88,0x06,0x81,0x28,0x81,0x05,0x54,0x1A,0x88,0x12,0x81,0x0F
	.byte 0xA2,0x16,0xAA,0x14,0x88,0x18,0x88,0x10,0x43,0x82,0x10,0x88,0x06,0xA2,0x20,0x56,0xC0
	.align	2
	
* 12: end of Demo, fighter has been erased but remaining enemies may not have been erased yet
case_init_taskman_disable_bugs_1840:
	jbsr	rst_28                            	| [rst  0x28] memset(mctl_mpool,0,$$14 * 12)
	jbsr	c_init_taskman_structs_1230       	| [call c_init_taskman_structs_1230]

	clr.b	d0                               	| [xor  a]
	move.b	d0,ds_cpu0_task_actv_9000+0x10      | [ld   (ds_cpu0_task_actv_9000 + 0x10),a] 0 (f_manage_bomber_attacks_1b65 ... manage bomber attack )
	move.b	d0,ds_9200_glbls+0x0B           	| [ld   (ds_9200_glbls + 0x0B),a] 0 ... glbl_enemy_enbl, end of demo

* have to re-set enable bit for this flag after init_structs
	addq.b	#1,d0                           	| [inc  a]
	move.b	d0,ds_cpu0_task_actv_9000+0x02      | [ld   (ds_cpu0_task_actv_9000 + 0x02),a] 1 ... f_manage_attract_mode_17B2 (attract-mode control)
	jra	l_attmode_state_step_19a7               	    | [jp   l_attmode_state_step_19a7]

* 08: init demo (following training mode) ... "GAME OVER" showing
case_init_demo_1852:
	clr.b	d0                               	| [$1852: xor  a]
	move.b	d0,ds_plyr_actv+_b_bmbr_boss_cflag	| [$1853: ld   (ds_plyr_actv +_b_bmbr_boss_cflag),a] 0 ... enable capture-mode selection
	addq.b	#1,d0                           	| [$1856: inc  a]
	move.b	d0,b_9AA0+0x17                  	| [$1857: ld   (b_9AA0 + 0x17),a] 1 ... sound_mgr_reset: non-zero causes re-initialization of sound mgr
	move.b	d0,ds_plyr_actv+_b_stgctr       	| [$185A: ld   (ds_plyr_actv +_b_stgctr),a] 1
	move.b	d0,ds_cpu0_task_actv_9000+0x03      | [$185D: ld   (ds_cpu0_task_actv_9000 + 0x03),a] 1  (f_ship_demo_controls_1700 ... fighter control in training/demo mode)
	move.b	d0,ds_cpu0_task_actv_9000+0x15      | [$1860: ld   (ds_cpu0_task_actv_9000 + 0x15),a] 1  (f_read_fire_button_1f04 ... fire button input)
	move.b	d0,ds_plyr_actv+_b_not_chllg_stg	| [$1863: ld   (ds_plyr_actv +_b_not_chllg_stg),a] 1  (0 if challenge stage ...see new_stg_game_only)
	lea	d_1887(pc),a0                      		| [$1866: ld   hl,#d_1887]
	move.l	a0,pdb_demo_fghtrvctrs_9282         | [$1869: ld   (pdb_demo_fghtrvctrs_9282),hl] &d_1887[0]
	jbsr	stg_init_env_01c5                   | [$186C: call stg_init_env_01c5]
	jbsr	c_fighter_onscreen_133A             | [$186F: call c_fighter_onscreen_133A] apparently erases some stuff from screen?
	move.b	#1,d0                           	| [$1872: ld   a,#1]
	move.b	d0,ds_9200_glbls+0x0B           	| [$1874: ld   (ds_9200_glbls + 0x0B),a] 1 ... glbl_enemy_enbl, one time init for demo
	move.b	d0,ds_plyr_actv+_b_atk_wv_enbl  	| [$1877: ld   (ds_plyr_actv +_b_atk_wv_enbl),a] 1 ... 0 when respawning player ship
	move.b	d0,ds_plyr_actv+_b_bmbr_boss_wingm	| [$187A: ld   (ds_plyr_actv +_b_bmbr_boss_wingm),a] 1 ... for demo, force the bomber-boss into wingman-mode
	addq.b	#1,d0                           	| [$187D: inc  a]
	move.b	d0,ds_new_stage_parms_99c0+0x04     | [$187E: ld   (ds_new_stage_parms_99c0 + 0x04),a] 2 ... max_bombers (demo)
	move.b	d0,ds_new_stage_parms_99c0+0x05     | [$1881: ld   (ds_new_stage_parms_99c0 + 0x05),a] 2 ... increases max bombers in certain conditions (demo)
	jra	l_attmode_state_step_19a7               | [$1884: jp   l_attmode_state_step_19a7]

* demo fighter vectors demo level before capture
d_1887:
	.byte 0x02,0x8A,0x04,0x82,0x07,0xAA,0x28,0x88,0x10,0xAA,0x38,0x82,0x12,0xAA,0x20,0x88
	.byte 0x14,0xAA,0x20,0x82,0x06,0xA8,0x0E,0xA2,0x17,0x88,0x12,0xA2,0x14,0x18,0x88,0x1B
	.byte 0x81,0x2A,0x5F,0x4C,0xC0
	.align	2
	
* 05: synchronize copyright text with completion of explosion of last boss
case_copyright_text_sync_18AC:
* tmr[2] always 0 at transition to this case (was reloaded at last of 5 texts in case_info_screen_sequencer_1984)
* if (0 == tmr[2])  collsn_notif && tmr[2]=9 && break
	move.b	ds4_game_tmrs_92ac+2,d0              	| [ld   a,(ds4_game_tmrs_92ac + 2)] always 0 here at entry to case_copyright_text_sync_18AC
	                               	| [and  a]
	jeq	l_18BB                             	| [jr   z,l_18BB]
* else  if (1 == tmr[2])  state++ | break
	subq.b	#1,d0                           	| [dec  a]
	jeq	l_attmode_state_step_19a7               	| [jp   z,l_attmode_state_step_19a7]
* else  if (6 == tmr)  copyright_info | break
	cmp.b	#5,d0                            	| [cp   #5]
	jeq	l_18C6                             	| [jr   z,l_18C6]
* else  break
	rts                                    	| [ret]

l_18BB:
* tmr == 0 ... put 4.5 seconds on the clock (but transitions to next case at tmr==1, so delay actually 4 secs)
	move.b	#0x34,d0                        	| [ld   a,#0x34]
	move.b	d0,b_obj_collsn_notif_9200+0x34 	| [ld   (b_obj_collsn_notif_9200 + 0x34),a] $34
	move.b	#9,d0                           	| [ld   a,#9]
	move.b	d0,ds4_game_tmrs_92ac+2             | [ld   (ds4_game_tmrs_92ac + 2),a] 9
	rts                                    	    | [ret]
l_18C6:
* tmr == 5, explosion complete ... '150' score on display, display namco copyright
	clr.b	d0                               	| [xor  a]
	move.b	d0,ds_sprite_posn_9300+0x62         | [ld   (ds_sprite_posn_9300 + 0x62),a] 0 ... fighter (1) is removed from screen
	move.b	#0x13,d2                        	| [ld   c,#0x13]
	jbsr	string_out_pe_30                    | [rst  0x30] string_out_pe ("(C) 1981 NAMCO LTD.")
	move.b	#0x14,d2                        	| [ld   c,#0x14]
	jbsr	string_out_pe_30                    | [rst  0x30] string_out_pe ("NAMCO" - 6 tiles)
	rts                                    		| [ret]

* 04, 09, 11: wait for fighter control task to disable itself
case_wait_for_fighter_task_18D1:
* if (0 == task_actv_tbl_0[0x03])  attmode_state_step()
	move.b	ds_cpu0_task_actv_9000+0x03,d0      | [$18D1: ld   a,(ds_cpu0_task_actv_9000 + 0x03)] wait for task[f_ship_demo_controls_1700 fighter ctrl ]==0 before advance state
	                               	            | [$18D4: and  a]
	jeq	l_attmode_state_step_19a7               | [$18D5: jp   z,l_attmode_state_step_19a7]
	rts                                    	    | [$18D8: ret]

* 03: one time init for 7 enemies in training mode
case_init_7_aliens_for_training_mode_18D9:
	move.b	#7,d1                           	| [ld   b,#7] 4 bosses + 3 moths
l_18DB_while:
	jbsr	c_sprite_tiles_displ_128C           | [call c_sprite_tiles_displ_128C] updates offset of pointer to _attrmode_sptiles[0]
	subq.b	#1,d1                           	| [...]
	jne	l_18DB_while                       	    | [djnz l_18DB_while]

	clr.b	d0                               	| [$18E0: xor  a]
	move.b	d0,ds_plyr_actv+_b_nships       	| [$18E1: ld   (ds_plyr_actv +_b_nships),a] 0
	move.b	d0,ds_cpu0_task_actv_9000+0x05      | [$18E4: ld   (ds_cpu0_task_actv_9000 + 0x05),a] 0 ... f_misc_gameplay_events_0857 uses tmr[2]
	jbsr	c_fighter_onscreen_133A             | [$18E7: call c_fighter_onscreen_133A] fghtr_onscreen()

* set inits and override defaults of bomber timers (note f_misc_gameplay_events_0857 disabled above)


	move.b	#0xFF,d5                      		| [$18EA: ld   hl,#0xFF0D]
	move.b	#0x0D,d6                      		| [$18EA: ld   hl,#0xFF0D]
       * tmrs_init[0x06] = 0xFF
	*move.b	d6,b_92C0+0x05                  	| [$18ED: ld   (b_92C0 + 0x05),hl] demo ... timrs[0x06] = $FF
	move.b	d5,b_92C0+0x06                  	| [$18ED: ld   (b_92C0 + 0x05),hl] demo ... timrs[0x06] = $FF
	move.b	d6,b_92C0+0x04                  	| [$18F0: ld   (b_92C0 + 0x04),hl] demo ... timrs
	move.b	d5,b_92C0+0x05                  	| [$18F0: ld   (b_92C0 + 0x04),hl] demo ... timrs
       * tmrs[0x02] = 0xFF
	*move.b	d6,b_92C0+0x01                  	| [$18F3: ld   (b_92C0 + 0x01),hl] demo ... timrs_ini[0x06] = $FF
	move.b	d5,b_92C0+0x02                  	| [$18F3: ld   (b_92C0 + 0x01),hl] demo ... timrs_ini[0x06] = $FF
	move.b	d6,b_92C0+0x00                  	| [$18F6: ld   (b_92C0 + 0x00),hl] demo ... timrs_ini
	move.b	d5,b_92C0+0x01                  	| [$18F6: ld   (b_92C0 + 0x00),hl] demo ... timrs_ini
* now: 92C0  0D FF FF FE 0D FF FF. FE is there from system tests, and has no effect

	lea	d_1928,a0                      			| [$18F9: ld   hl,#d_1928] demo fighter vectors
	move.l	a0,pdb_demo_fghtrvctrs_9282         | [$18FC: ld   (pdb_demo_fghtrvctrs_9282),hl] &d_1928[0] ... demo fighter vectors

* memset($92ca,$00,$10)
	clr.b	d0                               	| [$18FF: xor  a]
	move.b	#0x10,d1                        	| [$1900: ld   b,#0x10]
	lea	bmbr_boss_pool_92ca,a0              	| [$1902: ld   hl,#bmbr_boss_pool_92ca] memset( ... , 0, $10 )
	jbsr	rst_18                            	| [$1905: rst  0x18] memset((HL), A=fill, B=ct)
	move.b	d0,ds_plyr_actv+_b_2ship        	| [$1906: ld   (ds_plyr_actv +_b_2ship),a] 0: not double fighter
	move.b	d0,ds_9200_glbls+0x0B           	| [$1909: ld   (ds_9200_glbls + 0x0B),a] 0: glbl_enemy_enbl (demo)
	addq.b	#1,d0                           	| [$190C: inc  a]
	move.b	d0,ds_plyr_actv+_b_bmbr_boss_cflag	| [$190D: ld   (ds_plyr_actv +_b_bmbr_boss_cflag),a] 1 ... force bomber-boss wingman for training mode
	move.b	d0,ds_cpu0_task_actv_9000+0x10      | [$1910: ld   (ds_cpu0_task_actv_9000 + 0x10),a] 1: f_manage_bomber_attacks_1b65 ... manage bomber attack
	move.b	d0,ds_cpu0_task_actv_9000+0x0B      | [$1913: ld   (ds_cpu0_task_actv_9000 + 0x0B),a] 1: f_update_enemy_status_1db3 ... check enemy status at 9200
	move.b	d0,ds_cpu0_task_actv_9000+0x03      | [$1916: ld   (ds_cpu0_task_actv_9000 + 0x03),a] 1: f_ship_demo_controls_1700 ... fighter control in training/demo mode
	*move.b	_sfr_dsw4,d0                    	| [$1919: ld   a,(_sfr_dsw4)] DSWA ... SOUND IN ATTRACT MODE: _fx[0x17]
	*ror.b	#1,d0                            	| [$191C: rrca]
	*and.b	#0x01,d0                         	| [$191D: and  #0x01]
	moveq	#1,d0								| force sound in attract mode
	move.b	d0,b_9AA0+0x17                  	| [ld   (b_9AA0 + 0x17),a] from DSWA "sound in attract mode" ... 0 == enable CPU-sub2 process

	jbsr	c_game_or_demo_init               	| [call c_game_or_demo_init]

	jra	l_attmode_state_step_19a7               	| [jp   l_attmode_state_step_19a7]

* demo fighter vectors training mode
d_1928:
	.byte 0x08,0x1B,0x81,0x3D,0x81,0x0A,0x42,0x19,0x81,0x28,0x81,0x08
	.byte 0x18,0x81,0x2E,0x81,0x03,0x1A,0x81,0x11,0x81,0x05,0x42,0xC0

* 00, 06, 13: clear tile and sprite ram
case_clear_video_ram_1940:
	jbsr	c_sctrl_playfld_clr_0160               	| [call c_sctrl_playfld_clr_0160]
	jbsr	c_sctrl_sprite_ram_clr_003c            	| [call c_sctrl_sprite_ram_clr_003c]
	jra	l_attmode_state_step_19a7               	| [jr   l_attmode_state_step_19a7]

* 01: setup info-screen: sprite tbl index, text index, timer[2]
case_setup_info_screen_1948:
	lea	d_attrmode_sptiles,a0          	| [ld   hl,#d_attrmode_sptiles] setup index into sprite data table
	move.l	a0,p_attrmode_sptiles_9280           	| [ld   (p_attrmode_sptiles_9280),hl] parameter to _sprite_tiles_displ

	clr.b	d0                               	| [xor  a]
	move.b	d0,ds_9200_glbls+0x05           	| [ld   (ds_9200_glbls + 0x05),a] 0 ... demo_scrn_txt_indx
	move.b	d0,w_bug_flying_hit_cnt_92a8         	| [ld   (w_bug_flying_hit_cnt_92a8),a] 0

	move.b	#2,d0                           	| [ld   a,#2]
	move.b	d0,ds4_game_tmrs_92ac+2              	| [ld   (ds4_game_tmrs_92ac + 2),a] 2 (1 sec)
	jra	l_attmode_state_step_19a7               	| [jr   l_attmode_state_step_19a7]

* parameters for sprite tiles used in attract mode, 4-bytes each:
*  0: offset/index of object to use
*  1: color/code
*      ccode<3:6>==code
*      ccode<0:2,7>==color
*  2: X coordinate
*  3: Y coordinate
*
d_attrmode_sptiles:
	.byte 0x08,0x1B,0x44,0x3A  | code $18 (bee)
	.byte 0x0A,0x12,0x44,0x42  | code $10 (moth)
	.byte 0x0C,0x08,0x7C,0x50  | code $08 (boss)
*d_attrmode_sptiles_7 | label not needed, residual value of the pointer is used
	.byte 0x34,0x08,0x34,0x5C  | code $08
	.byte 0x30,0x08,0x64,0x5C  | code $08
	.byte 0x32,0x08,0x94,0x5C  | code $08
	.byte 0x4A,0x12,0xA4,0x64  | code $10
	.byte 0x36,0x08,0xC4,0x5C  | code $08
	.byte 0x58,0x12,0xB4,0x64  | code $10
	.byte 0x52,0x12,0xD4,0x64  | code $10

* 02: info-screen sequencer, advance text and sprite tiles indices
case_info_screen_sequencer_1984:
*  if ( 0 == game_tmrs[2] ) ... (2 on the clock from case_setup_info_screen_1948)
	move.b	ds4_game_tmrs_92ac+2,d0              	| [$1984: ld   a,(ds4_game_tmrs_92ac + 2)]
	                               	| [and  a]
	beq.b	0f                               	| [...]
	rts                                    	| [ret  nz] [...]
0:
* then ...
* . game_tmrs[2] = 2| // 1 second
	move.b	#2,d0                           	| [ld   a,#2]
	move.b	d0,ds4_game_tmrs_92ac+2              	| [ld   (ds4_game_tmrs_92ac + 2),a] info-screen: 2counts (1 second) between text

* . if (index == 5) then  state++ | break
	move.b	ds_9200_glbls+0x05,d0           	| [ld   a,(ds_9200_glbls + 0x05)] if 5 ... demo_scrn_txt_indx
	cmp.b	#5,d0                            	| [cp   #5]
	jeq	l_attmode_state_step_19a7               	| [jr   z,l_attmode_state_step_19a7]
* . else
* .. txt_index++ | show text
	addq.b	#1,d0                           	| [$1995: inc  a]
	move.b	d0,ds_9200_glbls+0x05           	| [$1996: ld   (ds_9200_glbls + 0x05),a] demo_scrn_txt_indx++
	add.b	#0x0D,d0                         	| [$1999: add  a,#0x0D] s_14EE - d_cstring_tbl - 1
	move.b	d0,d2                           	| [$199B: ld   c,a] C = 0x0D + A ... string index
	jbsr	string_out_pe_30                    | [$199C: rst  0x30] string_out_pe ("GALAGA", "--SCORE--", etc)

* .. [index >= 3] && sprite_tiles_displ() && break
	move.b	ds_9200_glbls+0x05,d0           	| [$199D: ld   a,(ds_9200_glbls + 0x05)] [demo_scrn_txt_indx >= 3] ... sprite tile display
	cmp.b	#3,d0                            	| [cp   #3]
	bcc.b	0f                               	| [...]
	rts                                    	| [ret  c] [...]
0:
	jbsr	c_sprite_tiles_displ_128C              	| [call c_sprite_tiles_displ_128C] advances pointer to sptiles_3[]

	rts                                    	| [ret]

l_attmode_state_step_19a7:
* .demo_idx++
	lea	ds_9200_glbls+0x03,a0          	| [ld   hl,#ds_9200_glbls + 0x03] advance state variable
	addq.b	#1,(a0)                         	| [inc  (hl)]
* if ( .demo_idx == 0x0F )  then demo_idx = 0
	move.b	(a0),d0                         	| [ld   a,(hl)]
	cmp.b	#0x0F,d0                         	| [cp   #0x0F]
	beq.b	0f                               	| [...]
	rts                                    	| [ret  nz] [...]
0:
	clr.b	(a0)                             	| [ld   (hl),#0]

	rts                                    	| [ret]

*=============================================================================
* f_manage_ship_capture_movement_19b2()
*  Description:
*   Manage ship movement during capturing phase. There are two segments - in
*   the first, the ship movement simply tracks that of the capturing boss.
*   Second, once the boss reaches position in the collective, the ship is
*   moved vertically an additional 24 steps toward the top of the screen so
*   that the final position is above the boss.
*   Enabled by f_boss_starts_tractor_beam_2222 tractor beam task when it terminates with the ship captured.
*   When first called 928E==1 (show text flag), which will show the text and
*   clear the flag.
*   Noticed that once the ship is positioned in the collective, it may
*   experience an additional small horizontal offset once its position begins
*   to be managed by the collective positioning manager.
*
*   this is first called when the ship connects with the boss and the tractor beam
*   has disappeared
* IN:
*  ...
* OUT:
*  ...
*-----------------------------------------------------------------------------
f_manage_ship_capture_movement_19b2:
*  if ( flag  != 0 )  goto show_text
	move.b	ds5_928A_captr_status+0x04,d0   	| [$19B2: ld   a,(ds5_928A_captr_status + 0x04)] == 1 when boss connects with ship (2318)
	                               	            | [$19B5: and  a]
	jne	l_19D2_fighter_captured            	    | [$19B6: jr   nz,l_19D2_fighter_captured]

*  else if ( game_tmrs[1] | 0 == 0 )  goto erase_text
*   ... with A already 0, we use OR to check Z flag for zero count... which efficently loads our count to A at the same time!
	lea	ds4_game_tmrs_92ac+1,a0             	| [$19B8: ld   hl,#ds4_game_tmrs_92ac + 1]
	or.b	(a0),d0                           	| [$19BB: or   (hl)]
	jeq	l_1A01_erase_text                  	    | [$19BC: jr   z,l_1A01_erase_text]

*  else if ( game_tmrs[1] != 4 ) goto 19c7
	cmp.b	#4,d0                            	| [$19BE: cp   #4]
	jne	l_19C7                             	    | [$19C0: jr   nz,l_19C7]

*  timer--   .....decrement timer at 4. ... why? the count is set to 6 (19D7)
	subq.b	#1,d0                           	| [$19C2: dec  a]
	move.b	d0,(a0)                         	| [$19C3: ld   (hl),a]
	move.b	d0,b_9AA0+0x09                  	| [$19C4: ld   (b_9AA0 + 0x09),a] game_tmrs[1] ... sound-fx count/enable registers
l_19C7:
	move.b	ds_plyr_actv+_b_cboss_slot,d0   	| [$19C7: ld   a,(ds_plyr_actv +_b_cboss_slot)] bug_flite_que[ plyr.cboss_slot ].b0D = 4
	add.b	#0x0D,d0                         	| [$19CA: add  a,#0x0D]
	move.b	d0,d6                           	| [$19CC: ld   l,a]
	lea	ds_bug_motion_que_9100,a0           	| [$19CD: ld   h,#>ds_bug_motion_que_9100] bug_flite_que[ plyr.cboss_slot ].b0D = 4
	and.w	#0xFF,d6
	add.w	d6,a0
	move.b	#4,(a0)                         	| [$19CF: ld   (hl),#4]
	rts                                    	    | [$19D1: ret]

l_19D2_fighter_captured:
	jbsr	osd_sound_stop
* sets up a captured-fighter as an enemy object
	move.b	#0x0A,d2                        	| [$19D2: ld   c,#0x0A] index of string
	jbsr	string_out_pe_30                    | [$19D4: rst  0x30] string_out_pe "FIGHTER CAPTURED"
	move.b	#6,d0                           	| [$19D5: ld   a,#6] set time of countdown
	move.b	d0,ds4_game_tmrs_92ac+1             | [$19D7: ld   (ds4_game_tmrs_92ac + 1),a] 6 ...time to show fighter-captured-text
	lea	ds_sprite_posn_9300+0x62,a0         	| [$19DA: ld   hl,#ds_sprite_posn_9300 + 0x62] ship (1) position
	move.b	ds_plyr_actv+_b_bmbr_boss_cobj,d0	| [$19DD: ld   a,(ds_plyr_actv +_b_bmbr_boss_cobj)]
	and.b	#7,d0                            	| [$19E0: and  #7] captured ships are in same order as bosses, from 8800-8807
	moveq	#0,d4                           	
	lea	ds_sprite_posn_9300,a1                  | [$19E3: ld   d,h]
	move.b	d0,d4
	add.w	d4,a1								| [$19E2: ld   e,a]
	move.b	(a0),d0                         	| [ld   a,(hl)] get column of ship object e.g. ... A := *(9362)
	move.b	d0,(a1)+                         	| [ld   (de),a] get column of captured ship object e.g. (DE == 9302)
	clr.b	(a0)+                             	| [ld   (hl),#0]
* set row offset of captured ship object
												| [$19E8: inc  l]
	addq.w	#1,d4								| [$19E9: inc  e] [a1 coherence]
	move.b	(a0),d0                         	| [$19EA: ld   a,(hl)]
	move.b	d0,(a1)                         	| [$19EB: ld   (de),a]
* odd byte of sprite ctrl...
* jotd: msb + reusing L plus 1 because inc a0
	lea	ds_sprite_ctrl_9B00+0x62+1,a0          	| [$19EC: ld   h,#>ds_sprite_ctrl_9B00]
	lea	ds_sprite_ctrl_9B00,a1                 	| [$19EE: ld   d,h]
	add.w	d4,a1								| e followed
	move.b	(a0),d0                         	| [$19EF: ld   a,(hl)]
	move.b	d0,(a1)                         	| [$19F0: ld   (de),a]
	lea	ds_sprite_code_8B00,a0              	| [$19F1: ld   h,#>ds_sprite_code_8B00]
	add.w	d4,a0                           	| [$19F3: ld   l,e]
	move.b	#7,(a0)                         	| [$19F4: ld   (hl),#7] sprite code 7 is the vertical ship "wing closed" used for captured ship
												| [$19F6: dec  l]
	move.b	#7,-(a0)                         	| [$19F7: ld   (hl),#7] sprite color ... red
	clr.b	d0                               	| [$19F9: xor  a]
	move.b	d0,ds5_928A_captr_status+0x01   	| [$19FA: ld   (ds5_928A_captr_status + 0x01),a] 0
	move.b	d0,ds5_928A_captr_status+0x04   	| [$19FD: ld   (ds5_928A_captr_status + 0x04),a] 0 .... erase fighter-captured text
	rts                                    		| [$1A00: ret]

l_1A01_erase_text:
* check if text has been cleared yet?
*  if ( *82d1 == $24 ) goto $1a10
	move.w	#0x8000+0x02C0+0x11,d7
	jbsr	osd_r_videoram					| [ld   a,(0x8000 + 0x02C0 + 0x11)] 'I' of fighter captured
	cmp.b	#0x24,d0                         	| [cp   #0x24]
	jeq	l_1A10                             	| [jr   z,l_1A10]
*  clear "fighter captured" text
	move.b	#0x0B,d2                        	| [ld   c,#0x0B] index into string table
	lea	0x8000+0x03A0+0x11,a0      	| [ld   hl,#0x8000 + 0x03A0 + 0x11] "leftmost" column of row where "fighter captured" is displayed
	jbsr	c_string_out_1398                      	| [call c_string_out_1398] erase fighter capture text
l_1A10:
	move.b	ds_plyr_actv+_b_bmbr_boss_cobj,d0	| [ld   a,(ds_plyr_actv +_b_bmbr_boss_cobj)]
	move.b	d0,d6                           	| [ld   l,a]
	and.b	#0x07,d0                         	| [and  #0x07] ships are in same order as bosses, from 8800-8807
	moveq	#0,d4
	move.b	d0,d4                           	| [ld   e,a]
	lea	b_8800,a0                      	        | [ld   h,#>b_8800]
	and.w	#0xFF,d6
	add.w	d6,a0
	move.b	b_9215_flip_screen,d0           	| [ld   a,(b_9215_flip_screen)]
	move.b	d0,d2                           	| [ld   c,a]
	move.b	(a0),d0                         	| [ld   a,(hl)] e.g. HL==8832
	cmp.b	#0x09,d0                         	| [cp   #0x09] check if object status "flying"
	jne	l_1A3F_join_ship_to_group          	    | [jr   nz,l_1A3F_join_ship_to_group] status changes to 2 (rotating) when boss reaches home positn
	lea	ds_sprite_posn_9300,a0              	| [ld   h,#>ds_sprite_posn_9300]
	add.w	d6,a0
	lea	ds_sprite_posn_9300,a1			        | [ld   d,h] DE == captd ship sprite posn
	add.w	D4,a1
	move.b	(a0)+,d0                         	| [ld   a,(hl)] HL == boss posn, horizontal
	move.b	d0,(a1)+                         	| [$1A26: ld   (de),a]
	                           	| [inc  l]
                           	| [inc  e]
	move.b	#0x10,d0                        	| [ld   a,#0x10] offset captured-ship vertically from flying boss
*  if ( !flip_screen ) goto 1a31
	btst.b	#0,d2                           	| [bit  0,c] C == _flip_screen
	jeq	l_1A31                             	    | [jr   z,l_1A31]
	neg.b	d0                               	| [neg] offset negated for inverted screen.
l_1A31:
	move.b	d0,d1                           	| [ld   b,a] A == vertical offset of ship from boss
	add.b	(a0),d0                          	| [add  a,(hl)] HL == boss in sprite posn regs (odds...vertical posn)
	move.b	d0,(a1)                         	| [ld   (de),a] ... DE == boss_posn + $10
	roxr.b	#1,d0                           	| [rra]
	eor.b	d1,d0                            	| [xor  b]
	rol.b	#1,d0                            	| [rlca]
	and.b	#0x01,d0                         	| [and  #0x01]
	COMPUTE_LSB_A0_D6	ds_sprite_posn_9300
	lea	ds_sprite_ctrl_9B00,a0              	| [ld   h,#>ds_sprite_ctrl_9B00] .b1
	and.w	#0xFF,d6
	add.w	d6,a0
	lea	ds_sprite_ctrl_9B00,a1              	
	add.w	d4,a1                           	| [ld   d,h]
	* change A1 MSB with A0 msb
	move.b	(a0),d7
	eor.b	d7,d0                            	| [xor  (hl)]
	move.b	d0,(a1)                         	| [ld   (de),a] update ship sprite ctrl (e.g. 9B03)
	rts                                    	    | [ret]

* ...boss status e.g. 8830[n] == $02  (rotating into position)
* d4 contains LSB of DE
l_1A3F_join_ship_to_group:
* if ( counter > 0 ) goto 1A4B
	lea	ds5_928A_captr_status+0x01,a0  	        | [$1A3F: ld   hl,#ds5_928A_captr_status + 0x01] counter while captured ship is joined with the collective
	move.b	(a0),d0                             | [$1A42: ld   a,(hl)] a=0
	                               	            | [$1A43: and  a]
	jne	l_1A4B_test_positioning_timer           | [$1A44: jr   nz,l_1A4B_test_positioning_timer]
* else initialize_ship_sprite
	lea	ds_sprite_code_8B00,a1              	| [$1A46: ld   d,#>ds_sprite_code_8B00]
	add.w	d4,a1
	move.b	#6,d0                           	| [$1A48: ld   a,#6] ship sprite code
	move.b	d0,(a1)                         	| [$1A4A: ld   (de),a]
l_1A4B_test_positioning_timer:
	addq.b	#1,(a0)                         	| [$1A4B: inc  (hl)] *( ds5_928A_captr_status + 1 )++
	cmp.b	#0x24,d0                         	| [$1A4C: cp   #0x24]
	jeq	l_1A6A_ship_in_position            	    | [$1A4E: jr   z,l_1A6A_ship_in_position]

* set position increment +1 for inverted screen, otherwise -1
	move.b	#1,d1                           	| [$1A50: ld   b,#1]
	btst.b	#0,d2                           	| [$1A52: bit  0,c] C == flip_screen
	jne	l_1A58                             	    | [$1A54: jr   nz,l_1A58]
	subq.b	#2,d1                           	| [$1A56: dec  b] * 2
l_1A58:
	moveq	#0,d6
	move.b	d4,d6                           	| [$1A58: ld   l,e]
	addq.b	#1,d6                           	| [$1A59: inc  l] set vertical position (odd-byte) [a0 coherence]
	lea	ds_sprite_posn_9300,a0              	| [$1A5A: ld   h,#>ds_sprite_posn_9300]
	add.w	d6,a0
	move.b	d1,d0                           	| [$1A5C: ld   a,b]
	add.b	(a0),d0                          	| [$1A5D: add  a,(hl)]
	move.b	d0,(a0)                         	| [$1A5E: ld   (hl),a]
	roxr.b	#1,d0                           	| [$1A5F: rra]
	eor.b	d1,d0                            	| [$1A60: xor  b]
	rol.b	#1,d0                            	| [$1A61: rlca]
	bcs.b	0f                               	| [...]
	rts                                    	    | [$1A62: ret  nc] [...]
0:
	lea	ds_sprite_ctrl_9B00,a0              	| [$1A63: ld   h,#>ds_sprite_ctrl_9B00]
	and.w	#0xFF,d6
	add.w	d6,a0
	move.b	(a0),d0                         	| [$1A65: ld   a,(hl)]
	eor.b	#0x01,d0                         	| [$1A66: xor  #0x01]
	move.b	d0,(a0)                         	| [$1A68: ld   (hl),a]
	rts                                    	    | [$1A69: ret]

l_1A6A_ship_in_position:
	clr.b	d0                               	| [xor  a]
	move.b	d0,ds_cpu0_task_actv_9000+0x11      | [ld   (ds_cpu0_task_actv_9000 + 0x11),a] 0: this task
	move.b	d0,b_9AA0+0x09                  	| [ld   (b_9AA0 + 0x09),a] 0: sound-fx count/enable registers

	lea	b_8800,a1                      	        | [ld   d,#>b_8800]
	add.w	d4,a1
	addq.b	#1,d0                           	| [inc  a]
	move.b	d0,(a1)                         	| [ld   (de),a] 1: b_8800[n] (stand-by position)
	move.b	d0,ds_plyr_actv+_b_bmbr_boss_cobj	| [ld   (ds_plyr_actv +_b_bmbr_boss_cobj),a] 1: invalidate the capture boss object (e.g. was $32)
	move.b	d0,ds_99B9_star_ctrl+0x00       	| [ld   (ds_99B9_star_ctrl + 0x00),a] 1: when fighter on screen
	addq.b	#1,d0                           	| [inc  a]
	move.b	d0,ds_9200_glbls+0x13           	| [ld   (ds_9200_glbls + 0x13),a] 2: restart-stage flag (fighter captured)
	rts                                    	    | [ret]

*=============================================================================
* f_clone_attack_manager_1A80()
*  Description:
*   "clone-attack" manager.
*   Not active until stage-4 or higher because the parameter is 0.
* IN:
*  ...
* OUT:
*  ...
*-----------------------------------------------------------------------------
f_clone_attack_manager_1A80:
* check parameter for condition to enable the bonus-bee feature.
* if ( num_bugs > num_bugs_for_bonus_bee ) then return
	move.b	ds_new_stage_parms_99c0+0x0A,d0     | [$1A80: ld   a,(ds_new_stage_parms_99c0 + 0x0A)] bonus-bee when bug count reaches this
	move.b	d0,d2                           	| [$1A83: ld   c,a]
	move.b	b_bugs_actv_nbr,d0              	| [$1A84: ld   a,(b_bugs_actv_nbr)]
	cmp.b	d2,d0                            	| [$1A87: cp   c]
	bcs.b	0f                               	| [...]
	rts                                    	    | [$1A88: ret  nc] [...]
0:

* if ( activated_one_already ) goto 1AD5
	move.b	ds_plyr_actv+_b_bbee_tmr,d0         | [$1A89: ld   a,(ds_plyr_actv +_b_bbee_tmr)]
	                               	            | [$1A8C: and  a]
	jne	l_1AD5_in_one_already              	    | [$1A8D: jr   nz,l_1AD5_in_one_already]
* else ... find_available
	lea	b_8800+0x07,a0                 	        | [$1A8F: ld   hl,#b_8800 + 0x07] first object of bee group (minus 1)
	move.w	#20,d1             	                | [$1A92: ld   bc,#20 * 256 + 0xFF] 20 of these pests (we don't care about C)
	move.b	#1,d0                           	| [$1A95: ld   a,#1] 1 == resting
l_1A97:
	addq.w	#1,a0                           	| [$1A97: inc  l] increment to next even offset
	jbsr	cpi                               	| [$1A98: cpi] A-(HL), HL <- HL+1, BC <- BC-1
	jeq	l_1AAB_found_one                   	    | [$1A9A: jr   z,l_1AAB_found_one]
	subq.b	#1,d1                           	| [...]
	jne	l_1A97                             	    | [$1A9C: djnz l_1A97]

* iterate through moth group and find one that is resting
	lea	b_8800+0x40-1,a0               	        | [$1A9E: ld   hl,#b_8800 + 0x40 - 1] offset into moth group
	move.w	#0x10,d1                        	| [$1AA1: ld   b,#0x10] 16 of the vermin
l_1AA3:
	addq.w	#1,a0                           	| [$1AA3: inc  l] increment to next even offset
	jbsr	cpi                               	| [$1AA4: cpi]
	jeq	l_1AAB_found_one                   	    | [$1AA6: jr   z,l_1AAB_found_one]
	subq.b	#1,d1                           	| [...]
	jne	l_1AA3                             	    | [$1AA8: djnz l_1AA3]
	rts                                    	    | [$1AAA: ret]

l_1AAB_found_one:
	move.b	#0xC0,d0                        	| [ld   a,#0xC0]
	move.b	d0,ds_plyr_actv+_b_bbee_tmr     	| [ld   (ds_plyr_actv +_b_bbee_tmr),a] $C0 ... delay count until bonus-bee launch
	subq.w	#1,a0                           	| [dec  l]
	COMPUTE_LSB_A0_D6	b_8800
	lea	ds_sprite_code_8B00,a1              	| [ld   d,#>ds_sprite_code_8B00]
	moveq	#0,d4
 	move.b	d6,d4                           	| [ld   e,l]
	add.w	d4,a1
	                          	                | [inc  e]
	move.b	(1,a1),d0                         	| [ld   a,(de)]
	                           	                | [dec  e]
	move.b	d0,d2                           	| [ld   c,a]
	move.b	ds_plyr_actv+_b_stgctr,d0       	| [ld   a,(ds_plyr_actv +_b_stgctr)] "Bonus-bee" manager
	lsr.b	#2,d0                            	| [srl  a] * 2
	move.b	d0,d6                           	| [ld   l,a]
	clr.b	d5                               	| [ld   h,#0]
	move.b	#3,d0                           	| [ld   a,#3]
	jbsr	c_divmod                          	| [call c_divmod] HL=HL/3
	addq.b	#4,d0                           	| [add  a,#4]
	lea	ds_plyr_actv+_b_bbee_obj,a0    	        | [ld   hl,#ds_plyr_actv +_b_bbee_obj]
	move.b	d4,(a0)+                         	| [ld   (hl),e]
	                           	                | [inc  l]
	move.b	d2,(a0)+                         	| [ld   (hl),c]
	                           	                | [inc  l]
	move.b	d0,(a0)                         	| [ld   (hl),a]
	move.w	#MUTANT_SND,d0
	jbsr	osd_sound_start
	move.b	d0,b_9AA0+0x12                  	| [ld   (b_9AA0 + 0x12),a] sound-fx count/enable registers, bonus-bee sound
	rts                                    	    | [ret]

l_1AD5_in_one_already:
	addq.b	#1,d0                           	| [inc  a] A == delay count until bonus-bee launch
	jeq	l_1AF4_ready_go                    	    | [jr   z,l_1AF4_ready_go]
	move.b	d0,ds_plyr_actv+_b_bbee_tmr     	| [ld   (ds_plyr_actv +_b_bbee_tmr),a] A<0 (delay count until bonus-bee launch)
	exg		d0,d7                              	| [ex   af,af'] stash the counter
 	lea	ds_plyr_actv+_b_bbee_obj,a0    	        | [ld   hl,#ds_plyr_actv +_b_bbee_obj]
	move.b	(a0),d4                         	| [ld   e,(hl)]
	lea	b_8800,a1                      	        | [ld   d,#>b_8800]
	and.w	#0xFF,d4
	add.w	d4,a1
	move.b	(a1),d0                         	| [ld   a,(de)]
* if ( object_status != 1 ) exit  ... (killed the little fucker before he could launch)
	subq.b	#1,d0                           	| [dec  a]
	jne	l_1B54_getout                      	    | [jp   nz,l_1B54_getout]
* else
	lea	ds_sprite_code_8B00,a1              	| [ld   d,#>ds_sprite_code_8B00]
	and.w	#0xFF,d4
	add.w	d4,a1
	addq.w	#1,a0                           	| [inc  l] HL:=982E   ... color 'A'
	exg		d0,d7                              	| [ex   af,af'] recover the counter
	btst.b	#4,d0                           	| [bit  4,a] check for %$10 (alternate color every 1/4 second)
	jeq	l_1AF0_alternating_colors          	    | [jr   z,l_1AF0_alternating_colors]
	addq.w	#1,a0                           	| [inc  l] HL:=982F   ... color 'B'
l_1AF0_alternating_colors:
	move.b	(a0),d0                         	| [ld   a,(hl)]
	addq.w	#1,a1                           	| [inc  e] point to color register (odd-byte offset)
	move.b	d0,(a1)                         	| [ld   (de),a]
	rts                                    	    | [ret]

l_1AF4_ready_go:
	move.b	ds_cpu0_task_actv_9000+0x15,d0      | [ld   a,(ds_cpu0_task_actv_9000 + 0x15)] a "bonus-bee" has started
	                               	            | [and  a]
	jne	l_1B00                             	    | [jr   nz,l_1B00]
	move.b	#0xE0,d0                        	| [ld   a,#0xE0]
	move.b	d0,ds_plyr_actv+_b_bbee_tmr     	| [ld   (ds_plyr_actv +_b_bbee_tmr),a] $E0
	rts                                    	    | [ret]

l_1B00:
	move.b	ds_plyr_actv+_b_bbee_obj,d0     	| [ld   a,(ds_plyr_actv +_b_bbee_obj)]
	move.b	d0,d6                           	| [ld   l,a]
	lea	b_8800,a0                      	        | [ld   h,#>b_8800]
	and.w	#0xFF,d6
	add.w	d6,a0
	move.b	(a0),d0                         	| [ld   a,(hl)]
	subq.b	#1,d0                           	| [dec  a]
	jne	l_1B54_getout                      	    | [jr   nz,l_1B54_getout] make sure he's not dead
	lea	b_obj_collsn_notif_9200,a0     	        | [ld   h,#>b_obj_collsn_notif_9200]
	add.w	d6,a0
	move.b	(a0),d0                         	| [$1B0C: ld   a,(hl)]
	btst.b	#7,d0                           	| [$1B0D: bit  7,a]
	jne	l_1B54_getout                      	    | [$1B0F: jr   nz,l_1B54_getout] make sure he's not dead
	move.b	ds_plyr_actv+_b_bbee_clr_b,d0   	| [$1B11: ld   a,(ds_plyr_actv +_b_bbee_clr_b)]
	subq.b	#4,d0                           	| [$1B14: sub  #4] convert color 4,5,or 6 to index from 0
	lea	d_1B59,a0                      	        | [$1B16: ld   hl,#d_1B59]
	jbsr	add_2_times_d0_to_a0_0008           | [$1B19: rst  0x08] HL += 2A
	lea	ds3_99B0_X3attackcfg,a1        	        | [$1B1A: ld   de,#ds3_99B0_X3attackcfg] setup X3 attacker, write 3 bytes...
                                                  * [0]:=3
                                                  * [1] [2] word loaded from 1B59[ 2 * ( actv_plyr_state + 0x0F ) ]
	move.b	#3,d0                           	| [$1B1D: ld   a,#3]
	move.b	d0,(a1)+                         	| [$1B1F: ld   (de),a] (99B0):=3
	                           	                | [$1B20: inc  e]
	jbsr	ldi                               	| [$1B21: ldi]
	jbsr	ldi                               	| [$1B23: ldi]
* setup vector argument to c_diving_movement_1083
	move.b	ds_plyr_actv+_b_bbee_clr_b,d0   	| [$1B25: ld   a,(ds_plyr_actv +_b_bbee_clr_b)]
	subq.b	#4,d0                           	| [$1B28: sub  #4] convert color 4,5,or 6 to index from 0
	and.b	#0x0F,d0                         	| [$1B2A: and  #0x0F] hmmmm.... we didn't do this before.. oh well
	move.b	d0,d2                           	| [$1B2C: ld   c,a]
	lea	d_1B5F,a0                      			| [$1B2D: ld   hl,#d_1B5F] setup to load pointers into DE
	jbsr	add_2_times_d0_to_a0_0008          	| [$1B30: rst  0x08] HL += 2A
	move.b	(a0)+,d3                        	| [$1B31: ld   e,(hl)]  big endian!!
												| [$1B32: inc  hl]
	move.b	(a0),d4								| [$1B33: ld   d,(hl)]
	LOAD_D3_16_FROM_D3D4
* setup HL pointer to object in sprite code registers
	lea	ds_sprite_code_8B00,a0              	| [$1B34: ld   h,#>ds_sprite_code_8B00]
	moveq	#0,d6
	move.b	ds_plyr_actv+_b_bbee_obj,d6     	| [$1B36: ld   a,(ds_plyr_actv +_b_bbee_obj)]
	add.w	d6,a0								| [$1B39: ld   l,a]
	move.b	d2,d0                           	| [$1B3A: ld   a,c] grab "color B" again
	rol.b	#3,d0                            	| [$1B3B: rlca] * 3
	add.b	#0x56,d0                         	| [$1B3E: add  a,#0x56]
	move.b	(a0),d2                         	| [$1B40: ld   c,(hl)]
	move.b	d0,(a0)                         	| [$1B41: ld   (hl),a]
	move.b	d2,d0                           	| [$1B42: ld   a,c] grab "color B" again
	and.b	#0xF8,d0                         	| [$1B43: and  #0xF8] ?
	move.b	d0,d2                           	| [$1B45: ld   c,a]
	move.b	ds_plyr_actv+_b_bbee_clr_a,d0   	| [$1B46: ld   a,(ds_plyr_actv +_b_bbee_clr_a)]
	and.b	#0x07,d0                         	| [$1B49: and  #0x07]
	or.b	d2,d0                             	| [$1B4B: or   c]
	move.b	d0,ds_plyr_actv+_b_bbee_clr_a   	| [$1B4C: ld   (ds_plyr_actv +_b_bbee_clr_a),a]
	COMPUTE_LSB_A0_D6	ds_sprite_code_8B00
	lea	b_8800,a0                      			| [$1B4F: ld   h,#>b_8800]
	add.w	d6,a0
	jbsr	c_diving_movement_1083              | [$1B51: call c_diving_movement_1083] bomber setup, clone-attack mgr
l_1B54_getout:
	clr.b	d0                               	| [$1B54: xor  a]
	move.b	d0,ds_cpu0_task_actv_9000+0x04      | [$1B55: ld   (ds_cpu0_task_actv_9000 + 0x04),a] 0: f_clone_attack_manager_1A80 ... this task
	rts                                    		| [$1B58: ret]

*=============================================================================
* bonus-bee configuration parameters
d_1B59:
	.byte 0x1E,0xBD
	.byte 0x0A,0xB8
	.byte 0x14,0xBC
	* flight paths of clone-attackers, big endian now
d_1B5F:
	.word db_04EA
	.word db_0473
	.word db_04AB

*=============================================================================
* f_manage_bomber_attacks_1b65()
*  Description:
*   Manage bomber attacks, enabled during demo in fighter-movement phase, as
*   well as in training mode. Disabled at start of each round until all
*   enemies are in home position, then enabled for the duration of the round.
* IN:
*  ...
* OUT:
*  ...
*-----------------------------------------------------------------------------
f_manage_bomber_attacks_1b65:
* if ( flag == zero ) skip the condition check
	move.b	ds_9200_glbls+0x0B,d0           	| [ld   a,(ds_9200_glbls + 0x0B)] glbl_enemy_enbl
	                               	| [and  a]
	jeq	l_1B75                             	| [jr   z,l_1B75]

* if ((0 == ds_cpu0_task_actv_9000[0x15])    	| (0 != ds_cpu0_task_actv_9000 + 0x1D))  return
	move.b	ds_cpu0_task_actv_9000+0x15,d0      | [ld   a,(ds_cpu0_task_actv_9000 + 0x15)] f_read_fire_button_1f04 (fire button input)
	move.b	d0,d2                           	| [ld   c,a]
	move.b	ds_cpu0_task_actv_9000+0x1D,d0      | [ld   a,(ds_cpu0_task_actv_9000 + 0x1D)] f_boss_capturing_ship_killed_2000 (destroyed capture-boss)
	not.b	d0                               	| [cpl]
	and.b	d2,d0                            	| [and  c]
	bne.b	0f                               	| [...]
	rts                                    	| [ret  z] [...]
0:

* check the queue for boss+wing mission ... parameters are queue'd by case boss launcher
l_1B75:
	move.b	#4,d1                           	| [ld   b,#4]
	* structure of 3 items: state/timer + 16bit pointer on flight path
	lea	bmbr_boss_pool_92ca,a0              	| [ld   hl,#bmbr_boss_pool_92ca] check 4 groups of 3 bytes
l_1B7A:
	move.b	(a0),d0                         	| [$1B7A: ld   a,(hl)] .b0: valid object index if slot active, otherwise $FF
	addq.b	#1,d0                           	| [$1B7B: inc  a] 0 if boss_wing_slots[n*4].b0 == $ff
	jne	l_launch_boss_wing_mission_1b8b         | [$1B7C: jr   nz,l_launch_boss_wing_mission_1b8b] if slot active, go launch it
	addq.w	#3,a0                           	| [$1B7E: inc  l]*3
	subq.b	#1,d1                           	| [...]
	jne	l_1B7A                             	    | [$1B81: djnz l_1B7A]

       * insert a 1/4 sec delay before trying next bomber
	move.b	ds3_frame_cts_92A0+0,d0         	| [$1B83: ld   a,(ds3_frame_cts_92A0 + 0)]
	and.b	#0x0F,d0                         	| [$1B86: and  #0x0F]
	jeq	check_bomber_for_ready_status_1ba8                             	    | [$1B88: jr   z,check_bomber_for_ready_status_1ba8]
	rts                                    	    | [$1B8A: ret]

* launching element of boss+wing mission
* A == bmbr_boss_pool_92ca[L].obj_idx + 1
l_launch_boss_wing_mission_1b8b:
	st.b	(a0)                      			| [$1B8B: ld   (hl),#0xFF] bmbr_boss_pool_92ca[ n * 3 + 0 ] = $ff
	subq.b	#1,d0                           	| [$1B8D: dec  a] undo increment of boss_wing_slots[n].idx
	lea	b_8800,a1                      			| [$1B8E: ld   d,#>b_8800]
	moveq	#0,d4
	move.b	d0,d4                           	| [$1B90: ld   e,a] e.g. E=$30 (boss)   8834 (boss already has a captured ship)
	and.w	#0x7F,d4							| [$1B91: res  7,e] bit-7 was used to indicate negated rotation angle to (ix)0x0C
	add.w	d4,a1

* stash A ... object/index from boss_wing_slots[n] (with bit-7 possibly set for negating rotation angle)
	exg		d0,d7                              	| [$1B93: ex   af,af']

* if (STAND_BY != obj_status[E].state) return ... disposition resting/inactive
	move.b	(a1),d0                         	| [$1B94: ld   a,(de)] 92CA[].b0
	subq.b	#1,d0                           	| [$1B95: dec  a]
	beq.b	0f                               	| [...]
	rts                                    	    | [$1B96: ret  nz] exit if not available (demo) [...]
0:

* pointer to object data
	addq.w	#1,a0                           	| [$1B97: inc  l]
	* a0 points to 92CB or something, loads subcpu 16 bit ROM address in D3/D4
	* it doesn't need to point on anything as this cpu doesn't access ROM
 	move.b	(a0)+,d4                         	| [$1B98: ld   e,(hl)] e.g. 92CA[].b1, lsb of pointer to data
	                           	                | [$1B99: inc  l]
	move.b	(a0),d3                         	| [$1B9A: ld   d,(hl)] e.g. 92CA[].b2, msb of pointer to data
	LOAD_D3_16_FROM_D3D4
	
* reload A
	exg	d0,d7                              	    | [$1B9B: ex   af,af']
 	move.b	d0,d6                           	| [$1B9C: ld   l,a] byte-0 of boss_wing_slots[n*3] ... object index/offset
	lea	b_8800,a0                      	        | [$1B9D: ld   h,#>b_8800] e.g. b_8800[$30]
	and.w	#0xFF,d6
	add.w	d6,a0
	jbsr	c_1079                            	| [$1B9F: call c_1079] DE, HL, and bit-7 of HL for negation of rotation angle if set

	move.w	#ATTACK_SND,d0
	jbsr	osd_sound_start
	move.b	#1,d0                           	| [$1BA2: ld   a,#1]
	move.b	d0,b_9AA0+0x13                  	| [$1BA4: ld   (b_9AA0 + 0x13),a] 1 ... sound-fx count/enable registers, bug dive attack sound
	rts                                    		| [$1BA7: ret]

check_bomber_for_ready_status_1ba8:
* check each bomber type for ready status i.e. yellow, red, boss
	lea	b_92C0,a0                 				| [$1BA8: ld   hl,#b_92C0 + 0x00] 3 bytes, 1 byte for each slot, enumerates selection of red, yellow, or boss
	move.b	#3,d1                           	| [$1BAB: ld   b,#3]
l_1BAD:
	subq.b	#1,(a0)                         	| [$1BAD: dec  (hl)] check if this one timed out
	jeq	alien_attacks_1BB4                      | [$1BAE: jr   z,alien_attacks_1BB4] b used below argument to "switch" to select type of alien launched?
	addq.w	#1,a0                           	| [$1BB0: inc  l]
	subq.b	#1,d1                           	| [...]
	jne	l_1BAD                             		| [$1BB1: djnz l_1BAD]
	rts                                    		| [$1BB3: ret] none are ready

* called when boss formations or single boss is attacking in the demo
alien_attacks_1BB4:
* if (bugs_flying_nbr >= max_flying_bugs_this_rnd) then ...
	move.b	ds_new_stage_parms_99c0+0x04,d2     | [$1BB4: ld   a,(ds_new_stage_parms_99c0 + 0x04)] max_bombers
	                                         	| [$1BB7: ld   c,a]
	move.b	b_bugs_flying_nbr_9287,d0           | [$1BB8: ld   a,(b_bugs_flying_nbr_9287)]
	cmp.b	d2,d0                            	| [$1BBB: cp   c]
	jcs	l_1BC0                             		| [$1BBC: jr   c,l_1BC0]
* maximum nbr of bugs already flying set slot-counter back to 1 since it can't be processed right now
	addq.b	#1,(a0)                         	| [$1BBE: inc  (hl)]
	rts                                    		| [$1BBF: ret]

* else ... launch another bombing excursion
l_1BC0:
* b_92C0_0[n] =  b_92C0_0[n + 4] ... set next timeout for this bomber type
												| [$1BC0: set  2,l] offset += 4
	move.b	(4,a0),d0                         	| [$1BC2: ld   a,(hl)] $92C0[n+4]
												| [$1BC3: res  2,l]
	move.b	d0,(a0)                         	| [$1BC5: ld   (hl),a] reset counter for next bomber

	move.b	d1,d0                           	| [$1BC6: ld   a,b] ... b from loop l_1bad above decremented from 3
	subq.b	#1,d0                           	| [$1BC7: dec  a] offset for 0 based indexing of "switch"

* switch(A)
	lea	d_1BD1,a0                      	        | [$1BC8: ld   hl,#d_1BD1]
	CHECK_D0W_UPPER_BOUND	3
	jbsr	add_4_times_d0_to_a0_0008           | [$1BCB: rst  0x08] HL += 2A
	                       	                    | [$1BCC: ld   a,(hl)]
	                       	                    | [$1BCD: inc  hl]
	                       	                    | [$1BCE: ld   h,(hl)]
	move.l	(a0),a0                       	    | [$1BCF: ld   l,a]
	jra	(a0)                               	    | [$1BD0: jp   (hl)]
d_1BD1:
* jp table in order of bomber launch timers
	.long case_bmbr_yellow_1BD7
	.long case_bmbr_red_1BF7
	.long case_bmbr_boss_1C01

* set bee launch params
case_bmbr_yellow_1BD7:
	move.b	#20,d1                          	| [$1BD7: ld   b,#20] number of yellow aliens
	lea	b_8800+0x08,a0                 	        | [$1BD9: ld   hl,#b_8800 + 0x08] $08-$2E
	move.w	#db_flv_atk_yllw_034F,d3            | [$1BDC: ld   de,#db_flv_atk_yllw]

* this section common to both bee and moth launcher, check for next one, skip if already active
l_1BDF:
	move.b	ds_plyr_actv+_b_bbee_obj,d0     	| [$1BDF: ld   a,(ds_plyr_actv +_b_bbee_obj)] load bonus-bee parameter
	move.b	d0,d2                           	| [$1BE2: ld   c,a] stash A
l_1BE3_while:
* if ( disposition == STAND_BY ) && ...
	move.b	(a0),d0                         	| [$1BE3: ld   a,(hl)] obj_status[L].state
	subq.b	#1,d0                           	| [$1BE4: dec  a]
	jne	l_1BEB_next                        	    | [$1BE5: jr   nz,l_1BEB_next]
* ... ( L != bonus_bee_index ) then l_1BF0_found_one
	move.b	d2,d0                           	| [$1BE7: ld   a,c] unstash A ... offset_to_bonus_bee
	COMPUTE_LSB_A0_D6		b_8800		        | recompute offset from original a0
	cmp.b	d6,d0                            	| [cp   l]
	jne	l_1BF0_found_one                   	    | [jr   nz,l_1BF0_found_one]
l_1BEB_next:
	addq.w	#2,a0                           	| [inc  l]*2
	subq.b	#1,d1                           	| [...]
	jne	l_1BE3_while                       	    | [djnz l_1BE3_while]
	rts                                    	    | [ret]

* bee or moth perform a diving attack
l_1BF0_found_one:
	move.b	d0,b_9AA0+0x13                  	| [ld   (b_9AA0 + 0x13),a] from C, !0 ... sound-fx count/enable registers, bug dive attack sound
	move.w	#ATTACK_SND,d0
	jbsr	osd_sound_start
	jbsr	c_diving_movement_1083              | [call c_diving_movement_1083] bomber setup, red or yellow alien
	rts                                    		| [ret]

* set red moth launch params
case_bmbr_red_1BF7:
	move.b	#16,d1                          	| [$1BF7: ld   b,#16] number of red aliens
	lea	b_8800+0x40,a0                 			| [$1BF9: ld   hl,#b_8800 + 0x40] red moths $40-$5E
	move.w	#db_flv_atk_red_03a9,d3             | [$1BFC: ld   de,#db_flv_atk_red]
	jra	l_1BDF                             		| [$1BFF: jr   l_1BDF] common to red and yellow alien

* boss launcher... only enable capture-mode for every other one ( %2 )
case_bmbr_boss_1C01:
* if (boss is diving/capturing ) then goto 1C30
	move.b	ds_plyr_actv+_b_bmbr_boss_cflag,d0	| [$1C01: ld   a,(ds_plyr_actv +_b_bmbr_boss_cflag)] 1 if capture-mode is active / capture-mode selection suppressed
												| [$1C04: and  a]
	jne	l_1C30                             		| [$1C05: jr   nz,l_1C30]
* if ( plyr.cboss_enable_toggle % 2 ) then goto 1C30
	lea	ds_plyr_actv+_b_bmbr_boss_wingm,a0		| [$1C07: ld   hl,#ds_plyr_actv +_b_bmbr_boss_wingm] toggle bomber boss wingman-enable
	addq.b	#1,(a0)                         	| [$1C0A: inc  (hl)]
	btst.b	#0,(a0)                         	| [$1C0B: bit  0,(hl)]
	jne	l_1C30                             		| [$1C0D: jr   nz,l_1C30]

* capture-mode select: for each boss, first one that status==standby beomes capture-boss
	move.b	#2,ixl		                        | [$1C0F: ld   ixl,2]
	move.w	#db_0454,d5                     	| [$1C12: ld   iy,#db_0454]
	lea	b_8800+0x30,a1                 			| [$1C16: ld   de,#b_8800 + 0x30] bosses start at $30 ... object/index of bomber to _1CAE
	move.b	#0x04,d1                        	| [$1C19: ld   b,#0x04] there are 4 of these evil creatures

l_1C1B_while:
	move.b	(a1),d0                         	| [$1C1B: ld   a,(de)] sprt_mctl_objs[de].state
	subq.b	#1,d0                           	| [$1C1C: dec  a] if disposition STAND_BY,  1->0
	jeq	l_1C24_is_standby                  	| [$1C1D: jr   z,l_1C24_is_standby]
	addq.w	#2,a1                           	| [$1C1F: inc  e] status bytes, evens ... i.e. 8830, 32, etc.
	subq.b	#1,d1                           	| [...]
	jne	l_1C1B_while                       	| [$1C20: djnz l_1C1B_while]
	rts                                    	| [$1C21: ret]

l_1C24_is_standby:
	COMPUTE_LSB_A1_D4	b_8800
	move.b	#1,d0                           	| [$1C24: ld   a,#1]
	move.b	d0,ds_plyr_actv+_b_bmbr_boss_cflag	| [$1C26: ld   (ds_plyr_actv +_b_bmbr_boss_cflag),a] 1 ... force next bomber-boss to wingman mode (suppress capture-boss select)
	move.b	d4,d0                           	| [$1C29: ld   a,e]
	move.b	d0,ds_plyr_actv+_b_bmbr_boss_cobj	| [$1C2A: ld   (ds_plyr_actv +_b_bmbr_boss_cobj),a] object/index of bomber to _1CAE ... bosses start at $30
	jra	j_1CAE                             		| [$1C2D: jp   j_1CAE] _boss_activate(e, ixl, b, iy) ... C?

* already in capture-mode, or capture-mode select is suppressed this time ... look for a wingman
* get red alien index, check if already flagged by plyr_state.clone_attkr_en
l_1C30:
* escort object/IDs order in data right->left so bit will shift out left->right
	lea	d_1D2C_wingmen,a0              	| [ld   hl,#d_1D2C_wingmen]
	and.w	#0xFF,d4
	move.w	#6-1,d1                 	| [ld   bc,#6 * 256 + 0] check 6 objects (B) and clear C None
	move.w	#0,d2                 	| [ld   bc,#6 * 256 + 0] check 6 objects (B) and clear C None
l_1C38_while:
	move.b	(a0)+,d4                         	| [$1C38: ld   e,(hl)]
												| [$1C39: inc  hl]
	lea	b_8800,a1                      			| [ld   d,#>b_8800]
	add.w	d4,a1								| update address each time
* if "special attacker" skip test object_status STAND_BY
	move.b	ds_plyr_actv+_b_bbee_obj,d0     	| [$1C3A: ld   a,(ds_plyr_actv +_b_bbee_obj)] check if wingman is already special-bomber
	cmp.b	d4,d0                            	| [$1C3D: cp   e]
	jeq	l_1C44                             		| [$1C3E: jr   z,l_1C44]
* test if object_status = STAND_BY
	move.b	(a1),d0                         	| [$1C40: ld   a,(de)]
	subq.b	#2,d0                           	| [$1C41: dec  a + sub  $01] one byte opcode ... affects X
l_1C44:
	roxl.b	#1,d2                           	| [rl   c] shifts in a bit from Cy if object status was 1 (00 - 01 = FF)
	dbf		d1,l_1C38_while                       		| [djnz l_1C38_while]

	move.b	#0,ixl                              | flag for 1st and 2nd loop?
	move.b	#4,d1                           	| [ld   b,#4]
	move.b	d2,ixh								| [ld   ixh,c] stash C ... bits set for each boss available in standby state

* first pass: look for 2 adjoining escorts available occuring in 3 adjacent spaces
l_1C4F_while:
	move.b	d2,d0                           	| [$1C4F: ld   a,c]
	and.b	#0x07,d0                         	| [$1C50: and  #0x07]
* if (a==3 || a==5|| a==6) ...
	cmp.b	#4,d0                            	| [cp   #4] (a ! 4) ...
	jeq	l_1C5B                             	    | [jr   z,l_1C5B]
	cmp.b	#3,d0                            	| [cp   #3] && (a>=3)
       * d == #>b_8800, e don't care
	bcs.b	0f                               	| [...]
	jbsr	bmbr_boss_activate_1c8d             | [call nc,bmbr_boss_activate_1c8d] _boss_activate(0xFF, 0, b, 0xFFFF)
0:
	SET_X_FROM_C
l_1C5B:
	roxr.b	#1,d2                           	| [rr   c]
	subq.b	#1,d1                           	| [...]
	jne	l_1C4F_while                       	    | [djnz l_1C4F_while] can't use dbf here we need d1 as-is

* second pass: look for 1 available escort
	addq.b	#1,ixl                          	| [inc  ixl] 1
	move.b	ixh,d2                         		| [ld   c,ixh] restore previous C
	move.b	#4,d1                           	| [ld   b,#4]
l_1C65_while:
	move.b	d2,d0                           	| [$1C65: ld   a,c]
	and.b	#0x07,d0                         	| [$1C66: and  #0x07]
	beq.b	0f                               	| [...]
	jbsr	bmbr_boss_activate_1c8d             | [$1C68: call nz,bmbr_boss_activate_1c8d] _boss_activate(0xFF, 1, b, 0xFFFF)
0:
	roxr.b	#1,d2                           	| [$1C6B: rr   c]
	subq.b	#1,d1                           	| [...]
	jne	l_1C65_while                       	    | [$1C6D: djnz l_1C65_while] can't use dbf: we need d1 index as-is

* third pass: take any available boss
	addq.b	#1,ixl                          	| [$1C6F: inc  ixl] 2
	lea	b_8800+0x30,a1                 	        | [$1C71: ld   de,#b_8800 + 0x30] boss objects are 30 34 36 32
	move.b	#4,d1                           	| [$1C74: ld   b,#4]
l_1C76_while:
	move.b	(a1),d0                         	| [$1C76: ld   a,(de)]
	subq.b	#1,d0                           	| [$1C77: dec  a]
	jeq	j_1CA0                             	    | [$1C78: jr   z,j_1CA0] _boss_activate(e, 2, b, 0xFFFF) ... status==STANDBY, skip index selection
	addq.w	#2,a1                           	| [$1C7A: inc  e]*2
	subq.b	#1,d1                               | we need original D1 value!! no dbf!!!
	jne		l_1C76_while                        | [$1C7B: djnz l_1C76_while]

* last pass: no boss available ... check for available rogue fighter (objects 00, 02, 04, 06)
	lea	b_8800,a0                      	| [$1C7E: ld   hl,#b_8800]
	move.w	#4-1,d1                           	| [$1C81: ld   b,#4]
l_1C83_while:
	move.b	(a0),d0                         	| [$1C83: ld   a,(hl)]
	subq.b	#1,d0                           	| [$1C84: dec  a]
	jeq	l_1D25                             	    | [$1C85: jp   z,l_1D25]
	addq.w	#2,a0                           	| [$1C88: inc  l] * 2
	subq.b	#1,d1                               | we need original D1 value!! no dbf!!!
	jne		l_1C83_while                       	| [$1C8A: djnz l_1C83_while]
	rts                                    	    | [$1C8C: ret]

*=============================================================================
* bmbr_boss_activate()
*  Description:
*   select bomber-boss object/index, select movement control vector
* IN:
*  B: 4,3,2,1 to select object/index of bomber
*  C: flags for escorts available (pass-thru)
*  D: pre-loaded with msb of pointer to objects array (for convenience as it was just used a few instructions ago)
*  E: object/index of bomber-boss candidate (from const array) if jp 1CA0 taken
*  IXL: 0 -> 2 escorts, 1 -> 1 escort (2 is for capture-boss so it doesn't apply)
* OUT:
*  ...
*-----------------------------------------------------------------------------
bmbr_boss_activate_1c8d:
* convert ordinal in B (i.e. 4,3,2,1) to object/index in home-position order (left to right)
* the ordinal (B) will be used later to index d_escort_ids[] which are ordered
* right->left, i.e. ordinal 4 indexes to an ID located leftmost and so on.
*  4 -> 4 -> 0 -> 0
*  3 -> 2 -> 2 -> 4
*  2 -> 3 -> 3 -> 6
*  1 -> 1 -> 1 -> 2
	lea	b_8800,a1			| reset MSB of DE
	move.b	d1,d0                           	| [ld   a,b]
	btst.b	#1,d0                           	| [bit  1,a]
	jeq	l_1C94                             	    | [jr   z,l_1C94]
	eor.b	#0x01,d0                         	| [xor  #0x01]
l_1C94:
	and.b	#0x03,d0                         	| [and  #0x03]
	asl.b	#1,d0                            	| [sla  a]
	add.b	#0x30,d0                         	| [add  a,#0x30] boss objects are 30 34 36 32
	moveq	#0,d4
	move.b	d0,d4                           	| [ld   e,a] object/index of bomber to _1CAE
	add.w	d4,a1
	move.b	(a1),d0                             | [ld   a,(de)] d == #>b_8800
	cmp.b	#0x01,d0                         	| [cp   #0x01] check for ready/available status
	beq.b	0f                               	| [...]
	rts                                    	| [ret  nz] [...]
0:
	move.l	(sp)+,a0                        	| [pop  hl] will return to task manager eventually

j_1CA0:
	COMPUTE_LSB_A1_D4	b_8800
	move.w	#db_flv_0411,d5                 	| [$1CA0: ld   iy,#db_flv_0411]
	move.b	ds_9200_glbls+0x0B,d0           	| [$1CA4: ld   a,(ds_9200_glbls + 0x0B)] enemy enable, select data ptr boss launch: if (0), iy=$00F1, else iy=$0411
	                               	            | [$1CA7: and  a]
	jne	j_1CAE                             	    | [$1CA8: jr   nz,l_1CAE]
	move.w	#db_flv_00f1,d5                 	| [$1CAA: ld   iy,#db_flv_00f1] training-mode


*-----------------------------------------------------------------------------
* setup bomber-boss, _boss_pool[0], bonus scoring, etc.
* if capture boss (jp $1CAE), parameters same as above except:
* IN:
*    b, c: not used when escort selection skipped (ixl == 2)
*    ixl:  2==solo/capture boss is valid and will skip escort selection ...
*            ... in addition to 0 -> 2 escorts, 1 -> 1 escort
*    d5.w (was iy): pointer on flv data (subcpu address)
*-----------------------------------------------------------------------------
j_1CAE:
	
* objects 32 & 36 are on right side (bit-1 set): set flag in bit-7 to indicate negative rotation
	move.b	d4,d0                           	| [$1CAE: ld   a,e] object/index of bomber
	ror.b	#2,d0                            	| [$1CAF: rrca] * 2
	SET_X_FROM_C
	move.b	d4,d0                           	| [$1CB1: ld   a,e]
	roxl.b	#1,d0                           	| [$1CB2: rla] Cy into bit-0
 	ror.b	#1,d0                            	| [$1CB3: rrca] flag in Cy and in bit-7
	scs	d7                              	    | [$1CB7: ex   af,af'] stash Cy for rotation flag
	move.b	d0,bmbr_boss_pool_92ca+0            | [$1CB4: ld   (bmbr_boss_pool_92ca + 0),a] object/index of bomber boss
	MOVE_TO_VAR	d5,bmbr_boss_pool_92ca+1		| [$1CB8: ld   (bmbr_boss_pool_92ca + 1),iy] flight vector of bomber boss
	
	addq.b	#1,d1                           	| [inc  b] `dec b` in c_1D03

* plyr_actv.bmbr_boss_scode[]
	move.b	d4,d0                           	| [ld   a,e] object/index of bomber
	and.b	#0x07,d0                         	| [and  #0x07]
	lea	ds_plyr_actv+_ds_bmbr_boss_scode,a0	    | [ld   hl,#ds_plyr_actv +_ds_bmbr_boss_scode]
	jbsr	add_d0_to_a0_0010                   | [rst  0x10] HL += A
* d_1CFD[ixl]
	jbsr	read_ixl_into_d0                    | [ld   a,ixl]
	exg	a1,a0                              	    | [ex   de,hl] stash hl (&plyr_actv.code)
	lea	d_1CFD,a0                      	        | [ld   hl,#d_1CFD]
	jbsr	add_2_times_d0_to_a0_0008           | [rst  0x08] HL += 2A
	move.b	(a0)+,(a1)+                         | [ld   a,(hl)]
	                         	                | [ld   (de),a] plyr_actv._bonus_codescore[E] = d_1CFD[2*A]
	                           	                | [inc  hl]
	addq.b	#1,d4              	                | [inc  e]  [a1 coherence] (not sure if required)
	move.b	(a0),(a1)                         	| [ld   a,(hl)]
	                         	                | [ld   (de),a]

* if (2 == ixl) then skip launching wingmen ... capture-boss situation
	jbsr	read_ixl_into_d0                         	| [ld   a,ixl]
	cmp.b	#2,d0                            	| [cp   #2]
	jeq	l_1CE3                             	| [jr   z,l_1CE3]

	lea	bmbr_boss_pool_92ca+1*3+0,a1        	| [ld   de,#bmbr_boss_pool_92ca + 1 * 3 + 0] 4 groups of 3 bytes
	
* if (1 == ixl) ... setup 1 escort, else setup 2 escorts
	
	subq.b	#1,d0                           	| [$1CDA: dec  a]
	jeq	l_1CE0                             		| [$1CDB: jr   z,l_1CE0]
	jbsr	c_1D03                            	| [$1CDD: call c_1D03] DE==&boss_pool[1] ... boss dives with wingman
l_1CE0:
	jbsr	c_1D03                            	| [$1CE0: call c_1D03] DE==&boss_pool[2] ... boss dives with wingman

* if rogue fighter for this boss !STAND_BY then return
l_1CE3:
	move.b	bmbr_boss_pool_92ca,d0         		| [ld   a,(bmbr_boss_pool_92ca + 0 * 3 + 0)] obj/index (setup from function arguments above)
	and.b	#0x07,d0                         	| [and  #0x07] object/index of captured fighter i.e. 00 04 06 02
	move.b	d0,d6                           	| [ld   l,a]
* check for 0
	lea	b_8800,a0                      	| [ld   h,#>b_8800]
	and.w	#0xFF,d6
	add.w	d6,a0
	move.b	(a0),d0                         	| [ld   a,(hl)]
	subq.b	#1,d0                           	| [dec  a]
	beq.b	0f                               	| [...]
	rts                                    	| [ret  nz] return to task manager [...]
0:

	move.b	d6,d2                           	| [ld   c,l] object/index of rogue-fighter e.g. $00, $02, $04, $06

* find available slot (don't know how many are occupied by wingmen?)
	lea	bmbr_boss_pool_92ca+0*3+0,a0        	| [ld   hl,#bmbr_boss_pool_92ca + 0 * 3 + 0] reset pointer, search for obj_idx==$FF
l_1CF2_while:
	addq.w	#3,a0                           	| [inc  l]
	move.b	(a0),d0                         	| [ld   a,(hl)]
	addq.b	#1,d0                           	| [inc  a]
	jne	l_1CF2_while                       	| [jr   nz,l_1CF2_while]

* setup A and Cy' parameters (HL, IY already loaded)
*  HL == &_boss_pool[n] ... n = { 3, 6, 9 }
*  IY == pointer to flight vector data
	move.b	d2,d0                           	| [ld   a,c] object/index of captured ship
	tst.b	d7                              	| [ex   af,af'] unstash rotation flag
	beq.b	0f
	SET_XC_FLAGS
	jra	l_1D16                             	| [jr   l_1D16] ... jp past setup section of function
0:
	CLEAR_XC_FLAGS
	jra	l_1D16                             	| [jr   l_1D16] ... jp past setup section of function

*=============================================================================
* data for bmbr_boss_activate_1c8d:
* ixl selects bonus-score to override in ds_plyr_actv._ds_array8[]
* .b0 ... add to bug_collsn[$0F] (adjusted scoring increment)
* .b1 -> obj_collsn_notif[L] ... sprite code + 0x80
d_1CFD:
	.byte 16 - 3, 0x80 + 0x3A  | 1600
	.byte  8 - 3, 0x80 + 0x37  | 800
	.byte  4 - 3, 0x80 + 0x35  | 400 (default)

*=============================================================================
* c_1D03()
*  Description:
*   bmbr_boss_escort_sel
*   ...boss takes a sortie with one or two wingmen attached.
* IN:
*  B
*  C: flags for escorts available
*  DE: &_boss_pool[n]
*  IY (D5): pointer to flight vector data
*  Cy': rotation flag, to be OR'd into pool_slot[n].idx<7>
* OUT:
*  B: index of next escort to be selected from const array
*  C: flags for escorts available
*-----------------------------------------------------------------------------
c_1D03:
	ror.b	#1,d2                            	| [$1D03: rrc  c]
	jcs	l_1D0D                             		| [$1D05: jr   c,l_1D0D]
	subq.b	#1,d1                           	| [$1D07: dec  b] after boss docked home with ship
	ror.b	#1,d2                            	| [$1D08: rrc  c]
	jcs	l_1D0D                             		| [$1D0A: jr   c,l_1D0D]
	subq.b	#1,d1                           	| [$1D0C: dec  b]
l_1D0D:
	move.b	d1,d0                           	| [$1D0D: ld   a,b]
	subq.b	#1,d1                           	| [$1D0E: dec  b]
	lea	d_1D2C_wingmen,a0              			| [$1D0F: ld   hl,#d_1D2C_wingmen]
	jbsr	add_d0_to_a0_0010                   | [$1D12: rst  0x10] HL += A

* setup parameters (IY, pointer to flight vector data, already loaded)
												| [$1D13: ex   af,af'] unstash rotation flag
	move.b	(a0),d0                         	| [$1D14: ld   a,(hl)] d_escorts[a] ... object/index
	exg	a1,a0                              		| [$1D15: ex   de,hl] &boss_wing_slots[n] to HL
	tst.b	d7                              	| [ex   af,af'] unstash rotation flag
	beq.b	0f
	SET_XC_FLAGS
	jra	l_1D16                             		| [jr   l_1D16] ... jp past setup section of function
0:
	CLEAR_XC_FLAGS

*=============================================================================
* skipping the setup section (rogue fighter)
* IN:
*  A  - object/index of red bomber wingman, captured ship etc.
*  HL - index to bmbr_boss_pool_92ca[]
*  IY - pointer to flight vector data
*  Cy - rotation flag
* OUT:
*  DE: &_boss_pool[n] ... pointer advanced in case of second call
*-----------------------------------------------------------------------------
l_1D16:
* load boss_wing_slots[n + 0], rotation flag from Cy to bit-7 of object/index
	roxl.b	#1,d0                           	| [rla] object/index
	ror.b	#1,d0                            	| [rrca] rotate out of a<0> thru Cy into a<7>
* re-stash Cy (rotation flag)
	scs	d7                              		| [ex   af,af']
	move.b	d0,(a0)+                         	| [ld   (hl),a] &boss_wing_slots[n + 0]

	* store sub-cpu ROM address that is in D5.W
	move.w	d5,-(a7)
	LOAD_D5D6_FROM_D5_16
												| [inc  l]
												| [ld   a,iyl]
	move.b	d6,(a0)+                         	| [ld   (hl),a]
												| [inc  l]
												| [ld   a,iyh]
	move.b	d5,(a0)+                         	| [ld   (hl),a]
												| [inc  l]
	move.w	(a7)+,d5							| we still need D5.W, c_1D03 can be called twice in a row
	exg	a1,a0                              		| [ex   de,hl] &boss_wing_slots[n] ... update pointer in DE for second subroutine call
	rts                                    		| [ret]

*=============================================================================
* Movement of captured rogue ship... out of section at l_1C83
*-----------------------------------------------------------------------------
l_1D25:
	move.w	#db_flv_rogefgter_0444,d3           	| [ld   de,#db_fltv_rogefgter]
	jbsr	c_diving_movement_1083                  | [call c_diving_movement_1083] rogue fighter
	rts                                    	        | [ret]

*=============================================================================
* 6 escort aliens (right to left under the 4 bosses )
d_1D2C_wingmen:
	.byte 0x4A,0x52,0x5A,0x58,0x50,0x48

*=============================================================================
* f_move_swarm_when_player_changes_1d32()
*  Description:
*   Moves bug nest on and off the screen at player changeover.
* IN:
*  ...
* OUT:
*  ...
*-----------------------------------------------------------------------------
f_move_swarm_when_player_changes_1d32:
	lea	b8_99B4_bugnest_onoff_scrn_tmr,a0	| [ld   hl,#b8_99B4_bugnest_onoff_scrn_tmr] increment timer
	move.b	(a0),d0                         	| [ld   a,(hl)]
	and.b	#0x7F,d0                         	| [and  #0x7F]
	sub.b	#0x7E,d0                         	| [sub  #0x7E] 126 (frames?)
	jeq	l_1D72                             	| [jr   z,l_1D72] A==0 ...

	move.b	(a0),d2                         	| [ld   c,(hl)]
	addq.b	#1,(a0)                         	| [inc  (hl)] update timer

	move.b	b_9215_flip_screen,d0           	| [ld   a,(b_9215_flip_screen)]

* rotate _scrn_tmr<7> into Cy for testing
	rol.b	#1,d2                            	| [rlc  c]
	eor.b	d2,d0                            	| [xor  c]
	ror.b	#1,d0                            	| [rrca]

	jcs	l_1D4B                             	    | [jr   c,l_1D4B]
	move.b	#-1,d0                           	| [ld   a,#1] offset is +1
	                               	            | [neg] offset is -1
	jra		0f
l_1D4B:
	move.b	#1,d0                           	| [ld   a,#1] offset is +1
0:
	move.b	d0,d2                           	| [ld   c,a]
	lea	ds_hpos_spcoords_9800+(10*2),a0      	| [ld   hl,#ds_hpos_spcoords_9800 + (10 * 2)] + byte offset to row coordinates

	move.b	#6,d1                           	| [ld   b,#6] 6 row coordinates to update
l_1D51:
	move.b	(a0),d0                         	| [ld   a,(hl)]
	add.b	d2,d0                            	| [add  a,c] + or - 1
	move.b	d0,(a0)+                         	| [ld   (hl),a] _sprite_coords[ n ] ... LSB
	roxr.b	#1,d0                           	| [rra]
	eor.b	d2,d0                            	| [xor  c]
	                           	                | [inc  l]
	rol.b	#1,d0                            	| [rlca]
	jcc	l_1D5E                             	    | [jr   nc,l_1D5E]
	move.b	(a0),d0                         	| [ld   a,(hl)]
	eor.b	#0x01,d0                         	| [xor  #0x01]
	move.b	d0,(a0)                         	| [ld   (hl),a] add carry (if any) into MSB
l_1D5E:
	addq.w	#1,a0                           	| [inc  l]
	subq.b	#1,d1                           	| [...]
	jne	l_1D51                             	| [djnz l_1D51]

* call MOB manager to get everything updated (each call updates half the mob)
* The call expects the frame count in A, but here it is overkill because the
* subroutine is only using bits 0-3 ("A % 4") and updates half of the objects
* on each odd count.
	move.b	ds3_frame_cts_92A0+0,d0         	| [ld   a,(ds3_frame_cts_92A0 + 0)]
	and.b	#0xFC,d0                         	| [and  #0xFC] force A%4 == 0
	addq.b	#1,d0                           	| [inc  a] force A%4 == 1
	move.w	d0,-(sp)                        	| [push af]
	jbsr	f_update_objects_23e0                            	| [call f_update_objects_23e0]
	move.w	(sp)+,d0                        	| [pop  af]
	addq.b	#2,d0                           	| [add  a,#2] force A%4 = 3
	jbsr	f_update_objects_23e0                            	| [call f_update_objects_23e0]

	rts                                    	| [ret]

l_1D72:
	move.b	d0,ds_cpu0_task_actv_9000+0x0E       	| [ld   (ds_cpu0_task_actv_9000 + 0x0E),a] f_move_swarm_when_player_changes_1d32
	rts                                    	| [ret]

*=============================================================================
* f_star_control_1d76()
*  Description:
*   handles changes in star control status?
* IN:
*  ...
* OUT:
*  ...
*-----------------------------------------------------------------------------
f_star_control_1d76:
	move.b	b_9215_flip_screen,d0           	| [ld   a,(b_9215_flip_screen)]
	move.b	d0,d1                           	| [ld   b,a]
	lea	ds_99B9_star_ctrl+0x00,a0      	| [ld   hl,#ds_99B9_star_ctrl + 0x00] 1 when ship on screen
	move.b	(a0)+,d0                         	| [ld   a,(hl)]
	                           	| [inc  l]
	tst.b	d0                               	| [and  a]
	jeq	l_1DA8                             	| [jr   z,l_1DA8]

	                               	| [and  a]
	move.b	#0xFD,d0                        	| [ld   a,#0xFD]
	tst.b	(a0)                         	| [ld   a,(hl)] 99BA
	jne	l_1D9B                             	| [jr   nz,l_1D9B] if ( *(99BA) != 0 )
	addq.w	#1,a0                           	| [inc  l]
	move.b	(a0)+,d0                         	| [ld   a,(hl)] 99BB
	                           	| [inc  l]
	cmp.b	(a0),d0                          	| [cp   (hl)] 99BC
	jeq	l_1D8F                             	| [jr   z,l_1D8F]
	addq.b	#1,(a0)                         	| [inc  (hl)]
l_1D8F:
	move.b	(a0)+,d0                         	| [ld   a,(hl)]
	                           	| [inc  l]
	add.b	(a0),d0                          	| [add  a,(hl)] 99BD
	move.b	d0,d2                           	| [ld   c,a]
	and.b	#0x3F,d0                         	| [and  #0x3F]
	move.b	d0,(a0)                         	| [ld   (hl),a]
	move.b	d2,d0                           	| [ld   a,c]
	rol.b	#2,d0                            	| [rlca] * 2
	and.b	#0x03,d0                         	| [and  #0x03]
l_1D9B:
	btst.b	#0,d1                           	| [bit  0,b] 9215_flip_screen
	jne	l_1DA1                             	| [jr   nz,l_1DA1]
	neg.b	d0                               	| [neg] twos complement
l_1DA1:
	subq.b	#1,d0                           	| [dec  a]
	and.b	#0x07,d0                         	| [and  #0x07]
l_1DA4:
	move.b	d0,ds_99B9_star_ctrl+0x05       	| [ld   (ds_99B9_star_ctrl + 0x05),a]
	rts                                    	| [ret]

l_1DA8:
	clr.b	d0                               	| [xor  a]
	move.b	d0,(a0)                         	| [ld   (hl),a] 0 ... 99BA?
	addq.w	#2,a0                           	| [inc  l]
 	move.b	d0,(a0)+                         	| [ld   (hl),a] 0 ... 99BC?
	                           	| [inc  l]
	move.b	d0,(a0)                         	| [ld   (hl),a] 0 ... 99BD?
	move.b	#7,d0                           	| [ld   a,#7] stops stars
	jra	l_1DA4                             	| [jr   l_1DA4] set star ctrl state

*=============================================================================
* f_update_enemy_status_1db3() ... 0x0B
*  Description:
*   Update enemy status.
*
*   only disabled when default task config is
*   re-loaded from ROM (c_init_taskman_structs_1230) just prior to the Top5
*   screen shown in attract-mode.
*
*   memory structure of enemy army:
*
*                         00 04 06 02            | captured ships
*                         30 34 36 32
*                   40 48 50 58 5A 52 4A 42
*                   44 4C 54 5C 5E 56 4E 46
*                08 10 18 20 28 2A 22 1A 12 0A
*                0C 14 1C 24 2C 2E 26 1E 16 0E
*
* IN:
*   obj_collsn_notif[L] set by cpu1:_rocket_hit_detection to $81.
*   detect and reset bit-7. $01 remains
*
* OUT:
* _obj_status.b0: "activity" byte (see d_23FF_jp_tbl for codes)
* _obj_status.b1: ($40...$45 if exploding)
*
*  mrw_sprite.cclr[ L ].color set to $0A for explosion
*  obj_collsn_notif[L]  == $01
*
*-----------------------------------------------------------------------------
f_update_enemy_status_1db3:
	lea	b_obj_collsn_notif_9200,a0     			| [ld   hl,#b_obj_collsn_notif_9200] $30 bytes ... test bit-7
	move.b	#0x30,d1                        	| [ld   b,#0x30]
l_1DB8:
	btst.b	#7,(a0)                         	| [bit  7,(hl)] bit-7 set ($81) by cpu1 (l_07DB) if the orc has been hit
	jne	l_1DC1_make_him_dead               		| [jr   nz,l_1DC1_make_him_dead]
	addq.w	#1,a0                           	| [inc  l]
l_1DBD:
	addq.w	#1,a0                           	| [inc  l]
	subq.b	#1,d1                           	| [...]
	jne	l_1DB8                             	| [djnz l_1DB8]

	rts                                    	| [ret]

l_1DC1_make_him_dead:
	bclr.b	#7,(a0)                         	| [$1DC1: res  7,(hl)] b_obj_collsn_notif_9200[n] for rckt_hit_hdlr
	
	* compute relative offset/index to apply to 88xx
	COMPUTE_LSB_A0_D6	b_obj_collsn_notif_9200
	lea	b_8800,a0                      	        | [$1DC3: ld   h,#>b_8800] disposition = 4 (dying/exploding)
	add.w	d6,a0
	move.b	#4,(a0)+                         	| [$1DC5: ld   (hl),#4]
	addq	#1,d6		                        | d6 offset follows for later
* use obj_status[].mctl_q_index for explosion counter (que object should already have been released at l_081E_hdl_flyng_bug
	                           	                | [$1DC7: inc  l]
	move.b	#0x40,(a0)                      	| [$1DC8: ld   (hl),#0x40] start value for the explosion (40...45)
	
	lea	ds_sprite_code_8B00,a0              	| [$1DCA: ld   h,#>ds_sprite_code_8B00]
	add.w	d6,a0			                    | apply offset to sprite code too
	move.b	#0x0A,(a0)                      	| [$1DCC: ld   (hl),#0x0A] update color for inactive/dead sprite
	lea	b_obj_collsn_notif_9200,a0     	        | [$1DCE: ld   h,#>b_obj_collsn_notif_9200] reload ptr
	add.w	d6,a0			                    | and there too
	jra	l_1DBD                             	    | [$1DD0: jr   l_1DBD]
* end 1DB3

*=============================================================================
* f_update_timers_1dd2()
*  Description:
*   Updates array of 4 timers at 2Hz rate.
* IN:
*  ...
* OUT:
*  ...
*-----------------------------------------------------------------------------
f_update_timers_1dd2:
*  if ( frame_cts[2] & 0x01 ) return ... divides the 4 Hz timer by 2 ... why not just use frame_cts[1]
	move.b	ds3_frame_cts_92A0+2,d0         	| [$1DD2: ld   a,(ds3_frame_cts_92A0 + 2)] [2]: 4 Hz timer
	and.b	#0x01,d0                         	| [$1DD5: and  #0x01]
	beq.b	0f                               	| [...]
	rts                                    		| [$1DD7: ret  nz] [...]
0:

	lea	ds4_game_tmrs_92ac,a0             	| [$1DD8: ld   hl,#ds4_game_tmrs_92ac + 0] decrement each of the 4 game timers
	move.b	#4,d1                           | [$1DDB: ld   b,#4]
*  for ( b = 0 | b < 4 | b++ ) {
*    if ( game_tmrs[b] > 0 )   game_tmrs[b]--
l_1DDD:
	move.b	(a0),d0                         	| [$1DDD: ld   a,(hl)]
												| [$1DDE: and  a]
	jeq	l_1DE2                             		| [$1DDF: jr   z,l_1DE2]
	subq.b	#1,(a0)                         	| [$1DE1: dec  (hl)]
l_1DE2:
	addq.w	#1,a0                           	| [$1DE2: inc  l]
	subq.b	#1,d1                           	| [...]
	jne	l_1DDD                             		| [$1DE3: djnz l_1DDD]
*  }
	rts                                    	| [ret]

*=============================================================================
* f_pulsating_swarm_movement_1de6()
*  Description:
*   Provides pulsating movement of the collective.
*   Enabled by f_lateral_movement_at_round_start_2a90 once the initial formation waves have completed.
* IN:
*  ...
* OUT:
*  ...
*-----------------------------------------------------------------------------
f_pulsating_swarm_movement_1de6:
*  if ( frame_count % 4 != 0 ) return
	move.b	ds3_frame_cts_92A0+0,d0         	| [ld  a,(ds3_frame_cts_92A0 + 0)] frame_ct%4 ... ... (provides 15Hz timer)
	and.b	#0x03,d0                         	| [and  #0x03]
	beq.b	0f                               	| [...]
	rts                                    	    | [ret  nz] [...]
0:

	lea	ds_9200_glbls+0x0F,a0          	        | [ld   hl,#ds_9200_glbls + 0x0F] nest_direction counter for expand/contract motion.
	move.b	(a0),d0                         	| [ld   a,(hl)]
	move.b	d0,d4                           	| [ld   e,a] PREVIOUS_nest_direction counter

	move.b	#-1,d3                          	| [ld   d,#-1]
	btst.b	#7,d0                           	| [bit  7,a]
	jne	l_1DFC_contracting                 	    | [jr   nz,l_1DFC_contracting]
* expanding
	addq.b	#2,d3                           	| [inc  d] * 2
	addq.b	#1,(a0)                         	| [inc  (hl)] nest_direction = 1
	jra	l_1DFD                             	    | [jr   l_1DFD]
l_1DFC_contracting:
	subq.b	#1,(a0)                         	| [dec  (hl)] nest_direction = -1

l_1DFD:
	cmp.b	#0x1F,d0                         	| [cp   #0x1F] counting up from $00 to $1F
	jne	l_1E03                             	    | [jr   nz,l_1E03]
	bset.b	#7,(a0)                         	| [set  7,(hl)] count|= $80 ... = $A0
l_1E03:
	cmp.b	#0x81,d0                         	| [cp   #0x81] counting down from $A0 to $81 (-$60 to -$7F)
	jne	l_1E09                             	    | [jr   nz,l_1E09]
	bclr.b	#7,(a0)                         	| [res  7,(hl)] count &= ~$80 ... = $00

* Now we have updated the counter, and have D==1 if expanding, D==-1 if contracting.
* Every 8*4 (32) frames, we change the bitmap which determines the positions that are
* updated. This happens to correspond with the "flapping" animation... ~1/2 second per flap.
l_1E09:
	move.b	(a0),d2                         	| [ld   c,(hl)] grab nest_direction while we still have the pointer
	and.b	#0x07,d0                         	| [and  #0x07] previous_cntr % 8
	sne		d7
	move.b	d3,d0                           	| [ld   a,d] direction counter increment (+1 or -1)
	move.b	d0,ds_9200_glbls+0x11           	| [ld   (ds_9200_glbls + 0x11),a] formatn_mv_signage, cpu2 cp with b_9A80 + 0x00

	move.b	d4,d0                           	| [ld   a,e] reload previous_nest_direction counter
	tst.b	d7
* if ( previous_counter % 8 == 0 ) then update_bitmap i.e. even multiple of 8
	jne	l_1E23                             	| [jr   nz,l_1E23]

	lea	d_1E64_bitmap_tables,a0        	| [ld   hl,#d_1E64_bitmap_tables]

* count * 2 i.e. count / 8 * 16 ... index into table row
	move.b	d2,d0                           	| [ld   a,c] A = updated_counter
	and.b	#0x18,d0                         	| [and  #0x18] make it even multiple of 8
	jbsr	add_2_times_d0_to_a0_0008              	| [rst  0x08] HL += 2A   .... table entries are $10 bytes long
	move.b	d4,d0                           	| [ld   a,e] reload previous_nest_direction counter
	lea	ds10_9920,a1                   	        | [ld   de,#ds10_9920] $10 bytes copied from 1E64+2*A
	move.w	#0x10,d1                        	| [ld   bc,#0x0010] 16
	jbsr	ldir                              	| [ldir]

l_1E23:   | 1E29 in galagao
* A ^= (HL) ... set Cy determines which parameter is taken. Bit-7 XOR'd with
* flip_screen-bit... done efficiently by rotating bit-7 into bit-0 and back.
	lea	b_9215_flip_screen,a0          	        | [ld   hl,#b_9215_flip_screen]
	rol.b	#1,d0                            	| [rlca] A == previous_counter
	move.b	(a0),d7
	eor.b	d7,d0                            	| [xor  (hl)]
	ror.b	#1,d0                            	| [rrca] Cy now indicates state of bit-7

* Setup parameters for first function call. The first call does just the
* left-most 5 columns. The second call does the rightmost 5 columns and the
* 6 row coordinates, which incidentally will have the same sign! So we stash
* the parameter for the second call in C, at the same time that B is set.

	lea	ds10_9920,a0                   	        | [ld   hl,#ds10_9920] 16 bytes copied from _bitmap_tables+2*A
	lea	ds_hpos_loc_offs_9900,a1            	| [ld   de,#ds_hpos_loc_offs_9900] hl==ds10_9920
	jcc	l_1E36                             	    | [jr   nc,l_1E36]
	move.b	#0x01,d1                        	| [ld   bc,#0x01FF] B==1, C==-1 (contracting group, non-inverted) 511
	move.b	#0xff,d2                        	| [ld   bc,#0x01FF] B==1, C==-1 (contracting group, non-inverted) 511
	jra	l_1E39                             	    | [jr   l_1E39]
l_1E36:
	move.b	#0xff,d1                        	| [ld   bc,#0xFF01] B==-1, C==1 (expanding group, non-inverted) 65281
	move.b	#0x01,d2                        	| [ld   bc,#0xFF01] B==-1, C==1 (expanding group, non-inverted) 65281
l_1E39:
	move.b	#5,ixl								| [ld   ixl,#5]                                | 5 leftmost columns
	jbsr	c_1E43                            	| [call c_1E43]

* setup parameters for second function call
	move.b	d2,d1                           	| [ld   b,c] load second parameter
	move.b	#0xb,ixl			                | [ld   ixl,0x0b]                              | 5 right columns + 6 rows

       * 1E43()

*=============================================================================
* c_1E43()
*  Description:
*   Compute row/col coordinates of formation in expand/contract movement.
*   The selected bitmap table determines whether any given coordinate
*   dimension is incremented at this update.
* IN:
*    HL == saved pointer into working copy of selected bitmap table ($10 bytes)
*    DE == saved pointer into home_posn_loc[]
*        ... object positioning (even: relative offsets .... odd: defaults/origin)
*    B == +/- 1 increment.
*    IXL == 5  (repeat count for 5 leftmost columns)
*    IXL == 11 (repeat count, for 5 rightmost columns + 6 rows which have the same sign)
* OUT:
*  ...
*-----------------------------------------------------------------------------
c_1E43:
j_1E43:   | aka 1E49
* check if updating this one
	move.b	(a0),d0
	ror.b	#1,d0                          	    | [rrc  (hl)]
	scs		d7
	move.b	d0,(a0)
	tst.b	d7
	jeq	l_1E5C_update_ptrs                 	    | [jr   nc,l_1E5C_update_ptrs]

* obj_pos_rel[ n ] += B
	move.b	(a1),d0                         	| [ld   a,(de)] even-bytes: relative offset
	add.b	d1,d0                            	| [add  a,b] +/- 1
	move.b	d0,(a1)                         	| [ld   (de),a]

* _home_posn_org[ n ] += B ... 10 column coordinates, 6 row coordinates, 16-bits per coordinate
	COMPUTE_LSB_A1_D4	ds_hpos_loc_offs_9900
	
	lea	ds_hpos_spcoords_9800,a1            	| [ld   d,#>ds_hpos_spcoords_9800]
	add.w	d4,a1
	move.b	(a1),d0                         	| [ld   a,(de)]
	add.b	d1,d0                            	| [add  a,b] +/- 1
	move.b	d0,(a1)                         	| [ld   (de),a]

* check for carry
	roxr.b	#1,d0                           	| [rra]
 	eor.b	d1,d0                            	| [xor  b]
	rol.b	#1,d0                            	| [rlca]
	jcc	l_1E5A                             	    | [jr   nc,l_1E5A]
* handle carry
	addq.w	#1,a1                           	| [inc  e]
	move.b	(a1),d0                         	| [ld   a,(de)] MSB
	eor.b	#0x01,d0                         	| [xor  #0x01]
	move.b	d0,(a1)                         	| [ld   (de),a]
	subq.w	#1,a1                           	| [dec  e] LSB again
 
l_1E5A:
	COMPUTE_LSB_A1_D4	ds_hpos_spcoords_9800
	lea	ds_hpos_loc_offs_9900,a1            	| [ld   d,#>ds_hpos_loc_offs_9900] reset pointer
	add.w	d4,a1

l_1E5C_update_ptrs:
	addq.w	#2,a1                           	| [inc  e]
 	addq.w	#1,a0                           	| [inc  l]
 	subq.b	#1,ixl                          	| [dec  ixl]
	jne	j_1E43                             	    | [jr   nz,j_1E43]
	rts                                    	    | [ret]

*=============================================================================
* d_1E64_bitmap_tables
*  Description:
*   bitmaps determine at which intervals the corresponding coordinate will
*   be incremented... allows outmost and lowest coordinates to expand faster.
*
*                                       	|<-------------- COLUMNS --------------------->|<---------- ROWS ---------->|
*
*-----------------------------------------------------------------------------
d_1E64_bitmap_tables:

	.byte 0xFF,0x77,0x55,0x14,0x10,0x10,0x14,0x55,0x77,0xFF,0x00,0x10,0x14,0x55,0x77,0xFF
	.byte 0xFF,0x77,0x55,0x51,0x10,0x10,0x51,0x55,0x77,0xFF,0x00,0x10,0x51,0x55,0x77,0xFF
	.byte 0xFF,0x77,0x57,0x15,0x10,0x10,0x15,0x57,0x77,0xFF,0x00,0x10,0x15,0x57,0x77,0xFF
	.byte 0xFF,0xF7,0xD5,0x91,0x10,0x10,0x91,0xD5,0xF7,0xFF,0x00,0x10,0x91,0xD5,0xF7,0xFF

*=============================================================================
* f_bomb_position_updater_1ea4()
*  Description:
*    Bomb position updater... this task is not disabled.
* IN:
*  ...
* OUT:
*  ...
*-----------------------------------------------------------------------------
f_bomb_position_updater_1ea4:
* Determine y-increment: each frame alternates 2 or 3 pixels-per-frame
* increment to provide the average Y velocity, and negated for inverted screen.
	move.b	ds3_frame_cts_92A0+0,d0         	| [$1EA4: ld   a,(ds3_frame_cts_92A0 + 0)]
	and.b	#0x01,d0                         	| [$1EA7: and  #0x01]
	addq.b	#2,d0                           	| [$1EA9: add  a,#2]
	move.b	d0,d1                           	| [$1EAB: ld   b,a]
	                               	            | [$1EAC: and  a]
	move.b	d1,d0                           	| [$1EAF: ld   a,b]
	tst.b	b_9215_flip_screen           	    | [$1EB0: ld   a,(b_9215_flip_screen)]
	jeq	l_1EB5                             	    | [$1EB1: jr   z,l_1EB5]
	neg.b	d0                               	| [$1EB3: neg]

l_1EB5:
	move.b	d0,ixh			                    | [ld   ixh,a]
	move.b	#0x68,d6                        	| [ld   l,#0x68] offset into object group for missiles
	lea	b_92B0,a1                 	            | [ld   de,#b_92B0 + 0x00] bomb h-rate array ( 8 * 2 )
	move.b	#8,ixl			                    | [ld   ixl,0x08]

l_1EBF_while:
* if sprite[bomb + n].code == $30 ...
	lea	ds_sprite_code_8B00,a0              	| [$1EBF: ld   h,#>ds_sprite_code_8B00]
	and.w	#0xFF,d6
	add.w	d6,a0
	move.b	(a0),d0                         	| [$1EC1: ld   a,(hl)]
	cmp.b	#0x30,d0                         	| [$1EC2: cp   #0x30] bomb sprite codes don't show up until some new-game inits are done
	jne	l_1EFF                             	    | [$1EC4: jr   nz,l_1EFF]
* ... sprite[bomb + n].posn.x != 0
	lea	ds_sprite_posn_9300,a0              	| [$1EC6: ld   h,#>ds_sprite_posn_9300]
	and.w	#0xFF,d6
	add.w	d6,a0
	move.b	(a0),d0                         	| [$1EC8: ld   a,(hl)]
	                               	            | [$1EC9: and  a]
	jeq	l_1EFF                             	    | [$1ECA: jr   z,l_1EFF]

* Fun fixed point math: X rate in 92B0[ even ] has a scale factor of
* 32-counts -> 1 pixel-per-frame. Each frame, the (unchanging) dividend
* is loaded from 92B0, the previous MOD32 is added, the new MOD32 is stashed
* in 92B1, and the quotient becomes the new X-offset. Eventually those
* remainders add up to another whole divisor which will add an extra pixel
* to the offset every nth frame. Easy peasy!
* BTW there really is odd values in 92B0, but we just seem to not care about it i.e. mask 7E.

	exg	a1,a0                              	    | [ex   de,hl] stash &sprite_posn[n].b0 in DE
	move.b	(a0)+,d1                         	| [ld   b,(hl)] bomb_rate[n].b0
	move.b	d1,d0                           	| [ld   a,b]
	and.b	#0x7E,d0                         	| [and  #0x7E] Bit-7 for negative ... and we don't want the 1 ???
	                                        	| [inc  l]
	add.b	(a0),d0                          	| [add  a,(hl)]
	move.b	d0,d2                           	| [ld   c,a] C = A = A + 92B0[odd] ... accumulated division remainder
	and.b	#0x1F,d0                         	| [and  #0x1F] MOD 32
	move.b	d0,(a0)+                         	| [ld   (hl),a] bomb_rate[n].b1
	                                        	| [inc  l]
* a >>= 5 (divide-by-32)
	move.b	d2,d0                           	| [ld   a,c]
	rol.b	#3,d0                            	| [rlca] * 3
	and.b	#0x07,d0                         	| [and  #0x07]

* use negative offset of X coordinate if bomb path is to the left
	btst.b	#7,d1                           	| [bit  7,b]
	jeq	l_1EE4                             	| [jr   z,l_1EE4]
	neg.b	d0                               	| [neg]

l_1EE4:
	exg	a1,a0                              	| [ex   de,hl] &sprite_posn[n].b0 from DE
* update X
	add.b	(a0),d0                          	| [add  a,(hl)]
	move.b	d0,(a0)+                         	| [ld   (hl),a] 9868[ even ] += A

* update Y, and handle Cy for value > $ff
	                                        	| [inc  l]
 	move.b	(a0),d0                         	| [ld   a,(hl)]
	add.b	ixh,d0                           	| [add  a,ixh]
	move.b	d0,(a0)                         	| [ld   (hl),a] sprite[n].y<7:0> += ixh

	roxr.b	#1,d0                           	| [rra] shifts CY into bit-7 on overflow from addition
	move.b	ixh,d7
	eor.b	d7,d0                            	| [xor  ixh]
	COMPUTE_LSB_A0_D6	ds_sprite_posn_9300
	rol.b	#1,d0                            	| [rlca] Cy xor'd with ixh<7> ... to Cy
	jcc	l_1EF9                             	    | [jr   nc,l_1EF9]

* update "bit-8" of Y coordinate ... should only overflow the Y coordinate once.
	lea	ds_sprite_ctrl_9B00,a0              	| [ld   h,#>ds_sprite_ctrl_9B00] sY<8>
	and.w	#0xFF,d6
	add.w	d6,a0
	move.b	(a0),d7
	ror.b	#1,d7                          	    | [rrc  (hl)] sY<8> into Cy
	INVERT_XC_FLAGS                        	    | [ccf]
	roxl.b	#1,d7                         	    | [rl   (hl)] sY<8>
	move.b	d7,(a0)
l_1EF9:
	*addq.w	#1,a0                           	| [inc  l]
	addq.w	#1,d6                           	| [inc  l]  [a0 coherence]

	subq.b	#1,ixl                          	| [dec  ixl]
	jne	l_1EBF_while                       	    | [jr   nz,l_1EBF_while]
	rts                                    	    | [ret]

l_1EFF:
	*addq.w	#1,a0                           	| [inc  l]
	addq.w	#1,d6                           	| [inc  l] [a0 coherence]
	addq.w	#2,a1                           	| [inc  e] * 2
	jra	l_1EF9                             	    | [jr   l_1EF9]

*=============================================================================
* f_read_fire_button_1f04()
*  Description:
*   Read fire button input.
*   The IO port is determined according to whether or not the screen is flipped.
*   The button state is read from bit-4. Based on observation in the MAME
*   debugger, it appears that the IO control chip initially places the value
*   $1F on the port (bit-5 pulled low), and then some time following that bit-4
*   is pulled low ($0F). Presumably this is provide a debounce feature. If
*   there is no activity on either the button or the left-right control, then
*   the value read from the port is $3F.
* IN:
*  ...
* OUT:
*  ...
*-----------------------------------------------------------------------------
f_read_fire_button_1f04:
* select the input port depending upon whether screen is flipped (cocktail mode!)
	*move.b	b_9215_flip_screen,d0           	| [ld   a,(b_9215_flip_screen)]
	*add.b	ds3_io_input_99b5+0x01,d0       	| [add  a,#<ds3_io_input_99b5 + 0x01] add lsb
	*move.b	d0,d6                           	| [ld   l,a]
	lea	ds3_io_input_99b5+1,a0      			| [ld   h,#>ds3_io_input_99b5 + 0x00] msb
	btst.b	#4,(a0)                         	| [bit  4,(hl)] test fire bit
	beq.b	0f                               	| [...]
	rts                                    	    | [ret  nz] active low input [...]
0:
* else
* call c_init_rocket_sprites_1F0F

*=============================================================================
* c_init_rocket_sprites_1F0F()
*  Description:
*   Intialize sprite objects for rockets.
*   rocket sprite.cclr[n].b0 is initialized by c_game_or_demo_init
*   Updates game shots fired count.
* IN:
*  ...
* OUT:
*  ...
*-----------------------------------------------------------------------------
c_init_rocket_sprites_1F0F:
* if ( 0 != sprite[ RCKT0 ].sX ) ...
	lea	ds_sprite_posn_9300+0x64,a0         	| [$1F0F: ld   hl,#ds_sprite_posn_9300 + 0x64] ROCKET_0
	lea	b_92A0+0x04,a1                 			| [$1F12: ld   de,#b_92A0 + 0x04] rockt_attribute[0]
	move.w	#0xA4,d4
	clr.b	d0                               	| [$1F15: xor  a]
	tst.b	(a0)                          		| [$1F16: cp   (hl)] if (0)
	jeq	shot_slot_free_1f1e  		       		| [$1F17: jr   z,shot_slot_free_1f1e]

* ... then ... if ( 0 != sprite[ RCKT1 ].sX )  return
	lea		ds_sprite_posn_9300+0x66,a0        	| [$1F19: ld   l,#<ds_sprite_posn_9300 + 0x66] ROCKET_1
	addq.w	#1,a1                           	| [$1F1B: inc  e] rockt_attribute[1]
	addq.w	#1,d4                           	| [$1F1B: inc  e] [a1 coherence]
	tst.b	(a0)                          		| [$1F1C: cp   (hl)] if (0 != sprite[RCKT1].sX)  ret
	beq.b	0f                               	| [...]
	rts                                    		| [$1F1D: ret  nz] [...]
0:

shot_slot_free_1f1e:
* save pointer to attribute, and stash 'offsetof( RCKT_X )' in E
	movem.w	d3/d4,-(sp)                    		| [$1F1E: push de] &rockt_attribute[n].posn.b0
	move.l	a1,-(sp)                        	| [$1F1E: push de] &rockt_attribute[n].posn.b0
	COMPUTE_LSB_A0_D6	ds_sprite_posn_9300
	exg	d6,d4                              		| [$1F1F: ex   de,hl]
	lea	ds_sprite_ctrl_9B00+0x62+1,a0       	| [$1F20: ld   hl,#ds_sprite_ctrl_9B00 + 0x62 + 1] sprite.ctrl[FIGHTR].b1
	lea	ds_sprite_ctrl_9B00,a1              	| [$1F23: ld   d,h]
	addq.b	#1,d4                           	| [$1F24: inc  e] sprite[RCKT_X].ctrl.b1 [a1 coherence]
    add.w	d4,a1	
	btst.b	#2,(a0)                         	| [$1F25: bit  2,(hl)] sprite.ctrl[FIGHTR].b1<2> ... ?
	jeq	l_1F2B                             		| [$1F27: jr   z,l_1F2B]
	move.l	(sp)+,a1                        	| [$1F29: pop  de]
	movem.w	(sp)+,d3/d4                    		| [$1F29: pop  de]
	rts                                    		| [$1F2A: ret]


l_1F2B:

* sprite.ctrl[RCKT+n].b1 = sprite.ctrl[SHIP].b1 ... ship.sY, bit-8
	jbsr	ldd                               	| [$1F2B: ldd] e.g. *(9B65--) = *(9B63--)
	subq.b	#1,d4								| [a1 coherence]
	COMPUTE_LSB_A0_D6	ds_sprite_ctrl_9B00
	lea	ds_sprite_posn_9300,a0              	| [$1F2D: ld   h,#>ds_sprite_posn_9300]
	add.w	d6,a0
	lea	ds_sprite_posn_9300,a1                  | [$1F2F: ld   d,h] stash it
	add.w	d4,a1
* sprite.posn[RCKT+n].b0 = sprite.posn[SPR_IDX_SHIP].b0  ... ship.sX
	jbsr	ldi                               	| [$1F30: ldi] e.g. *(9B64++) = *(9B62++)
* sprite.posn[RCKT+n].b1 = sprite.posn[SPR_IDX_SHIP].b1  ... ship.sY, bit 0-7
	jbsr	ldd                               	| [$1F32: ldd] e.g. *(9B65--) = *(9B63--)
	* after both ldi/ldd calls a1/d4/a0/d6 are as before calls

* B = sprite.ctrl[SHIP].b0
	lea	ds_sprite_ctrl_9B00,a0              	| [$1F34: ld   h,#>ds_sprite_ctrl_9B00]
	and.w	#0xFF,d6
	add.w	d6,a0
	lea	ds_sprite_ctrl_9B00,a1                  | [$1F36: ld   d,h]
	add.w	d4,a1
	move.b	(a0),d1                         	| [$1F37: ld   b,(hl)] sprite.ctrl[FGHTR].b0: normally 0 (not doubled or flipped)
                                                  * stash in B ... see l_1F5E below
	exg	a1,a0                              		| [$1F38: ex   de,hl] HL := sprite.ctrl[RCKT].b0
	exg	d4,d6                              		| [$1F38: ex   de,hl] HL := sprite.ctrl[RCKT].b0
	
* sprite.ctrl[RCKT].b0.dblw = (two_ship << 3 )
	move.b	ds_plyr_actv+_b_2ship,d0        	| [$1F39: ld   a,(ds_plyr_actv +_b_2ship)] 9827
	and.b	#0x01,d0                         	| [$1F3C: and  #0x01] make sure its only bit-0 I guess ?
	rol.b	#3,d0                            	| [$1F3E: rlca] * 3

* sprite.ctrl[SHIP].b0 ... typically 0, unless ship is spinning
	or.b	d1,d0                             	| [$1F41: or   b] .ctrl[RCKT].b0|= .ctrl[SHIP].b0
	move.b	d0,(a0)                         	| [$1F42: ld   (hl),a]

* determine rocket sprite code based on ship sprite code, which ranges from 6 (upright orientation)
* down to the 90 degree rotation. Rocket code can be 30, 31, or 33 (360, 315, or 90 degree).
* rocket sprite 32 is also 360 or 0 degree but not used (unless its the 2nd rocket, which is done by sprite doubling).
	lea	ds_sprite_code_8B00,a1              	| [$1F43: ld   d,#>ds_sprite_code_8B00]
	add.w	d4,a1
	move.b	(a1),d0                         	| [$1F45: ld   a,(de)]
	lea	ds_sprite_code_8B00,a0                  | [$1F46: ld   h,d]
	add.w	d6,a0
	and.b	#0x07,d0                         	| [$1F47: and  #0x07] fighter sprite codes are $00...$07
	move.b	#0x30,d2                        	| [$1F49: ld   c,#0x30] code $30 ... 360 degree default orientation
* if ( A >= 5 ) then  ... code = $30
	cmp.b	#5,d0                            	| [$1F4B: cp   #5]
	jcc	l_1F56_set_rocket_sprite_code      		| [$1F4D: jr   nc,l_1F56_set_rocket_sprite_code]
* else ( A >= 2 ) then .. code = $31
	addq.b	#1,d2                           	| [$1F4F: inc  c] code $31 ... 45 degree rotation
	cmp.b	#2,d0                            	| [$1F50: cp   #2]
	jcc	l_1F56_set_rocket_sprite_code      		| [$1F52: jr   nc,l_1F56_set_rocket_sprite_code]
* else  ... code = $33
	addq.b	#2,d2                           	| [$1F54: inc  c] code $32 is skipped (also 360) * 2
l_1F56_set_rocket_sprite_code:
	move.b	d2,(a0)                         	| [$1F56: ld   (hl),c]


* Displacement in both X and Y axis must be computed in order to launch rockets
* from the spinning ship. The "primary" axis of travel is whichever one the
* ship is more closely aligned with and is assigned the maximum displacement
* value of 6.
*
* If the code is 4 thru 6, sY is the primary axis of motion (norm
* for non-rotated ship), indicated by setting the orientation bit (+ $40).
*
* dX in the secondary axis is determined by the sprite rotation (code)
* as shown in the table below, where the displacement ranges from 0 (ship
* rotated 90 * n) to a maximum amount of 3 as the ship approaches a rotation
* of primary+45.
*
* See c_0704_update_rockets (rckt_man_0704) in cpu1.
*
*   code= 6     dS=0      $40     ... 7 - (6+1)
*   code= 5     dS=1      $40     ... 7 - (5+1)
*   code= 4     dS=2      $40     ... 7 - (4+1)
*   code= 3     dS=3      $00
*   code= 2     dS=2      $00
*   code= 1     dS=1      $00
*   code= 0     dS=0      $00

* if ( A >= 4 ) ...
	cmp.b	#4,d0                            	| [cp   #4] A == sprite.cclr[SHIP].b0|
	jcs	l_1F5E                             		| [jr   c,l_1F5E]

* ... dS = 7 - ( code + 1 ) + 0x40
	not.b	d0                               	| [cpl]
	add.b	#0x40+7,d0                        	| [add  a,#0x40 + 7]
* else ... no orientation swap needed, use sprite code for dS

l_1F5E:
	asl.b	#1,d0                            	| [sla  a] "orientation" bit into bit-7 ...
	move.b	d0,d2                           	| [ld   c,a] ... and displacement << 1  into bits 1:2
* sprite.ctrl bits ...  flipx into bit:5, flipy into bit:6
	move.b	d1,d0                           	| [1F61: ld   a,b] sprite.ctrl[SHIP].b0
	ror.b	#3,d0                            	| [1F62: rrca] * 3
	and.b	#0x60,d0                         	| [1F65: and  #0x60] mask of rotated SPRCTRL[0]:0 and SPRCTRL[0]:1 bits
	move.b	d0,d1                           	| [1F67: ld   b,a]
												| [1F68: and  a]
	*move.b	d1,d0                           	| [1F6C: ld   a,b] flipx/flipy bits (0x60)
*	tst.b	b_9215_flip_screen           		| [1F68: ld   a,(b_9215_flip_screen)]
*	jne	l_1F71                             		| [1F6D: jr   nz,l_1F71]
	eor.b	#0x60,d0                         	| [1F6F: xor  #0x60] screen not flipped so invert those bits

l_1F71:
	or.b	d2,d0                             	| [1F71: or   c] bit7=orientation, bit6=flipY, bit5=flipX, 1:2=displacement
	move.l	(sp)+,a1                        	| [1F72: pop  de] pointer to rocket attribute
	movem.w	(sp)+,d3/d4                    		| [1F72: pop  de] pointer to rocket attribute
	move.b	d0,(a1)                         	| [1F73: ld   (de),a]
	COMPUTE_LSB_A0_D6	ds_sprite_code_8B00
	lea	b_8800,a0                      			| [1F74: $1F74: ld   h,#>b_8800] disposition = 6 ... active rocket object
	and.w	#0xFF,d6
	add.w	d6,a0
	move.b	#6,(a0)                         	| [$1F76: ld   (hl),#6] L == offsetof(rocket)
	move.b	#1,d0                           	| [$1F78: ld   a,#1]
	move.b	d0,b_9AA0+0x0F                  	| [$1F7A: ld   (b_9AA0 + 0x0F),a] 1 ... sound-fx count/enable registers, shot-sound
	move.w	#SHOT_SND,d0
	jbsr	osd_sound_start
	* count how many shots fired overall
	MOVE_TO_REG	ds_plyr_actv+_w_shot_ct,d5  	| [$1F7D: ld   hl,(ds_plyr_actv +_w_shot_ct)]
	addq.w	#1,d5                           	| [$1F80: inc  hl]	just to count shots fired probably
	MOVE_TO_VAR	d5,ds_plyr_actv+_w_shot_ct      | [$1F81: ld   (ds_plyr_actv +_w_shot_ct),hl] game shots fired count ++
	rts                                    		| [$1F84: ret]
* end 1F04

*=============================================================================
* f_controller_io_and_ship_movement_1f85()
*  Description:
*   Handle changes in controller IO Input bits, update ship movement.
*   (Called continuously in game-play, but also toward end of demo starting
*   when the two ships are joined.)
* IN:
*  ...
* OUT:
*  ...
*-----------------------------------------------------------------------------
f_controller_io_and_ship_movement_1f85:
	move.b	ds_plyr_actv+_b_2ship,d4        	| [ld   a,(ds_plyr_actv +_b_2ship)]
	                                         	| [ld   e,a]

* read from io_input[1] or io_input[2] depending whether screen is flipped.
	*move.b	b_9215_flip_screen,d0           	| [ld   a,(b_9215_flip_screen)]
	*add.b	<ds3_io_input_99b5+0x01,d0       	| [add  a,#<ds3_io_input_99b5 + 0x01] LSB
	*move.b	d0,d6                           	| [ld   l,a]
												| [ld   h,#>ds3_io_input_99b5 + 0x00] MSB
	move.b	ds3_io_input_99b5+1,d0              | [ld   a,(hl)]

*      call c_skip_real_io_input_1F92

*=============================================================================
* c_skip_real_io_input_1F92()
*  Description:
*   Skip real IO input in the demo.
*
*   The dX.flag determines the movement step (dX): when the ship movement
*   direction is changed, dX is 1 pixel increment for 1 frame and then 2 pixel
*   step thereafter as long as the control stick is held continously to the
*   direction. If the stick input is neutral, dX.flag (b_92A0[3]) is cleared.
*
*   In a two-ship configuration, the position is handled with respect to the
*   left ship... the right limit gets special handling accordingly.
*
* IN:
*   A == IO input control bits
*        2 ---> R
*        8 ---> L
*   E == actv_plyr_state[7]  .... double ship flag
*
* OUT:
*  ...
*-----------------------------------------------------------------------------
c_skip_real_io_input_1F92:
* if ( ( A & 0x0A ) == $0A ... inputs are active low, neither left or right active
	and.b	#0x0A,d0                         	| [$1F92: and  #0x0A]
	cmp.b	#0x0A,d0                         	| [$1F94: cp   #0x0A]
	jeq	l_1FCF_no_input                    	    | [$1F96: jr   z,l_1FCF_no_input]

* invert the input bits if screen flipped (swap L/R direction)
	*lea	b_9215_flip_screen,a0          	        | [$1F98: ld   hl,#b_9215_flip_screen]
	*btst.b	#0,(a0)                         	| [$1F9B: bit  0,(hl)]
	*jeq	l_1FA1_set_ship_dx                 	    | [$1F9D: jr   z,l_1FA1_set_ship_dx]
	*eor.b	#0x0A,d0                         	| [$1F9F: xor  #0x0A] screen is flipped

* set ship.dX (1 or 2)
l_1FA1_set_ship_dx:
	lea	b_92A0+0x03,a0                 	        | [$1FA1: ld   hl,#b_92A0 + 0x03] ship_dX_flag
	move.b	d0,d1                           	| [$1FA4: ld   b,a] stash the control input bits
	move.b	#1,d2                           	| [$1FA5: ld   c,#1] ship_dX = 1
* toggle ship_dX_flag
	move.b	(a0),d0                         	| [$1FA7: ld   a,(hl)]
	eor.b	#0x01,d0                         	| [$1FA8: xor  #0x01]
	move.b	d0,(a0)                         	| [$1FAA: ld   (hl),a] dX.flag ^= 1
* if (0 == ship_dX_flag) ship_dX++
	jne	l_1FAE_handle_input_bits           	    | [$1FAB: jr   nz,l_1FAE_handle_input_bits]
	addq.b	#1,d2                           	| [$1FAD: inc  c]

l_1FAE_handle_input_bits:
* if ( ship.posn.x == 0 ) return
	lea	ds_sprite_posn_9300+0x62,a0         	| [$1FAE: ld   hl,#ds_sprite_posn_9300 + 0x62] "main" ship (single) position
	move.b	(a0),d0                         	| [$1FB1: ld   a,(hl)]
	                               	            | [$1FB2: and  a]
	bne.b	0f                               	| [...]
	rts                                    	    | [$1FB3: ret  z] [...]
0:

* if ( input.Right ) ...
	btst.b	#1,d1                           	| [$1FB4: bit  1,b] if ( ! input bits.right ) ... inverted
	jne	l_1FC7_test_llmt                   	    | [$1FB6: jr   nz,l_1FC7_test_llmt]

* if ( ship.posn.x > 0xD1) ... moving right: check right limit for double-ship
	move.b	(a0),d0                         	| [$1FB8: ld   a,(hl)]
	cmp.b	#0xD1,d0                         	| [$1FB9: cp   #0xD1] right limit, double-ship
	jcs	l_1FC0_test_rlmt_single            	    | [$1FBB: jr   c,l_1FC0_test_rlmt_single]
* else if ( double_ship ) return
	btst.b	#0,d4                           	| [$1FBD: bit  0,e] if ( is_double_ship & 0x01 )
	beq.b	0f                               	| [...]
	rts                                    	    | [$1FBF: ret  nz] at right limit of double-ship [...]
0:

l_1FC0_test_rlmt_single:
* if ( ship.posn.x >= 0xE1 ) return
	cmp.b	#0xE1,d0                         	| [$1FC0: cp   #0xE1] right limit, single-ship
	bcs.b	0f                               	| [...]
	rts                                    	    | [$1FC2: ret  nc] [...]
0:
* add dX for right direction
	add.b	d2,d0                            	| [$1FC3: add  a,c] fighter dX
	move.b	d0,(a0)                         	| [$1FC4: ld   (hl),a]
	jra	l_1FD4_update_two_ship             	    | [$1FC5: jr   l_1FD4_update_two_ship]

* ... else ... test left limit
l_1FC7_test_llmt:
* if ( ship.posn.x < 0x12 ) return
	move.b	(a0),d0                         	| [$1FC7: ld   a,(hl)]
	cmp.b	#0x12,d0                         	| [$1FC8: cp   #0x12] left limit
	bcc.b	0f                               	| [...]
	rts                                    	    | [$1FCA: ret  c] [...]
0:
* else
	sub.b	d2,d0                            	| [$1FCB: sub  c] subtract dX
	move.b	d0,(a0)                         	| [$1FCC: ld   (hl),a]
	jra	l_1FD4_update_two_ship             	    | [$1FCD: jr   l_1FD4_update_two_ship]

l_1FCF_no_input:
	clr.b	d0                               	| [$1FCF: xor  a]
	move.b	d0,b_92A0+0x03                  	| [$1FD0: ld   (b_92A0 + 0x03),a] ship_dX_flag = 0
	rts                                    	    | [$1FD3: ret]


l_1FD4_update_two_ship:
* if ( ! two_ship_plyr )  return
	btst.b	#0,d4                           	| [$1FD4: bit  0,e]
	bne.b	0f                               	| [...]
	rts                                    	    | [$1FD6: ret  z] [...]
0:
* else ... ship2.posn.x = ship1.posn.x + $0F
	add.b	#0x0F,d0                         	| [$1FD7: add  a,#0x0F] +single ship position
	move.b	d0,ds_sprite_posn_9300+0x60         | [$1FD9: ld   (ds_sprite_posn_9300 + 0x60), a] double ship position
	rts                                    	    | [$1FDC: ret]

* end 1F85


* _l_1FDD:

*=============================================================================

*       ds.b  0x23                                  | pad

*=============================================================================

*           00002000  f_boss_capturing_ship_killed_2000

*
* input file gg1-3.s
*
* gg1-3.s
*  gg1-3.2m, 'maincpu' (Z80)
*
*  Manages formation, attack convoys, boss/capture.
*
*
*.module mob_mgr


**.area ROM (ABS,OVR)
*       .org 0x1FFF
*       .db  0xFF                                   | checksum 0x8C
*       .org 0x2000
*.area CSEG20


*=============================================================================
* f_boss_capturing_ship_killed_2000()
*  Description:
*    activated when the boss that has captured the ship is destroyed 
* IN:
*  ...
* OUT:
*  ...
* this routine spends its time loading h without changing l... There are several
* arrays which share the same lsb... Annoying as hell to port!
*-----------------------------------------------------------------------------
f_boss_capturing_ship_killed_2000:
	move.b	ds_plyr_actv+_b_bmbr_boss_cobj,d6	| [ld   a,(ds_plyr_actv +_b_bmbr_boss_cobj)] object locator for captured ship
	                           	                | [ld   l,a]
	lea	b_8800,a0                      	        | [ld   h,#>b_8800]
	and.w	#0xFF,d6
	add.w	d6,a0
	move.b	(a0),d0                         	| [ld   a,(hl)]
	                               	            | [and  a]
	jne	l_20BF                             	    | [jp   nz,l_20BF] no idea how it could be nz...
* if ( captr_status_1 == 0 )
	move.b	ds5_928A_captr_status+0x01,d0   	| [ld   a,(ds5_928A_captr_status + 0x01)]
	                               	            | [and  a]
	jeq	l_20C7                             	    | [jp   z,l_20C7]
* else if ( captr_status_1 == 1 )
	subq.b	#1,d0                           	| [dec  a]
	jeq	l_20D1_update_ship_spin            	    | [jp   z,l_20D1_update_ship_spin]
* else ... status is 2 when stopped spinning and preparing for landing
	lea	ds_sprite_posn_9300,a0              	| [ld   h,#>ds_sprite_posn_9300]
	add.w	d6,a0
	move.b	(a0),d0                         	| [ld   a,(hl)]
	cmp.b	#0x80,d0                         	| [cp   #0x80]
	jeq	l_2026                             	    | [jr   z,l_2026]
	jpl	l_2023                             	    | [jp   p,l_2023]
	addq.b	#1,(a0)                         	| [inc  (hl)]
	jra	l_205E                             	    | [jr   l_205E]
l_2023:
	subq.b	#1,(a0)                         	| [dec  (hl)]
	jra	l_205E                             	    | [jr   l_205E]

l_2026:
	addq.w	#1,a0                           	| [inc l]
	addq.w	#1,d6                           	| [inc l] inc d6 too to follow offset
	move.b	b_9215_flip_screen,d0           	| [ld   a,(b_9215_flip_screen)]
	                               	| [and  a]
	jne	l_204C                             	| [jr   nz,l_204C]
	move.b	(a0),d0                         	| [ld   a,(hl)]
	cmp.b	#0x29,d0                         	| [cp   #0x29]
	jne	l_2041                             	| [jr   nz,l_2041]
	lea	ds_sprite_ctrl_9B00,a0              	| [ld   h,#>ds_sprite_ctrl_9B00]
	and.w	#0xFF,d6
	move.b	(a0,d6.w),d0                         	| [ld   a,(hl)]
	lea	ds_sprite_posn_9300,a0              	| [ld   h,#>ds_sprite_posn_9300]
	and.w	#0xFF,d6
	add.w	d6,a0
	subq.b	#1,d0                           	| [dec  a]
	jne	l_2041                             	| [jr   nz,l_2041]
l_203A:
	move.b	#3,d0                           	| [ld   a,#3]
	move.b	d0,ds5_928A_captr_status+0x01   	| [ld   (ds5_928A_captr_status + 0x01),a] 3 (ships are joined now)
	jra	l_205E                             	| [jr   l_205E]

l_2041:
	addq.b	#1,(a0)                         	| [inc  (hl)]
	jne	l_205E                             	| [jr   nz,l_205E]
l_2044:
	lea	ds_sprite_ctrl_9B00,a0              	| [ld   h,#>ds_sprite_ctrl_9B00] rescued ship is "landing"
	and.w	#0xFF,d6
	add.w	d6,a0
	move.b	(a0),d0                         	| [ld   a,(hl)]
	eor.b	#0x01,d0                         	| [xor  #0x01]
	move.b	d0,(a0)                         	| [ld   (hl),a]
	jra	l_205E                             	| [jr   l_205E]
l_204C:
	move.b	(a0),d0                         	| [ld   a,(hl)] when?
	cmp.b	#0x37,d0                         	| [cp   #0x37]
	jne	l_2059                             	| [jr   nz,l_2059]
	lea	ds_sprite_ctrl_9B00,a0              	| [ld   h,#>ds_sprite_ctrl_9B00]
	and.w	#0xFF,d6
	add.w	d6,a0
	move.b	(a0),d0                         	| [ld   a,(hl)]
	lea	ds_sprite_posn_9300,a0              	| [ld   h,#>ds_sprite_posn_9300]
	and.w	#0xFF,d6
	add.w	d6,a0
	tst.b	d0                               	| [and  a]
	jeq	l_203A                             	| [jr   z,l_203A]
l_2059:
	subq.b	#1,(a0)                         	| [dec  (hl)]
	move.b	(a0),d0                         	| [ld   a,(hl)]
	addq.b	#1,d0                           	| [inc  a]
	jeq	l_2044                             	| [jr   z,l_2044]
l_205E:
	lea	ds_sprite_code_8B00+0x62,a0         	| [ld   hl,#ds_sprite_code_8B00 + 0x62] ship (1) sprite code
	move.b	(a0),d0                         	| [ld   a,(hl)]
	subq.b	#6,d0                           	| [sub  #6] glyphs 6 & 7 are both for upright ship... (7 is "wings closed" if captured)
	lea	ds_sprite_posn_9300+0x62,a0             | [ld   h,#>ds_sprite_posn_9300]
	move.b	d0,d2                           	| [ld   c,a] ... so we have 0 or possibly 1 here.
	jne	l_2075                             	| [jr   nz,l_2075]
	move.b	(a0),d0                         	| [ld   a,(hl)]
	cmp.b	#0x71,d0                         	| [cp   #0x71]
	jeq	l_2075                             	| [jr   z,l_2075]
	jpl	l_2073                             	| [jp   p,l_2073]
	addq.b	#1,(a0)                         	| [inc  (hl)] when?
	rts                                    	| [ret]
l_2073:
	subq.b	#1,(a0)                         	| [dec  (hl)]
	rts                                    	| [ret]

* the rescued ship has been moved horizontally to column adjacent to main-ship
l_2075:
	move.b	ds5_928A_captr_status+0x01,d0   	| [ld   a,(ds5_928A_captr_status + 0x01)] rescued ship is "landing" (becomes 3 when ships join)
	cmp.b	#3,d0                            	| [cp   #3]
	beq.b	0f                               	| [...]
	rts                                    	    | [ret  nz] [...]
0:
 * both ships are now joined
	move.b	ds_plyr_actv+_b_bmbr_boss_cobj,d6	| [ld   a,(ds_plyr_actv +_b_bmbr_boss_cobj)] object locator for the captured ship
												| [ld   l,a]
	lea	ds_sprite_posn_9300,a0              	| [ld   h,#>ds_sprite_posn_9300]
	and.w	#0xFF,d6
	add.w	d6,a0
	clr.b	(a0)+                             	| [ld   (hl),#0] 0 out the sprite position of the captured ship object e.g. 9300, 9302 etc.
	addq.w	#1,d6                          	    | [inc  l]  [a0 coherence]
											    | [dec  c]
	tst.b	d2                           	    | [inc  c]
	jeq	l_208F                             	    | [jr   z,l_208F]

	lea	ds_sprite_posn_9300+0x63,a1         	| [ld   de,#ds_sprite_posn_9300 + 0x63] this is if ship (1) sprite code was 7
	clr.b	d0                               	| [xor  a]
	move.b	d0,ds_plyr_actv+_b_bmbr_boss_cflag	| [ld   (ds_plyr_actv +_b_bmbr_boss_cflag),a] 0 ... enable capture-mode selection
	jra	l_2097                             	    | [jr   l_2097]

* ship sprite code was 6
l_208F:
	move.b	#1,d0                           	| [ld   a,#1]
	move.b	d0,ds_plyr_actv+_b_2ship        	| [ld   (ds_plyr_actv +_b_2ship),a]
	lea	ds_sprite_posn_9300+0x61,a1         	| [ld   de,#ds_sprite_posn_9300 + 0x61]

* capture ship rejoined with active ship
l_2097:
	move.b	(a0),d0                         	| [$2097: ld   a,(hl)] e.g. HL==9301 sprite_posn
	move.b	d0,(a1)                         	| [$2098: ld   (de),a] e.g. DE==9363 sprite_posn
	* recompute lsb offset (maybe not useful)
	COMPUTE_LSB_A0_D6	ds_sprite_posn_9300
	COMPUTE_LSB_A1_D4	ds_sprite_posn_9300
	lea	ds_sprite_ctrl_9B00,a0              	| [$2099: ld   h,#>ds_sprite_ctrl_9B00]
	add.w	d6,a0
	lea	ds_sprite_ctrl_9B00,a1                  | [$2099: ld   h,#>ds_sprite_ctrl_9B00]
	add.w	d4,a1              	                | [$209B: ld   d,h]
	move.b	(a0),d0                         	| [$209C: ld   a,(hl)] e.g. HL==9B01.. ctrl_2:bit0==enable and ctrl2_bit7==sx_bit8
	move.b	d0,(a1)                         	| [$209D: ld   (de),a]
	subq.w	#1,a0                           	| [$209E: dec  l]

	COMPUTE_LSB_A0_D6	ds_sprite_ctrl_9B00
	lea	b_8800,a0                      	        | [$209F: ld   h,#>b_8800]
	add.w	d6,a0
	move.b	#0x80,(a0)                      	| [$20A1: ld   (hl),#0x80] set captured ship object state inactive
	lea	ds_sprite_code_8B00,a0              	| [$20A3: ld   h,#>ds_sprite_code_8B00]
	COMPUTE_LSB_A1_D4	ds_sprite_ctrl_9B00
	move.b	d4,d6                           	| [$20A5: ld   l,e]
	subq.w	#1,d6                           	| [$20A6: dec  l] [a0 coherence]
	add.w	d6,a0

	move.b	#6,(a0)                         	| [$20A7: ld   (hl),#6] sprite code 6
	                                            | [$20A9: inc	l]
	move.b	#9,(1,a0)                         	| [$20AA: ld   (hl),#9] color map 9 for white ship
	                                            | [$20AC: dec	l]
	lea	ds_sprite_posn_9300,a0              	| [$20AD: ld   h,#>ds_sprite_posn_9300]
	add.w	d6,a0
	move.b	#0x80,(a0)                      	| [$20AF: ld   (hl),#0x80] put in center
	move.b	#1,d0                           	| [$20B1: ld   a,#1]
	move.b	d0,ds_cpu0_task_actv_9000+0x14      | [$20B3: ld   (ds_cpu0_task_actv_9000 + 0x14),a] 1 (f_rts_0827 ... empty task)
	move.b	d0,ds_cpu0_task_actv_9000+0x15      | [$20B6: ld   (ds_cpu0_task_actv_9000 + 0x15),a] 1 (f_read_fire_button_1f04 ...fire button input))
	move.b	d0,ds_cpu1_task_actv+0x05       	| [$20B9: ld   (ds_cpu1_task_actv + 0x05),a] 1 (cpu1:f_05EE .. Manage ship collision detection)
	move.b	d0,ds_99B9_star_ctrl+0x00       	| [$20BC: ld   (ds_99B9_star_ctrl + 0x00),a] 1 (when ship on screen
* capture ship rejoined with active ship
l_20BF:
	clr.b	d0                               	| [$20BF: xor  a]
	move.b	d0,ds_cpu0_task_actv_9000+0x1D      | [$20C0: ld   (ds_cpu0_task_actv_9000 + 0x1D),a] 0 ... this task
	move.b	d0,b_9AA0+0x11                  	| [$20C3: ld   (b_9AA0 + 0x11),a] 0 ... sound-fx count/enable registers, stop "rescued ship" music
	jbsr	osd_sound_stop
	rts                                    	    | [$20C6: ret]

l_20C7:                                         | *( ds5_928A_captr_status + 0x01 ) == 0
	addq.b	#1,d0                           	| [$20C7: inc  a]
	move.b	d0,ds5_928A_captr_status+0x01   	| [$20C8: ld   (ds5_928A_captr_status + 0x01),a] 1
	move.b	#2,d0                           	| [$20CB: ld   a,#2]
	move.b	d0,ds4_game_tmrs_92ac+1             | [$20CD: ld   (ds4_game_tmrs_92ac + 1),a] 2
	rts                                    	    | [$20D0: ret]

l_20D1_update_ship_spin:
	COMPUTE_LSB_A0_D6	b_8800
	lea	ds_sprite_ctrl_9B00,a0              	| [$20D1: ld   h,#>ds_sprite_ctrl_9B00] base address for c_2188
	add.w	d6,a0
	move.b	ds4_game_tmrs_92ac+1,d0             | [$20D3: ld   a,(ds4_game_tmrs_92ac + 1)]
	move.b	d0,d4                           	| [$20D6: ld   e,a]
	move.b	b_bugs_flying_nbr_9287,d0           | [$20D7: ld   a,(b_bugs_flying_nbr_9287)]
	or.b	d4,d0                             	| [$20DA: or   e]
	move.b	d0,ds5_928A_captr_status+0x03   	| [$20DB: ld   (ds5_928A_captr_status + 0x03),a]
	jbsr	c_2188_ship_spin                  	| [$20DE: call c_2188_ship_spin] Base address in HL, retval in B
	subq.b	#1,d1                           	| [$20E1: dec  b] what's in B?
	beq.b	0f                               	| [...]
	rts                                    	    | [$20E2: ret  nz] [...]
0:
* rescued ship stopped spinning ... begin "landing"
	move.b	d0,ds_cpu0_task_actv_9000+0x14      | [$20E3: ld   (ds_cpu0_task_actv_9000 + 0x14),a] 0 (f_rts_0827)
	move.b	d0,ds_cpu0_task_actv_9000+0x15      | [$20E6: ld   (ds_cpu0_task_actv_9000 + 0x15),a] 0 (f_read_fire_button_1f04 ...fire button input))
	move.b	d0,ds_cpu1_task_actv+0x05       	| [$20E9: ld   (ds_cpu1_task_actv + 0x05),a] 0 (cpu1:f_05EE)
	move.b	#2,d0                           	| [$20EC: ld   a,#2]
	move.b	d0,ds5_928A_captr_status+0x01   	| [$20EE: ld   (ds5_928A_captr_status + 0x01),a] 2
	rts                                    	    | [$20F1: ret]
* end 2000?

*=============================================================================
* f_tractor_beam_captures_ship_20f2()
*  Description:
*   handles the sequence where the tractor beam captures the ship.
* IN:
*  ...
* OUT:
*  ...
*-----------------------------------------------------------------------------
f_tractor_beam_captures_ship_20f2:
	lea	ds_sprite_ctrl_9B00+0x62,a0         	| [$20F2: ld   hl,#ds_sprite_ctrl_9B00 + 0x62] ship (1) position ...base address for c_2188
	jbsr	c_2188_ship_spin                  	| [$20F5: call c_2188_ship_spin] Base address in HL, retval in B
	btst.b	#0,d1                           	| [$20F8: bit  0,b]
	jne	l_2151                             	    | [$20FA: jr   nz,l_2151]
	move.b	ds5_928A_captr_status+0x01,d0   	| [$20FC: ld   a,(ds5_928A_captr_status + 0x01)] check bit 7
	btst.b	#7,d0                           	| [$20FF: bit  7,a]
	jne	l_215D                             	    | [$2101: jr   nz,l_215D]
	move.b	ds5_928A_captr_status+0x03,d0   	| [$2103: ld   a,(ds5_928A_captr_status + 0x03)]
	                               	            | [$2106: and  a]
	bne.b	0f                               	| [...]
	rts                                    	    | [$2107: ret  z] [...]
0:
	* jotd: ds_sprite_posn_9300: 9300, only msb is loaded means that offset 0x62 must be added
	lea	ds_sprite_posn_9300+0x62,a0             | [$2108: ld   h,#>ds_sprite_posn_9300]
	lea	ds_sprite_posn_9300,a1
	moveq	#0,d4
	move.b	ds_plyr_actv+_b_bmbr_boss_cobj,d4	| [$210A: ld   a,(ds_plyr_actv +_b_bmbr_boss_cobj)] object index of capturing boss i.e. 30 34 36 32
	add.w	d4,a1                           	| [$210D: ld   e,a]
												| [$210E: ld   d,h]
	move.b	(a1),d0                         	| [$210F: ld   a,(de)] get capturing boss column position position
	cmp.b	(a0),d0                          	| [$2110: cp   (hl)] compare to ship position
	jeq	l_211A_move_ship_row               	    | [$2111: jr   z,l_211A_move_ship_row] if equal
	jpl	l_2119_handle_ship_left            	    | [$2113: jp   p,l_2119_handle_ship_left]
	subq.b	#1,(a0)                         	| [$2116: dec  (hl)] move ship left one step
	jra	l_211A_move_ship_row               	    | [$2117: jr   l_211A_move_ship_row]

l_2119_handle_ship_left:
	addq.b	#1,(a0)                         	| [$2119: inc  (hl)] move ship right one step as it's captured
l_211A_move_ship_row:
	addq.w	#1,a0                           	| [$211A: inc  l]
	move.b	b_9215_flip_screen,d0           	| [$211B: ld   a,(b_9215_flip_screen)]
	                               	            | [$211E: and  a]
*	jeq	l_212C_not_flipped_screen          	    | [$211F: jr   z,l_212C_not_flipped_screen]
** handle flipped screen
*	addq.b	#1,(a0)                         	| [$2121: inc  (hl)]
*	move.b	(a0),d0                         	| [$2122: ld   a,(hl)]
*	cmp.b	#0x7A,d0                         	| [$2123: cp   #0x7A]
*	jeq	l_214C_disable_firepower           	    | [$2125: jr   z,l_214C_disable_firepower]
*	cmp.b	#0x80,d0                         	| [$2127: cp   #0x80]
*	jeq	l_2141_connected                   	    | [$2129: jr   z,l_2141_connected]
*	rts                                    	    | [$212B: ret]

*l_212C_not_flipped_screen:
	subq.b	#1,(a0)                         	| [$212C: dec  (hl)] move ship up as it's captured
	move.b	(a0),d0                         	| [$212D: ld   a,(hl)]
	addq.b	#1,d0                           	| [$212E: inc  a]
	jne	l_2139                             	    | [$212F: jr   nz,l_2139]
* handle overflow by toggling bit-0 (off)
	* jotd: adding +0x63 as previous value was ship vertical pos where L=0x63
	lea	ds_sprite_ctrl_9B00+0x63,a0             | [$2131: ld   h,#>ds_sprite_ctrl_9B00]
	move.b	(a0),d0                         	| [$2133: ld   a,(hl)]
	eor.b	#0x01,d0                         	| [$2134: xor  #0x01]
	move.b	d0,(a0)                         	| [$2136: ld   (hl),a]
	lea	ds_sprite_posn_9300+0x63,a0             | [$2137: ld   h,#>ds_sprite_posn_9300]
l_2139:
	move.b	(a0),d0                         	| [$2139: ld   a,(hl)]
	cmp.b	#0xE6,d0                         	| [$213A: cp   #0xE6]
	jeq	l_214C_disable_firepower           	    | [$213C: jr   z,l_214C_disable_firepower]
	cmp.b	#0xE0,d0                         	| [$213E: cp   #0xE0]
	beq.b	0f                               	| [...]
	rts                                    	    | [$2140: ret  nz] [...]
0:
l_2141_connected:
	clr.b	d0                               	| [$2141: xor  a]
	move.b	d0,ds5_928A_captr_status+0x03   	| [$2142: ld   (ds5_928A_captr_status + 0x03),a] 0
												| [$2145: inc  a] huh?
	move.b	#7,d0                           	| [$2146: ld   a,#7] color map of redship
	* change color of player ship to red when boss connects with it during capture
	move.b	d0,ds_sprite_code_8B00+0x63         | [$2148: ld   (ds_sprite_code_8B00 + 0x63),a]
	rts                                    	    | [$214B: ret]

* disables your rockets when the boss has finally connected.
l_214C_disable_firepower:
	clr.b	d0                               	| [$214C: xor  a]
	move.b	d0,ds_cpu0_task_actv_9000+0x15      | [$214D: ld   (ds_cpu0_task_actv_9000 + 0x15),a] 0 ... f_read_fire_button_1f04 (fire button input)
	rts                                    	    | [$2150: ret]

 * either the boss made final connection with ship, or the boss was shot while beaming the ship
l_2151:
* if ( firepower_enabled )...
	move.b	ds_cpu0_task_actv_9000+0x15,d0      | [$2151: ld   a,(ds_cpu0_task_actv_9000 + 0x15)] f_read_fire_button_1f04
	                               	            | [$2154: and  a]
	jne	l_215D                             	    | [$2155: jr   nz,l_215D]
* else ...
	addq.b	#1,d0                           	| [$2157: inc  a]
	move.b	d0,ds_9200_glbls+0x0D           	| [$2158: ld   (ds_9200_glbls + 0x0D),a] 1 ... boss connected with ship and firepower has been disabled
	jra	l_217F_finished                    	    | [$215B: jr   l_217F_finished]

* the ship is in the beam but then shoots the boss
l_215D:
	* l is 0x62, add 1 to skip inc
	lea	ds_sprite_posn_9300+0x62+1,a0           | [$215D: ld   h,#>ds_sprite_posn_9300]
												| [$215F: inc  l]
	move.b	b_9215_flip_screen,d0           	| [$2160: ld   a,(b_9215_flip_screen)]
	                               	            | [$2163: and  a]
	jeq	l_216D                             	    | [$2164: jr   z,l_216D]
	move.b	(a0),d0                         	| [$2166: ld   a,(hl)]
	cmp.b	#0x37,d0                         	| [$2167: cp   #0x37]
	jeq	l_217D                             	    | [$2169: jr   z,l_217D]
	subq.b	#1,(a0)                         	| [$216B: dec  (hl)]
	rts                                    	    | [$216C: ret]

l_216D:                                           | when?
	move.b	(a0),d0                         	| [$216D: ld   a,(hl)]
	cmp.b	#0x29,d0                         	| [$216E: cp   #0x29]
	jeq	l_217D                             	    | [$2170: jr   z,l_217D]
	addq.b	#1,(a0)                         	| [$2172: inc  (hl)]
	beq.b	0f                               	| [...]
	rts                                    	    | [$2173: ret  nz] [...]
0:
	COMPUTE_LSB_A0_D6	ds_sprite_posn_9300
	lea	ds_sprite_ctrl_9B00,a0              	| [$2174: ld   h,#>ds_sprite_ctrl_9B00]
	add.w	d6,a0
	move.b	(a0),d0                         	| [$2176: ld   a,(hl)]
	eor.b	#0x01,d0                         	| [$2177: xor  #0x01]
	move.b	d0,(a0)                         	| [$2179: ld   (hl),a]
	lea	ds_sprite_posn_9300,a0              	| [$217A: ld   h,#>ds_sprite_posn_9300]
	add.w	d6,a0
	rts                                    	    | [$217C: ret]
l_217D:
	subq.b	#1,d1                           	| [$217D: dec  b]
	beq.b	0f                               	| [...]
	rts                                    	    | [$217E: ret  nz] [...]
0:
l_217F_finished:
	clr.b	d0                               	| [$217F: xor  a]
	move.b	d0,ds_cpu0_task_actv_9000+0x1C      | [$2180: ld   (ds_cpu0_task_actv_9000 + 0x1C),a] 0: f_tractor_beam_captures_ship_20f2 ... this task
	addq.b	#1,d0                           	| [$2183: inc  a]
	move.b	d0,ds_cpu1_task_actv+0x05       	| [$2184: ld   (ds_cpu1_task_actv + 0x05),a] 1: cpu1:f_05EE ... Manage ship collision detection
	rts                                    	    | [$2187: ret]
* end 20F2

*=============================================================================
* c_2188_ship_spin()
*  Description:
*   Spins the ship, either when being captured, or being released.
* IN:
*   Base address in HL (from ds_sprite_ctrl_9B00)
* OUT:
*   D0, D1
*-----------------------------------------------------------------------------
c_2188_ship_spin:
	move.b	(a0),d0                         	| [ld   a,(hl)]
	move.b	d0,d2                           	| [ld   c,a]
	lsr.b	#1,d0                            	| [srl  a]
	eor.b	d2,d0                            	| [xor  c]
	move.b	d0,d2                           	| [ld   c,a]
	COMPUTE_LSB_A0_D6	ds_sprite_ctrl_9B00
	lea	ds_sprite_code_8B00,a0              	| [ld   h,#>ds_sprite_code_8B00]
	and.w	#0xFF,d6
	add.w	d6,a0
	clr.b	d1                               	| [ld   b,#0]
	move.b	(a0),d0                         	| [ld   a,(hl)]
	and.b	#0x07,d0                         	| [and  #0x07]
	cmp.b	#6,d0                            	| [cp   #6]
	jne	l_21A7                             	    | [jr   nz,l_21A7] iterated up and down between 0 and 6 as ship rotates in the beam
	                           	                | [dec  c]
	tst.b	d2                           	    | [inc  c]
	jne	l_21A7                             	    | [jr   nz,l_21A7]
	exg	d0,d7                              	    | [ex   af,af'] ship rotated around through 180 degrees
	move.b	ds5_928A_captr_status+0x03,d0   	| [ld   a,(ds5_928A_captr_status + 0x03)]
	                               	            | [and  a]
	jne	l_21A6                             	    | [jr   nz,l_21A6]
	addq.b	#1,d1                           	| [inc  b]
	rts                                    	    | [ret]

l_21A6:
	exg	d0,d7                              	    | [ex   af,af']
l_21A7:
	btst.b	#0,d2                           	| [bit  0,c]
	jne	l_21B2                             	    | [jr   nz,l_21B2]
	cmp.b	#6,d0                            	| [cp   #6]
	jeq	l_21B8                             	    | [jr   z,l_21B8]
	addq.b	#1,(a0)                         	| [inc  (hl)]
	jra	l_21C0                             	    | [jr   l_21C0]
l_21B2:
	tst.b	d0                               	| [and  a]
	jeq	l_21B8                             	    | [jr   z,l_21B8]
	subq.b	#1,(a0)                         	| [dec  (hl)]
	jra	l_21C0                             	    | [jr   l_21C0]
l_21B8:
	subq.b	#1,d2                           	| [dec  c]
	jpl	l_21A7                             	    | [jp   p,l_21A7]
	move.b	#3,d2                           	| [ld   c,#3]
	jra	l_21A7                             	    | [jr   l_21A7]
l_21C0:
	move.b	d2,d0                           	| [ld   a,c]
	btst.b	#1,d0                           	| [bit  1,a]
	jeq	l_21C7                             	    | [jr   z,l_21C7]
	eor.b	#0x01,d0                         	| [xor  #0x01]
l_21C7:
	COMPUTE_LSB_A0_D6	ds_sprite_code_8B00
	lea	ds_sprite_ctrl_9B00,a0              	| [ld   h,#>ds_sprite_ctrl_9B00]
	add.w	d6,a0
	move.b	d0,(a0)                         	| [ld   (hl),a]
	rts                                    	    | [ret]
* end 2188

*=============================================================================
* f_boss_diving_down_to_capture_ship_21cb()
*  Description:
*   Active when a boss diving down to capture the ship. Ends when the boss
*   takes position to start the beam.
* IN:
*  ...
* OUT:
*  ...
*-----------------------------------------------------------------------------
f_boss_diving_down_to_capture_ship_21cb:
* if ( HOMING == b_8800[ plyr_actv.captr_boss_id ] )0
	lea	ds_plyr_actv+_b_bmbr_boss_cobj,a0	    | [$21CB: ld   hl,#ds_plyr_actv +_b_bmbr_boss_cobj] = $9828
	move.b	(a0),d4                             | [$21CE: ld   e,(hl)]
	lea	b_8800,a1                      	        | [$21CF: ld   d,#>b_8800]
	and.w	#0xFF,d4                            
	add.w	d4,a1                               
	move.b	(a1),d0                             | [$21D1: ld   a,(de)]
	cmp.b	#9,d0                               | [$21D2: cp   #9]
	jne	l_221A                             	    | [$21D4: jr   nz,l_221A] exit
* ... then ...
* get the element of the bug_motion_que being used by this object. The byte-
* offset of the element is stored by plyr_actv.b09
	addq.w	#1,a0                           	| [$21D6: inc  l] _b09_cboss_slot ... set by cpu-b as capturing boss starts dive
	moveq	#0,d0
	move.b	(a0),d0                         	| [$21D7: ld   a,(hl)]
	lea		ds_bug_motion_que_9100,a2           | [$21D8: ld   ixl,a]
    add.w	d0,a2                               | [$21DA: ld   ixh,>ds_bug_motion_que_9100]
	tst.b	(mq_unknown_0A,a2)                  | [$21DD: ld   a,0x0A(ix)] while !0, capture boss is diving
                               	                | [$21E0: and  a]
	beq.b	0f                               	| [...]
	rts                                    	    | [$21E1: ret  nz] [...]
0:
	* boss is no longer diving but may have a non-zero angle
	* so now it must rotate into capture position
	move.b	#0x0C,d0                        	| [$21E2: ld   a,#0x0C]
	btst.b	#0,(mq_angle_msb_05,a2)             | [$21E4: bit  0,0x05(ix)] if set, negate (ix)0x0C ... capture boss nearly in position
	jeq	l_21EC                             	    | [$21E8: jr   z,l_21EC]
	neg.b	d0                               	| [$21EA: neg]
l_21EC:
	move.b	d0,(mq_angle_increment_0C,a2)       | [$21EC: ld   0x0C(ix),a] 12 or -12 if (ix)0x05:0 set
	move.b	(mq_angle_msb_05,a2),d0             | [$21EF: ld   a,0x05(ix)]
	ror.b	#1,d0                            	| [$21F2: rrca]
	SET_X_FROM_C
	move.b	(mq_angle_lsb_04,a2),d0             | [$21F3: ld   a,0x04(ix)]
	roxr.b	#1,d0                           	| [$21F6: rra]
	sub.b	#0x78,d0                         	| [$21F7: sub  #0x78]
	cmp.b	#0x10,d0                         	| [$21F9: cp   #0x10]
	bcs.b	0f                               	| [...]
	rts                                    	    | [$21FB: ret  nc] [...]
0:
* in position
	move.b	ds_new_stage_parms_99c0+0x06,d0     | [$21FC: ld   a,(ds_new_stage_parms_99c0 + 0x06)] plyr_state_actv[0x0A] ... ship capture status
	move.b	d0,ds_plyr_actv+_b_captr_flag   	| [$21FF: ld   (ds_plyr_actv +_b_captr_flag),a] new_stage_parms[ 6 ]
	clr.b	d0                               	| [$2202: xor  a]
	move.b	d0,(mq_angle_increment_0C,a2)       | [$2203: ld   0x0C(ix),a] 0
	move.b	d0,ds_cpu0_task_actv_9000+0x19      | [$2206: ld   (ds_cpu0_task_actv_9000 + 0x19),a] 0 (f_boss_diving_down_to_capture_ship_21cb)
	move.b	d0,ds5_928A_captr_status+0x01   	| [$2209: ld   (ds5_928A_captr_status + 0x01),a] 0
	move.b	d0,ds_9200_glbls+0x0D           	| [$220C: ld   (ds_9200_glbls + 0x0D),a] 0
	addq.b	#1,d0                           	| [$220F: inc  a]
	move.b	d0,ds_cpu0_task_actv_9000+0x18      | [$2210: ld   (ds_cpu0_task_actv_9000 + 0x18),a] 1 (f_boss_starts_tractor_beam_2222 ... Boss starts tractor beam)
	move.b	d0,ds5_928A_captr_status+0x02   	| [$2213: ld   (ds5_928A_captr_status + 0x02),a] 1
	move.b	d0,ds5_928A_captr_status+0x03   	| [$2216: ld   (ds5_928A_captr_status + 0x03),a] 1
	rts                                    	    | [$2219: ret]
l_221A:
	clr.b	d0                               	| [$221A: xor  a]
	move.b	d0,ds_cpu0_task_actv_9000+0x19      | [$221B: ld   (ds_cpu0_task_actv_9000 + 0x19),a] 0 (f_boss_diving_down_to_capture_ship_21cb)
	move.b	d0,ds_plyr_actv+_b_bmbr_boss_cflag	| [$221E: ld   (ds_plyr_actv +_b_bmbr_boss_cflag),a] 0 ... enable capture-mode selection
	rts                                    	    | [$2221: ret]
* end 21CB

*=============================================================================
* f_boss_starts_tractor_beam_2222()
*  Description:
*   Boss starts tractor beam
*   Activated by f_boss_diving_down_to_capture_ship_21cb (capture boss dives down)
* IN:
*  ...
* OUT:
*  ...
*-----------------------------------------------------------------------------
f_boss_starts_tractor_beam_2222:
*  if ( frame_count % 4 != 0 ) goto 2257
	move.b	ds3_frame_cts_92A0+0,d0         	| [$2222: ld   a,(ds3_frame_cts_92A0 + 0)] frame_ct%4 ... (provides 15Hz timer)
	move.b	d0,d2                           	| [$2225: ld   c,a]
	and.b	#0x03,d0                         	| [$2226: and  #0x03]
	jne	l_2257                             	    | [$2228: jr   nz,l_2257]
*  else
	move.b	ds5_928A_captr_status+0x00,d0   	| [$222A: ld   a,(ds5_928A_captr_status + 0x00)] beam started
	neg.b	d0                               	| [$222D: neg]
	sub.b	#0x18,d0                         	| [$222F: sub  #0x18]
	move.b	#0x21,d5                        	| [$2231: ld   h,#0x21]
	rol.b	#1,d0                            	| [$2233: rlca]
	SET_X_FROM_C
	roxl.b	#1,d5                           	| [$2234: rl   h]
	rol.b	#1,d0                            	| [$2236: rlca]
	SET_X_FROM_C
	roxl.b	#1,d5                           	| [$2237: rl   h]
	and.b	#0xE0,d0                         	| [$2239: and  #0xE0]
	add.b	#0x15,d0                         	| [$223B: add  a,#0x15]
	move.b	d0,d6                           	| [$223D: ld   l,a]
	move.b	d2,d0                           	| [$223E: ld   a,c]
	ror.b	#2,d0                            	| [$223F: rrca] * 2
	and.b	#0x03,d0                         	| [$2241: and  #0x03]
	jne	l_2246                             	    | [$2243: jr   nz,l_2246]
	addq.b	#1,d0                           	| [$2245: inc  a]
l_2246:
	add.b	#0x17,d0                         	| [$2246: add  a,#0x17]
	move.w	#0x0016,d3                      	| [$2248: ld   de,#0x0016] 22
	move.b	#6,d2                           	| [$224B: ld   c,#6]
	LOAD_D5_16_FROM_D5D6
l_224D:
	move.b	#0x0A,d1                        	| [$224D: ld   b,#0x0A]
	move.w	d5,d7
l_224F:
	jbsr	osd_w_colorram                     	| [$224F: ld   (hl),a]
	addq.w	#1,d7              	                | [$2250: inc  l]
	subq.b	#1,d1                           	| [...]
	jne	l_224F                             	    | [$2251: djnz l_224F]

	add.w	d3,d7                            	| [$2253: add  hl,de]
	subq.b	#1,d2                           	| [$2254: dec  c]
	jne	l_224D                             	    | [$2255: jr   nz,l_224D]

l_2257:
	lea	ds5_928A_captr_status+0x01,a0  	        | [$2257: ld   hl,#ds5_928A_captr_status + 0x01] check bit 7
	btst.b	#7,(a0)                         	| [$225A: bit  7,(hl)]
	jne	l_226A                             	    | [$225C: jr   nz,l_226A]
	move.b	ds_plyr_actv+_b_bmbr_boss_cobj,d0	| [$225E: ld   a,(ds_plyr_actv +_b_bmbr_boss_cobj)]
	move.b	d0,d4                           	| [$2261: ld   e,a]
	lea	b_8800,a1                      	        | [$2262: ld   d,#>b_8800]
	and.w	#0xFF,d4
	add.w	d4,a1
	move.b	(a1),d0                         	| [$2264: ld   a,(de)]
	cmp.b	#0x09,d0                         	| [$2265: cp   #0x09] 09 ... in a diving attack
	jne	l_2327_shot_boss_while_capturing   	    | [$2267: jp   nz,l_2327_shot_boss_while_capturing]
l_226A:
* if  ( ( *( ds5_928A_captr_status + 0x02 )-- ) > 0 ) goto 233D
	lea	ds5_928A_captr_status+0x02,a0  	| [ld   hl,#ds5_928A_captr_status + 0x02] -=1
	subq.b	#1,(a0)                         	| [dec  (hl)]
	jne	l_233D                             	    | [jp   nz,l_233D]
* else
	move.b	ds_plyr_actv+_b_captr_flag,d0   	| [$226D: ld   a,(ds_plyr_actv +_b_captr_flag)] *( ds5_928A_captr_status + 0x02 )
	move.b	d0,(a0)                         	| [$226E: ld   (hl),a]
* if ( *(_captr_status + 0x01) & $80 ) goto 22AB
	lea	ds5_928A_captr_status+0x01,a0  	        | [$2271: ld   hl,#ds5_928A_captr_status + 0x01] check bit 7
	btst.b	#7,(a0)                         	| [$2274: bit  7,(hl)]
	jne	l_22AB                             	    | [$2275: jr   nz,l_22AB]
* else
	move.b	d0,b_9AA0+0x05                  	| [$227C: ld   (b_9AA0 + 0x05),a] sound-fx count/enable registers, trigger capture beam sound
	move.w	#CAPTURE_DOWN_SND,d0
	jbsr	osd_sound_start
	move.b	ds_plyr_actv+_b_cboss_slot,d0   	| [$227F: ld   a,(ds_plyr_actv +_b_cboss_slot)] bug_flite_que[ plyr.cboss_slot ].b0D = $FF
	add.b	#0x0D,d0                         	| [$2282: add  a,#0x0D]
	move.b	d0,d4                           	| [$2284: ld   e,a]
	lea	ds_bug_motion_que_9100,a1           	| [$2285: ld   d,#>ds_bug_motion_que_9100] bug_flite_que[ plyr.cboss_slot ].b0D = $FF
	and.w	#0xFF,d4
	add.w	d4,a1
	st.b	d0                                	| [$2287: ld   a,#0xFF]
	move.b	d0,(a1)                         	| [$2289: ld   (de),a]
	addq.b	#1,(a0)                         	| [$228A: inc  (hl)]
	move.b	(a0),d0                         	| [$228B: ld   a,(hl)]
	and.b	#0x0F,d0                         	| [$228C: and  #0x0F]
	cmp.b	#0x0B,d0                         	| [$228E: cp   #0x0B]
	jeq	l_22D2                             	    | [$2290: jr   z,l_22D2]
	btst.b	#6,(a0)                         	| [$2292: bit  6,(hl)]
	jne	l_22C1                             	    | [$2294: jr   nz,l_22C1]
	move.w	d0,-(sp)                        	| [$2296: push af]
	move.b	d0,d2                           	| [$2297: ld   c,a]
	rol.b	#1,d0                            	| [$2298: rlca]
	add.b	d2,d0                            	| [$2299: add  a,c]
	lea	d_23A1-6,a0                    	        | [$229A: ld   hl,#d_23A1 - 6] get data src, getting ready to shoot the tractor beam
	jbsr	add_2_times_d0_to_a0_0008           | [$229D: rst  0x08] HL += 2A
	move.w	(sp)+,d0                        	| [$229E: pop  af]
	jbsr	compute_beam_tile_address_238A    	| [$229F: call compute_beam_tile_address_238A]
	move.w	#6-1,d1                           	| [$22A2: ld   b,#6]
l_22A4:
	move.b	(a0)+,d0                         	| [$22A4: ld   a,(hl)]
	jbsr	osd_w_videoram                      | [$22A5: ld   (de),a] draw the capturing beam
												| [$22A6: inc  hl]
	sub.w	#0x20,d7                          	| [$22A7: rst  0x20] DE-=$20
	dbf		d1,l_22A4                           | [$22A8: djnz l_22A4]
	rts                                    	    | [$22AA: ret]

l_22AB:
	addq.b	#1,(a0)                         	| [$22AB: inc  (hl)]
	move.b	(a0),d0                         	| [$22AC: ld   a,(hl)]
	and.b	#0x0F,d0                         	| [$22AD: and  #0x0F]
	cmp.b	#0x0B,d0                         	| [$22AF: cp   #0x0B]
	jne	l_22C5                             	    | [$22B1: jr   nz,l_22C5]
	clr.b	d0                               	| [$22B3: xor  a]
	move.b	d0,ds_cpu0_task_actv_9000+0x18      | [$22B4: ld   (ds_cpu0_task_actv_9000 + 0x18),a] 0 (f_boss_starts_tractor_beam_2222 ... this one)
	move.b	d0,b_9AA0+0x05                  	| [$22B7: ld   (b_9AA0 + 0x05),a] 0 ... sound-fx count/enable registers, capture beam sound active uno
	move.b	d0,b_9AA0+0x06                  	| [$22BA: ld   (b_9AA0 + 0x06),a] 0 ... sound-fx count/enable registers, capture beam sound active deux
	move.b	d0,ds_plyr_actv+_b_bmbr_boss_cflag	| [$22BD: ld   (ds_plyr_actv +_b_bmbr_boss_cflag),a] 0 ... enable capture-mode selection
	rts                                    	    | [$22C0: ret]

l_22C1:
	neg.b	d0                               	| [$22C1: neg] from 2294, boss almost ready to attach to the ship
	add.b	#0x0B,d0                         	| [$22C3: add  a,#0x0B]
l_22C5:
	jbsr	compute_beam_tile_address_238A      | [$22C8: call compute_beam_tile_address_238A]
	move.b	#6,d1                           	| [$22CA: ld   b,#6]
	move.b	#0x24,d2                        	| [$22CC: ld   c,#0x24]
l_22CC:
	move.b	d2,d0                           	| [$22CC: ld   a,c]
	jbsr	osd_w_videoram                    	| [$22CD: ld   (de),a]
	sub.w	#0x20,d7                          	| [$22CE: rst  0x20] DE-=$20
	subq.b	#1,d1                           	| [...]
	jne	l_22CC                             	    | [$22CF: djnz l_22CC]
	rts                                    	    | [$22D1: ret]

l_22D2:
	btst.b	#6,(a0)                         	| [$22D2: bit  6,(hl)] got the ship, ship is red, beam gone
	jeq	l_231C                             	    | [$22D4: jr   z,l_231C]
	move.b	ds_9200_glbls+0x0D,d0           	| [$22D6: ld   a,(ds_9200_glbls + 0x0D)] if 1, boss has connected with ship and firepower disabled
	                               	            | [$22D9: and  a]
	jeq	l_22E3                             	    | [$22DA: jr   z,l_22E3]
	btst.b	#5,(a0)                         	| [$22DC: bit  5,(hl)]
	jne	l_22E3                             	    | [$22DE: jr   nz,l_22E3]
	move.b	#0x68,(a0)                      	| [$22E0: ld   (hl),#0x68]
	rts                                    	    | [$22E2: ret]

* capture beam has stopped (whether or not ship is captured or got destroyed by a bomb)
l_22E3:
	clr.b	d0                               	| [$22E3: xor  a]
	move.b	d0,ds_cpu0_task_actv_9000+0x18      | [$22E4: ld   (ds_cpu0_task_actv_9000 + 0x18),a] 0 (disable f_boss_starts_tractor_beam_2222 ... this one)
	                                         	| [$22E7: ld   (b_9AA0 + 0x05),a] 0 ... sound-fx count/enable registers, capture beam sound active uno
	                                         	| [$22EA: ld   (b_9AA0 + 0x06),a] 0 ... sound-fx count/enable registers, capture beam sound active deux
	                               	            | [$22ED: and  a]
	move.b	ds_plyr_actv+_b_cboss_slot,d0   	| [$22F0: ld   a,(ds_plyr_actv +_b_cboss_slot)] bug_flite_que[ plyr.cboss_slot + $nn ] ... nn -> b0D or b08
	tst.b	ds_9200_glbls+0x0D           	    | [$22F1: ld   a,(ds_9200_glbls + 0x0D)] if 1, boss has connected with ship and firepower disabled
	jne	l_2305                             	    | [$22F4: jr   nz,l_2305]
* if  0 == b_9200[$0D] ...
	add.b	#0x0D,d0                         	| [$22F6: add  a,#0x0D]
	move.b	d0,d4                           	| [$22F8: ld   e,a]
	lea	ds_bug_motion_que_9100,a1           	| [$22F9: ld   d,#>ds_bug_motion_que_9100] bug_flite_que[plyr.boss_slot].b0D = 1 ... token expiration on next step
	and.w	#0xFF,d4
	add.w	d4,a1
	clr.b	d0                               	| [$22FB: xor  a]
	move.b	d0,ds_plyr_actv+_b_bmbr_boss_cflag	| [$22FC: ld   (ds_plyr_actv +_b_bmbr_boss_cflag),a] 0 ... enable capture-mode selection
	addq.b	#1,d0                           	| [$22FF: inc  a]
	move.b	d0,ds_plyr_actv+_b_bmbr_boss_cobj	| [$2300: ld   (ds_plyr_actv +_b_bmbr_boss_cobj),a] 1 ... why 1?
	move.b	d0,(a1)                         	| [$2303: ld   (de),a] bug_flite_que[plyr.cboss_slot].b0D = 1 ... token expiration on next step
	rts                                    	    | [$2304: ret]

* ... else ... (connected with ship)
l_2305:
	add.b	#8,d0                            	| [$2305: add  a,#8]
	move.b	d0,d6                           	| [$2307: ld   l,a]
	lea	ds_bug_motion_que_9100,a0           	| [$2308: ld   h,#>ds_bug_motion_que_9100] bug_flite_que[plyr.cboss_slot].p08 = &db_046B[0] ... pointer to flite data
	and.w	#0xFF,d6
	add.w	d6,a0
	move.w	#db_flv_cboss_046B,d3               | [$230A: ld   de,#db_flv_cboss]
	LOAD_D3D4_FROM_D3_16
	move.b	d4,(a0)+                         	| [$230D: ld   (hl),e]
	                           	                | [$230E: inc  l]
	move.b	d3,(a0)                         	| [$230F: ld   (hl),d]
	clr.b	d0                               	| [$2310: xor  a]
	move.b	d0,ds_99B9_star_ctrl+0x01       	| [$2311: ld   (ds_99B9_star_ctrl + 0x01),a] 0
	addq.b	#1,d0                           	| [$2314: inc  a]
	move.b	d0,ds_cpu0_task_actv_9000+0x11      | [$2315: ld   (ds_cpu0_task_actv_9000 + 0x11),a] 1 (enable f_manage_ship_capture_movement_19b2 ... fighter captured)
	move.b	d0,ds5_928A_captr_status+0x04   	| [$2318: ld   (ds5_928A_captr_status + 0x04),a] 1 ... (fighter captured)
	rts                                    	    | [$231B: ret]

l_231C:
	move.b	#0x40,d0                        	| [$231C: ld   a,#0x40] beam nearly got ship
	move.b	d0,ds5_928A_captr_status+0x02   	| [$231E: ld   (ds5_928A_captr_status + 0x02),a] 928C=928b=$40
	move.b	#0x40,d0                        	| [$2321: ld   a,#0x40] well this is inefficient ...!
	move.b	d0,ds5_928A_captr_status+0x01   	| [$2323: ld   (ds5_928A_captr_status + 0x01),a] 928C=928b=$40
	rts                                    	    | [$2326: ret]

l_2327_shot_boss_while_capturing:
	move.b	#3,d0                           	| [$2327: ld   a,#3]
	move.b	d0,ds_plyr_actv+_b_captr_flag   	| [$2329: ld   (ds_plyr_actv +_b_captr_flag),a] 3 (shot_boss_while_capturing)
	move.b	#0x80,(a0)                      	| [$232C: ld   (hl),#0x80] HL == ds5_928A_captr_status + 0x01
	clr.b	d0                               	| [$232E: xor  a]
	move.b	d0,ds5_928A_captr_status+0x03   	| [$232F: ld   (ds5_928A_captr_status + 0x03),a] 0
	move.b	d0,ds_99B9_star_ctrl+0x01       	| [$2332: ld   (ds_99B9_star_ctrl + 0x01),a] 0
	addq.b	#1,d0                           	| [$2335: inc  a]
	move.b	d0,ds5_928A_captr_status+0x02   	| [$2336: ld   (ds5_928A_captr_status + 0x02),a] 1 ... shot_boss_while_capturing
	move.b	d0,ds_cpu0_task_actv_9000+0x14      | [$2339: ld   (ds_cpu0_task_actv_9000 + 0x14),a] 1  (f_controller_io_and_ship_movement_1f85 ... control stick input)
	rts                                    	    | [$233C: ret]

l_233D:
	move.b	ds5_928A_captr_status+0x01,d0   	| [$233D: ld   a,(ds5_928A_captr_status + 0x01)] if !$40 see 2323  (from 226E... beam just started)
	cmp.b	#0x40,d0                         	| [$2340: cp   #0x40]
	beq.b	0f                               	| [...]
	rts                                    	    | [$2342: ret  nz] [...]
0:
* beam just about to grab ship
	move.b	b_9215_flip_screen,d0           	| [$2343: ld   a,(b_9215_flip_screen)]
	move.b	d0,d2                           	| [$2346: ld   c,a]
	move.b	ds_sprite_posn_9300+0x62,d0         | [$2347: ld   a,(ds_sprite_posn_9300 + 0x62)] ship (1) position
	btst.b	#0,d2                           	| [$234A: bit  0,c]
	jeq	l_2352                             	    | [$234C: jr   z,l_2352]
	add.b	#0x0E,d0                         	| [$234E: add  a,#0x0E]
	neg.b	d0                               	| [$2350: neg]
l_2352:
	move.b	d0,d1                           	| [$2352: ld   b,a]
	move.b	ds5_928A_captr_status+0x00,d0   	| [$2353: ld   a,(ds5_928A_captr_status + 0x00)] beam is pulling the ship
	sub.b	d1,d0                            	| [$2356: sub  b]
	add.b	#0x1B,d0                         	| [$2357: add  a,#0x1B]
	cmp.b	#0x36,d0                         	| [$2359: cp   #0x36]
	bcs.b	0f                               	| [...]
	rts                                    	    | [$235B: ret  nc] [...]
0:
* if ( game_state == ATTRACT_MODE ) goto 236d
	move.b	b8_game_state_9201,d0           	| [$235C: ld   a,(b8_game_state_9201)]  == ATTRACT_MODE
	subq.b	#1,d0                           	| [$235F: dec  a]
	jeq	l_236D                             	    | [$2360: jr   z,l_236D]
* else if (  !  ( task_enabled  &&  !restart_stage )  return
	move.b	ds_cpu0_task_actv_9000+0x14,d0      | [$2362: ld   a,(ds_cpu0_task_actv_9000 + 0x14)] f_move_swarm_when_player_changes_1d32 (Moves bug nest on and off the screen )
	move.b	d0,d2                           	| [$2365: ld   c,a]
	move.b	ds_9200_glbls+0x13,d0           	| [$2366: ld   a,(ds_9200_glbls + 0x13)]
	eor.b	#0x01,d0                         	| [$2369: xor  #0x01]
	and.b	d2,d0                            	| [$236B: and  c]
	bne.b	0f                               	| [...]
	rts                                    	    | [$236C: ret  z] [...]
0:

l_236D:
	clr.b	d0                               	| [$236D: xor  a]
	move.b	d0,ds_cpu0_task_actv_9000+0x14      | [$236E: ld   (ds_cpu0_task_actv_9000 + 0x14),a] 0: f_controller_io_and_ship_movement_1f85... control stick input
	move.b	d0,b_9AA0+0x05                  	| [$2371: ld   (b_9AA0 + 0x05),a] 0: sound-fx count/enable registers, capture beam sound active uno
	* stop capture beam sound
	move.b	d0,ds_cpu1_task_actv+0x05       	| [$2374: ld   (ds_cpu1_task_actv + 0x05),a] 0 ... cpu1:f_05EE
	move.b	d0,ds_9200_glbls+0x13           	| [$2377: ld   (ds_9200_glbls + 0x13),a] 0
	addq.b	#1,d0                           	| [$237A: inc  a]
	move.b	d0,ds_cpu0_task_actv_9000+0x1C      | [$237B: ld   (ds_cpu0_task_actv_9000 + 0x1C),a] 1: f_tractor_beam_captures_ship_20f2 ... tractor beam captures
	move.w	#CAPTURE_UP_SND,d0
	jbsr	osd_sound_start
	move.b	d0,b_9AA0+0x06                  	| [$237E: ld   (b_9AA0 + 0x06),a] 1 ... sound-fx count/enable registers, tractor beam
	move.b	d0,ds_99B9_star_ctrl+0x01       	| [$2381: ld   (ds_99B9_star_ctrl + 0x01),a] 1
	move.b	#0x0A,d0                        	| [$2384: ld   a,#0x0A]
	move.b	d0,ds_plyr_actv+_b_captr_flag   	| [$2386: ld   (ds_plyr_actv +_b_captr_flag),a] $0A ... tractor beam capturing ship
	rts                                    	    | [$2389: ret]

*=============================================================================
* compute_beam_tile_address_238A()
*  Description:
*   for f_boss_starts_tractor_beam_2222
*   boss about to start tractor beam
* IN:
*   A==
* OUT: D7.W address of beam character
*  ...
*-----------------------------------------------------------------------------
compute_beam_tile_address_238A:
	move.b	d0,d2                           	| [$238A: ld   c,a]
	move.b	ds5_928A_captr_status+0x00,d0   	| [$238B: ld   a,(ds5_928A_captr_status + 0x00)] boss about to start tractor beam
	neg.b	d0                               	| [$238E: neg]
	add.b	#0x10,d0                         	| [$2390: add  a,#0x10]
	move.b	#0x20,d3                        	| [$2392: ld   d,#0x20]
	rol.b	#1,d0                            	| [$2394: rlca]
	SET_X_FROM_C
	roxl.b	#1,d3                           	| [$2395: rl   d]
	rol.b	#1,d0                            	| [$2397: rlca]
	SET_X_FROM_C
	roxl.b	#1,d3                           	| [$2398: rl   d]
	and.b	#0xE0,d0                         	| [$239A: and  #0xE0]
	add.b	#0x14,d0                         	| [$239C: add  a,#0x14]
	add.b	d2,d0                            	| [$239E: add  a,c]
	                           	                | [$239F: ld   e,a]
	move.b	d3,d7
	rol.w	#8,d7
	move.b	d0,d7
	rts                                    	    | [$23A0: ret]
* end 238A

*=============================================================================
* data for f_boss_starts_tractor_beam_2222
* 6-bytes per entry, (table starts 6-bytes past the value ld'd to HL)
d_23A1:
	.byte 0x24,0x4E,0x4F,0x50,0x51,0x24,0x24,0x52,0x53,0x54
	.byte 0x55,0x24,0x24,0x56,0x57,0x58,0x59,0x24,0x24,0x5A,0x5B,0x5C,0x5D,0x24,0x24,0x5E
	.byte 0x5F,0x60,0x61,0x24,0x62,0x63,0x64,0x65,0x66,0x67,0x68,0x69,0x6A,0x6B,0x6C,0x6D
	.byte 0x6E,0x6F,0x70,0x71,0x72,0x73,0x74,0x75,0x76,0x77,0x78,0x79,0x7A,0x7B,0x7C,0x7D
	.byte 0x7E,0x7F

*=============================================================================
* f_update_objects_23dd()
*  Description:
*   This task is never disabled.
*   Updates each object in obj_status[] and updates global count of active
*   objects.
*   Call here for f_move_swarm_when_player_changes_1d32, but normally this is a periodic task called 60Hz.
*   Using bits <1:0> of framecounter as the state variable, 1 cycle of this
*   task is completed over four successive frames, i.e. the cycle is repeated
*   at a rate of 15Hz. Half of the objects are updated at each alternating odd
*   frame. On one even frame object count is updated.
*   The function body is broken out to a separate subroutine allowing the
*   frame count to be forced in A (needed for update at player changeover)
* IN:
*  ...
* OUT:
*  ...
*-----------------------------------------------------------------------------
f_update_objects_23dd:
	move.b	ds3_frame_cts_92A0+0,d0         	| [$23DD: ld   a,(ds3_frame_cts_92A0 + 0)]

* f_update_objects_23e0

*=============================================================================
* f_update_objects_23e0()
*  Description:
*   Implementation of f_update_objects_23dd()
*   See comments for f_update_objects_23dd() above.
* IN:
*  A==_frame_counter
* OUT:
*  ...
*-----------------------------------------------------------------------------
f_update_objects_23e0:
* check if even or odd frame
	btst.b	#0,d0                           	| [$23E0: bit  0,a]
	jeq	l_2596_even_frame                  		| [$23E2: jp   z,l_2596_even_frame]

* frame count bit-1 provides start index/offset of obj_status[], i.e. 0,4,8,etc.
* on frame 1 and 2,6,10,etc. on frame 3
	and.b	#0x02,d0                         	| [$23E5: and  #0x02]
	move.b	d0,d4                           	| [$23E7: ld   e,a] E==0 if frame 1, E==2 if frame 3
	move.b	b_bugs_actv_cnt,d0              	| [$23E8: ld   a,(b_bugs_actv_cnt)]
	move.b	d0,ixl								| [$23EB: ld   ixl,a] use as "local" variable for object counter
	move.b	#32,d1                          	| [$23ED: ld   b,#32] size of object set / 2
l_next_object_23EF:
	lea	b_8800,a1                      			| [$23EF: ld   d,#>b_8800]
	and.w	#0xFF,d4
	add.w	d4,a1
	moveq	#0,d0
	move.b	(a1),d0                             | [ld   a,(de)]
* test for $80 (inactive status)
	tst.b	d0                            	    | [sla  a] test for bit-7
	jmi	l_2416                             	    | [jr   c,l_2416] DE+=4

	* there are active sprites on screen
	
	lea	d_23FF_jp_tbl,a0        | [$23F6: ld   hl,#d_23FF_jp_tbl]
	and.w	#0xFF,d0
	CHECK_D0W_UPPER_BOUND	10
	asl.b	#2,d0				| [$23F9: rst  0x10] HL += A
	                        	| [$23FA: ld   a,(hl)]
	                       	    | [$23FB: inc  hl]
	                       	    | [$23FC: ld   h,(hl)]
	move.l	(a0,d0.w),a0        | [$23FD: ld   l,a]
	jra	(a0)                    | [$23FE: jp   (hl)]

* each case is entered with D4 set to current object index, A1 points to object

d_23FF_jp_tbl:
	.long case_inactive_2416                    | 80: inactive object (already tested for 0x80 so this is a placeholder)
	.long case_assimilated_into_collective_2488 | 01: assimilated into the collective and resting peacefully.
	.long case_rotating_into_collective_245F    | 02: rotating back into position in the collective
	.long case_state_progression_254D           | 03: state progression ... 7's to 3's, and then 9's, 2's, and finally 1's
	.long case_nearly_fatally_shot_24B2         | 04: nearly fatally shot
	.long case_show_score_2535                  | 05: showing a score bitmap for a bonus hit
	.long case_state_progression_254D           | 06: disable this one and the borg runs out of nukes
	.long case_spawning_orc_2590                | 07: once for each orc as he is spawning (new stage)
	.long case_shot_captured_ship_243C          | 08: shot my damn ship (DE==8862 ... 8863 counts down from $0F for all steps of explosion)
	.long case_diving_attack_or_loop_2422       | 09: ... after getting to the loop spot, or anytime on a diving attack.

l_reset_index_and_continue_2413:
	subq.b	#1,d4                           	| [dec  e] reset index/pointer to b0 [a1 coherence]

l_2414_inc_active:
	addq.b	#1,ixl                          	| [inc  ixl] b_bugs_actv_cnt++

case_inactive_2416:
l_2416:
											    | [ld   a,#4]
												| [add  a,e]
	addq.b	#4,d4                           	| [ld   e,a] index += 4
	subq.b	#1,d1                           	| [...]
	jne	l_next_object_23EF                      | [djnz l_next_object_23EF] next object
	jbsr	read_ixl_into_d0                    | [ld  a,ixl] b_bugs_actv_cnt
	move.b	d0,b_bugs_actv_cnt              	| [ld  (b_bugs_actv_cnt),a]
	rts                                    	| [ret]

* 09: diving
case_diving_attack_or_loop_2422:
	move.b	d4,d6                           	| [$2422: ld   l,e]
	lea	db_obj_home_posn_rc,a0         			| [$2423: ld   h,#>db_obj_home_posn_rc]
	and.w	#0xFF,d6
	add.w	d6,a0
	move.b	(a0)+,d2                         	| [$2425: ld   c,(hl)] row position index
												| [$2426: inc  l]
	move.b	(a0),d6                         	| [$2427: ld   l,(hl)] column position index
	lea	ds_hpos_loc_offs_9900,a0            	| [$2428: ld   h,#>ds_hpos_loc_offs_9900] .b0
	and.w	#0xFF,d6
	add.w	d6,a0
	move.b	(a0),d0                         	| [$242A: ld   a,(hl)] X coordinate offset
	exg		d0,d7                              	| [$242B: ex   af,af']
	* jotd: code resets HL lsb
	lea	ds_hpos_loc_offs_9900,a0            	| [ld   h,#>ds_hpos_loc_offs_9900] .b0
	move.b	d2,d6                           	| [$242C: ld   l,c] row position index
	add.w	d6,a0
	move.b	(a0),d2                         	| [$242D: ld   c,(hl)] Y coordinate offset

* get a pointer to corresponding element of bug_motion_que[] ... byte-offset (index) in 8800[n].b1
	addq.w	#1,a1                           	| [$242E: inc  e]
	addq.b	#1,d4								| [inc  e] [a1 coherence]
	move.b	(a1),d0                         	| [$242F: ld   a,(de)]
	add.b	#0x11,d0                         	| [$2430: add  a,#0x11] 0x11(ix)
	move.b	d0,d6                           	| [$2432: ld   l,a]
	lea	ds_bug_motion_que_9100,a0           	| [$2433: ld   h,#>ds_bug_motion_que_9100]
	and.w	#0xFF,d6
	add.w	d6,a0
	exg		d0,d7                              	| [$2435: ex   af,af']
	move.b	d0,(a0)+                         	| [$2436: ld   (hl),a] X coordinate offset
	addq.b	#1,d6								| [$2437: inc  l] 0x12(ix) [a0 coherence]
	move.b	d2,(a0)                         	| [$2438: ld   (hl),c] y coordinate offset
	jra	l_reset_index_and_continue_2413         | [$2439: jp   l_reset_index_and_continue_2413] reset index to .b0 and continue

* 08: destruction of the ship
case_shot_captured_ship_243C:
	lea	ds_sprite_code_8B00,a0              	| [$243C: ld   h,#>ds_sprite_code_8B00]
	move.b	d4,d6                           	| [$243E: ld   l,e]
	and.w	#0xFF,d6
	add.w	d6,a0
	addq.w	#1,a1                           	| [inc  e]
	addq.b	#1,d4					            | [$243F: inc  e] [a1 coherence]
	move.b	(a1),d0                         	| [$2440: ld   a,(de)] obj_status[].mctl_q_index used for explosion counter
	subq.b	#1,d0                           	| [$2441: dec  a]
	jeq	l_2451                             	    | [$2442: jr   z,l_2451] the counter (odd-byte) counts down to 0 (from $F) during explosion
	move.b	d0,(a1)                         	| [$2444: ld   (de),a]
	subq.w	#1,a1                           	| [$2445: dec  e]
	subq.b	#1,d4					            | [dec  e] [a1 coherence]
	and.b	#0x03,d0                         	| [$2446: and  #0x03]
	jne	l_2416                             	    | [$2448: jr   nz,l_2416]
	move.b	(a0),d0                         	| [$244A: ld   a,(hl)]
	addq.b	#4,d0                           	| [$244B: add  a,#4]
	move.b	d0,(a0)                         	| [$244D: ld   (hl),a]
	jra	l_2416                             	    | [$244E: jp   l_2416]

l_2451:
	COMPUTE_LSB_A0_D6	ds_sprite_code_8B00
	lea	ds_sprite_posn_9300,a0              	| [ld   h,#>ds_sprite_posn_9300]
	and.w	#0xFF,d6
	add.w	d6,a0
	clr.b	d0                               	| [xor  a]
	move.b	d0,(a0)                         	| [ld   (hl),a]
	lea	ds_sprite_ctrl_9B00,a0              	| [ld   h,#>ds_sprite_ctrl_9B00]
	and.w	#0xFF,d6
	add.w	d6,a0
	move.b	d0,(a0)                         	| [ld   (hl),a]
	subq.b	#1,d4					            | [dec  e]
	move.b	#0x80,d0                        	| [ld   a,#0x80] set inactive code
	move.b	d0,-(a1)                         	| [ld   (de),a]
	jra	l_2416                             	    | [jp   l_2416]

* 02: reached home and rotating into resting position
case_rotating_into_collective_245F:
	move.b	d4,d6                           	| [$245F: ld   l,e]
	lea	ds_sprite_ctrl_9B00,a0              	| [$2461: ld   h,#>ds_sprite_ctrl_9B00]
	and.w	#0xFF,d6
	add.w	d6,a0
	move.b	(a0),d0                         	| [$2462: ld   a,(hl)]
	lea	ds_sprite_code_8B00,a0              	| [$2465: ld   h,#>ds_sprite_code_8B00]
	and.w	#0xFF,d6
	add.w	d6,a0
	and.b	#0x01,d0                         	| [$2463: and  #0x01] test flip X
	jne	l_2473                             	    | [$2467: jr   nz,l_2473]
	move.b	(a0),d0                         	| [$2469: ld   a,(hl)]
	and.b	#0x07,d0                         	| [$246A: and  #0x07]
	cmp.b	#6,d0                            	| [$246C: cp   #6]
	jeq	l_2483                             	    | [$246E: jr   z,l_2483]
	addq.b	#1,(a0)                         	| [$2470: inc  (hl)]
	jra	l_249B                             	    | [$2471: jr   l_249B]

l_2473:
	move.b	(a0),d0                         	| [$2473: ld   a,(hl)]
	and.b	#0x07,d0                         	| [$2474: and  #0x07]
	jne	l_2480                             	    | [$2476: jr   nz,l_2480]
	lea	ds_sprite_ctrl_9B00,a0              	| [$2478: ld   h,#>ds_sprite_ctrl_9B00]
	and.w	#0xFF,d6
	add.w	d6,a0
	bclr.b	#0,(a0)                         	| [$247A: res  0,(hl)]
	*lea	ds_sprite_code_8B00,a0              | [$247C: ld   h,#>ds_sprite_code_8B00] not used
	*and.w	#0xFF,d6
	*add.w	d6,a0
	jra	l_249B                             	    | [$247E: jr   l_249B]

l_2480:
	subq.b	#1,(a0)                         	| [$2480: dec  (hl)]
	jra	l_249B                             	    | [$2481: jr   l_249B]

l_2483:
	move.b	#1,d0                           	| [$2483: ld   a,#1] disposition = 1: home
	move.b	d0,(a1)                         	| [$2485: ld   (de),a]
	jra	l_249B                             	    | [$2486: jr   l_249B]

* 01: assimilated into the collective
case_assimilated_into_collective_2488:
	lea	ds_sprite_code_8B00,a0              	| [$2488: ld   h,#>ds_sprite_code_8B00]
	move.b	d4,d6                           	| [$248A: ld   l,e]
	and.w	#0xFF,d6
	add.w	d6,a0
* alternate between tile code 6 and 7 every 1/2 sec: rotate bit-1 of 4 Hz timer into Cy
* and then rl the Cy into bit-0 of sprite code
	move.b	ds3_frame_cts_92A0+2,d0         	| [$248B: ld   a,(ds3_frame_cts_92A0 + 2)]
	move.b	(a0),d7
	ror.b	#1,d7                          	    | [$248E: rrc  (hl)]
	ror.b	#2,d0                               | [$2490: rrca] * 2
	SET_X_FROM_C
	roxl.b	#1,d7                         	    | [$2492: rl   (hl)]
	move.b	d7,(a0)
	move.b	ds_9200_glbls+0x0B,d0           	| [$2494: ld   a,(ds_9200_glbls + 0x0B)] update stuff if enemy enable set
	                               	            | [$2497: and  a]
	jeq	l_2414_inc_active                  	    | [$2498: jp   z,l_2414_inc_active]

l_249B:
	lea	db_obj_home_posn_rc,a0         	        | [$249B: ld   h,#>db_obj_home_posn_rc]
	and.w	#0xFF,d6
	add.w	d6,a0
	move.b	(a0)+,d2                         	| [$249D: ld   c,(hl)] row position index
	                           	                | [$249E: inc  l]
	move.b	(a0),d6                         	| [$249F: ld   l,(hl)] column position index
	lea	ds_hpos_spcoords_9800,a0            	| [$24A0: ld   h,#>ds_hpos_spcoords_9800] L == offset to MSB
	and.w	#0xFF,d6
	add.w	d6,a0
	move.b	(a0),d0                         	| [$24A2: ld   a,(hl)]
	lea	ds_sprite_posn_9300,a1              	| [$24A3: ld   d,#>ds_sprite_posn_9300]
	and.w	#0xFF,d4
	add.w	d4,a1
	move.b	d0,(a1)+                         	| [$24A5: ld   (de),a] X pix coordinate
	addq.b	#1,d4                           	| [$24A6: inc  e] [a1 coherence]
	move.b	d2,d6                           	| [$24A7: ld   l,c] row position index
	lea	ds_hpos_spcoords_9800,a0            	| offset to MSB again
	add.w	d6,a0
	move.b	(a0)+,d0                         	| [$24A8: ld   a,(hl)] (+inc l)
	move.b	d0,(a1)                         	| [$24A9: ld   (de),a] Y pix coordinate
	lea	ds_sprite_ctrl_9B00,a1              	| [$24AA: ld   d,#>ds_sprite_ctrl_9B00] sprite.ctrl[n].sY (bit 8 into MSB)
	add.w	d4,a1
	addq.b	#1,d6                           	| [$24AC: inc  l] [a0 coherence]
	move.b	(a0),d0                         	| [$24AD: ld   a,(hl)]
	move.b	d0,(a1)                         	| [$24AE: ld   (de),a]
	jra	l_reset_index_and_continue_2413         | [$24AF: jp   l_reset_index_and_continue_2413] reset index to .b0 and continue

* 04: rckt_hit_hdlr
* here handles enemy explosion: called at each explosion stage
case_nearly_fatally_shot_24B2:
	move.b	d4,d6                           	| [$24B2: ld   l,e] will be used below!
	addq.w	#1,a1                           	| [$24B3: inc  e] .b1
	addq.b	#1,d4                           	| [inc  e] [a1 coherence]
	move.b	(a1),d0                         	| [$24B4: ld   a,(de)] b8800_obj_status[ E ].obj_idx (explosion count, see f_update_enemy_status_1db3)
* if count == 45 then finish
	cmp.b	#0x45,d0                         	| [$24B5: cp   #0x45]
	jeq	l_24E6_i_am_at_45                  	    | [$24B7: jr   z,l_24E6_i_am_at_45] set by f_update_enemy_status_1db3
	addq.b	#1,d0                           	| [$24B9: inc  a]
	move.b	d0,(a1)                         	| [$24BA: ld   (de),a] 8800[odd]++ ... (40 -> 41, 42, 43, 44, 45 ) explosion changing
	subq.w	#1,a1                           	| [$24BB: dec  e]
	subq.b	#1,d4                           	| [dec  e] [a1 coherence]
* if count == 44 then code = count + 3
	cmp.b	#0x45,d0                         	| [$24BC: cp   #0x45]
	jne	l_24C2                             	    | [$24BE: jr   nz,l_24C2]
	addq.b	#3,d0                           	| [$24C0: add  a,#3] end of explosion
l_24C2:
* if count < 44 then code = count
	cmp.b	#0x44,d0                         	| [$24C2: cp   #0x44]
	jne	l_24E0                             	    | [$24C4: jr   nz,l_24E0]

* sprite.posn[ L ].b0 -= 8
	lea	ds_sprite_posn_9300,a0              	| [$24C6: ld   h,#>ds_sprite_posn_9300] .b0
	and.w	#0xFF,d6
	add.w	d6,a0
	exg		d7,d0                              	| [$24C8: ex   af,af'] stash this till after the l_24DA
	move.b	(a0),d0                         	| [$24C9: ld   a,(hl)]
	sub.b	#8,d0                            	| [$24CA: sub  #8]
	move.b	d0,(a0)+                         	| [$24CC: ld   (hl),a]
	* no need to update D6     	                | [$24CD: inc  l] .b1
												| [$24CE: ld   a,(hl)]
* subtract only in bits<7:0> then flip b9 on Cy
	COMPUTE_LSB_A0_D6	ds_sprite_posn_9300		| pre-compute d6
	sub.b	#8,(a0)                            	| [$24CF: sub  #8]
	* no need to use register & we need C flag  | [$24D1: ld   (hl),a]
	jcc	l_24DA                             		| [$24D2: jr   nc,l_24DA]
	lea	ds_sprite_ctrl_9B00,a0              	| [$24D4: ld   h,#>ds_sprite_ctrl_9B00] killed boss that had the ship in the demo (not in game?)
	add.w	d6,a0
	move.b	(a0),d0                         	| [$24D6: ld   a,(hl)]
	eor.b	#0x01,d0                         	| [$24D7: xor  #0x01]
	move.b	d0,(a0)                         	| [$24D9: ld   (hl),a]
l_24DA:
	subq.b	#1,d6                           	| [$24DA: dec  l] .b0 [a0 coherence]
	lea	ds_sprite_ctrl_9B00,a0              	| [$24DB: ld   h,#>ds_sprite_ctrl_9B00]
	add.w	d6,a0
	move.b	#0x0C,(a0)                      	| [$24DD: ld   (hl),#0x0C]
	exg		d7,d0                               | [$24DF: ex   af,af'] unstash A which is the count
l_24E0:
	lea	ds_sprite_code_8B00,a0              	| [$24E0: ld   h,#>ds_sprite_code_8B00]
	and.w	#0xFF,d6
	add.w	d6,a0
	move.b	d0,(a0)                         	| [$24E2: ld   (hl),a]
	jra	l_2416                             	    | [$24E3: jp   l_2416]

l_24E6_i_am_at_45:
	subq.b	#1,d4                           	| [dec  e] [a1 coherence]
	subq.w	#1,a1                           	| [$24E6: dec  e] restore pointer to .b0
	lea	b_obj_collsn_notif_9200,a0     	        | [$24E7: ld   h,#>b_obj_collsn_notif_9200] 1?
	and.w	#0xFF,d6
	add.w	d6,a0
	move.b	(a0),d0                         	| [$24E9: ld   a,(hl)] .b0 ... stash the code for l_24FD
* if 1 ... (not special sprite code)
	cmp.b	#0x01,d0                         	| [$24EA: cp   #0x01] hit-status register at 9200[i]==$01, unless it shows small score indicator
	jne	l_24FD                             	    | [$24EC: jr   nz,l_24FD]
* ... then ...
	lea	ds_sprite_posn_9300,a0              	| [$24EE: ld   h,#>ds_sprite_posn_9300]
	add.w	d6,a0
	clr.b	(a0)                             	| [$24F0: ld   (hl),#0]
	lea	ds_sprite_ctrl_9B00,a0              	| [$24F2: ld   h,#>ds_sprite_ctrl_9B00]
	add.w	d6,a0
	clr.b	(a0)                             	| [$24F4: $24F4: ld   (hl),#0]
	lea	b_8800,a0                      	        | [$24F6: $24F6: ld   h,#>b_8800]
	add.w	d6,a0
	move.b	#0x80,(a0)                      	| [$24F8: ld   (hl),#0x80] $80 is code for inactive sprite
	jra	l_2416                             	    | [$24FA: jp   l_2416]

* Show the sprite with the small score text for shots that award bonus points:
*  Boss .. $35 (400)  $37 (800)  $3A (1600)  ... see d_1CFD
*  all 8 on bonus round are destroyed ($38 ... 1000 pts)----
*  all 3 bonus-bee destroyed  ($38 ... 1000 pts)
*  flying rogue ship (9202)..($38 .. 1000 pts)
l_24FD:
* code set at l_08B0 determines bonus text sprite code
	lea	ds_sprite_code_8B00,a0              	| [$24FD: : ld   h,#>ds_sprite_code_8B00]
	and.w	#0xFF,d6
	add.w	d6,a0
	move.b	d0,(a0)                         	| [$24FF: ld   (hl),a] sprite_cclr[L].code = obj_collsn_notif[L]
	cmp.b	#0x37,d0                         	| [$2500: cp   #0x37] if code < 37, goto 250E
	jcs	l_250E                             	    | [$2502: jr   c,l_250E]
	move.b	#0x0D,d2                        	| [$2504: ld   c,#0x0D] color
	addq.w	#1,a0                           	| [$2506: inc  l]
	addq.b	#1,d6                           	| [inc  l] coherence
	cmp.b	#0x3A,d0                         	| [$2507: cp   #0x3A]
	jcs	l_250C                             	    | [$2509: jr   c,l_250C] if code < 3A, goto 250C
	addq.b	#1,d2                           	| [$250B: inc  c] color++

l_250C:
	move.b	d2,(a0)                         	| [$250C: ld   (hl),c] sprite_cclr[L].clr=c
	subq.w	#1,a0                           	| [$250D: dec  l]
	subq.b	#1,d6                           	| [dec  l] [a0 coherence]
l_250E:
	lea	ds_sprite_posn_9300,a0              	| [$250E: ld   h,#>ds_sprite_posn_9300]
	and.w	#0xFF,d6
	add.w	d6,a0
	move.b	#8,d2                           	| [$2510: ld   c,#8]
	cmp.b	#0x3B,d0                         	| [$2512: cp   #0x3B]
	jcc	l_251C                             	    | [$2514: jr   nc,l_251C] if code >= 3B, goto 251C
	clr.b	d2                               	| [$2516: ld   c,#0]
	move.b	(a0),d0                         	| [$2518: ld   a,(hl)]
	add.b	#8,d0                            	| [$2519: add  a,#8]
	move.b	d0,(a0)                         	| [$251B: ld   (hl),a]
l_251C:
	addq.w	#1,a0                           	| [$251C: inc  l]
	addq.b	#1,d6                           	| [inc  l]  [a0 coherence]
	move.b	(a0),d0                         	| [$251D: ld   a,(hl)]
	add.b	#0x08,d0                         	| [$251E: add  a,#0x08]
	scs		d7
	move.b	d0,(a0)                         	| [$2520: ld   (hl),a]
	lea	ds_sprite_ctrl_9B00,a0              	| [$2521: ld   h,#>ds_sprite_ctrl_9B00]
	and.w	#0xFF,d6
	add.w	d6,a0
* mrw_sprite.cclr[ L ].b1 ^= (0 != AF.pair.b1)|
	tst.b	d7
	jeq	l_2529                             	    | [$2523: jr   nc,l_2529]
	move.b	(a0),d0                         	| [$2525: ld   a,(hl)]
	eor.b	#0x01,d0                         	| [$2526: xor  #0x01]
	move.b	d0,(a0)                         	| [$2528: ld   (hl),a]
l_2529:
	subq.b	#1,d6                           	| [$2529: dec  l] [a0 coherence]
	move.b	d2,-(a0)                         	| [$252A: ld   (hl),c]
	
	lea	b_8800,a0                      	        | [$252B: ld   h,#>b_8800]
	and.w	#0xFF,d6
	add.w	d6,a0
	move.b	#5,(a0)+                         	| [$252D: ld   (hl),#5] state 05 (showing score bitmap)
	addq.b	#1,d6                           	| [$252F: inc  l]  [a0 coherence]
	move.b	#0x13,(a0)                      	| [$2530: ld   (hl),#0x13] down counter for score bitmap
	jra	l_2416                             	    | [$2532: jp   l_2416]

* 05: shot boss, showing the score bitmap
case_show_score_2535:
* pointer to b8800_obj_status[ L ] from DE
* b8800_obj_status[ L ].obj_idx-- ... count for score bitmap
	moveq	#0,d6
	move.b	d4,d6                           	| [$2535: ld   l,e]
	addq.w	#1,d6                           	| [$2536: inc  l] [a0 coherence]
	lea		b_8800,a0                           | [$2537: ld   h,d]
	add.w	d6,a0						
	subq.b	#1,(a0)                         	| [$2538: dec  (hl)] down counter for score bitmap
	jne	l_2416                             	    | [$2539: jp   nz,l_2416]
	subq.b	#1,d6                           	| [$253C: dec  l] [a0 coherence]
	move.b	#0x80,-(a0)                      	| [$253D: ld   (hl),#0x80] disposition = inactive
	lea	ds_sprite_posn_9300,a0              	| [$253F: ld   h,#>ds_sprite_posn_9300]
	and.w	#0xFF,d6
	add.w	d6,a0
	clr.b	(a0)                             	| [$2541: ld   (hl),#0]
	lea	ds_sprite_ctrl_9B00,a0              	| [$2543: ld   h,#>ds_sprite_ctrl_9B00]
	and.w	#0xFF,d6
	add.w	d6,a0
	clr.b	(a0)                             	| [$2545: ld   (hl),#0]
* hmmm seems like we already done this ...
	move.b	#0x80,d0                        	| [$2547: ld   a,#0x80]
	move.b	d0,(a1)                         	| [$2549: ld   (de),a]
	jra	l_2416                             	    | [$254A: jp   l_2416]

* 3 or 6: terminate cylons or bombs that have gone past the sides or bottom of screen
case_state_progression_254D:
	lea	ds_sprite_posn_9300,a0              	| [ld   h,#>ds_sprite_posn_9300] read directly from SFRs (not buffer RAM)
	move.b	d4,d6                           	| [ld   l,e] object offset
	and.w	#0xFF,d6
	bset.b	#7,d6                           	| [set  7,l] +=$80 ... set pointer to read directly from the SFR
	add.w	d6,a0
	move.b	(a0),d0                         	| [ld   a,(hl)]
	cmp.b	#0xF4,d0                         	| [cp   #0xF4]
* if (posn.x > $F4) ... skip check Y
	jcc	l_2571                             	| [jr   nc,l_2571]
	addq.w	#1,a0                           	| [inc  l]
	addq.b	#1,d6                           	| [inc  l] [a0 coherence]
	move.b	(a0),d2                         	| [ld   c,(hl)] sprite_posn.y<0:7>
	lea	ds_sprite_ctrl_9B00,a0              	| [ld   h,#>ds_sprite_ctrl_9B00]
	and.w	#0xFF,d6
	add.w	d6,a0
	move.b	(a0),d0                         	| [ld   a,(hl)] sprite_posn.y<8>
	subq.w	#1,a0                           	| [dec  l]
	subq.b	#1,d6                           	| [dec  l] [a0 coherence]
	ror.b	#1,d0                            	| [rrca] sprite_posn.y<8> into Cy
	SET_X_FROM_C
	move.b	d2,d0                           	| [ld   a,c]
	roxr.b	#1,d0                           	| [rra] sprite_posn.y<8:1> in A
	cmp.b	#22>>1,d0			| cp   #22 >> 1                              | 0x0B
	jcs	l_2571                             	| [jr   c,l_2571]
	cmp.b	#330>>1,d0				| cp   #330 >> 1                             | 0xA5
	jcc	l_2571                             	| [jr   nc,l_2571]

* in range ... if not a bomb then go increment count
	move.b	(a1),d0                         	| [ld   a,(de)] b_8800[e].obj_status
	cmp.b	#6,d0                            	| [cp   #6]
	jne	l_2414_inc_active                  	    | [jp   nz,l_2414_inc_active] if not a bomb
	jra	l_2416                             	    | [jp   l_2416] it's a bomb

l_2571:
	sub.b	#0x80,d6                 	        | [res  7,l]  subs 0x80 to l
	sub.w	#0x80,a0                 	        | [res  7,l]
	move.b	(a1),d0                         	| [ld   a,(de)]
	cmp.b	#3,d0                            	| [cp   #3] check if flying bug object
	jeq	l_2582_kill_bug_q_slot             	    | [jr   z,l_2582_kill_bug_q_slot] if bug object

l_2578_mk_obj_inactive:
	move.b	#0x80,d0                        	| [ld   a,#0x80]
	move.b	d0,(a1)                         	| [ld   (de),a]
	lea	ds_sprite_posn_9300,a0              	| [ld   h,#>ds_sprite_posn_9300]
	and.w	#0xFF,d6
	add.w	d6,a0
	clr.b	(a0)                             	| [ld   (hl),#0]
	jra	l_2416                             	    | [jp   l_2416]

l_2582_kill_bug_q_slot:
							                    | [$2582: inc  e]
	move.b	(1,a1),d0                         	| [$2583: ld   a,(de)] b_8800[e].motion_q_idx
							                    | [$2584: dec  e]
	add.b	#0x13,d0                         	| [$2585: add  a,#0x13]
	move.b	d0,d6                           	| [$2587: ld   l,a]
	lea	ds_bug_motion_que_9100,a0           	| [$2588: ld   h,#>ds_bug_motion_que_9100]
	and.w	#0xFF,d6
	add.w	d6,a0
	clr.b	(a0)                             	| [$258A: ld   (hl),#0] e.g. "0x13(ix)"

	lea	ds_bug_motion_que_9100,a0
	move.b	d4,d6                           	| [$258C: ld   l,e]
	add.w	d6,a0
	jra	l_2578_mk_obj_inactive             		| [$258D: jp   l_2578_mk_obj_inactive]

* 07: once for each orc as he is spawning (new stage)
case_spawning_orc_2590:
	move.b	#3,d0                           	| [$2590: ld   a,#3]
	move.b	d0,(a1)                         	| [$2592: ld   (de),a] disposition = 3 ... from 7 (spawning)
	jra	l_2414_inc_active                  	    | [$2593: jp   l_2414_inc_active]

l_2596_even_frame:
* if ( framect & 0x02 ) ...
	btst.b	#1,d0                           	| [bit  1,a] frame_count
	bne.b	0f                               	| [...]
	rts                                    	| [ret  z] [...]
0:
* ... update object_count
	lea	b_bugs_actv_cnt,a0             	        | [ld   hl,#b_bugs_actv_cnt] store active_objects_nbr and clear the object count
	move.b	(a0),d0                         	| [ld   a,(hl)]
	clr.b	(a0)+                             	| [ld   (hl),#0]
	addq.b	#1,d6              	                | [inc  l]
	move.b	d0,(a0)                         	| [ld   (hl),a] b_bugs_actv_nbr = bugs_actv_cnt
	rts                                    	    | [ret]

*=============================================================================
* void gctl_stg_new_atk_wavs_init()
*  Description:
*   Setup the mob to do its evil work. Builds up 5 configuration tables at
*   b_8920 which organizes the mob objects into the flying waves.
*   These are formed into the attack wave queue structures by f_insert_attackers_2916().
*   The format is oriented toward having two flights of 4 creatures in each
*   wave, so they are configured in pairs and I refer to as "lefty" and "righty"
*   in each pair, although it is an arbitrary designation. In waves that fly
*   in a single trailing formation, they are still treated as pairs, but the
*   timing has to be managed to maintain uniform spacing. so there is
*   an additional flag in the control data byte of the lefty that causes a
*   delay before the entry of each righty.
* IN:
*  ...
* OUT:
*  ...
*-----------------------------------------------------------------------------
gctl_stg_new_atk_wavs_init_25a2:
	lea	db_attk_wav_IDs,a0                  	| [$25A2: ld   hl,#db_attk_wav_IDs]
	move.l	a0,pb_attk_wav_IDs              	| [$25A5: ld   (pb_attk_wav_IDs),hl]

* calculate pointer into data table:
*  set A as offset into table using stage count,
*  set DE as base pointer to data, either combat data or challenge stage data

* if past the highest stage ($17) we can only keep playing the last 4 levels
	move.b	ds_plyr_actv+_b_stgctr,d0       	| [$25A8: ld   a,(ds_plyr_actv +_b_stgctr)] stage build caravan tables
	move.b	d0,d2                           	| [$25AB: ld   c,a] stash it for is_challg_stg

* while ( A > $17 ) ...
l_25AC_while:
	cmp.b	#0x17,d0                         	| [$25AC: cp   #0x17] 23 - ( 23 % 4 ) - 1 == 17 ... nbr of level indices
	jcs	l_25B4                               	| [$25AE: jr   c,l_25B4]
* ... do ...
	subq.b	#4,d0                           	| [$25B0: sub  #4]
	jra	l_25AC_while                       	    | [$25B2: jr   l_25AC_while]

* if ( ! challenge stage ) ...
l_25B4:
	move.b	d0,d1                           	| [$25B4: ld   b,a] adjusted level
	addq.b	#1,d0                           	| [$25B5: inc  a]
	and.b	#0x03,d0                         	| [$25B6: and  #0x03]
	jeq	l_25D3_is_challg_stg               	    | [$25B8: jr   z,l_25D3_is_challg_stg]

* ... then ...
* HL = &idx_tbl[ rank * 17 ][ 0 ] ... select index table row, by rank
	move.b	b_mchn_cfg_rank_9984,d0              	| [$25BA: ld   a,(b_mchn_cfg_rank_9984)]
	move.b	#17,d6                          	| [$25BD: ld   l,#17]
	jbsr	c_104E_mul_16_8                   	| [$25BF: call c_104E_mul_16_8] L = rank * 17
	move.b	d6,d0                           	| [$25C2: ld   a,l]
	lea	d_combat_stg_dat_idx,a0        	        | [$25C3: ld   hl,#d_combat_stg_dat_idx]
	jbsr	add_d0_to_a0_0010                   | [$25C6: rst  0x10] HL += A
	lea	d_combat_stg_dat,a1            	        | [$25C7: ld   de,#d_combat_stg_dat] base data ptr

* set offset into index table @row ... index = level - ( level % 4 ) - 1
	move.b	d1,d0                           	| [$25CA: ld   a,b] adjusted level
	lsr.b	#2,d1                            	| [$25CB: srl  b] 2 shifts and the sub ... %4 * 2
	sub.b	d1,d0                            	| [$25CF: sub  b]
	subq.b	#1,d0                           	| [$25D0: dec  a]
	jra	l_25E0_set_data_ptr                	    | [$25D1: jr   l_25E0_set_data_ptr]

* base ptr for challenge stg ... only 1 index table to work with (no rank selection) e.g.
*  ptr = d_idx[ stage / 4  &  $07 ]
l_25D3_is_challg_stg:
	lea	d_challg_stg_data_idx,a0       	        | [$25D3: ld   hl,#d_challg_stg_data_idx]
	move.b	d2,d0                           	| [$25D6: ld   a,c] stage_counter
	lsr.b	#2,d0                            	| [$25D7: srl  a] * 2
	and.b	#0x07,d0                         	| [$25DB: and  #0x07] 8 elements in index table
	lea	d_challg_stg_dat,a1            	        | [$25DD: ld   de,#d_challg_stg_dat] base data ptr


l_25E0_set_data_ptr:

* HL == stg_data_idx + row * 17 ... where row is rank
* A  == offset into stg data idx
* DE == &_stg_dat[0]

* p_data_tabl_row = &data_tbl[ data_row_offset ]
	jbsr	add_d0_to_a0_0010                   | [$25E0: rst  0x10] HL += A
	move.b	(a0),d0                         	| [$25E1: ld   a,(hl)] A = data_row_offset = idx_tbl[ A ]
	exg	a1,a0                              	    | [$25E2: ex   de,hl] HL = _stg_dat[0]
	jbsr	add_d0_to_a0_0010                   | [$25E3: rst  0x10] HL += A

* First, load bomb-control params from the 2 byte header (once per stage).

* stg_parm_0E[ 0 ] = _stg_dat[row][0]
	move.b	(a0),d0                         	| [$25E4: ld   a,(hl)]
	addq.w	#1,a0                           	| [$25E5: inc  hl]
	move.b	d0,b_92E2+0x00                  	| [$25E6: ld   (b_92E2 + 0x00),a] _stg_dat[0]
* stg_parm_0F[ 1 ] = _stg_dat[row][1]
	move.b	(a0),d0                         	| [$25E9: ld   a,(hl)]
	addq.w	#1,a0                           	| [$25EA: inc  hl]
	move.b	d0,b_92E2+0x01                  	| [$25EB: ld   (b_92E2 + 0x01),a] _stg_dat[1] ... loaded to 0x0f(ix)

* Initialize table of attack-wave structs with start token of 1st group
	lea	ds_8920,a1                     	        | [$25EE: ld   de,#ds_8920] attk_waves[n] = $7E
	move.b	#0x7E,d0                        	| [$25F1: ld   a,#0x7E] start token of each group
	move.b	d0,(a1)+                         	| [$25F3: ld   (de),a]
												| [$25F4: inc  e]

* The 2-byte header is followed by a series of 8 structs of 3-bytes each
* which establish the parameters of each attack wave. The first of 3-bytes
* determines the presence of "transients" in the attack wave (and is
* the control variable for the following while() block)

l_25F5_while_not_end_stg_dat:

* while ( 0xFF != _stg_dat[n] )
	move.b	(a0)+,d0                         	| [$25F5: ld   a,(hl)] A = _stg_dat[ 2 + 3 * n ]
												| [$25F6: inc  hl] HL = &_stg_dat + 2 + 3 * n + 1
	cmp.b	#0xFF,d0                         	| [$25F7: cp   #0xFF] check for end token, stage data
	jeq	l_2681_end_of_table                	    | [$25F9: jp   z,l_2681_end_of_table]
	move.b	d0,d2                           	| [$25FC: ld   c,a] A = _stg_dat[ 2 + 3 * n ]
	movem.w	d3/d4,-(sp)                    	    | [$25FD: push de] DE == &ds_8920[e]
	move.l	a1,-(sp)                        	| [$25FD: push de] DE == &ds_8920[e]
	move.l	a0,-(sp)                        	| [$25FE: push hl] HL == &_stg_dat[ 2 + 3 * n + 1 ]

* memset(tmp_buf, $ff, 16)
	lea	ds_atk_wav_tmp_buf_9100,a0          	| [$25FF: ld   hl,#ds_atk_wav_tmp_buf_9100] memset(..., $ff, $10) ...tmp array for assembling object IDs for each wave
	st.b	d0                                	| [$2602: ld   a,#0xFF]
	move.b	#0x10,d1                        	| [$2604: ld   b,#0x10]
	jbsr	rst_18                            	| [$2606: rst  0x18] memset((HL), A=fill, B=ct)

* if ( 0 != ( _stg_dat[ 2 + 3 * n + 0 ] ) & 0x0F ) ...
	move.b	d2,d0                           	| [$2607: ld   a,c] A = _stg_dat[ 2 + 3 * n + 0 ]
	and.b	#0x0F,d0                         	| [$2608: and  #0x0F]
	jeq	l_2636                             	    | [$260A: jr   z,l_2636]

* ... then ...
	move.b	d0,d1                           	| [$260C: ld   b,a] sets the loop count ... after first bonus-round
	lsr.b	#1,d0                            	| [$260D: srl  a]
	addq.b	#4,d0                           	| [$260F: add  a,#4]
	move.b	d0,d4                           	| [$2611: ld   e,a]
l_2612:
j_2612:
	jbsr	c_1000                            	| [$2612: call c_1000] randomizer
	move.b	d0,d6                           	| [$2615: ld   l,a]
	clr.b	d5                               	| [$2616: ld   h,#0]
	move.b	d4,d0                           	| [$2618: ld   a,e]
	jbsr	c_divmod                          	| [$2619: call c_divmod] HL=HL/E
	btst.b	#0,d1                           	| [$261C: bit  0,b]
	jeq	l_2622                             	    | [$261E: jr   z,l_2622]
	bset.b	#3,d0                           	| [$2620: set  3,a]
l_2622:
	lea	ds_atk_wav_tmp_buf_9100,a0          	| [$2622: ld   h,#>ds_atk_wav_tmp_buf_9100] tmp_buf[ A ]
	move.b	d0,d6                           	| [$2624: ld   l,a]
	and.w	#0xFF,d6
	add.w	d6,a0
	move.b	(a0),d0                         	| [$2625: ld   a,(hl)]
	addq.b	#1,d0                           	| [$2626: inc  a]
	jne	j_2612                             	    | [$2627: jr   nz,j_2612]
	move.b	d1,d0                           	| [$2629: ld   a,b]
	rol.b	#1,d0                            	| [$262A: rlca]
	rol.b	#1,d2                            	| [$262B: rlc  c]
	jcc	l_2631                             	    | [$262D: jr   nc,l_2631]
	or.b	#0x40,d0                          	| [$262F: or   #0x40]
l_2631:
	or.b	#0x38,d0                          	| [$2631: or   #0x38]
	move.b	d0,(a0)                         	| [$2633: ld   (hl),a]
	subq.b	#1,d1                           	| [...]
	jne	l_2612                             	    | [$2634: djnz l_2612]


* Insert the 8 non-transient bugs into the temporary attack wave (object IDs of
* bugs that have a final home positions).... $FFs remain in unused slots, e.g.
*   0x58,0x5A,0x5C,0x5E,0xFF,0xFF,0xFF,0xFF,0x28,0x2A,0x2C,0x2E,0xFF,0xFF,0xFF,0xFF,

l_2636:
	lea	ds_atk_wav_tmp_buf_9100,a0          	| [$2636: ld   hl,#ds_atk_wav_tmp_buf_9100]
	move.l	pb_attk_wav_IDs,a1          	    | [$2639: ld   de,(pb_attk_wav_IDs)]
	move.b	#8,d1                           	| [$263D: ld   b,#8]

l_263F_while_b:
j_263F_skip_until_ff:
	move.b	(a0),d0                         	| [$263F: ld   a,(hl)]
	cmp.b	#0xFF,d0                         	| [$2640: cp   #0xFF] check for unused position in tmp buffer
	jeq	l_2647_is_ff                       	    | [$2642: jr   z,l_2647_is_ff]
	addq.w	#1,a0                           	| [$2644: inc  hl] skip if not $ff
	jra	j_263F_skip_until_ff               	    | [$2645: jr   j_263F_skip_until_ff]

l_2647_is_ff:
	move.b	(a1)+,(a0)+                         | [$2647: ld   a,(de)] attk_wav_IDs[e]
												| [$2648: ld   (hl),a] atk_wav_tmp_buf[l] = attk_wav_IDs[e]
												| [$2649: inc  de]
												| [$264A: inc  hl]
	move.b	d1,d0                           	| [$264B: ld   a,b] loop count
	cmp.b	#5,d0                            	| [$264C: cp   #5]
	jne	l_2652                             	    | [$264E: jr   nz,l_2652] if ct > 4 ... skip to atk_wav_tmp_buf[ l + 8 ]
	lea		ds_atk_wav_tmp_buf_9100+8,a0        | [$2650: ld   l,#8] alignment to $0100 boundary!
l_2652:
	subq.b	#1,d1                           	| [...]
	jne	l_263F_while_b                     	    | [$2652: djnz l_263F_while_b]
	move.l	a1,pb_attk_wav_IDs              	| [$2654: ld   (pb_attk_wav_IDs),de] &db_attk_wav_IDs[ 8 * n ]
	move.l	(sp)+,a0                        	| [$2658: pop  hl] HL == &_stg_dat[ 2 + 3 * n + 1 ]
	move.l	(sp)+,a1                        	| [$2659: pop  de] DE == &ds_8920[ $11 * n ]
	movem.w	(sp)+,d3/d4                    	    | [pop  de] DE == &ds_8920[ $11 * n ]
	move.b	(a0)+,d1                         	| [$265A: ld   b,(hl)]
	                           	                | [$265B: inc  hl]
	move.b	(a0)+,d2                         	| [$265C: ld   c,(hl)] HL == &_stg_dat[ 2 + 3 * n + 2 ]
	                           	                | [$265D: inc  hl]
	move.l	a0,-(sp)                        	| [$265E: push hl] HL == &_stg_dat[ 2 + 3 * n + 0 ] ... next n

* tmp buffer looks like this with transients inserted at 'x' ...  UUUUxxxxVVVVxxxx
* where U and V are IDs loaded from db_attk_wav_IDs (UUUUVVVV)
* Loop X times to copy each pair of "lefty" and "righty" object IDs i.e. " bb uu cc vv"
* ... where B and C are used to select the bug motion depending whether he is a "lefty" or a "righty".
	lea	ds_atk_wav_tmp_buf_9100,a0          	| [ld   hl,#ds_atk_wav_tmp_buf_9100]
l_2662_form_pair:
	move.b	d1,d0                           	| [ld   a,b] bb
	move.b	d0,(a1)                         	| [ld   (de),a]
* read_until_ff
	move.b	(a0),d0                         	| [ld   a,(hl)] UU
	cmp.b	#0xFF,d0                         	| [cp   #0xFF]
	jeq	l_2679_next_wave                   	    | [jr   z,l_2679_next_wave]
	addq.w	#1,a1                           	| [inc  e]
	move.b	d0,(a1)+                         	| [ld   (de),a]
	                           	                | [inc  e]
	move.b	d2,d0                           	| [ld   a,c] cc
	move.b	d0,(a1)+                         	| [ld   (de),a]
										        | [inc  e]
	                           	                | [set  3,l] HL += $08
	move.b	(8,a0),d0                         	| [ld   a,(hl)] VV
	move.b	d0,(a1)+                         	| [ld   (de),a]
	                           	                | [inc  e]
	                           	                | [res  3,l] HL -= $08
	addq.w	#1,a0                           	| [inc  hl]
	jra	l_2662_form_pair                   	    | [jr   l_2662_form_pair]

l_2679_next_wave:
	move.b	#0x7E,d0                        	| [ld   a,#0x7E] start token of each group (will overwrite with 7f if finished)
	move.b	d0,(a1)+                         	| [ld   (de),a]
	                           	| [inc  e] DE = &ds_8920[ $11 * n + 1 ]
	move.l	(sp)+,a0                        	| [pop  hl] &_stg_dat[ 2 + 3 * n + 0 ]
	jra	l_25F5_while_not_end_stg_dat       	| [jp   l_25F5_while_not_end_stg_dat]


l_2681_end_of_table:
* pointer is already advanced, so decrement it so we overwrite the 7E with 7F
	subq.w	#1,a1                           	| [dec  e]

* check capture-mode and two-ship status
	move.b	ds_plyr_actv+_b_bmbr_boss_cflag,d0	| [ld   a,(ds_plyr_actv +_b_bmbr_boss_cflag)] 1 if capture-mode is active
	move.b	d0,d1                           	| [ld   b,a]
	move.b	ds_plyr_actv+_b_2ship,d0        	| [ld   a,(ds_plyr_actv +_b_2ship)]
	subq.b	#1,d0                           	| [dec  a]
	and.b	d1,d0                            	| [and  b]
	jeq	l_26A4_done                        	    | [jr   z,l_26A4_done]
* !capture-mode and !two-ship-status... we have a rogue fighter in the mob.
	move.b	ds_plyr_actv+_b_not_chllg_stg,d0	| [ld   a,(ds_plyr_actv +_b_not_chllg_stg)] ==(stg_ctr+1)%4 ...i.e. 0 if challenge stage
	                               	| [and  a]
	jeq	l_26A4_done                        	| [jr   z,l_26A4_done] doesn't matter on a challenge stage.

	illegal		| screen shit??? check pointers?
* HL = DE-4 ... e.g. 8975-4==8971
	move.w	d3,d5
	subq.w	#4,d5
	                           	| [ld   h,d]
	                           	| [ld   a,e]
	                           	| [sub  #4]
	                           	| [ld   l,a]

	move.b	(a0),d0                         	| [ld   a,(hl)]
	move.b	d0,(a1)+                         	| [ld   (de),a]
	                           	| [inc  e] e.g. DE = 8976
	move.b	#4,d0                           	| [ld   a,#4]
	move.b	d0,(a1)+                         	| [ld   (de),a]
	                           	| [inc  e]
	move.b	#0x80+0x07,d0                   	| [ld   a,#0x80 + 0x07]
	move.b	d0,ds_sprite_code_8B00+0x04          	| [ld   (ds_sprite_code_8B00 + 0x04),a] = $80 + $07

l_26A4_done:
	move.b	#0x7F,d0                        	| [ld   a,#0x7F] end token marker
	move.b	d0,(a1)                         	| [ld   (de),a] ($8920 + $11*5)

	rts                                    	| [ret]


*=============================================================================
* data for gctl_stg_new_atk_wavs_init_25a2
*-----------------------------------------------------------------------------

* Selection indices for stage data ... pre-computed multiples of 18 for row offsets.

* combat levels, e.g. 1,2,5,6,7,9 etc.
* 4 sets... 1 for each rank "B", "C", "D", or "A"
* In each set, one element per stage, i.e. 17 distinct stage configurations (see l_25AC)
* Indices are pre-multiplied (multiples of 0x12, i.e. row length of combat__stg_data)

d_combat_stg_dat_idx:
	.byte 0x00,0x12,0x24,0x36,0x00,0x48,0x6C,0x5A,0x48,0x6C,0x00,0x7E,0xA2,0x90,0xB4,0xD8,0xC6
	.byte 0x00,0x12,0x48,0x6C,0x5A,0x7E,0xA2,0x00,0x7E,0xD8,0xC6,0xB4,0xD8,0xC6,0xB4,0xD8,0xC6
	.byte 0x00,0x12,0x7E,0xA2,0x90,0x7E,0xD8,0xC6,0xB4,0xD8,0xC6,0xB4,0xD8,0xC6,0xB4,0xD8,0xC6
	.byte 0x00,0x12,0x48,0x36,0x24,0x48,0x6C,0x00,0x7E,0xA2,0x90,0xB4,0xD8,0x00,0xB4,0xD8,0xC6

* challenge stage e.g. 3,8,10 etc. 8 unique challenge stages.
d_challg_stg_data_idx:
	.byte 0x00,0x12,0x24,0x36,0x48,0x5A,0x6C,0x7E


* Stage data: each row is 1 level ... 5 waves of bug formations per level

* 2 byte header: ?
* one triplet of bytes for each of the 5 waves:
* byte 0:
*   gctl_stg_new_atk_wavs_init_25a2, controls loading of transients into attack wave table
* byte 1 & 2
*   bit 7     byte-2 only ... if clear, 2nd bug of pair is delayed for trailing formation
*   bit 6     if set selects second set of 3-bytes in db_2A6C[]
*   bits 0:5  index of word in LUT at db_word_address_table_2a3c ( 0x18 entries)
*   bit 0     also, if set,0e(ix) = 0x44 ... finalize_object

* combat stage data
d_combat_stg_dat:
	.byte 0x14,0x00, 0x00,0x00,0x40+0x80, 0x00,0x01,0x01+0x00, 0x00,0x41,0x41+0x00, 0x00,0x40,0x40+0x00, 0x00,0x00,0x00+0x00, 0xFF
	.byte 0x14,0x01, 0x00,0x42,0x02+0x80, 0x00,0x03,0x05+0x80, 0x00,0x43,0x45+0x80, 0x00,0x42,0x44+0x80, 0x00,0x02,0x04+0x80, 0xFF
	.byte 0x14,0x01, 0x82,0x00,0x40+0x80, 0x00,0x01,0x01+0x00, 0x00,0x41,0x41+0x00, 0x02,0x40,0x40+0x00, 0x02,0x00,0x00+0x00, 0xFF
	.byte 0x14,0x01, 0x82,0x02,0x42+0x80, 0x00,0x03,0x05+0x80, 0x00,0x43,0x45+0x80, 0x02,0x42,0x44+0x80, 0x02,0x02,0x04+0x80, 0xFF
	.byte 0x14,0x01, 0x82,0x00,0x40+0x80, 0x00,0x01,0x41+0x80, 0x00,0x41,0x01+0x80, 0x02,0x40,0x00+0x80, 0x02,0x40,0x00+0x80, 0xFF
	.byte 0x14,0x01, 0x82,0x00,0x40+0x80, 0x42,0x01,0x01+0x00, 0xF2,0x41,0x41+0x00, 0x02,0x40,0x40+0x00, 0x02,0x00,0x00+0x00, 0xFF
	.byte 0x14,0x01, 0xA4,0x02,0x42+0x80, 0x52,0x03,0x05+0x80, 0xF2,0x43,0x45+0x80, 0x02,0x42,0x44+0x80, 0x02,0x02,0x04+0x80, 0xFF
	.byte 0x14,0x01, 0x82,0x00,0x40+0x80, 0x52,0x01,0x41+0x80, 0xF2,0x41,0x01+0x80, 0x02,0x40,0x00+0x80, 0x02,0x40,0x00+0x80, 0xFF
	.byte 0x14,0x01, 0xA4,0x00,0x40+0x80, 0x42,0x01,0x01+0x00, 0xF4,0x41,0x41+0x00, 0x04,0x40,0x40+0x00, 0x04,0x00,0x00+0x00, 0xFF
	.byte 0x14,0x01, 0xA4,0x02,0x42+0x80, 0x52,0x03,0x05+0x80, 0xF4,0x43,0x45+0x80, 0x04,0x42,0x44+0x80, 0x04,0x02,0x04+0x80, 0xFF
	.byte 0x14,0x03, 0xA4,0x00,0x40+0x80, 0x54,0x01,0x41+0x80, 0xF4,0x41,0x01+0x80, 0x04,0x40,0x00+0x80, 0x04,0x40,0x00+0x80, 0xFF
	.byte 0x14,0x03, 0xA4,0x00,0x40+0x80, 0x54,0x01,0x01+0x00, 0xF4,0x41,0x41+0x00, 0x04,0x40,0x40+0x00, 0x04,0x00,0x00+0x00, 0xFF
	.byte 0x14,0x03, 0xA4,0x02,0x42+0x80, 0x54,0x03,0x05+0x80, 0xF4,0x43,0x45+0x80, 0x04,0x42,0x44+0x80, 0x04,0x02,0x04+0x80, 0xFF

* challenge stage data
d_challg_stg_dat:
	.byte 0xFF,0x00, 0x00,0x06,0x46+0x80, 0x00,0x07,0x07+0x00, 0x00,0x47,0x47+0x00, 0x00,0x46,0x46+0x00, 0x00,0x06,0x06+0x00, 0xFF
	.byte 0xFF,0x00, 0x00,0x08,0x48+0x80, 0x00,0x09,0x49+0x80, 0x00,0x09,0x49+0x80, 0x00,0x48,0x48+0x00, 0x00,0x08,0x08+0x00, 0xFF
	.byte 0xFF,0x00, 0x00,0x0A,0x4A+0x00, 0x00,0x0B,0x4B+0x80, 0x00,0x0B,0x4B+0x80, 0x00,0x0A,0x4A+0x00, 0x00,0x16,0x56+0x00, 0xFF
	.byte 0xFF,0x00, 0x00,0x0C,0x4C+0x80, 0x00,0x0D,0x0D+0x00, 0x00,0x4D,0x4D+0x00, 0x00,0x0C,0x4C+0x80, 0x00,0x17,0x57+0x80, 0xFF
	.byte 0xFF,0x00, 0x00,0x0E,0x0E+0x00, 0x00,0x0F,0x0F+0x00, 0x00,0x4F,0x4F+0x00, 0x00,0x0E,0x0E+0x00, 0x00,0x4E,0x4E+0x00, 0xFF
	.byte 0xFF,0x00, 0x00,0x10,0x10+0x00, 0x00,0x11,0x51+0x80, 0x00,0x11,0x51+0x80, 0x00,0x50,0x50+0x00, 0x00,0x10,0x10+0x00, 0xFF
	.byte 0xFF,0x00, 0x00,0x12,0x12+0x00, 0x00,0x13,0x13+0x00, 0x00,0x53,0x53+0x00, 0x00,0x52,0x52+0x00, 0x00,0x12,0x12+0x00, 0xFF
	.byte 0xFF,0x00, 0x00,0x14,0x54+0x80, 0x00,0x15,0x15+0x00, 0x00,0x55,0x55+0x00, 0x00,0x14,0x54+0x80, 0x00,0x14,0x54+0x80, 0xFF


* This is a table of object IDs which organizes the mob into the series of 5 waves.
db_attk_wav_IDs:
	.byte 0x58,0x5A,0x5C,0x5E,0x28,0x2A,0x2C,0x2E
	.byte 0x30,0x34,0x36,0x32,0x50,0x52,0x54,0x56
	.byte 0x42,0x46,0x40,0x44,0x4A,0x4E,0x48,0x4C
	.byte 0x1A,0x1E,0x20,0x24,0x22,0x26,0x18,0x1C
	.byte 0x08,0x0C,0x12,0x16,0x10,0x14,0x0A,0x0E


*=============================================================================
* c_2896()
*  Description:
*   stg_init_env_01c5
*   Called at beginning of each stage, including challenge stages and demo.
*   Initializes mrw_sprite[n].cclr.b0 for 3 sets of creatures. Color code is
*   packed into b<0:2>, and bomb-drop parameter packed into b<7>
*   Load attributes for challenge stage hit-8 bonus.
*
*   Default sprite code configuration:
*
*    00 00 00 00 00 00 00 00 18 00 18 00 18 00 18 00
*    18 00 18 00 18 00 18 00 18 00 18 00 18 00 18 00
*    18 00 18 00 18 00 18 00 18 00 18 00 18 00 18 00
*    08 00 08 00 08 00 08 00 00 00 00 00 00 00 00 00
*    10 00 10 00 10 00 10 00 10 00 10 00 10 00 10 00
*    10 00 10 00 10 00 10 00 10 00 10 00 10 00 10 00
*    00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
*    00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
*
*   Called before gctl_stg_new_atk_wavs_init_25a2.
* IN:
*  ...
* OUT:
*  ...
*-----------------------------------------------------------------------------
c_2896:
* once per stage, set the player's private pointer to attack wave object setup tables
	lea	ds_8920,a0                     	        | [$2896: ld   hl,#ds_8920] -> plyr_actv.p_atkwav_tbl
	move.l	a0,ds_plyr_actv+_p_atkwav_tbl   	| [$2899: ld   (ds_plyr_actv +_p_atkwav_tbl),hl] = &ds_8920[0] ... initialize it

* pointer to table of packed bits set in b<7>  ... see code leading up to _29AE
	lea	d_2908,a3                      	        | [$289C: $289C: ld   iy,#d_2908]

* if ( 0 == not_chllng_stg ) ...
	move.b	ds_plyr_actv+_b_not_chllg_stg,d0	| [$28A0: ld   a,(ds_plyr_actv +_b_not_chllg_stg)] ==(stg_ctr+1)%4 ...i.e. 0 if challenge stage
	                               	            | [$28A3: and  a]
	jne	l_28CD_not_challenge_stage         	    | [$28A4: jr   nz,l_28CD_not_challenge_stage]
* ...
	move.b	ds_plyr_actv+_b_stgctr,d0       	| [$28A6: ld   a,(ds_plyr_actv +_b_stgctr)] stage init sprite codes
	ror.b	#2,d0                            	| [$28A9: rrca] * 2
	move.b	d0,d2                           	| [$28AB: ld   c,a] table index (below)
	ror.b	#1,d0                            	| [$28AC: rrca]
	move.b	d0,d1                           	| [$28AD: ld   b,a]
	and.b	#0xE0>>3,d0                       	| [$28AE: and  #0xE0 >> 3] 0x1C ... test if stage >= 32
	jeq	l_28B5                             	    | [$28B1: jr   z,l_28B5]
	move.b	#3,d0                           	| [$28B3: ld   a,#3] select index 3 if stage >= 32
	bra.b	0f
l_28B5:
	move.b	d1,d0                           	| [$28B0: ld   a,b] .stage_ctr >> 3
0:
	and.b	#0x03,d0                         	| [$28B5: and  #0x03] 4 entries in data (every 8 challenge stages the selection index is stepped)
	lea	d_stage_chllg_rnd_attrib,a0    	        | [$28B7: ld   hl,#d_stage_chllg_rnd_attrib]
	jbsr	add_2_times_d0_to_a0_0008           | [$28BA: rst  0x08] HL += 2A
	lea	ds2_stg_chllg_rnd_attrib,a1    	        | [$28BB: ld   de,#ds2_stg_chllg_rnd_attrib] challenge bonus attributes (2 bytes from 2900[])
	move.b	d2,d0                           	| [$28BE: ld   a,c]
	jbsr	ldi                               	| [$28BF: ldi] "LD (DE),(HL)", DE++, HL++, BC--
	jbsr	ldi                               	| [$28C1: ldi]

	lea	d_290E,a0                      	        | [$28C3: ld   hl,#d_290E] 8 entries
	and.b	#0x07,d0                         	| [$28C6: and  #0x07]
	jbsr	add_d0_to_a0_0010                   | [$28C8: rst  0x10] HL += A
	move.b	(a0),d3                         	| [$28C9: ld   d,(hl)]
	move.b	d3,d4                           	| [$28CA: ld   e,d]
	jra	l_28D0                             	    | [$28CB: jr   l_28D0]

l_28CD_not_challenge_stage:
 * Initialization values are base-code + 2 bits of color table.
 * 0x1B = 0x18 + 0x03
 * 0x08 = 0x08 + 0x00
 * 0x12 = 0x10 + 0x02
 * left shift codes by 1 bit because the flag (bit-7) will be rra'd from Cy
 * Results in 3-bits of color (multiple of 2)
	move.b	#(0x18+3)*2,d3	| [ld   de,#(0x18 + 3) * 2 * 0x0100  +  (0x10 + 2) * 2]
	move.b	#(0x10+2)*2,d4	| [ld   de,#(0x18 + 3) * 2 * 0x0100  +  (0x10 + 2) * 2]

l_28D0:
	lea	ds_sprite_code_8B00+0x08,a0     | [$28D0: ld   hl,#ds_sprite_code_8B00 + 0x08] offsetof first bee in the group
	move.b	#1,ixl						| [$28D3: ld  ixl,#1]                                 | start count for bit shifting
	move.b	#20,d1                      | [$28D6: ld   b,#20] 20 bees ... $08-$2E
	move.b	d3,ixh					    | [$28D8: ld   ixh,d]                                 | D == moth == $18	| $03
	jbsr	init_creatures_class_28e9   | [$28DA: call init_creatures_class_28e9]
	move.b	#8,d1                       | [$28DD: ld   b,#8] 8 bosses and bonus-bees ... $30-$3E
	move.b	#(0x08)*2,ixh			    | [$28DF: ld   ixh,#(0x08 + 0x0) * 2]                 | code      == $08	| $00
	jbsr	init_creatures_class_28e9   | [$28E2: call init_creatures_class_28e9]
	move.b	#16,d1                      | [$28E5: ld   b,#16] 16 moths ... $40-$5E
	move.b	d4,ixh				        | [$28E7: ld   ixh,e]                                 | E == bee  == $10	| $02
       * call init_creatures_class_28e9

*=============================================================================
* init_creatures_class_28e9()
*  Description:
*    Initialize a class of creatures.
* IN:
*  B == number of creatures in this class
*  HL == sprite_code_buf[ $08 + ? ]
*  IY == &d_2908[0], etc.
*  IXL == persistent count of bits shifted off of IY[ n++ ]
*  IXH == $36 or $10 or $24
* OUT:
*  ...
* First time, IXL==1, forcing C to be loaded.
* After that, reload C every 8 times.
* Each time, C is RL'd into Cy, and Cy RR'd into A.
*-----------------------------------------------------------------------------
init_creatures_class_28e9:
* if ( --IXL == 0 )
	subq.b	#1,ixl                          | [$28E9: dec  ixl]
	jne	l_28F5                             	| [$28EB: jr   nz,l_28F5]
* then ...  C = IY[ n++ ], IXL = 8
	move.b	(a3)+,d2                    	| [$28ED: ld   c,0x00(iy)]
	                           	            | [$28F0: inc  iy]
	move.b	#8,ixl		                    | [$28F2: ld   ixl,#8]
l_28F5:
	rol.b	#1,d2                           | [$28F5: rlc  c]
	SET_X_FROM_C
	move.b	ixh,d0                         	| [$28F7: ld   a,ixh] base sprite-code parameter
	roxr.b	#1,d0                           | [$28F9: rra]
	move.b	d0,(a0)                         | [$28FA: ld   (hl),a]
	addq.w	#2,a0                           | [$28FB: inc  l] * 2
	subq.b	#1,d1                           | [...]
	jne	init_creatures_class_28e9          	| [$28FD: djnz l_28E9]
	rts                                    	| [$28FF: ret]


*=============================================================================
* setup challenge stage bonus attributes at l_28B5 (b_9280 + 0x04)
* .b0: add to bug_collsn[$0F]
* .b1: obj_collsn_notif[] ... hit-flag + sprite-code for score tile
* (base-score multiples are * 10 thanks to d_scoreman_inc_lut[0])
d_stage_chllg_rnd_attrib:
	.byte 10, 0x80 + 0x38
	.byte 15, 0x80 + 0x39
	.byte 20, 0x80 + 0x3C
	.byte 30, 0x80 + 0x3D

d_2908:
	.byte 0xA5,0x5A,0xA9,0x0F,0x0A,0x50 | 44-bits used
d_290E:
	.byte 0x36,0x24,0xD4,0xBA,0xE4,0xCC,0xA8,0xF4
	.align	2
*=============================================================================
* f_insert_attackers_2916()
*  Description:
*   Inserts creature objects from the attack wave table into the movement
*   queue. Essentially, it launches the attack formations swarming into the
*   screen. The table of attack wave structures is built in gctl_stg_new_atk_wavs_init_25a2.
*   Each struct starts with $7E, and the end of table marker is $7F.
*   This task will be enabled by stg_init_env_01c5... after the
*   creature classes and formation tables are initialized.
* IN:
*  ...
* OUT:
*  ...
*-----------------------------------------------------------------------------
f_insert_attackers_2916:

* check for end of table
* if ( 7f == current_token ) goto complete
	move.l	ds_plyr_actv+_p_atkwav_tbl,a0	    | [$2916: ld   hl,(ds_plyr_actv +_p_atkwav_tbl)] &ds_8920[n]
	move.b	(a0),d0                         	| [$2919: ld   a,(hl)]
	cmp.b	#0x7F,d0                         	| [$291A: cp   #0x7F]
	jeq	l_2A29_attack_waves_complete       	    | [$291C: jp   z,l_2A29_attack_waves_complete]

* check for start of table structure
* if ( 7e == token ) then .... else .... goto _next_pair
	cmp.b	#0x7E,d0                         	| [$291F: cp   #0x7E]
	jne	l_2953_next_pair                   	    | [$2921: jr   nz,l_2953_next_pair]

* if ( ! _attack_wave_enable ) return
	move.b	ds_plyr_actv+_b_atk_wv_enbl,d0  	| [$2923: ld   a,(ds_plyr_actv +_b_atk_wv_enbl)] 0 if restarting the stage (respawning player ship)
	                               	            | [$2926: and  a]
	bne.b	0f                               	| [...]
	rts                                    	    | [$2927: ret  z] [...]
0:

* if ( 0 != bugs_flying_nbr ) goto _set_tmr0
	move.b	b_bugs_flying_nbr_9287,d0           | [$2928: ld   a,(b_bugs_flying_nbr_9287)]
                                                | [$292B: and  a]
	jne	l_294D_set_tmr0                    	    | [$292C: jr   nz,l_294D_set_tmr0]

* if ( 0 == not_challenge_stg ) ...
	move.b	ds_plyr_actv+_b_not_chllg_stg,d0	| [$292E: ld   a,(ds_plyr_actv +_b_not_chllg_stg)] ==(stg_ctr+1)%4 ...i.e. 0 if challenge stage
								                | [$2931: ld   b,a] this does nothing |)
	                                         	| [$2932: and  a]
	jne	l_2944_attack_wave_start           	    | [$2933: jr   nz,l_2944_attack_wave_start]
* ...
*  if ( 1 == game_tmrs[0] ) ..
	move.b	ds4_game_tmrs_92ac+0,d0             | [$2935: ld   a,(ds4_game_tmrs_92ac + 0)] if tmr==1 ( on stage 3 ..challenge stage)
	cmp.b	#1,d0                            	| [$2938: cp   #1]
	jne	l_2942_chk_tmr0                    	    | [$293A: jr   nz,l_2942_chk_tmr0]
*  ..
	move.b	#8,d0                           	| [$293C: ld   a,#8]
	move.b	d0,w_bug_flying_hit_cnt_92a8        | [$293E: ld   (w_bug_flying_hit_cnt_92a8),a] 8 ... count down each flying bug hit
	rts                                    	    | [$2941: ret]
*  ..
* if ( 0 != game_tmrs[0] ) return
l_2942_chk_tmr0:
	tst.b	d0                               	| [$2942: and  a] game_tmr0
	beq.b	0f                               	| [...]
	rts                                    	    | [$2943: ret  nz] [...]
0:
* ...

* Finally... sending out next wave of creatures. We are on start token 7E so do nothing on this time step.
* this is called only when creatures arrive in the level, not when they attack from the existing swarm
l_2944_attack_wave_start:
	addq.w	#1,a0                           	| [$2944: inc  hl]
	move.l	a0,ds_plyr_actv+_p_atkwav_tbl   	| [$2945: ld   (ds_plyr_actv +_p_atkwav_tbl),hl] +=1 (first element of byte-pair following the 7e)
	lea	ds_plyr_actv+_b_attkwv_ctr,a0  	        | [$2948: ld   hl,#ds_plyr_actv +_b_attkwv_ctr] +=1
	addq.b	#1,(a0)                         	| [$294B: inc  (hl)]
	rts                                    	    | [$294C: ret]

l_294D_set_tmr0:
	move.b	#2,d0                           	| [$294D: ld   a,#2]
	move.b	d0,ds4_game_tmrs_92ac+0             | [$294F: ld   (ds4_game_tmrs_92ac + 0),a] 2
	rts                                    	    | [$2952: ret]
* ....

* finally, next token-pair !
l_2953_next_pair:
	move.b	d0,d2                           	| [$2953: ld   c,a] *.p_atkwav_tbl ... stash for later
* bit-7 is set if this toaster is a wing-man or a split waves, and therefore no delay,
* otherwise it is clear for trailing formation i.e. delay before launching.
* if ( 0 == *.p_atkwav_tbl & 0x80 ) ...
	btst.b	#7,d0                           	| [$2954: bit  7,a]
	jne	insert_bug_in_queue_295e                | [$2956: jr   nz,insert_bug_in_queue_295e]
* then ...
	move.b	ds3_frame_cts_92A0+0,d0         	| [$2958: ld   a,(ds3_frame_cts_92A0 + 0)]
	and.b	#0x07,d0                         	| [$295B: and  #0x07]
	beq.b	0f                               	| [...]
	rts                                    	    | [$295D:ret  nz] [...]
0:

* ready to stick another bug in the flying queue
insert_bug_in_queue_295e:
* make byte offset into lut at db_word_address_table_2a3c  (_finalize_object) ... also we're done with bit-7
	asl.b	#1,d2                            	| [$295E: sla  c]

* find a slot in the queue
	move.b	#0x0C,d1                        	| [$2960: ld   b,#0x0C] number of structures in array
	move.w	#0x0014,d3                      	| [$2962: ld   de,#0x0014] size of 1 data structure 20
	lea	ds_bug_motion_que_9100,a2           	| [$2965: ld   ix,#ds_bug_motion_que_9100]
l_2969_while:
	btst.b	#0,(0x13,a2)                    	| [$2969: bit  0,0x13(ix)]
	jeq	l_2974_got_slot                    	    | [$296D: jr   z,l_2974_got_slot]
	add.w	d3,a2                            	| [$296F: add  ix,de] advance pointer
	subq.b	#1,d1                           	| [...]
	jne	l_2969_while                       	    | [$2971: djnz l_2969_while]
	rts                                    	    | [$2973: ret] can't find a slot... bummer

* each time is another bug of a new wave formation getting ready to appear
l_2974_got_slot:
	addq.w	#1,a0                           	| [$2974: inc  hl]
	move.b	(a0),d0                         	| [$2975: ld   a,(hl)] atkwav_tbl[n].pair.h ... object ID/offset, e.g. 58
	move.b	d0,d1                           	| [$2976: ld   b,a] stash it

* if object >= $78  &&  object < $80 ) ...
	and.b	#0x78,d0                         	| [$2977: and  #0x78]
	cmp.b	#0x78,d0                         	| [$2979: cp   #0x78]
	jne	l_2980                             	    | [$297C: jr   nz,l_2980]
	move.b	d1,d0                           	| [$297B: ld   a,b]
* ...  then ...
	bclr.b	#6,d0                           	| [$297E: res  6,a] what object is > $78?
	bra.b	0f
l_2980:
	move.b	d1,d0                           	| [$297B: ld   a,b]
0:
	move.b	d0,(0x10,a2)                    	| [$2980: ld   0x10(ix),a] object index
	addq.w	#1,a0                           	| [$2983: inc  hl]
	move.l	a0,ds_plyr_actv+_p_atkwav_tbl   	| [$2984: ld   (ds_plyr_actv +_p_atkwav_tbl),hl] advance to next token-pair e.g. HL:=8923

	lea	b_8800,a0                      	        | [$2987: ld   h,#>b_8800]
	move.b	d0,d6                           	| [$2989: ld   l,a]
	and.w	#0xFF,d6
	add.w	d6,a0
	move.b	#7,(a0)+                         	| [$298A: ld   (hl),#7] 8800[L].l ... disposition = "spawning" ... i.e. case_spawning_orc_2590

* store the slot index (offset) for this object
	addq.w	#1,d6              	                | [$298C: inc  l]
	* here this isn't ixl but a2-ds_bug_motion_que_9100, for this
	* we use a macro that we have, just swapping registers
	exg		a1,a2
	COMPUTE_LSB_A1_D4	ds_bug_motion_que_9100  | [$298D: ld   e,ixl]
	exg		a1,a2            	    
	move.b	d4,(a0)                         	| [$298F: ld   (hl),e] 8800[L].h ... offset of slot (n*$14)
	lea	ds_sprite_posn_9300,a0              	| [$2990: ld   h,#>ds_sprite_posn_9300]
	add.w	d6,a0

* if ( object >= $38 && object < $40 ) then goto _setup_transients
	and.b	#0x38,d0                         	| [$2992: and  #0x38]
	cmp.b	#0x38,d0                         	| [$2994: cp   #0x38]
	jeq	l_29B3_setup_transients            	    | [$2996: jr   z,l_29B3_setup_transients]
* else ...
* Init routine c_2896 has populated the sprite code buffer such that each even
* byte consists of the "primary" code (multiple of 8), AND'd with the color.
	subq.w	#1,a0                           	| [$2998: dec  l] e.g. HL=9358
	COMPUTE_LSB_A0_D6	ds_sprite_posn_9300
	lea	ds_sprite_code_8B00,a0              	| [$2999: ld   h,#>ds_sprite_code_8B00] sprite[L].code.b0 &= 0x78
	and.w	#0xFF,d6
	add.w	d6,a0
	move.b	(a0),d0                         	| [$299B: ld   a,(hl)]
	move.b	d0,d3                           	| [$299C: ld   d,a] stash it
	and.b	#0x78,d0                         	| [$299D: and  #0x78] base sprite code for this object (multiple of 8)
	move.b	d0,(a0)+                         	| [$299F: ld   (hl),a] sprite[n].cclr.b0
	                           	                | [$29A0: inc  l] .b1
	move.b	d3,d0                           	| [$29A1: ld   a,d]
	and.b	#0x07,d0                         	| [$29A2: and  #0x07] color table in bits <0:2>
	move.b	d0,(a0)                         	| [$29A6: ld   (hl),a] sprite[n].cclr.b1
	btst.b	#7,d3                           	| [$29A4: bit  7,d]

* if ( ! code_bit_7 )
	jeq	l_29AE                             	    | [$29A9: jr   z,l_29AE]
* else
	move.b	b_92E2+0x01,d0                  	| [$29AB: ld   a,(b_92E2 + 0x01)] to 0x0F(ix) ... _stg_dat[1] ... bomb drop enable flags
	bra.b	0f
l_29AE:
	clr.b	d0                               	| [$29A7: ld   a,#0]
0:
	move.b	d0,(0x0F,a2)                    	| [ld   0x0F(ix),a] 0, or b_92E2[1] ... bomb drop enable flags
	jra	l_29D1_finalize_object_setup       	    | [jr   l_29D1_finalize_object_setup]

* handle the additional "transient" buggers that fly-in but don't join ... Stage 4 or higher.
l_29B3_setup_transients:
	move.b	#0x02,d3
	move.b	#0x10,d4             	            | [$29B3: ld   de,#0x02 * 256 + 0x0010] redmoth, color 02, 270-deg rotation
	btst.b	#6,d1                           	| [$29B6: bit  6,b]
	jne	l_29C7                             	    | [$29B8: jr   nz,l_29C7]
	move.b	#0x03,d3
	move.b	#0x18,d4             	            | [$29BA: ld   de,#0x03 * 256 + 0x0018] yellowbee, color 03, 270-deg rotation
	move.b	ds_plyr_actv+_b_attkwv_ctr,d0   	| [$29BD: ld   a,(ds_plyr_actv +_b_attkwv_ctr)]
	cmp.b	#0x02,d0                            | [$29C0: cp   #0x02]
	jne	l_29C7                                  | [$29C2: jr   nz,l_29C7]
	move.b	#0,d3
	move.b	#8,d4               	            | [$29C4: ld   de,#0x0000 + 0x0008] boss, color 00, 270-deg rotation (>=stage 9)
l_29C7:
	lea	ds_sprite_code_8B00,a0              	| [$29C7: ld   h,#>ds_sprite_code_8B00]
	and.w	#0xFF,d6
	add.w	d6,a0
	move.b	d3,(a0)                         	| [$29C9: ld   (hl),d] color, e.g. 8B3B=$03
												| [$29CA: dec  l]
	move.b	d4,(-1,a0)                         	| [$29CB: ld   (hl),e] color, e.g. 8B3A=$18
												| [$29CC: inc  l]
	clr.b	(0x0F,a2)                        	| [$29CD: ld   0x0F(ix),#0] setup transients ... bomb drop enable flags

l_29D1_finalize_object_setup:
	move.b	d2,d3                           	| [$29D1: ld   d,c] first byte of token-pair, left-shifted 1 (byte-1 of _stg_dat triplet)
	bclr.b	#7,d2                           	| [$29D2: res  7,c]
	move.b	#8,d1                           	| [$29D4: ld   b,#8] critters that enter at the top
* if ( C & 0x02 ) ...
	btst.b	#1,d2                           	| [$29D6: bit  1,c]
	jeq	l_29DC                             	    | [$29D8: jr   z,l_29DC]
* then ...
	move.b	#0x44,d1                        	| [$29DA: ld   b,#0x44] critters that enter on the sides
l_29DC:
	move.b	d1,(0x0E,a2)                    	| [$29DC: ld   0x0E(ix),b] $08 or $44 ... bomb drop counter

* ds_bug_move_queue[IX].b08 = db_word_address_table_2a3c[C] ... LSB of data pointer
	and.w	#0xFF,d2                            | [$29DF: ld   b,#0]
	lea	db_word_address_table_2a3c,a0                     	        | [$29E1: ld   hl,#db_word_address_table_2a3c]
	add.w	d2,a0                            	| [$29E4: add  hl,bc] only C is significant
	move.b	(1,a0),d0                         	| [$29E5: ld   a,(hl)] lsb! table is in the code, thus big endian
	                           	                | [$29E6: inc  hl] don't increase, we run big-endian!
	move.b	d0,(0x08,a2)                    	| [$29E7: ld   0x08(ix),a] lo-byte of pointer e.g. cpu-sub1:001D

* get upper nibble of word at db_word_address_table_2a3c[w] (bits 5:7 will be masked by 0x0E below)
* rld (hl): Performs a 4-bit leftward rotation of the 12-bit number whose
* 4 most significant bits are the 4 least significant bits of A
	clr.b	d0                               	| [$29EA: xor  a]
	* BUT (a0) points to ROM in the original game. We don't want to change
	* the value, so we back it up and restore it afterwards
	* (this could act as a pretty efficient protection against bootlegs!)
	move.b	(a0),d1
	jbsr	rld                               	| [$29EB: rld]
	move.b	d1,(a0)
	move.b	d0,d1                           	| [$29ED: ld   b,a]

* ds_bug_move_queue[IX].b09  = db_word_address_table_2a3c[C + 1] & 0x1F ... MSB of data pointer
	move.b	(a0),d0                         	| [$29EE: ld   a,(hl)] msb
	and.b	#0x1F,d0                         	| [$29EF: and  #0x1F]
	move.b	d0,(0x09,a2)                    	| [$29F1: ld   0x09(ix),a] hi-byte of pointer e.g. cpu-sub1:001D

* ... get upper 4-bits of word at db_word_address_table_2a3c[w] which were rld'd into A: these
* are $2 thru $A even, and this is multiplied by 3 by the expression A*2+A
	move.b	d1,d0                           	| [$29F4: ld   a,b]
	and.b	#0x0E,d0                         	| [$29F5: and  #0x0E] bits 5:7 of db_word_address_table_2a3c[].b1
	move.b	d0,d1                           	| [$29F7: ld   b,a]
	rol.b	#1,d0                            	| [$29F8: rlca]
	add.b	d1,d0                            	| [$29F9: add  a,b]
	lea	db_2A6C,a0                     	        | [$29FA: ld   hl,#db_2A6C]
	jbsr	add_d0_to_a0_0010                   | [$29FD: rst  0x10] HL += A

* D is b0 of byte-pair (left shifted 1, so in _stg_dat it is 0x40)
* if ( D & 0x80 )
	btst.b	#7,d3                           	| [$29FE: bit  7,d] 29FE
	jeq	l_2A05                             	    | [$2A00: jr   z,l_2A05]
* ... then ... HL += 3 ... selects the second set of 3 bytes
	addq.w	#3,a0                           	| [$2A02: inc  hl] * 3

l_2A05:
	move.b	(a0)+,d0                         	| [$2A05: ld   a,(hl)]
	                           	                | [$2A06: inc  hl]
	move.b	d0,(0x01,a2)                    	| [$2A07: ld   0x01(ix),a] db_2A6C[L].b0
	move.b	(a0)+,d0                         	| [$2A0A: ld   a,(hl)]
	                           	                | [$2A0B: inc  hl]
	move.b	d0,(0x03,a2)                    	| [$2A0C: ld   0x03(ix),a] db_2A6C[L].b1
	move.b	(a0)+,d0                         	| [$2A0F: ld   a,(hl)]
	                           	                | [$2A10: inc  hl]
	move.b	d0,(mq_angle_msb_05,a2)                    	| [$2A11: ld   0x05(ix),a] db_2A6C[L].b2
	clr.b	d0                               	| [$2A14: xor  a]
	move.b	d0,(0x00,a2)                    	| [$2A15: ld   0x00(ix),a] 0
	move.b	d0,(0x02,a2)                    	| [$2A18: ld   0x02(ix),a] 0
	move.b	d0,(mq_angle_lsb_04,a2)                    	| [$2A1B: ld   0x04(ix),a] 0
	addq.b	#1,d0                           	| [$2A1E: inc  a]
	move.b	d0,(0x0D,a2)                    	| [$2A1F: ld   0x0D(ix),a] 1 ... expiration counter
	or.b	d3,d0                             	| [$2A22: or   d] 1st byte of current byte-pair (left shifted 1, so in _stg_dat it is 0x40)
	and.b	#0x81,d0                         	| [$2A23: and  #0x81] .b13<7> negates rotation angle
	move.b	d0,(0x13,a2)                    	| [$2A25: ld   0x13(ix),a] A &= $81 ... .b13<0> makes object slot active
	rts                                    	    | [$2A28: ret]

* all 8 of the last wave of bees are on screen now... waiting for them to get in position.
* if (nbr_flying bugs > 0 ) return
l_2A29_attack_waves_complete:
	move.b	b_bugs_flying_nbr_9287,d0            | [ld   a,(b_bugs_flying_nbr_9287)]
	                               	             | [and  a]
	beq.b	0f                               	 | [...]
	rts                                    	     | [ret  nz] [...]
0:

* the last one has found its position in the collective.
	move.b	d0,ds_cpu0_task_actv_9000+0x08       | [ld   (ds_cpu0_task_actv_9000 + 0x08),a] 0  (f_insert_attackers_2916 ... end of attack waves)
	addq.b	#1,d0                           	 | [inc  a]
	move.b	d0,ds_cpu0_task_actv_9000+0x04       | [ld   (ds_cpu0_task_actv_9000 + 0x04),a] 1  (f_clone_attack_manager_1A80 ... bonus-bee manager)
	move.b	d0,ds_cpu0_task_actv_9000+0x10       | [ld   (ds_cpu0_task_actv_9000 + 0x10),a] 1  (f_manage_bomber_attacks_1b65 ... manage bomber attack )
	move.b	d0,ds_plyr_actv+_b_nestlr_inh   	 | [ld   (ds_plyr_actv +_b_nestlr_inh),a] 1  ... inhibit nest left/right movement
	rts                                    	     | [ret]



*=============================================================================

* bits 0:12  - pointer to data tables for flying pattern control.
* bits 13:15 - selection index into lut 2A6C.
db_word_address_table_2a3c:
	.word db_flv_001d + 0x0000, db_flv_0067 + 0x2000, db_flv_009f + 0x4000, db_flv_00d4 + 0x2000
	.word db_flv_017b + 0x0000, db_flv_01b0 + 0x6000, db_flv_01e8 + 0x0000, db_flv_01f5 + 0x2000
	.word db_flv_020b + 0x0000, db_flv_021b + 0x2000, db_flv_022b + 0x8000, db_flv_0241 + 0x2000
	.word db_flv_025d + 0x8000, db_flv_0279 + 0x2000, db_flv_029e + 0x0000, db_flv_02ba + 0x2000
	.word db_flv_02d9 + 0x0000, db_flv_02fb + 0x2000, db_flv_031d + 0x0000, db_flv_0333 + 0x2000
	.word db_flv_0fda + 0x0000, db_flv_0ff0 + 0x2000, db_flv_022b + 0xA000, db_flv_025d + 0xA000

* bits 13:15 from above provide bits<1:3> of the index
* bit-6 of _stg_dat provide bits<1> of the index (second set of 3-bytes in each pair)
db_2A6C:
* (ix)0x01 (ix)0x03 (ix)0x05
	.byte 0x9B,0x34,0x03 | 0
	.byte 0x9B,0x44,0x03
	.byte 0x23,0x00,0x00 | 2
	.byte 0x23,0x78,0x02
	.byte 0x9B,0x2C,0x03 | 4
	.byte 0x9B,0x4C,0x03
	.byte 0x2B,0x00,0x00 | 6
	.byte 0x2B,0x78,0x02
	.byte 0x9B,0x34,0x03 | 8
	.byte 0x9B,0x34,0x03
	.byte 0x9B,0x44,0x03 | A
	.byte 0x9B,0x44,0x03


*=============================================================================
* f_lateral_movement_at_round_start_2a90()
*  Description:
*   left/right movement of collective while attack waves coming in at
*   start of round.
* IN:
*  ...
* OUT:
*  ...
*-----------------------------------------------------------------------------
f_lateral_movement_at_round_start_2a90:

*  if ( frame_cnt % 4 != 0 ) return
	move.b	ds3_frame_cts_92A0+0,d0         	| [ld   a,(ds3_frame_cts_92A0 + 0)]
	subq.b	#1,d0                           	| [dec  a] why -1 ?
	and.b	#0x03,d0                         	| [and  #0x03]
	beq.b	0f                               	| [...]
	rts                                    	    | [ret  nz] [...]
0:

* check for exit condition
*  if  ! ( num_bugs != 0 ||  f_insert_attackers_2916_active )  then ...
	move.b	b_bugs_actv_nbr,d0              	| [ld   a,(b_bugs_actv_nbr)]
	move.b	d0,d1                           	| [ld   b,a]
	move.b	ds_cpu0_task_actv_9000+0x08,d0      | [ld   a,(ds_cpu0_task_actv_9000 + 0x08)] f_insert_attackers_2916 supervises attack waves
	or.b	d1,d0                             	| [or   b]
	jeq	l_2AE9_done                        	| [jr   z,l_2AE9_done]

* if ( 0 == nest_dir_lr ) then C = 1,  else C = -1
	                               	| [and  a]
	move.b	#1,d2                           	| [ld   c,#1]
	tst.b	ds_9200_glbls+0x0F           	| [ld   a,(ds_9200_glbls + 0x0F)] nest direction... 1==left, 0==right
	jeq	l_2AAB                             	| [jr   z,l_2AAB]
	subq.b	#2,d2                           	| [dec  c] * 2

* initialize index and loop counter, update the table
l_2AAB:
	clr.b	d6                               	| [ld   l,#0] index into table
	move.b	#10,d1                          	| [ld   b,#10] nbr of column positions
l_2AAF:
* increment the relative position
	lea	ds_hpos_loc_offs_9900,a0            	| [ld   h,#>ds_hpos_loc_offs_9900] even-bytes, relative offset, all 0's, then all 1's, etc. etc.
	and.w	#0xFF,d6
	add.w	d6,a0
	move.b	(a0),d0                         	| [ld   a,(hl)]
	add.b	d2,d0                            	| [add  a,c] +1 or -1
	move.b	d0,(a0)                         	| [ld   (hl),a]
* increment sprite position LSB
	lea	ds_hpos_spcoords_9800,a0            	| [ld   h,#>ds_hpos_spcoords_9800]
	and.w	#0xFF,d6
	add.w	d6,a0
	move.b	(a0),d0                         	| [ld   a,(hl)]
	add.b	d2,d0                            	| [add  a,c]
	move.b	d0,(a0)                         	| [ld   (hl),a]
* HL+=2
	addq.b	#2,d6                           	| [inc  l] * 2 [a0 coherence]
	subq.b	#1,d1                           	| [...]
	jne	l_2AAF                             	| [djnz l_2AAF]

* if ( 0 == nestlr_inh                  	||  0 != obj_pos_rel[0] )  ...
	                               	| [and  a]
	move.b	ds_hpos_loc_offs_9900+0x00,d0        	| [ld   a,(ds_hpos_loc_offs_9900 + 0x00)] check for 0 i.e. returned to center
	tst.b	ds_plyr_actv+_b_nestlr_inh   	| [ld   a,(ds_plyr_actv +_b_nestlr_inh)]
	jeq	l_2AC9                             	| [jr   z,l_2AC9]
	tst.b	d0                               	| [and  a]
	jeq	l_2ADA_done                        	| [jr   z,l_2ADA_done]
l_2AC9:
* ... then ...
* if ( 32 == obj_pos_rel[0] )  then nest_dir_lr = 1
	cmp.b	#32,d0                           	| [cp   #32]
	jne	l_2AD3                             	| [jr   nz,l_2AD3]

	move.b	#1,d0                           	| [ld   a,#1]
	move.b	d0,ds_9200_glbls+0x0F           	| [ld   (ds_9200_glbls + 0x0F),a] 1 ... nest direction... right limit reached
	rts                                    	| [ret]

l_2AD3:
* if ( -32 == obj_pos_rel[0] ) then nest_dir_lr = 0
	sub.b	#0xE0,d0                         	| [sub  #0xE0] -$20
	beq.b	0f                               	| [...]
	rts                                    	    | [ret  nz] [...]
0:

	move.b	d0,ds_9200_glbls+0x0F           	| [ld   (ds_9200_glbls + 0x0F),a] 0 ... nest direction... left limit reached
	rts                                    	    | [ret]

* the formation is complete... diving attacks shall commence
l_2ADA_done:
	clr.b	d0                               	| [xor  a]
	move.b	d0,ds_9200_glbls+0x0F           	| [ld   (ds_9200_glbls + 0x0F),a] 0 ... nest direction
	move.b	d0,ds_cpu0_task_actv_9000+0x0A      | [ld   (ds_cpu0_task_actv_9000 + 0x0A),a] 0 ... disable this task (f_lateral_movement_at_round_start_2a90)
	addq.b	#1,d0                           	| [inc  a]
	move.b	d0,b_9AA0+0x00                  	| [ld   (b_9AA0 + 0x00),a] 1 ... sound-fx count/enable register, pulsing formation sound effect
	move.b	d0,ds_cpu0_task_actv_9000+0x09      | [ld   (ds_cpu0_task_actv_9000 + 0x09),a] 1 ... enable f_pulsating_swarm_movement_1de6 ... collective bug movement
	rts                                    	    | [ret]

* last bug of challenge is gone or killed
l_2AE9_done:
	move.b	d0,ds_cpu0_task_actv_9000+0x0A      | [ld   (ds_cpu0_task_actv_9000 + 0x0A),a] 0 ... disable this task (f_lateral_movement_at_round_start_2a90)
	rts                                    	    | [ret]


*=============================================================================
*
* Place 2C00 in its own segment so the pad is not needed.
*
*l_2AED:
*       ds.b 0x0113                                 | pad

*=============================================================================

* input file gg1-4.s
*
* gg1-4.s
*  gg1-4.2l 'maincpu' (Z80)
*
*  Hi-score dialog, power-on memory tests, and service-mode menu functions
*  combined into gg1-4 and removed files reset.s and svc_mode.s
*  from branch "sdasz80_03172012".
*
*
*.module game_over



**.area ROM (ABS,OVR)
*       .org 0x2FFF
*       .db 0x74                                   | checksum
*.area CSEG30


*=============================================================================
* _top5_dlg_proc()
*  Description:
*   Checks players score for ranking in the Best 5. Scores are 6 characters
*   BCD format, stored highest digit (100000's) at highest address of array.
*   This is called from game_ctrl (background task) and is blocking on the
*   game-timers.
*   Returns from 317F
* IN:
*  ...
* OUT:
*  ...
* Note: 83ED-83F2 is high score in tile RAM.
*-----------------------------------------------------------------------------
c_top5_dlg_proc:
	lea	0x8000+0x03E0+0x1D,a0      	| [ld   hl,#0x8000 + 0x03E0 + 0x1D] 100000's digit of plyr1 score (83F8-FD)
	move.b	ds_plyr_actv+_b_plyr_nbr,d0     	| [ld   a,(ds_plyr_actv +_b_plyr_nbr)] 0==plyr1, 1==plyr2
	                               	| [and  a]
	jeq	l_300C                             	| [jr   z,l_300C]
	lea	0x8000+0x03E0+0x08,a0      	| [ld   hl,#0x8000 + 0x03E0 + 0x08] 100000's digit of plyr2 score (83E3-E8)

l_300C:
* setup pointer to active player score in HL. Offset 5 advances pointer to 100000's place character.
	move.l	a0,b_8A00                  	| [ld   (b_8A00 + 0x00),hl] ptr to plyr1 score or plyr2 score on screen.

	lea	b_best5_score5+0x05,a1         	| [ld   de,#b_best5_score5 + 0x05]
	jbsr	c_31F7_chk_score_rank             	| [call c_31F7_chk_score_rank] score > 5th place?
	bcs.b	0f                               	| [...]
	rts                                    	| [ret  nc] [...]
0:

	lea	b_best5_score4+0x05,a1         	| [ld   de,#b_best5_score4 + 0x05]
	jbsr	c_31F7_chk_score_rank       | [call c_31F7_chk_score_rank] score > 4th place?
	scs		d7
	move.b	#5,d0                       | [ld   a,#5]
	tst.b	d7
	jeq	l_3047                          | [jr   nc,l_3047]

	lea	b_best5_score3+0x05,a1         	| [ld   de,#b_best5_score3 + 0x05]
	jbsr	c_31F7_chk_score_rank       | [call c_31F7_chk_score_rank] score > 4th place?
	scs		d7
	move.b	#4,d0                       | [ld   a,#4]
	tst.b	d7
	jeq	l_3047                          | [jr   nc,l_3047]

	lea	b_best5_score2+0x05,a1         	| [ld   de,#b_best5_score2 + 0x05]
	jbsr	c_31F7_chk_score_rank       | [call c_31F7_chk_score_rank] score > 3th place?
	scs		d7
	move.b	#3,d0                       | [ld   a,#3]
	tst.b	d7
	jeq	l_3047                          | [jr   nc,l_3047]
 
	lea	b_best5_score1+0x05,a1         	| [ld   de,#b_best5_score1 + 0x05]
	jbsr	c_31F7_chk_score_rank       | [call c_31F7_chk_score_rank] score > 2th place?
	scs		d7
	move.b	#2,d0                       | [ld   a,#2]
	tst.b	d7
	jeq	l_3047                          | [jr   nc,l_3047]
	st.b	d0                          | [ld   a,#0xFF]
	*move.b	d0,0x9AA0+0x0C              | [ld   (0x9AA0 + 0x0C),a] special tune for 1st place
	move.b	#1,d0                       | [ld   a,#1]
	jra	l_304A                          | [jr   l_304A]
l_3047:
	*move.b	d0,0x9AA0+0x10              | [ld   (0x9AA0 + 0x10),a] select the tune

l_304A:
* set the jp address for the subroutine.
	move.b	d0,b_8A00+0x11              | [ld   (b_8A00 + 0x11),a] 1==1ST place etc.
	lea	d_31A6,a0                      	| [ld   hl,#d_31A6] jp table address
	subq.b	#1,d0                       | [dec  a]
	jbsr	add_4_times_d0_to_a0_0008   | [rst  0x08] HL += 2A
	jbsr	c_3118_insert_top5_score    | [call c_3118_insert_top5_score]

* insert new player name in table.
* data: 0,3,6,9,12 (12 for first place)
* the table gives repetition count for ldir below ( 5 - X * 3 ) where X is 1st through 5th place.
	move.b	b_8A00+0x11,d0                  	| [ld   a,(b_8A00 + 0x11)] 1==1ST place etc. ... d_31A1 [ A - 1 ]
	lea	d_31A1,a0                      	| [ld   hl,#d_31A1] ld the table address
	subq.b	#1,d0                           	| [dec  a]
	jbsr	add_d0_to_a0_0010                            	| [rst  0x10] HL += A
	move.b	(a0),d0                         	| [ld   a,(hl)]
	lea	b_best5_name4+0x02,a0          	| [ld   hl,#b_best5_name4 + 0x02] 3rd letter of 4th place name
	lea	b_best5_name5+0x02,a1          	| [ld   de,#b_best5_name5 + 0x02] 3rd letter of 5th place name
	tst.b	d0                               	| [and  a]
	jeq	l_306C                             	| [jr   z,l_306C]
	move.b	d0,d2                           	| [ld   c,a]
	clr.b	d1                               	| [ld   b,#0]
    jbsr   lddr
* note, HL now == &newname[0] - 1
l_306C:
	move.b	#3,d1                           	| [ld   b,#3]
	move.b	#0x24,d0                        	| [ld   a,#0x24] clear the old name out (3 space characters)
	move.l	a0,b_8A00+0x06                  	| [ld   (b_8A00 + 0x04),hl] pointer to new name in table... address would be  &newname[0] - 1
l_3073:
	addq.w	#1,a0                           	| [inc  l] pre-increment since we start at ( &newname[0] - 1 )
	move.b	d0,(a0)                         	| [ld   (hl),a]
	subq.b	#1,d1                           	| [...]
	jne	l_3073                             	| [djnz l_3073]

	move.b	#0x49,d0                        	| [ld   a,#0x49]
	move.b	d0,b_8A00+0x10                  	| [ld   (b_8A00 + 0x10),a] $49 ... lower address byte of first character of name entry in tile-ram

	lea	s_327F_enter_your_initials,a0  	| [ld   hl,#s_327F_enter_your_initials]
	jbsr	c_text_out_ce_3328                     	| [call c_text_out_ce_3328] "ENTER YOUR INITIALS !"
	jbsr	c_text_out_331b                        	| [call c_text_out_331b] "SCORE  NAME"          HL==3298
	jbsr	c_text_out_ce_3328                     	| [call c_text_out_ce_3328] "TOP 5"                HL==32AB

	lea	0x8000+0x0300+0x09,a1      	| [ld   de,#0x8000 + 0x0300 + 0x09]
	move.l	b_8A00,a0              	| [ld   hl,(b_8A00 + 0x00)] ptr to plyr1 score or plyr2 score on screen.
 	jbsr	string_copy_3275                            	| [call string_copy_3275] puts players score below "SCORE"

* puts_AAA (default initials of new score entry) below NAME
	move.w	#0x8000+0x0140+0x09,d7      	| [ld   hl,#0x8000 + 0x0140 + 0x09] row below 'A' in "NAME"
	move.w	#-32,d3                         	| [ld   de,#-32] offset 1 column right -32
	moveq	#10,d0
	jbsr	osd_w_videoram                      	| [ld   (hl),#0x0A]
	add.w	d3,d7                            	| [add  hl,de]
	jbsr	osd_w_videoram                      	| [ld   (hl),#0x0A]
	add.w	d3,d7                            	| [add  hl,de]
	jbsr	osd_w_videoram                      	| [ld   (hl),#0x0A]

	jbsr	c_puts_top5scores_321d                 	| [call c_puts_top5scores_321d]
	jbsr	c_plyr_initials_entry_hilite_line 	| [call c_plyr_initials_entry_hilite_line]

* wait 2 seconds
	move.b	#4,d0                           	| [ld   a,#4]
	move.b	d0,ds4_game_tmrs_92ac+2              	| [ld   (ds4_game_tmrs_92ac + 2),a]
l_30AA:
	move.b	ds4_game_tmrs_92ac+2,d0              	| [ld   a,(ds4_game_tmrs_92ac + 2)]
	                               	| [and  a]
	jne	l_30AA                             	| [jr   nz,l_30AA]

	move.b	#40,d0                          	| [ld   a,#40] 20 seconds
	move.b	d0,ds4_game_tmrs_92ac+2              	| [ld   (ds4_game_tmrs_92ac + 2),a] :=$28

* jp here from section _314C
l_30B5_next_char_selectn:
	jbsr	c_puts_top5scores_321d              | [call c_puts_top5scores_321d]
	jbsr	c_plyr_initials_entry_hilite_line 	| [call c_plyr_initials_entry_hilite_line]

* get time 0 from frame counter
	move.b	ds3_frame_cts_92A0+0,d0         	| [ld   a,(ds3_frame_cts_92A0 + 0)]
	move.b	d0,d2                           	| [ld   c,a]

* jp here to return from section _stick_right
l_30BF_dlg_proc:
l_30BF_frame_sync:
	jbsr	c_32ED_top5_dlg_endproc           	| [call c_32ED_top5_dlg_endproc] checks coin-in once per frame
	move.b	ds3_frame_cts_92A0+0,d0         	| [ld   a,(ds3_frame_cts_92A0 + 0)]
	cmp.b	d2,d0                            	| [cp   c]
	jeq	l_30BF_frame_sync                  	    | [jr   z,l_30BF_frame_sync]

	move.b	d0,d2                           	| [ld   c,a]
	and.b	#0x0F,d0                         	| [and  #0x0F] 15 frames
	bne.b	0f                               	| [...]
	jbsr	c_3141_xor_char_color             	| [call z,c_3141_xor_char_color] alternate color 4 times/second
0:

* read IO port: setup for second player control panel if needed for tabletop
	lea	ds3_io_input_99b5+0x01,a0      	| [ld   hl,#ds3_io_input_99b5 + 0x01] plyr 1 input register
	move.b	b_9215_flip_screen,d0           	| [ld   a,(b_9215_flip_screen)]
	                               	| [and  a]
	jeq	l_30D8_chk_button                  	| [jr   z,l_30D8_chk_button]
	addq.w	#1,a0                           	| [inc  hl] HL := &io_input[2]
l_30D8_chk_button:
	btst.b	#4,(a0)                         	| [bit  4,(hl)] check for button (active low)
	jeq	j_314C_select_char                 	| [jp   z,j_314C_select_char] jp l_30B5 on 1st or 2nd letter selection...
                                                  * ... ret from _top5_dlg_proc after 3rd letter selection
	move.b	(a0),d0                         	| [ld   a,(hl)]
	and.b	#0x0A,d0                         	| [and  #0x0A]
	lea	b_8A00+0x04,a0                 	| [ld   hl,#b_8A00 + 0x02] L==2, R==8 X=A   previous controller state
	lea	b_8A00+0x05,a1                 	| [ld   de,#b_8A00 + 0x03] character selection counter/timer
	cmp.b	(a0),d0                          	| [cp   (hl)]
	jeq	l_30ED                             	| [jr   z,l_30ED]
	move.b	d0,(a0)                         	| [ld   (hl),a] the controller state has changed... save previous state
* reset the counter/timer
	move.b	#0xFD,d0                        	| [ld   a,#0xFD] (first timeout at next frame)
	move.b	d0,(a1)                         	| [ld   (de),a] (8A03) := $FD
* increment the counter/timer and check for 16 frames elapsed
l_30ED:
	move.b	(a1),d0                         	| [ld   a,(de)] DE==$8A03
	addq.b	#1,d0                           	| [inc  a]
	move.b	d0,(a1)                         	| [ld   (de),a] *($8A03)++
	and.b	#0x0F,d0                         	| [and  #0x0F]
	jne	l_30BF_dlg_proc                    	| [jr   nz,l_30BF_dlg_proc] done with this frame

* update letter selection every 1/4 second based on stick input.
	move.b	(a0),d0                         	| [ld   a,(hl)] get control stick value L==2, R==8 X==A
	cmp.b	#8,d0                            	| [cp   #8]
	jeq	l_311D_stick_right                 	| [jr   z,l_311D_stick_right] returns by  jp l_30BF
	cmp.b	#2,d0                            	| [cp   #2]
	jne	l_30BF_dlg_proc                    	| [jr   nz,l_30BF_dlg_proc] stick not left (or right)
	move.b	#40,d0                          	| [ld   a,#40] 20 seconds
	move.b	d0,ds4_game_tmrs_92ac+2              	| [ld   (ds4_game_tmrs_92ac + 2),a] reset timer

	move.b	b_8A00+0x10,d0                  	| [ld   a,(b_8A00 + 0x10)] lower byte of first character's address in v-ram
	move.b	d0,d6                           	| [ld   l,a]
	move.w	#0x8000+0100,d7          	| [ld   h,#>0x8000 + >0x0100]
	and.w	#0xFF,d6
	add.w	d6,d7
	jbsr	osd_r_videoram                         	| [ld   a,(hl)]
	subq.b	#1,d0                           	| [dec  a]
	cmp.b	#9,d0                            	| [cp   #9] check for if wrap around bottom-to-top
	bne.b	0f                               	| [...]
	jbsr	c_3138_lda2A                      	| [call z,c_3138_lda2A] A:=$2A  (allow the '.' character)
0:
	cmp.b	#0x29,d0                         	| [cp   #0x29]
	bne.b	0f                               	| [...]
	jbsr	c_313B_lda24                      	| [call z,c_313B_lda24] A:=$24  (24 is "space", 23 is 'Z')
0:
	jbsr	osd_w_videoram                         	| [ld   (hl),a]
	jra	l_30BF_dlg_proc                    	| [jp   l_30BF_dlg_proc]

*=============================================================================
* c_3118_insert_top5_score()
*  Description:
*   Inserts the new Top 5 score in the table.
* IN:
*  HL== jp table address from d_31A6, i.e:
*    case_31B0
*    case_31B4
*    case_31B8
*    case_31CE
*    case_31D9
* OUT:
*  ...
*-----------------------------------------------------------------------------
c_3118_insert_top5_score:
	move.l	(a0),a0
	                      	| [ld   a,(hl)]
	                     	| [inc  hl]
	                     	| [ld   h,(hl)]
	                     	| [ld   l,a]
	jra	(a0)                               	| [jp   (hl)]
* returns from jp'd section

*=============================================================================
* l_311D_stick_right()
*  Description:
*   Update current character selection and reset the keep alive timer. Handles
*   wrap-around top-to-bottom
* IN:
*  ...
* OUT:
*  ...
*-----------------------------------------------------------------------------
l_311D_stick_right:
* get lower byte of current character's address in v-ram
	move.b	b_8A00+0x10,d0                  	| [ld   a,(b_8A00 + 0x10)] HL = $8000 + $0100 + b_8A00[ 0x10 ]
	move.b	d0,d6                           	| [ld   l,a]
	move.w	#0x8100,d7          	| [ld   h,#>0x8000 + >0x0100]
	and.w	#0xFF,d6
	add.w	d6,d7
	move.b	#40,d0                          	| [ld   a,#40] 20 seconds
	move.b	d0,ds4_game_tmrs_92ac+2              	| [ld   (ds4_game_tmrs_92ac + 2),a] reset timer
	jbsr	osd_r_videoram                         	| [ld   a,(hl)]
	addq.b	#1,d0                           	| [inc  a]
	cmp.b	#0x2B,d0                         	| [cp   #0x2B] 2A is '.' character which is allowed
	bne.b	0f                               	| [...]
	jbsr	c_313E_lda0A                      	| [call z,c_313E_lda0A]
0:
	cmp.b	#0x25,d0                         	| [cp   #0x25] 2A is ' ' character which is allowed
	bne.b	0f                               	| [...]
	jbsr	c_3138_lda2A                      	| [call z,c_3138_lda2A]
0:
	jbsr	osd_w_videoram                         	| [ld   (hl),a]
	jra	l_30BF_dlg_proc                    	| [jp   l_30BF_dlg_proc]

*=============================================================================
* c_3138_lda2A()
*  Description:
*   Refactoring gone mad...
* IN:
*  ...
* OUT:
*  ...
*-----------------------------------------------------------------------------
c_3138_lda2A:
	move.b	#0x2A,d0                        	| [ld   a,#0x2A]
	rts                                    	| [ret]

*=============================================================================
* c_313B_lda24()
*  Description:
*    This seems somewhat inefficient.
* IN:
*  ...
* OUT:
*  ...
*-----------------------------------------------------------------------------
c_313B_lda24:
	move.b	#0x24,d0                        	| [ld   a,#0x24]
	rts                                    	| [ret]

*=============================================================================
* c_313E_lda0A()
*  Description:
*   Really?
* IN:
*  ...
* OUT:
*  ...
*-----------------------------------------------------------------------------
c_313E_lda0A:
	move.b	#0x0A,d0                        	| [ld   a,#0x0A]
	rts                                    	| [ret]

*=============================================================================
* c_3141_xor_char_color()
*  Description:
*    Invert current color code of selected character.
*    0 Cyan -> 5 Yellow
* IN:
*  *(b_8A00 + 0x10) == lower byte of selected character's address in v-ram
* OUT:
*  ...
*-----------------------------------------------------------------------------
c_3141_xor_char_color:
* lower byte of selected character's address in v-ram
	move.b	b_8A00+0x10,d0                  	| [ld   a,(b_8A00 + 0x10)] HL = $8400 + $0100 + b_8A00[ 0x10) ]
	move.b	d0,d6                           	| [ld   l,a]
	move.w	#0x8500,d7         	| [ld   h,#>m_color_ram + >0x0100]
	and.w	#0xFF,d6
	add.w	d6,a0
	jbsr	osd_w_colorram                         	| [ld   a,(hl)]
	eor.b	#0x05,d0                         	| [xor  #0x05]
	jbsr	osd_w_colorram                         	| [ld   (hl),a]
	rts                                    	| [ret]

*=============================================================================
* j_314C_select_char()
*  Description:
*    'enter your intiials', handle fire button input.
*    Returns from _top5_dlg_proc after 3rd initial entered.
* IN:
*  ...
* OUT:
*  ...
*-----------------------------------------------------------------------------
j_314C_select_char:
* get the selected character from the 1st,2nd,or 3rd slot.
* get lower byte of current character's address in v-ram
	move.b	b_8A00+0x10,d0                  	| [ld   a,(b_8A00 + 0x10)] HL = $8400 + $0100 + b_8A00[ 0x10 ]
	move.b	d0,d6                           	| [ld   l,a]
	move.w	#0x8500,d7         	| [ld   h,#>m_color_ram + >0x0100]
	and.w	#0xFF,d6
	add.w	d6,d7
	moveq	#0,d0
	jbsr	osd_w_colorram                             	| [ld   (hl),#0] set color to Cyan
	move.w	#0x8100,d7          	| [ld   h,#>0x8000 + >0x0100]
	add.w	d6,d7
	jbsr	osd_r_videoram
	move.b	d0,d2                         	| [ld   c,(hl)] copy the character from the input entry position in tile-ram
	move.b	#40,d0                          	| [ld   a,#40] 20 seconds
	move.b	d0,ds4_game_tmrs_92ac+2              	| [ld   (ds4_game_tmrs_92ac + 2),a] :=$28

* get the pointer to the new name entry in the table, and increment since it is actually ( &name[0] -1 )
	move.l	b_8A00+0x06,a0              	| [ld   hl,(b_8A00 + 0x04)]
	addq.w	#1,a0                           	| [inc  hl]

	move.b	d2,(a0)                         	| [ld   (hl),c] copy the character to the table
	move.l	a0,b_8A00+0x06                  	| [ld   (b_8A00 + 0x04),hl] save the updated pointer

	lea	b_8A00+0x10,a0                 	| [ld   hl,#b_8A00 + 0x10] get lower byte of current input character's address in v-ram
	move.b	(a0),d0                         	| [ld   a,(hl)]
	sub.b	#0x20,d0                         	| [sub  #0x20] offset one position (column) to the right
	scs		d7
	move.b	d0,(a0)                         	| [ld   (hl),a]

* the characters are entered at xx49, xx29, xx09.
* so at the 3rd character, the sub $20 would result in a Cy.
	tst.b	d7
	jeq	l_30B5_next_char_selectn           	| [jp   nc,l_30B5_next_char_selectn]

* after 3rd character has been accepted, update the display and wait for the music to time out.
	jbsr	c_puts_top5scores_321d                 	| [call c_puts_top5scores_321d] selected character appears in the name under TOP 5
	jbsr	c_plyr_initials_entry_hilite_line 	| [call c_plyr_initials_entry_hilite_line]

	move.b	#76,d0                          	| [ld   a,#76]
	move.b	d0,ds3_frame_cts_92A0+0         	| [ld   (ds3_frame_cts_92A0 + 0),a] :=$4C
l_3179:
	move.b	ds3_frame_cts_92A0+0,d0         	| [ld   a,(ds3_frame_cts_92A0 + 0)]
	                               	| [and  a]
	jne	l_3179                             	| [jr   nz,l_3179]
	rts                                    	| [ret]

*=============================================================================
* c_plyr_initials_entry_hilite_line()
*  Description:
*   Hi-lite the row in yellow text corresponding to the player's score
*   ranking on the "Enter your initials" dialog screen.
* IN:
*  ...
* OUT:
*  ...
*-----------------------------------------------------------------------------
c_plyr_initials_entry_hilite_line:
	move.b	b_8A00+0x11,d0                  	| [ld   a,(b_8A00 + 0x11)] 1==1ST place etc.
	lea	d_3197_hiscore_line_ptrs,a0    	| [ld   hl,#d_3197_hiscore_line_ptrs]
	subq.b	#1,d0                           	| [dec  a]
	jbsr	add_4_times_d0_to_a0_0008                            	| [rst  0x08] HL += 2A (determine index into table of word ptrs)
	move.l	a0,d7           | [ld   a,(hl)]
	                       	| [inc  hl]
	                       	| [ld   h,(hl)]
	                       	| [ld   l,a]
	move.b	#0x16,d1                        	| [ld   b,#0x16] number of characters to modify
	                       	| [ld   de,#-0x20] advance 1 cell column to the right
	move.b	#5,d0
l_3191:
	jbsr	osd_w_colorram                         	| [ld   (hl),#5] set character attribute byte to hi-lite color.
	sub.w	#0x20,d7                            	| [add  hl,de]
	subq.b	#1,d1                           	| [...]
	jne	l_3191                             	| [djnz l_3191]
	rts                                    	| [ret]

*=============================================================================
* Table of pointers to each line of on-screen Top 5 table. Reminider that each
* additional 2 byte increment offsets the pointer down 1 row (due to how v-ram
* is organized).
*
d_3197_hiscore_line_ptrs:
	.long 0x8400 + 0x0374
	.long 0x8400 + 0x0376
	.long 0x8400 + 0x0378
	.long 0x8400 + 0x037A
	.long 0x8400 + 0x037C

*=============================================================================
d_31A1:
	.byte 0x0C,0x09,0x06,0x03,0x00
	.align	2

*=============================================================================
*  Description:
*   pointers for c_3118_insert_top5_score
*-----------------------------------------------------------------------------
d_31A6:
	.long case_31B0
	.long case_31B4
	.long case_31B8
	.long case_31CE
	.long case_31D9

case_31B0:
	move.b	#0x12,d0                        	| [ld   a,#0x12]
	jra	l_31BA                             	| [jr   l_31BA]
case_31B4:
	move.b	#0x0C,d0                        	| [ld   a,#0x0C]
	jra	l_31BA                             	| [jr   l_31BA]
case_31B8:
	move.b	#0x06,d0                        	| [ld   a,#0x06]
l_31BA:
	lea	b_best5_score4+0x05,a0         	| [ld   hl,#b_best5_score4 + 0x05]
	lea	b_best5_score5+0x05,a1         	| [ld   de,#b_best5_score5 + 0x05]
	move.b	#0x00,d1                        	| [ld   bc,#0x0006] 6
	move.b	#0x06,d2                        	| [ld   bc,#0x0006] 6
    jbsr   lddr
	lea	b_best5_score4+0x05,a1         	| [ld   de,#b_best5_score4 + 0x05]
	move.b	d0,d2                           	| [ld   c,a]
    jbsr   lddr
	jra	case_31D9                          	| [jp   case_31D9]

case_31CE:
	lea	b_best5_score5+0x05,a1         	| [ld   de,#b_best5_score5 + 0x05]
	lea	b_best5_score4+0x05,a0         	| [ld   hl,#b_best5_score4 + 0x05]
	move.w	#0x06,d1                        	| [ld   bc,#0x0006] 6
	jbsr	lddr

case_31D9:
	move.b	b_8A00+0x11,d0                  	| [ld   a,(b_8A00 + 0x11)] 1==1ST place etc. ... index into hi-score table ... d_31ED[ 2 * (A - 1) ]
	subq.b	#1,d0                           	| [dec  a]
	lea	d_31ED_hi_score_tbl,a0         	| [ld   hl,#d_31ED_hi_score_tbl] array of addresses of score table elements
	jbsr	add_4_times_d0_to_a0_0008                            	| [rst  0x08] HL += 2A
	move.l	(a0),a1                        	| [ld   e,(hl)]
	                        	| [inc  hl]
	                        	| [ld   d,(hl)]
	move.l	b_8A00,a0              	| [ld   hl,(b_8A00 + 0x00)] ptr to plyr1 score or plyr2 score on screen.
	move.w	#0x06,d1                        	| [ld   bc,#0x0006] 6
	jbsr	lddr
	rts                                    	| [ret]

*=============================================================================
* pointers to individual score strings of Top 5 table (documented elsewhere)
* scores only, complete table structure in best_score_table_32C5
d_31ED_hi_score_tbl:
	.long b_best5_score1 + 0x05
	.long b_best5_score2 + 0x05
	.long b_best5_score3 + 0x05
	.long b_best5_score4 + 0x05
	.long b_best5_score5 + 0x05

*=============================================================================
* c_31F7_chk_score_rank()
*  Description:
*  called by _top5_dlg_proc, once for each of 5th place score, 4th place etc.
*
* IN:
*  DE == pointer to 100000's digit (highest address) of score table entry.
*  $8A00 == pointer to 100000's digit (highest address) of either plyr1
*           or plyr2 score (6 characters in tile-ram).
* OUT:
*  Cy (Player Score > Table Entry)
*-----------------------------------------------------------------------------
c_31F7_chk_score_rank:
	move.l	b_8A00,a0              	| [ld   hl,(b_8A00 + 0x00)] ptr to plyr1 score or plyr2 score on screen.
	move.b	#6,d1                           	| [ld   b,#6]
l_31FC:
	move.b	(a1),d0                         	| [ld   a,(de)] score digit

* skip "spaces" (only the 100000 place of table entry could be "space" character)
	cmp.b	#0x24,d0                         	| [cp   #0x24]
	jeq	l_320E                             	| [jr   z,l_320E]

* ... and since table entries are all at least 20000, then any space in the player score will not place.
	move.b	(a0),d0                         	| [ld   a,(hl)] ptr to plyr1 score or plyr2 score on screen
	cmp.b	#0x24,d0                         	| [cp   #0x24]
	bne.b	0f                               	| [...]
	rts                                    	| [ret  z] [...]
0:

	move.b	(a1),d0                         	| [ld   a,(de)]
l_3206:
* sets Cy if score digit > table digit
	cmp.b	(a0),d0                          	| [cp   (hl)] ptr to plyr1 score or plyr2 score on screen
	beq.b	0f                               	| [...]
	rts                                    	| [ret  nz] [...]
0:
l_3208:
	subq.w	#1,a0                           	| [dec  l]
	subq.w	#1,a1                           	| [dec  e]
	subq.b	#1,d1                           	| [...]
	jne	l_31FC                             	| [djnz l_31FC]

	clr.b	d0                               	| [xor  a]
	rts                                    	| [ret]

l_320E:
* table digit == $24
	cmp.b	(a0),d0                          	| [cp   (hl)] ptr to plyr1 score or plyr2 score on screen
	jeq	l_3208                             		| [jr   z,l_3208] if both spaces, jp to next
* score digit != $24 ...
	clr.b	d0                               	| [xor  a] "table digit"
	jra	l_3206                             		| [jr   l_3206]

*=============================================================================
* hiscore_heroes()
*  Description:
* IN:
*  ...
* OUT:
*  ...
*-----------------------------------------------------------------------------
c_mach_hiscore_show_3214:
	lea	str_3345,a0                    			| [$3214: ld   hl,#str_3345] 'GALACTIC HEROES'
	jbsr	c_text_out_ce_3328                  | [$3217: call c_text_out_ce_3328]
	jbsr	c_text_out_ce_3328                  | [$321A: call c_text_out_ce_3328] 'BEST 5'  hl==335c
*=============================================================================
* hiscore_scrn()
*  Description:
*   Common sub for Enter Initials and Galactic Heroes - display each score
*   entry under "TOP 5".
*
* IN:
*  ...
* OUT:
*  ...
*-----------------------------------------------------------------------------
c_puts_top5scores_321d:
	lea	s_32B4_score_name,a0           			| [ld   hl,#s_32B4_score_name]
	jbsr	c_text_out_331b                     | [call c_text_out_331b] puts 'SCORE     NAME' below 'TOP 5'
	move.b	#1,d1                           	| [ld   b,#1] starting index for c_3231
	jbsr	c_3231                            	| [call c_3231] '1ST............'
	jbsr	c_3231                            	| [call c_3231] '2ND............'
	jbsr	c_3231                            	| [call c_3231] '3RD............'
	jbsr	c_3231                            	| [call c_3231] '4RD............'
                                                  * continue to '5TH' ...
*=============================================================================
* c_3231()
*  Description:
*   Setting lines for hi-score table. 1st,2nd,3rd,and 4th are by calling the
*   function. 5th is by allowing execution to fall through from c_puts_top5scores_321d.
*   Each call to 3270 offsets DE for the next column (-$20) and advanced HL.
* IN:
*  B=rank (1 to 5)
* OUT:
*  B+=1
*-----------------------------------------------------------------------------
c_3231:
	moveq	#0,d0
	move.b	d1,d0                           	| [$3231: ld   a,b] B=rank (1 to 5)
	subq.b	#1,d0                           	| [$3232: dec  a]
	lsl.w	#4,d0                            	| [$3233: add  a,a]
												| [add  a,a]
												| [add  a,a] A=offset into table ... (B-1)*8
	lea	best_score_table_32C5,a0                | [$3236: ld   hl,#best_score_table_32C5] score placement characters: 'ST', 'ND', 'RD' etc.
	lea	(a0,d0.w),a0                            | [$3239: rst  0x10] HL += A
	move.l	(a0)+,a1                         	| [$323A: ld   e,(hl)] destination lo-byte
												| [$323B: inc  hl]
												| [$323C: ld   d,(hl)] destination hi-byte
												| [$323D: inc  hl]
	move.b	d1,d0                           	| [$323E: ld   a,b] B=numerical score placement
	jbsr	write_videoram_to_a1                | [$323F: ld   (de),a] putc '5' of '5TH' on screen.
	sub.w	#0x20,a1                          	| [$3240: call c_3273] DE:-=$20
	jbsr	c_put_initial_3270                  | [$3243: call c_put_initial_3270] putc 'T' of '5TH' on screen.
	jbsr	c_put_initial_3270                  | [$3246: call c_put_initial_3270] putc 'H' of '5TH' on screen.
	sub.w	#0x40,a1                            | [$3249: call c_3273] DE:-=$20
												| [$324C: call c_3273] DE:-=$20
	move.l	(a0)+,a2                         	| [$324F: ld   a,(hl)] const ptr to score (hi-byte)
												| [$3250: inc  hl]
												| [$3251: ld   c,(hl)] const ptr to score (lo-byte)
												| [$3252: inc  hl]
	move.l	a0,-(sp)                        	| [$3253: push hl] save const ptr to player initials.
												| [$3254: ld   h,c]
												| [$3255: ld   l,a] HL=ptr to 6-bytes score text
	
	
	move.l	a2,a0								| source address
	jbsr	string_copy_3275                    | [$3256: call string_copy_3275] puts 'XXXXX' of 5th place on screen.
												| [$3259: ld   a,e]
	sub.w	#0x20*6,a1                        	| [$325A: sub  #0x20 * 6] advance column ptr right 6 characters.
	                          		            | [$325D: jr   nc,l_3260]
	                                        	| [$325F: dec  d] when not jr?
l_3260:
                 	                           	| [$325C: ld   e,a]
	move.l	(sp)+,a0                        	| [$3260: pop  hl]
	move.l	(a0),a0                         	| [$3261: ld   a,(hl)]
												| [$3262: inc  hl]
	                         	                | [$3263: ld   h,(hl)]
	                         	                | [$3264: ld   l,a]
	* ROM? pointer in d5/D6...
	jbsr	c_put_initial_3270                  | [$3265: call c_put_initial_3270] putc 1st initial
	jbsr	c_put_initial_3270                  | [$3268: call c_put_initial_3270] putc 2nd initial
	jbsr	c_put_initial_3270                  | [$326B: call c_put_initial_3270] putc 3rd initial
	addq.b	#1,d1                           	| [$326E: inc  b]
	rts                                    	    | [$326F: ret]

*=============================================================================
* c_put_initial_3270()
*  Description:
* IN:
*  HL=character to "putc".
*  DE=destination position.
* OUT:
*  Increments HL (useful for multi-character strings)
*-----------------------------------------------------------------------------
c_put_initial_3270:
	move.b	(a0)+,d0                         	| [ld   a,(hl)]
	jbsr	write_videoram_to_a1                         	| [ld   (de),a]
	                           	| [inc  hl]

*=============================================================================
* c_3273()
*  Description:
*   Use with "puts" routines to advance one character to right in tile memory.
*   This is continuation of 3270 above, but also is called explicitly.
* IN:
*  ...
* OUT:
*  ...
*-----------------------------------------------------------------------------
c_3273:
	jbsr	rst_20                            	| [rst  0x20] DE-=$20
	rts                                    	| [ret]
* end 'call _3270'

*=============================================================================
* string_copy_3275()
*  Description:
*  Copies a 6 byte string.
*  The format for '12345' is: "0x05 0x04 0x03 0x02 0x01 0x24" (24 is space)
* IN:
*  HL=pointer to source string (last character i.e. the "space")
*  DE="puts" destination address (on screen)
* OUT:
*  ...
*-----------------------------------------------------------------------------
string_copy_3275:
	exg	a1,d7
	move.b	#6,d2                           	| [ld   c,#6]
l_3277:
	move.b	(a0),d0                         	| [ld   a,(hl)]
	jbsr	osd_w_videoram                         	| [ld   (de),a]
	subq.w	#1,a0                           	| [dec  hl]
	sub.w	#0x20,d7                            	| [rst  0x20] DE-=$20
	subq.b	#1,d2                           	| [dec  c]
	jne	l_3277                             	| [jr   nz,l_3277]
	exg	a1,d7
	rts                                    	| [ret] end 'call _3275'

*=============================================================================
*  Description:
*   High score table strings.
*-----------------------------------------------------------------------------
s_327F_enter_your_initials:
* "ENTER YOUR INITIALS !"
	.long 0x8000 + 0x0320 + 0x04
	.byte 0x15
	.byte 0x04                                   | color code (c_text_out_ce_3328)
	.byte 0x0E,0x17,0x1D,0x0E,0x1B,0x24,0x22,0x18,0x1E,0x1B,0x24,0x12,0x17,0x12,0x1D,0x12,0x0A,0x15,0x1C,0x24,0x2C
* "SCORE       NAME" (after l_3073, in cyan ... not color encoded)
	.long 0x8000 + 0x02E0 + 0x07
	.byte 0x10
	.byte 0x1C,0x0C,0x18,0x1B,0x0E,0x24,0x24,0x24,0x24,0x24,0x24,0x24,0x17,0x0A,0x16,0x0E
* "TOP 5" (32AB)
	.long 0x8000 + 0x0240 + 0x10
	.byte 0x05
	.byte 0x04                                   | color code (c_text_out_ce_3328)
	.byte 0x1D,0x18,0x19,0x24,0x05
s_32B4_score_name:
* "SCORE     NAME" (c_puts_top5scores_321d)
	.long 0x8000 + 0x0280 + 0x12
	.byte 0x0E
	.byte 0x1C,0x0C,0x18,0x1B,0x0E,0x24,0x24,0x24,0x24,0x24,0x17,0x0A,0x16,0x0E

* formatting for score table list at _3236
*  struct{
*   byte *position_address
*   char2[] text
*   byte *score_bcd    ( e.g. "123456" encoded as "06 05 04 03 02 01" and ptr=&"01")
*   byte *initials
best_score_table_32C5:
	.long 0x8000 + 0x0340 + 0x14
	.byte 0x1C,0x1D  || "ST"
	.long b_best5_score1 + 0x05
	.long b_best5_name1
	.word	0		| padding to make 16 bytes
       *
	.long 0x8000 + 0x0340 + 0x16
	.byte 0x17,0x0D  || "ND"
	.long b_best5_score2 + 0x05
	.long b_best5_name2
	.word	0		| padding to make 16 bytes
       *
	.long 0x8000 + 0x0340 + 0x18
	.byte 0x1B,0x0D  || "RD"
	.long b_best5_score3 + 0x05
	.long b_best5_name3
	.word	0		| padding to make 16 bytes
       *
	.long 0x8000 + 0x0340 + 0x1A
	.byte 0x1D,0x11  || "TH"
	.long b_best5_score4 + 0x05
	.long b_best5_name4
	.word	0		| padding to make 16 bytes
       *
	.long 0x8000 + 0x0340 + 0x1C
	.byte 0x1D,0x11  || "TH"
	.long b_best5_score5 + 0x05
	.long b_best5_name5

*=============================================================================
* c_32ED_top5_dlg_endproc()
*  Description:
*   Closes the 'enter your initials' process.
*   checks credits available and exits early if credits are available.
* IN:
*  ...
* OUT:
*  ...
*-----------------------------------------------------------------------------
c_32ED_top5_dlg_endproc:
* if (free-play)
	move.b	ds3_io_input_99b5+0x00,d0       	| [ld   a,(ds3_io_input_99b5 + 0x00)] io_input[credit_count]
	cmp.b	#0xA0,d0                         	| [cp   #0xA0]
	jeq	l_32FB_check_for_timeout           	| [jr   z,l_32FB_check_for_timeout]
* else if ( hw credit cnt > current credit count ) goto finish
	move.b	d0,d1                           	| [ld   b,a]
	move.b	b8_99B8_credit_cnt,d0           	| [ld   a,(b8_99B8_credit_cnt)]
	cmp.b	d1,d0                            	| [cp   b]
	jcs	l_3300_finish                      	| [jr   c,l_3300_finish]

l_32FB_check_for_timeout:
	move.b	ds4_game_tmrs_92ac+2,d0              	| [ld   a,(ds4_game_tmrs_92ac + 2)]
	                               	| [and  a]
	beq.b	0f                               	| [...]
	rts                                    	| [ret  nz] [...]
0:

* Time up. Copy available characters from input to Top 5 score name table.

* The pop forces 1 stack frame to be skipped (returns to caller of _top5_dlg_proc)
l_3300_finish:
	move.l	(sp)+,a0                        	| [pop  hl]

* Setup HL and DE as pointers for copy from input characters to new Top5 table name entry.
	lea	0x8100,a0          	| [ld   h,#>0x8000 + >0x0100]
	and.w	#0xFF,d6
	move.b	b_8A00+0x10,d0                  	| [ld   a,(b_8A00 + 0x10)] lower byte of current character's address in v-ram
	move.b	d0,d6                           	| [ld   l,a]
	add.w	d6,a0
	move.l	b_8A00+0x06,a1              	| [ld   de,(b_8A00 + 0x04)] pointer to next name character to store in Top 5 table...
 	addq.w	#1,a1                           	| [inc  de] ... actually it points to ( next_character - 1 )

* When the time runs out, 1, 2, or 3 characters may have already been selected
* by the player. Rather than keeping count, it simply checks that the column
* pointer from the input is off past the right limit. The rightmost input
* character is $8109 and will underflow when subtracting $20. Since the
* subtraction is done by addition (-21h == $DF), the inverse of the Cy flag can
* be used to detect the equivalent of the underflow of the subtraction.
	move.l	a0,d5
	LOAD_D5D6_FROM_D5_16
l_330C:
	jbsr	ldi                               	| [ldi]
	move.b	#-0x21,d0                       	| [ld   a,#-0x21] subtract $21 since the LDI added 1 to HL
	subq.b	#1,d5                           	| [dec  h]
	add.b	d6,d0                            	| [add  a,l]
	jcc	l_3315                             	| [jr   nc,l_3315]
	addq.b	#1,d5                           	| [inc  h] L is 9, 29, or 49 so Cy is set, and we restor the  H...
l_3315:
	move.b	d0,d6                           	| [ld   l,a]
	btst.b	#0,d5                           	| [bit  0,h] if the Cy was set, then bit 0 should be set.
	jne	l_330C                             	| [jr   nz,l_330C]
	LOAD_D5_16_FROM_D5D6
	move.l	d5,a0
	
	rts                                    	| [ret]

*=============================================================================
* c_text_out_331b()
*  Description:
*  Text out, color attribute not encoded. Text blocks are length-encoded.
* IN:
*  HL=start address of string
* OUT:
*  HL=start address at next string
*-----------------------------------------------------------------------------
c_text_out_331b:
* destination address
	moveq	#0,d7
	move.b	(2,a0),d7
	rol.w	#8,d7
	move.b	(3,a0),d7                         	| [$331B: ld   e,(hl)] LSB
	addq.w	#4,a0                               | [$331C: inc  hl]
	                         	                | [$331D: ld   d,(hl)] MSB
	                                            | [$331E: inc  hl]
								
* byte count of string
	move.b	(a0)+,d1                         	| [$331F: ld   b,(hl)]
	                           	                | [$3320: inc  hl]

l_3321:
	move.b	(a0)+,d0                         	| [$3321: ld   a,(hl)] character code
	jbsr	osd_w_videoram                      | [$3322: ld   (de),a] putc
	                           	                | [$3323: inc  hl] src++
	sub.w	#0x20,d7                            | [$3324: rst  0x20] DE-=$20
	subq.b	#1,d1                           	| [...]
	jne	l_3321                             	    | [$3325: djnz l_3321]
	rts                                    	    | [$3327: ret]

*=============================================================================
* c_text_out_ce_3328()
*  Description:
*   Text out, color attribute encoded. Text blocks are length-encoded.
*   Used by game_over.
* IN: A0: pointer on text structure to display
*  ...
* OUT: A0: A0 when IN plus 4
*  ...
*-----------------------------------------------------------------------------
c_text_out_ce_3328:
	addq	#2,a0
	move.b	(a0)+,d3                         	| [$3328: ld   e,(hl)] LSB
	                           	                | [$3329: inc  hl]
	move.b	(a0)+,d4                         	| [$332A: ld   d,(hl)] MSB
	                           	                | [$332B: inc  hl]
	move.b	(a0)+,d1                         	| [$332C: ld   b,(hl)] strlen
	                           	                | [$332D: inc  hl]
	move.b	(a0)+,d2                         	| [$332E: ld   c,(hl)] color
	                           	                | [$332F: inc  hl]
	LOAD_D3_16_FROM_D3D4
	exg	d3,d7                              	    | [$3330: ex   de,hl]
	exg		a1,a0
l_3331:
	move.b	(a1)+,d0                         	| [$3331: ld   a,(de)] data address
	jbsr	osd_w_videoram                     	| [$3332: ld   (hl),a]
	bset.b	#10,d7                           	| [$3333: set  2,h] dest+=$0400 (tile color regs)
	move.b	d2,d0                         	    | [$3335: ld   (hl),c]
	jbsr	osd_w_colorram
	bclr.b	#10,d7                           	| [$3336: res  2,h]
	                                        	| [$3338: inc  de]
	move.b	#-0x20,d0                       	| [$3339: ld   a,#-0x20]
	sub.w	#0x100,d7                           | [$333B: dec  h]
	add.b	d7,d0                            	| [$333C: add  a,l]
	jcc	l_3340                             	    | [$333D: jr   nc,l_3340]
	add.w	#0x100,d7                           | [$333F: inc  h]
l_3340:
	move.b	d0,d7                           	| [$3340: ld   l,a]
	subq.b	#1,d1                           	| [...]
	jne	l_3331                             	    | [$3341: djnz l_3331]
	exg		a1,a0                              	| [$3343: ex   de,hl]
	rts                                    	    | [$3344: ret]

*=============================================================================
* strings for mach_hiscore_show
*=============================================================================
str_3345:
* "THE GALACTIC HEROES"
	.long 0x8000 + 0x0320 + 0x05
	.byte 0x13
	.byte 0x02
	.byte 0x1D,0x11,0x0E,0x24,0x10,0x0A,0x15,0x0A,0x0C,0x1D,0x12,0x0C,0x24,0x11,0x0E,0x1B,0x18,0x0E,0x1C
*_335C:
* "-- BEST 5 --"
	.long 0x8000 + 0x02C0 + 0x0C
	.byte 0x0C
	.byte 0x04
	.byte 0x26,0x26,0x24,0x0B,0x0E,0x1C,0x1D,0x24,0x05,0x24,0x26,0x26
	.align	2

*=============================================================================
* jp_RAM_test()
*  Description:
*   RAM test at powerup (from machine reset at 2c4) or Service-switch reset.
* IN:
*  ...
* OUT:
*  ...
*-----------------------------------------------------------------------------
jp_RAM_test:
	lea	str_3B7E(pc),a0                    	| [ld   hl,#str_3B7E] load start address of src string "RAM  OK"
	jbsr	c_text_out_331b                        	| [call c_text_out_331b] display "RAM  OK"

											| [ld   (_sfr_watchdog),a]
											| [call c_svc_clr_snd_regs] $9AA0, $40 bytes

* enable f_05BE in CPU-sub1 (empty task) ... disabled in game_ctrl start
	move.b	#7,d0                           	| [ld   a,#7]
	move.b	d0,ds_cpu1_task_actv+0x00       	| [ld   (ds_cpu1_task_actv + 0x00),a] 7 ... skips to f_05BE in CPU-sub task-table

	jbsr	c_spriteposn_regs_init            	| [call c_spriteposn_regs_init]


*=============================================================================
* j_36BA_Machine_init()
*  Description:
*   Waits a short delay by the frame counter, re-checks Test-switch prior to
*   display of the cross hatch test pattern before "normal" startup.
*
*     Per Bally Manual "If you wish to keep this test pattern on the monitor screen
*     for futher use, slide Self-Test switch back to the "ON" position after the
*     cross hatch appears and before it disappears."
*
*   Once the Test-switch is turned Off, proceeds to set the IO controller to "credit"
*   mode and waits for input data to start (IO data requests are being done in the
*   "Task manager" periodic process.
* IN:
*  ...
* OUT:
*  ...
*-----------------------------------------------------------------------------
* drawing the cross hatch pattern - tile ram layout is pretty clumsy!

	move.w	#0x8000,d7                  	| [ld   hl,#0x8000]

	move.b	#0x10,d1                        	| [ld   b,#0x10]
l_36D4:
	move.b	#0x28,d0
	jbsr	osd_w_videoram                      	| [ld   (hl),#0x28]
	addq.w	#1,d7                           	| [inc  hl]
	move.b	#0x27,d0
	jbsr	osd_w_videoram                      	| [ld   (hl),#0x27]
	addq.w	#1,d7                           	| [inc  hl]
	subq.b	#1,d1                           	| [...]
	jne	l_36D4                             	| [djnz l_36D4]

	
	move.b	#0x10,d1                        	| [ld   b,#0x10]
l_36DE:
	move.b	#0x2D,d0
	jbsr	osd_w_videoram                      	| [ld   (hl),#0x2D]
	addq.w	#1,d7                           	| [inc  hl]
	move.b	#0x2B,d0
	jbsr	osd_w_videoram                      	| [ld   (hl),#0x2B]
	addq.w	#1,d7                           	| [inc  hl]
	subq.b	#1,d1                           	| [...]
	jne	l_36DE                             	| [djnz l_36DE]

	move.b	#0x10,d1                        	| [ld   b,#0x10]
l_36E8:
	move.b	#0x28,d0
	jbsr	osd_w_videoram                      	| [ld   (hl),#0x28]
	addq.w	#1,d7                           	| [inc  hl]
	move.b	#0x2D,d0
	jbsr	osd_w_videoram                      	| [ld   (hl),#0x2D]
	addq.w	#1,d7                           	| [inc  hl]
	subq.b	#1,d1                           	| [...]
	jne	l_36E8                             	| [djnz l_36E8]

	move.b	#0x10,d1                        	| [ld   b,#0x10]
l_36F2:
	move.b	#0x27,d0
	jbsr	osd_w_videoram                      	| [ld   (hl),#0x27]
	addq.w	#1,d7                           	| [inc  hl]
	move.b	#0x2B,d0
	jbsr	osd_w_videoram                  | [ld   (hl),#0x2B]
	addq.w	#1,d7                           | [inc  hl]
	subq.b	#1,d1                           | [...]
	jne	l_36F2                             	| [djnz l_36F2]

* remainder of cross hatch pattern is copied, i.e.  *(0x8000 + DE) = *(0x8000 + HL)
*	exg	a1,a0                              	| [ex   de,hl]
*
*	move.w	0x8000+0x0040,d7           	| [ld   hl,#0x8000 + 0x0040] DE==$8080
*	move.b	#0x03,d1                        	| [ld   bc,#0x0340] 832
*	move.b	#0x40,d2                        	| [ld   bc,#0x0340] 832
*	jbsr	ldir                              	| [ldir]
*
*	lea	0x8000(pc),a0                  	| [ld   hl,#0x8000] DE==$83C0
*	move.b	#0x00,d1                        	| [ld   bc,#0x0040] 64
*	move.b	#0x40,d2                        	| [ld   bc,#0x0040] 64
*	jbsr	ldir                              	| [ldir]



	
	* JOTD: now init CPU1 from here
	
	
	jbsr	galaga1_reset

	* some vars that game initializes during system tests and which the
	* game relies on!!
	
	move.b	#0xEA,ds_new_stage_parms_99c0+0x05
	move.w	#0xEAF5,d5
	MOVE_TO_VAR	d5,ds_plyr_actv+_w_shot_ct
	
	jra	j_Game_init_02d3                        	| [jp   j_Game_init_02d3]


*=============================================================================
* c_svc_easteregg_hdlr()
*  Description:
*   Easter Egg screen!
* IN:`
*  ...
* OUT:
*  ...
*-----------------------------------------------------------------------------
c_svc_easteregg_hdlr:
	jbsr	c_3774                            	| [call c_3774]
	jbsr	c_3774                            	| [call c_3774]
	jbsr	c_3774                            	| [call c_3774]
	move.w	#0x05,d0                        	| [ld   a,#0x05]
	add.w	d0,a0
	rts                        	| [jp   rst_HLplusA] returns to caller from HLplusA

*=============================================================================
* c_3774()
*  Description:
* IN:
*  ...
* OUT:
*  ...
*-----------------------------------------------------------------------------
c_3774:
	move.b	(a1),d0                         	| [ld   a,(de)]
	move.b	#8,d2                           	| [ld   c,#8]
l_3777:
	add.b	d0,d0                            	| [add  a,a]
	jcc	l_377B                             	| [jr   nc,l_377B]
	addq.b	#1,(a0)                         	| [inc  (hl)]
l_377B:
	addq.w	#1,a0                           	| [inc  hl]
	subq.b	#1,d2                           	| [dec  c]
	jne	l_3777                             	| [jr   nz,l_3777]
	addq.w	#1,a1                           	| [inc  de]
	addq.w	#1,a0                           	| [inc  hl]
	rts                                    	| [ret]

*=============================================================================
* control input sequence to trigger Easter Egg.
* ... 5R 6L 3R 7L
d_easteregg_trigger:
	.byte 0x02,0x02,0x02,0x02,0x02
	.byte 0x08,0x08,0x08,0x08,0x08,0x08
	.byte 0x02,0x02,0x02
	.byte 0x08,0x08,0x08,0x08,0x08,0x08,0x08
	.byte 0xFF

* easter egg screen data
d_easteregg_data:
	.byte 0x01,0x3E,0x00,0x7F,0x41,0x00,0x21,0x41,0x00,0x00
	.byte 0x41,0x00,0x36,0x3E,0x00,0x49,0x00,0x03,0x49,0x22,0x03,0x49,0x41,0x00,0x36,0x41
	.byte 0x3E,0x00,0x3E,0x41,0x3E,0x00,0x41,0x49,0x7F,0x41,0x49,0x20,0x7F,0x49,0x18,0x00
	.byte 0x32,0x20,0x40,0x00,0x7F,0x40,0x01,0x00,0x7F,0x7F,0x3F,0x40,0x21,0x44,0x40,0x00
	.byte 0x44,0x00,0x3C,0x44,0x01,0x42,0x3F,0x01,0x81,0x00,0x01,0xA5,0x7F,0x01,0xA5,0x04
	.byte 0x7F,0x99,0x08,0x00,0x42,0x10,0x00,0x3C,0x7F,0x00

*=============================================================================
* c_io_cmd_wait()
*  Description:
*   wait for IO_ACKRDY "command executed" ($10) read from IO chip status sfr.
* IN:
*  ...
* OUT:
*  ...
*-----------------------------------------------------------------------------
c_io_cmd_wait:
	rts
*while_io_cmd_wait:
*	move.b	0x7100,d0                       	| [ld   a,(0x7100)] read IO status
*   
*	cmp.b	#0x10,d0                         	| [cp   #0x10]
*	bne.b	0f                               	| [...]
*	rts                                    	| [ret  z] [...]
*0:
*	jra	while_io_cmd_wait                  	| [jr   while_io_cmd_wait]


_l_37F4:



*=============================================================================
* c_svc_updt_dsply()
*  Description:
*   Displays dip switch configuration in test screen.
* IN:
*  ...
* OUT:
*  ...
*   Switches are active low, i.e. OFF -> 1, ON -> 0
*   Bally machine apparently does not have a config switch for the cab type.
*   DSWA is not the same as NAMCO.
*   Notes from Mame136 galaga.c:
*   The Cabinet Type "dip switch" actually comes from the edge connector, but is mapped
*   in memory in place of dip switch #8. dip switch #8 selects single/dual coin counters
*   and is entirely handled by hardware.
*
*   DSWA -> sfr_dsw_X:1 (6J)
*                         SW#8 SW#7 SW#6 SW#5 SW#4 SW#3 SW#2 SW#1
*            DIFFICULTY      -    -    -    -    -    -    X    X
*               UNKNOWN      -    -    -    -    -    X    -    -  (@ f_0ECA)
* SOUND IN ATTRACT MODE      -    -    -    -    X    -    -    -
*          FREEZE VIDEO      -    -    -    X    -    -    -    -
*          CABINET TYPE      X    -    -    -    -    -    -    -
*
*  DSWB -> sfr_dsw_X:0 (6K)
*                      SW#8 SW#7 SW#6 SW#5 SW#4 SW#3 SW#2 SW#1
*   COINS PER CREDIT      -    -    -    -    -    X    X    X
*  BONUS SHIPS AWARD      -    -    X    X    X    -    -    -
*    NBR OF FIGHTERS      X    X    -    -    -    -    -    -
*
*
*-----------------------------------------------------------------------------
c_svc_updt_dsply:

* CABINET TYPE (DSWA)
* 0x80 -> UPRIGHT
* 0x00 -> TABLE

*	move.b	_sfr_dsw8,d0                    	| [ld   a,(_sfr_dsw8)] cabinet type
*	roxr.b	#1,d0                           	| [rra] get DSWA#8 (sfr_dsw8:1)
** inverting the bit provides the index
*	addq.b	#1,d0                           	| [inc  a] invert bit in bit-0
*	and.b	#0x01,d0                         	| [and  #0x01]
	moveq	#0,d0
	move.b	d0,b_mchn_cfg_cab_type          	| [ld   (b_mchn_cfg_cab_type),a]
*  svc_cab_type( a )
	lea	str_3ACC,a0                    	| [ld   hl,#str_3ACC] 0-"UPRIGHT", 1-"TABLE"
	jbsr	add_4_times_d0_to_a0_0008             	| [rst  0x08] HL += 2A
	jbsr	c_svc_cab_type                    	| [call c_svc_cab_type]

* By pushing the "1 PLAYER" and the "2 PLAYER" buttons at the same time, the
* picture will turn updside down and stay that way until you release the buttons.
* If the buttons are not pushed, the picture stays inverted momentarily until
* a 0 is read from the IO chip (due to residual non-zero value left from memory test).
*	move.b	ds3_io_input_99b5+0x00,d0       	| [ld   a,(ds3_io_input_99b5 + 0x00)]
*	clr.b	d2                               	| [ld   c,#0]
*	and.b	#0x0C,d0                         	| [and  #0x0C] 08->2plyr_start, 04->1plyr_start
*	jne	l_380F                             	    | [jr   nz,l_380F]
*	addq.b	#1,d2                           	| [inc  c] c:=1  (flips the screen)
*l_380F:
*	move.b	d2,d0                           	| [ld   a,c]
	                                         	| [ld   (0xA007),a] flip screen control
	moveq	#0,d2

* DIFFICULTY LEVEL SETTING (DSWA)
*    0x00  = 0 -> A (MEDIUM)
*    0x01  = 1 -> C (HARD)
*    0x02  = 2 -> D (HARDEST)
*    0x03  = 3 -> A (EASY)

	                   	                        | [$3813: ld   hl,#_sfr_dsw1] difficulty level
	jbsr	osd_read_dsw_1                      | [$3816: ld   a,(hl)]
	ror.b	#1,d0                           	| [$3817: rra] get DSWA#1 (sfr_dsw1:1)
	and.b	#0x01,d0                         	| [$3818: and  #0x01]
	move.b	d0,d2                           	| [$381A: ld   c,a]
	                           	                | [$381B: inc  hl]
	jbsr	osd_read_dsw_2                      | [$381C: ld   a,(hl)]
	and.b	#0x02,d0                         	| [$381D: and  #0x02] get DSWA#2 (sfr_dsw2:1)
	or.b	d2,d0                             	| [$381F: or   c] lo-bit in C
	move.b	d0,b_mchn_cfg_rank_9984             | [$3820: ld   (b_mchn_cfg_rank_9984),a]
	lea	str_3A68,a0                    	        | [$3823: ld   hl,#str_3A68] base_address of rank-characters (B/C/D/A)
	jbsr	add_d0_to_a0_0010                   | [$3826: rst  0x10] HL += A
	lea	0x8000+0x0220+0x0C,a1      	            | [$3827: ld   de,#0x8000 + 0x0220 + 0x0C] rank-character ("B", "C", "D", or "A")
	move.b	(a0),d0                             | [$382A: ldi] (DE)<-(HL) ..."X" of "RANK X" displayed
	jbsr	write_videoram_to_a1
	lea	str_3AE4,a0                    	        | [$382C: ld   hl,#str_3AE4] "RANK"
	jbsr	c_text_out_331b                        	| [$382F: call c_text_out_331b] display "RANK"


* NUMBER OF FIGHTERS (DSWB)
*     0x00 -> 2
*     0x40 -> 4
*     0x80 -> 3
*     0xC0 -> 5

* configuration setting is "number of fighters - 1"
	jbsr	osd_read_dsw_7                 	    | [$3832: ld   hl,#_sfr_dsw7] get DSWB#7 (sfr_dsw7:0)
	                         	                | [$3835: ld   a,(hl)] hi-bit
	move.b		d0,d7
	jbsr	osd_read_dsw_8   			        | [$3836: inc  hl] get DSWB#8 (sfr_dsw8:0)
	move.b	d0,d2                         	    | [$3837: ld   c,(hl)] lo-bit
	move.b	d7,d0
	roxr.b	#1,d2                           	| [$3838: rr   c] "right-shift" lo-bit into Cy flag.
	addx.b	d0,d0								| [$383A: adc  a,a]   | "left-shift" the hi-bit and add the lo-bit from Cy flag.
	and.b	#0x03,d0                         	| [$383B: and  #0x03]
	addq.b	#1,d0                           	| [$383D: inc  a] this gives "cfg = nbr_of_ships - 1"
	move.b	d0,b_mchn_cfg_nships            	| [$383E: ld   (b_mchn_cfg_nships),a]

*  0x8000[$02EA] = mchn_cfg_nships + 1
	addq.b	#1,d0                           	| [$3841: inc  a]
	move.w	#0x8000+0x02E0+0x0A,d7       	    | [$3842: ld   (0x8000 + 0x02E0 + 0x0A),a] "X" of "X SHIPS" displayed
	jbsr	osd_w_videoram
*  text_out($3AEB)
	lea	str_3AEB,a0                    	        | [$3845: ld   hl,#str_3AEB] "SHIPS"
	jbsr	c_text_out_331b                        	| [$3848: call c_text_out_331b]


* load default IO params (sets up credit-mode and joystick remapping - see _372D)
* 4 arguments to "set coinage" command (9281-4) will be updated below to capture
* dip switch changes for credit-mode.
	lea	d_3AC4,a0                      	        | [$384B: ld   hl,#d_3AC4]
	lea	ds8_9280_tmp_IO_parms,a1       	        | [$384E: ld   de,#ds8_9280_tmp_IO_parms] default IO params for credit-mode (8 bytes)
	move.w	#0x08,d1                        	| [$3851: ld   bc,#0x0008] 8
	jbsr	ldir                              	| [$3854: ldir]
 
* COINS PER CREDIT (DSWB)
*  Mask   SW#1 SW#2 SW#3
*  0x00   ON   ON   ON  - free play
*  0x04   ON   ON   OFF - 4-coin/1-credit
*  0x02   ON   OFF  ON  - 3-coin/1-credit
*  0x06   ON   OFF  OFF - 2-coin/1-credit
*  0x01   OFF  ON   ON  - 2-coin/3-credit
*  0x05   OFF  ON   OFF - 1-coin/3-credit
*  0x03   OFF  OFF  ON  - 1-coin/2-credit
*  0x07   OFF  OFF  OFF - 1-coin/1-credit

*	lea	_sfr_dsw1,a0                   	        | [ld   hl,#_sfr_dsw1] coins per credit
*	move.b	#3,d1                           	| [ld   b,#3] 3 bits
*	clr.b	d0                               	| [xor  a]
*l_385C:
*	move.b	(a0),d2                         	| [ld   c,(hl)]
*	roxr.b	#1,d2                           	| [rr   c] "right-shift" lo-bit into Cy flag.
*	addx.b	d0,d0								| adc  a,a                                   | "left-shift" the hi-bit and add the lo-bit from Cy flag.
*	addq.w	#1,a0                           	| [inc  hl]
*	subq.b	#1,d1                           	| [...]
*	jne	l_385C                             	| [djnz l_385C]
*
*	and.b	#0x07,d0                         	| [and  #0x07] 3-bits only please
	moveq	#1,d0
* if ( free_play )
	jeq	l_389B                             	| [jr   z,l_389B]
* else  TableOffset=(Index-1)*8 ... resulting offsets are $00,$08,$10,$18,$20,$28,$30)
	subq.b	#1,d0                           	| [dec  a]
	lsl.b	#3,d0
	                            	| [add  a,a]
	                            	| [add  a,a]
	                            	| [add  a,a]

* Update 4 arguments to "set coinage" command from the table.
	lea	str_3A6C,a0                    	| [ld   hl,#str_3A6C]
	jbsr	add_d0_to_a0_0010                            	| [rst  0x10] HL += A
	lea	ds8_9280_tmp_IO_parms+1,a1     	| [ld   de,#ds8_9280_tmp_IO_parms + 1]
	move.w	#0x04,d1                        	| [ld   bc,#0x0004] 4
	jbsr	ldir                              	| [ldir]
* the next four bytes are the text characters
	lea	0x8000+0x02E0+0x08,a1      	| [ld   de,#0x8000 + 0x02E0 + 0x08]
	move.b	(a0)+,d0                               	| [ldi] show digit for number of coins
	jbsr	osd_w_videoram
	lea	0x8000+0x0220+0x08,a1      	| [ld   de,#0x8000 + 0x0220 + 0x08]
	move.b	(a0)+,d0                               	| [ldi] show digit for number of coins
	jbsr	osd_w_videoram
	lea	0x8000+0x01E0+0x08,a1      	| [ld   de,#0x8000 + 0x01E0 + 0x08]
	move.b	(a0)+,d0                               	| [ldi] show digit for number of coins
	jbsr	osd_w_videoram
	lea	0x8000+0x00E0+0x08,a1      	| [ld   de,#0x8000 + 0x00E0 + 0x08]
	move.b	(a0)+,d0                               	| [ldi] show digit for number of coins
	jbsr	osd_w_videoram

	move.b	#0x24,d0                        	| [ld   a,#0x24]
	move.w	#0x8000+0x0200+0x08,d7       	| [ld   (0x8000 + 0x0200 + 0x08),a] shows a space after "COIN(S)"
	jbsr	osd_w_videoram
	lea	str_3AF3,a0                    	| [ld   hl,#str_3AF3] " COIN"
	jbsr	c_text_out_331b                        	| [call c_text_out_331b]
	jbsr	c_text_out_331b                        	| [call c_text_out_331b] "CREDIT" of "X CREDIT"
	jra	l_38AB                             	| [jr   l_38AB]

* Update 4 arguments to "set coinage" command from the table for free-play mode
l_389B:
	lea	ds8_9280_tmp_IO_parms+1,a0     	| [ld   hl,#ds8_9280_tmp_IO_parms + 1] 4 bytes (arguments to "set coinage" command)
	move.b	#4,d1                           	| [ld   b,#4]
l_38A0:
	clr.b	(a0)+                             	| [ld   (hl),#0]
												| [inc  hl]
	subq.b	#1,d1                           	| [...]
	jne	l_38A0                             	| [djnz l_38A0]

	lea	str_3B04,a0                    	| [ld   hl,#str_3B04]
	jbsr	c_text_out_331b                        	| [call c_text_out_331b] "FREE PLAY"

* Bonus Ships Awarded (DSWB)
* Mask  Selection    S#4 S#5 S#6    Index into table 3AA4
* 0x20  20-60-60     ON  ON  OFF    1
* 0x10  20-70-70     ON  OFF ON     2
* 0x30  20-80-80     ON  OFF OFF    3
* 0x08  30-100-100   OFF ON  ON     4
* 0x28  30-120-120   OFF ON  OFF    5
* 0x18  20-60        OFF OFF ON     6
* 0x38  30-80        OFF OFF OFF    7
* 0x00  None         ON  ON  ON     0
* Bonus config displayed in following format:
* 1ST BONUS  X0000 PTS
* 2ND BONUS XX0000 PTS
* AND EVERY XX0000 PTS

l_38AB:
	sub.w	#4,a7
	move.l	a7,a0
	jbsr		osd_read_dsw_4
	move.b	d0,(a0)
	jbsr		osd_read_dsw_5
	move.b	d0,(1,a0)
	jbsr		osd_read_dsw_6
	move.b	d0,(2,a0)
	                                    		| [ld   hl,#_sfr_dsw4] bonus levels

	move.b	#3,d1                           	| [ld   b,#3] 3 positions to read
	clr.b	d0                               	| [xor  a]
	CLEAR_XC_FLAGS
l_38B1:
	move.b	(a0)+,d2                         	| [ld   c,(hl)]
	roxr.b	#1,d2                           	| [rr   c] "right-shift" lo-bit into Cy flag.
	addx.b	d0,d0				                | [adc  a,a]  "left-shift" the hi-bit and add the lo-bit from Cy flag.
	                           	| [inc  hl]
	subq.b	#1,d1                           	| [...]
	jne	l_38B1                             	| [djnz l_38B1]

	addq.w	#4,a7
*  if ( 0 == switch_selection ) goto 392D  // display "BONUS NOTHING", ret to 35be
	and.b	#0x07,d0                         	| [and  #0x07]
	jeq	l_392D                             	| [jp   z,l_392D]

	move.b	d0,d2                           	| [ld   c,a]
	move.b	b_mchn_cfg_nships,d0            	| [ld   a,(b_mchn_cfg_nships)] Bonus levels depend upon number of fighters starting.
	and.b	#0x04,d0                         	| [and  #0x04] note: num_ships = mchn_cfg_nships + 1
	add.b	d0,d0                            	| [add  a,a]
	add.b	d2,d0                            	| [add  a,c] add dsw value
	add.b	d0,d0                            	| [add  a,a] a:=a*2 ... use as offset into table
	lea	str_3AA4,a0                    	| [ld   hl,#str_3AA4] bonus config data
	jbsr	add_d0_to_a0_0010                            	| [rst  0x10] HL += A...A==2,C,4,6,E,8,A
	lea	w_mchn_cfg_bonus_9980,a1            	| [ld   de,#w_mchn_cfg_bonus_9980] ld two-bytes (str_3AA4)
	jbsr	ldi                               	| [ldi]
	jbsr	ldi                               	| [ldi]
	subq.w	#1,a0                           	| [dec  hl] point to second byte of two-byte Table entry
	move.b	#1,d2                           	| [ld   c,#1] flag tells 38DA that it was 'called' i.e. get out by return
	jbsr	c_38DA                            	| [call c_38DA] display 'second and every' bonus settings
	subq.w	#1,a0                           	| [dec  hl] point to first byte of two-byte table entry
	clr.b	d2                               	| [ld   c,#0] flag allows 3904 ret to occur

*=============================================================================
* c_38DA()
*  Description:
* IN:
*  ...
* OUT:
*  ...
*-----------------------------------------------------------------------------
c_38DA:
	moveq	#0,d0
	move.b	(a0),d0                         	| [ld   a,(hl)] ld one byte from the two-byte table entry
	addq.b	#1,d0                           	| [inc  a] setup test for $FF in the bonus-none parameters
	jeq	l_393B                             	    | [jp   z,l_393B] if 'bonus none', skip the 'second and every' display (when?)
	move.b	d2,d0                           	| [ld   a,c] first-pass (second-and-every) indicated by 1, second-pass indicated by 0..
	add.b	d0,d0                            	| [add  a,a] ...so A==2 or A==0  (offset from 3B1A to string address loaded into HL)
	move.l	a0,-(sp)                        	| [push hl] save address of table-entry
	lea	bonus_text_ptr_table_3b1a,a0                    	        | [ld   hl,#str_3B1A] i.e., 1E 3B "1ST BONUS ", 36 3B "2ND BONUS"
	add.b	d0,d0                   | [rst  0x10] HL += A                                  | HL += A
	move.l	(a0,d0.w),a0                         	| [ld   a,(hl)] get LSB of src address
	                                        	| [inc  hl]
                                               	| [ld   h,(hl)] get MSB of src address
                                               	| [ld   l,a] ld LSB to L
	movem.w	d1/d2,-(sp)                    	    | [push bc] C holds the so-called 'first-bonus/second-bonus' flag, save it!
	jbsr	c_text_out_331b                        	| [call c_text_out_331b] display "2ND BONUS" or "1ST BONUS"
	jbsr	c_text_out_331b                        	| [call c_text_out_331b] display "0000 PTS" of "??? BONUS XX0000 PTS"...
                                                  * HL==$3B2B or HL==$3B42, as there are two copies of "0000 PTS"
                                                  * DE==$80B2, that value will be used later......?

	movem.w	(sp)+,d1/d2                    	    | [pop  bc] get back the first-pass-second-pass flag
	move.l	(sp)+,a0                        	| [pop  hl] get back the address of the table-entry
	move.b	(a0),d0                         	| [ld   a,(hl)] ld the table-entry...
	and.b	#0x7F,d0                         	| [and  #0x7F] ... and mask out bit-7 which indicates there is no 'and-every' setting
	exg	a1,a0                              	    | [ex   de,hl] save address of table-entry in HL... DE==$80B2 (address of ' ' in "PTS ")
	lea	0x8000+0x01E0+0x10,a0      	            | [ld   hl,#0x8000 + 0x01E0 + 0x10]
	move.b	d2,d1                           	| [ld   b,c] the first time through here, C==1...
	subq.b	#1,d1                           	| [...]
	jne	l_38FF                             	    | [djnz l_38FF] ... so the second time, when the Flag is 0 we skip next two lines
	addq.w	#2,a0                           	| [inc  hl] * 2
l_38FF:
	jbsr	c_391E                            	| [call c_391E] display "X" of "??? BONUS XX0000 PTS"
	exg	a1,a0                              	| [ex   de,hl] HL:= to second-or-first-table-entry again
	subq.b	#1,d2                           	| [dec  c] C:=$00 at end of first-pass...
	beq.b	0f                               	| [...]
	rts                                    	| [ret  nz] ...after second-pass, ret to _35BE, end 'call _37F4' (displaying dsw menu) [...]
0:
	exg	a1,a0                              	| [ex   de,hl] save the current bonus-parameter-table-entry into DE
	move.b	(a1),d0                         	| [ld   a,(de)] A:=$86 for 20-60 setting, the second of the two byte-parameters
	btst.b	#7,d0                           	| [bit  7,a] if (bit-7)...
	jne	l_3949                             	| [jp   nz,l_3949] ... then jp (bit test is Z flag... bit-7 set if no 'and-every' bonus)
	lea	0x8000+0x01E0+0x14,a0      	| [ld   hl,#0x8000 + 0x01E0 + 0x14] address of character X in "AND EVERY X 0000 PTS"
	jbsr	c_391E                            	| [call c_391E] display XX of "AND EVERY XX0000 PTS"
	movem.w	d3/d4,-(sp)                    	| [push de]
	move.l	a1,-(sp)                        	| [push de]
	lea	str_3B4D,a0                    	| [ld   hl,#str_3B4D] "AND EVERY"
	jbsr	c_text_out_331b                        	| [call c_text_out_331b]
	jbsr	c_text_out_331b                        	| [call c_text_out_331b] display "0000 PTS" of "AND EVERY XX0000 PTS"  ( HL expected to be $3B59)
	move.l	(sp)+,a0                        	| [pop  hl]
	rts                                    	| [ret]
* end 'call 38DA', ret to _38D7

*=============================================================================
* c_391E()
*  Description:
*   converts bonus levels to decimal and display on screen
*   on entry, HL==address_to_write_to
*               A==value from bonus-parameter-table
* IN:
*  ...
* OUT:
*  ...
*-----------------------------------------------------------------------------
c_391E:
	move.b	#0x24,d1                        	| [ld   b,#0x24] start with a ' ' (space) character in B
	cmp.b	#0x0A,d0                         	| [cp   #0x0A] check if value if > 10
	jcs	l_3928                             	| [jr   c,l_3928] if Cy, it means that A<$0A, so jr past the display of the 10's place digit
	move.b	#1,d1                           	| [ld   b,#1] value is 10 or greater...
	sub.b	#0x0A,d0                         	| [sub  #0x0A] ...so subtract off the value of 10...
l_3928:
	exg	d1,d0                         	| [ld   (hl),b] ...and write a "1" to screen for the "10's" place
	jbsr	osd_w_videoram
	exg	d1,d0
	bclr.b	#5,d7                           	| [res  5,l] i.e.  HL:-=$20, which will offset 1 column to the right on the screen
	jbsr	osd_w_videoram
	                         	| [ld   (hl),a] write the "one's" place to the screen
	rts                                    	| [ret] end 'call _391E'
* jp here from 38BA
l_392D:
	lea	str_3B64,a0                    	        | [ld   hl,#str_3B64] "BONUS NOTHING"
	jbsr	c_text_out_331b                        	| [call c_text_out_331b]
	lea	w_mchn_cfg_bonus_9980,a0            	| [ld   hl,#w_mchn_cfg_bonus_9980]
	move.b	#0xFF,(a0)+                      	| [ld   (hl),#0xFF]
	                           	| [inc  hl]
	move.b	#0xFF,(a0)                      	| [ld   (hl),#0xFF]
* put space characters on the line where "2ND BONUS ?????? PTS" goes ( jp here from $38DC??? )
l_393B:
	exg	a1,a0                              	| [ex   de,hl] save HL
	move.w	#0x8000+0x0320+0x12,d7      	| [ld   hl,#0x8000 + 0x0320 + 0x12]
	move.b	#0x16,d1                        	| [ld   b,#0x16] writing out $16 characters
* while ( b > 0 )
l_3941:
	move.b	#0x24,d0                      	| [ld   (hl),#0x24] space ' '
	jbsr	osd_w_videoram
	                        	| [ld   a,#0xE0]
	sub.w	#0x20,d7                           	| [dec  h] effectively, HL:-=$100
	                            	| [rst  0x10] HL += A, which adds back $E0, effectively we've done HL:-=$20
	subq.b	#1,d1                           	| [...]
	jne	l_3941                             	| [djnz l_3941]

* jp here from $3909... putting space character on the line where "AND EVERY ?????? PTS" goes
l_3949:
	move.w	#0x8000+0x0320+0x14,d7      	| [ld   hl,#0x8000 + 0x0320 + 0x14]
	move.b	#0x16,d1                        	| [ld   b,#0x16]
l_394E:
	move.b	#0x24,d0                      	| [ld   (hl),#0x24]
	jbsr	osd_w_videoram
	                        	| [ld   a,#0xE0]
	sub.w	#0x20,d7                           	| [dec  h]
	                            	| [rst  0x10] HL += A
	subq.b	#1,d1                           	| [...]
	jne	l_394E                             	| [djnz l_394E]
	exg	a1,a0                              	| [ex   de,hl] see 393b
	rts                                    	| [ret] if jp'd to _392D, ret to _35BE... end 'call _37F4' (displaying dsw options)
                                                  * if jp'd to _393B,l_3949 end 'call 38DA', ret to _35BE
*=============================================================================
* c_tileram_regs_clr()
*  Description:
* IN:
*  ...
* OUT:
*  ...
*-----------------------------------------------------------------------------
c_tileram_regs_clr:
	move.w	#0x8000,d7                  	| [ld   hl,#0x8000]
	             	| [ld   de,#0x8000 + 0x01]
	move.w	#0x03FF,d1                        	| [ld   bc,#0x0400] 1024
	                        	| [ld   bc,#0x0400] 1024
	move.b	#0x24,D0                      	| [ld   (hl),#0x24]
	                             	| [ldir]
0:
	jbsr	osd_w_videoram
	addq.w	#1,d7
	dbf		d1,0b

	move.w	#0x03FF,d1                        	| [ld   bc,#0x0400] 1024
	move.b	#3,d0
0:
	jbsr	osd_w_colorram                         	| [ld   (hl),#3] now filling in at $8400 (color ram)...
	dbf		d1,0b
	                     	| [ld   bc,#0x03FF] 1023
	                     	| [ld   bc,#0x03FF] 1023
	                       	| [ldir]
	move.b	#7,d0                           	| [ld   a,#7] star ctrl default param
	move.b	d0,ds_99B9_star_ctrl+0x05       	| [ld   (ds_99B9_star_ctrl + 0x05),a] :=7
	rts                                    	| [ret]
* end call

*=============================================================================
* c_spriteposn_regs_init()
*  Description: could be optimized
* IN:
*  ...
* OUT:
*  ...
*-----------------------------------------------------------------------------
c_spriteposn_regs_init:
	lea	sfr_sprite_posn_9380,a0             	| [ld   hl,##sfr_sprite_posn_9380] $80 bytes
	move.b	#0x80,d1                        	| [ld   b,#0x80] length of sprite position regs
l_3977:
	move.b	#0xF1,(a0)+                      	| [ld   (hl),#0xF1]
	                           	| [inc  hl]
	subq.b	#1,d1                           	| [...]
	jne	l_3977                             	| [djnz l_3977]
	rts                                    	| [ret] extra garbage on screen gone with RAM OK showing
* end call

*=============================================================================
* c_svc_machine_totals()
*  Description:
*   Show "remaining" counts of Games Played and Points Scored, in this format:
*   'XX.XYYY.YYYY.ZZZZ.ZAAA.'
*   The indicators are subtracted from their maximum...
*    i.e. 999-UUU=XXX or 9999999-UUUUUUU=YYYYYYY
*
*   XXX:     b16_99E0_ttl_plays_bcd  (lower 3 BCD nibbles only i.e. 0-999)
*
*   YYYYYYY: b32_99E2_sum_score_bcd  (lower 3 BCD nibbles only i.e. 0-999)
*
*   ZZZZZ:   b32_99E6_gametime_secs_bcd (5 BCD digits of seconds count ...
*            ... omit the 1/60th count)
*   AAA:     b16_99EA_bonus_ct_bcd  (lower 3 BCD nibbles only i.e. 0-999)
* IN:
*  ...
* OUT:
*  ...
* NOTE: the game time and bonus count would only be non-zero if the machine is
*       warm reset during a running game. MAME (136) doesn't seem to handle
*       warm reset properly and it hangs at "RAM OK".
*-----------------------------------------------------------------------------
c_svc_machine_totals:
	lea	b16_99E0_ttl_plays_bcd,a0      	| [ld   hl,#b16_99E0_ttl_plays_bcd]
	lea	0x8000+0x0340+0x1E,a1      	| [ld   de,#0x8000 + 0x0340 + 0x1E] at lower left of screen

* the first set has 2 digits, followed by the '.'
	move.b	#2,d2                           	| [ld   c,#2]

	move.b	#1,d1                           	| [ld   b,#1]
	jbsr	c_3997                            	| [call c_3997] XX.X

	move.b	#3,d1                           	| [ld   b,#3]
	jbsr	c_3997                            	| [call c_3997] ____YYY.YYYY

	move.b	#2,d1                           	| [ld   b,#2]
	jbsr	c_3997                            	| [call c_3997] HL=99E6

	addq.w	#1,a0                           	| [inc  hl] skip 1/60th part of timer.

	move.b	#1,d1                           	| [ld   b,#1]

* 3997 again ("inline")... do the bonus-count portion ("AAA")

*=============================================================================
* c_3997()
*  Description:
* IN:
*  ...
* OUT:
*  ...
*-----------------------------------------------------------------------------
c_3997:
	jbsr	c_39AA                            	| [call c_39AA]
l_399A:
	jbsr	c_39A0                            	| [call c_39A0] does 39AA also
	subq.b	#1,d1                           	| [...]
	jne	l_399A                             	| [djnz l_399A]
	rts                                    	| [ret]

*=============================================================================
* c_39A0()
*  Description:
* IN:
*  ...
* OUT:
*  ...
*-----------------------------------------------------------------------------
c_39A0:
	move.b	#0x99,d0                        	| [ld   a,#0x99]
	sub.b	(a0),d0                          	| [sub  (hl)]
	roxr.b	#4,d0                           	| [rra] * 4
	jbsr	c_39AE                            	| [call c_39AE]

* optimization: fall-through to c_39AA

*=============================================================================
* c_39AA()
*  Description:
* IN:
*  ...
* OUT:
*  ...
*-----------------------------------------------------------------------------
c_39AA:
	move.b	#0x99,d0                        	| [ld   a,#0x99]
	sub.b	(a0),d0                          	| [sub  (hl)]
	addq.w	#1,a0                           	| [inc  hl]

* optimization: fall through to call c_39AE

*=============================================================================
* c_39AE()
*  Description:
*   Put Digit.
*   The running count in C is checked... when ==0,  put the '.'
*   Updates tile position to right (-$20) for each character shown.
* IN:
*  A=character code to display.
*  C=remaining count of digits in the sequence
* OUT:
*  C=remaining count of digits in the sequence
*  DE= next tile position.
*-----------------------------------------------------------------------------
c_39AE:
	and.b	#0x0F,d0                         	| [and  #0x0F]
	jbsr	write_videoram_to_a1                         	| [ld   (de),a]
	jbsr	rst_20                            	| [rst  0x20] DE-=$20
	subq.b	#1,d2                           	| [dec  c]
	beq.b	0f                               	| [...]
	rts                                    	| [ret  nz] [...]
0:
	move.b	#0x2A,d0                        	| [ld   a,#0x2A] '.' character
	move.b	#4,d2                           	| [ld   c,#4]
	jbsr	write_videoram_to_a1                         	| [ld   (de),a]
	jbsr	rst_20                            	| [rst  0x20] DE-=$20
	rts                                    	| [ret]

*=============================================================================
* c_svc_machine_ttls_erase()
*  Description:
*   Erases Machine Totals
* IN:
*  ...
* OUT:
*  ...
*-----------------------------------------------------------------------------
c_svc_machine_ttls_erase:
	lea	0x8000+0x0340+0x1E,a0      	| [ld   hl,#0x8000 + 0x0340 + 0x1E]

	move.b	#0x17,d1                        	| [ld   b,#0x17] nr of characters to fill
	                       	| [ld   de,#-0x20]
l_39C3:
	move.b	#0x24,(a0)                      	| [ld   (hl),#0x24]
	sub.w	#0x20,a0                            	| [add  hl,de]
	subq.b	#1,d1                           	| [...]
	jne	l_39C3                             	| [djnz l_39C3]

	rts                                    	| [ret]

*=============================================================================
* c_svc_test_input_hdlr()
*  Description:
*   Handle inputs during Self-Test Mode.
*   Moving the controller left or right, and pressing any game button or
*   activating the coin switches results in the selection and activation of
*   the various game sounds.
*   There is also an additional mode, undocumented in the Bally Manual, which
*   displays the Machine Information if a "Service Switch" is activated.
*   This switch is not documented in the Bally manual.
*   MAME does however have a defintion of the switch, i.e.
*   	PORT_BIT( 0x04, IP_ACTIVE_LOW, IPT_SERVICE1 )
* IN:
*  B=countdown from $10 representing active input state in terms of
*     bit-position in HL.
* OUT:
*  saves BC, HL
*-----------------------------------------------------------------------------

* c_svc_test_input_hdlr : entry point is below...

l_39C9_call397D:
	illegal
	move.l	a0,-(sp)                        	| [push hl]
	jbsr	c_svc_machine_totals              	| [call c_svc_machine_totals]

*  reset Machine Totals timer
	move.w	#15*60,d5                    	| [ld   hl,#(15 * 60)]
	move.w	d5,w_svc_15sec_tmr              	| [ld   (w_svc_15sec_tmr),hl] init timer (15*60)

	move.l	(sp)+,a0                        	| [pop  hl]

	movem.w	(sp)+,d1/d2                    	| [pop  bc]
	rts                                    	| [ret]


*=============================================================================
* c_svc_clr_snd_regs()
*  Description:
*   Initialize data structures for sound manager.
* IN:
*  ...
* OUT:
*  ...
*-----------------------------------------------------------------------------
c_svc_clr_snd_regs:
	lea	ds_9AA0,a0                     	| [ld   hl,#ds_9AA0] sound mgr SFRs, clear $40 bytes
	move.b	#0x40,d1                        	| [ld   b,#0x40] length to fill
l_3A41:
	clr.b	(a0)+                             	| [ld   (hl),#0] fill with 0
												| [inc  hl]
	subq.b	#1,d1                           	| [...]
	jne	l_3A41                             	| [djnz l_3A41]
	rts                                    	| [ret]

*-----------------------------------------------------------------------------
str_3A47:
	.long 0x8000 + 0x02E0 + 0x0E
	.byte 0x05
	.byte 0x1C,0x18,0x1E,0x17,0x0D || "SOUND"

	.align	2

*=============================================================================
* c_svc_cab_type()
*  Description:
*   wrapper for c_text_out_331b (dereferences the pointer passed in HL)
*   (caller is displaying the cab-type)
* IN:
*  ...
* OUT:
*  ...
*-----------------------------------------------------------------------------
c_svc_cab_type:
	move.l	(a0),a0
	                       	| [ld   a,(hl)] LSB
	                       	| [inc  hl]
	                       	| [ld   h,(hl)] MSB
	                       	| [ld   l,a] LSB
	jra	c_text_out_331b                         	| [jp   c_text_out_331b] jp instead of calling so we only have to ret once
* (returns from subroutine at $331B)


*=============================================================================
*
* Text strings and other data
*
*-----------------------------------------------------------------------------

* text-characters for difficulty settings-MEDIUM,HARD,HARDEST,EASY respectively
str_3A68:
	.byte 0x0B,0x0C,0x0D,0x0A

* format characters for COIN/CREDIT display
str_3A6C:
	.byte 0x04,0x01,0x04,0x01,0x04,0x1C,0x01,0x24  || 4-coin(s)/1-credit( )
	.byte 0x03,0x01,0x03,0x01,0x03,0x1C,0x01,0x24  || 3-coin(s)/1-credit( )
	.byte 0x02,0x01,0x02,0x01,0x02,0x1C,0x01,0x24  || 2-coin(s)/1-credit( )
	.byte 0x02,0x03,0x02,0x03,0x02,0x1C,0x03,0x1C  || 2-coin(s)/3-credit(s)
	.byte 0x01,0x03,0x01,0x03,0x01,0x24,0x03,0x1C  || 1-coin( )/3-credit(s)
	.byte 0x01,0x02,0x01,0x02,0x01,0x24,0x02,0x1C  || 1-coin( )/2-credit(s)
	.byte 0x01,0x01,0x01,0x01,0x01,0x24,0x01,0x24  || 1-coin( )/1-credit( )

* bonus-setting parameters...e.g. $02,$06 -> "20000-60000-60000"
str_3AA4:
	.byte 0xFF,0xFF        || NO BONUS SHIPS GIVEN WITH THIS SETTING
	.byte 0x02,0x06
	.byte 0x02,0x07
	.byte 0x02,0x08
	.byte 0x03,0x0A
	.byte 0x03,0x0C
	.byte 0x02,0x06 + 0x80 || bit-7 means there's no 'and-every' bonus
	.byte 0x03,0x08 + 0x80 || bit-7 means there's no 'and-every' bonus

* ???????????
str_3AB4:
	.byte 0xFF,0xFF,0x03,0x0A,0x03,0x0C,0x03,0x0F,0x03,0x8A,0x03,0x8C,0x03,0x8F,0x03,0xFF

* default params for IO test
d_3AC4:
	.byte 0x01,0x01,0x01,0x01,0x01,0x02,0x03,0x00
	.align	2

* pointers to cabinet-types strings.
str_3ACC:
	.long str_3AD0                               | pointer to "UPRIGHT" text
	.long str_3ADA                               | pointer to "TABLE" text
str_3AD0:
	.long 0x8000 + 0x02E0 + 0x06
	.byte 0x07
	.byte 0x1E,0x19,0x1B,0x12,0x10,0x11,0x1D || "UPRIGHT"
str_3ADA:
	.long 0x8000 + 0x02E0 + 0x06
	.byte 0x07
	.byte 0x1D,0x0A,0x0B,0x15,0x0E,0x24,0x24 || "TABLE  "
str_3AE4:
	.long 0x8000 + 0x02E0 + 0x0C
	.byte 0x04
	.byte 0x1B,0x0A,0x17,0x14 || "RANK",
str_3AEB:
	.long 0x8000 + 0x02A0 + 0x0A
	.byte 0x05
	.byte 0x1C,0x11,0x12,0x19,0x1C || "SHIPS",
str_3AF3:
	.long 0x8000 + 0x02C0 + 0x08
	.byte 0x05
	.byte 0x24,0x0C,0x18,0x12,0x17 || " COIN",
str_3AFB:
	.long 0x8000 + 0x01A0 + 0x08
	.byte 0x06
	.byte 0x0C,0x1B,0x0E,0x0D,0x12,0x1D || "CREDIT"
str_3B04:
	.long 0x8000 + 0x02E0 + 0x08
	.byte 0x12
	.byte 0x0F,0x1B,0x0E,0x0E,0x24,0x19,0x15,0x0A,0x22 || "FREE PLAY"
	.byte 0x24,0x24,0x24,0x24,0x24,0x24,0x24,0x24,0x24
	.byte 0x24 || extra space character?
bonus_text_ptr_table_3b1a:
	.long str_1ST_BONUS
	.long str_2ND_BONUS
str_1ST_BONUS:
	.long 0x8000 + 0x0330
	.byte 0x0A
	.byte 0x01,0x1C,0x1D,0x24,0x0B,0x18,0x17,0x1E,0x1C,0x24 || "1ST BONUS "
str_3B2B:
	.long 0x8000 + 0x01B0
	.byte 0x08
	.byte 0x00,0x00,0x00,0x00,0x24,0x19,0x1D,0x1C || "0000 PTS"
str_2ND_BONUS:
	.long 0x8000 + 0x0320 + 0x12
	.byte 0x09
	.byte 0x02,0x17,0x0D,0x24,0x0B,0x18,0x17,0x1E,0x1C || "2ND BONUS"
str_3B42:
	.long 0x8000 + 0x01B0 + 0x02
	.byte 0x08
	.byte 0x00,0x00,0x00,0x00,0x24,0x19,0x1D,0x1C || "0000 PTS"
str_3B4D:
	.long 0x8000 + 0x0320 + 0x14
	.byte 0x09
	.byte 0x0A,0x17,0x0D,0x24,0x0E,0x1F,0x0E,0x1B,0x22 || "AND EVERY"
str_3B59:
	.long 0x8000 + 0x01A0 + 0x14
	.byte 0x08
	.byte 0x00,0x00,0x00,0x00,0x24,0x19,0x1D,0x1C || "0000 PTS"
str_3B64:
	.long 0x8000 + 0x0320 + 0x10
	.byte 0x16
	.byte 0x0B,0x18,0x17,0x1E,0x1C,0x24,0x17,0x18,0x1D,0x11,0x12,0x17,0x10 || "BONUS NOTHING"
	.byte 0x24,0x24,0x24,0x24,0x24,0x24,0x24,0x24,0x24
	.byte 0x24 || this seems to be extra character
str_3B7E:
	.long 0x8000 + 0x02E0 + 0x02
	.byte 0x07
	.byte 0x1B,0x0A,0x16,0x24,0x24,0x18,0x14 || "RAM  OK"
str_3B88:
	.long 0x8000 + 0x02E0 + 0x04
	.byte 0x07
	.byte 0x1B,0x18,0x16,0x24,0x24,0x18,0x14 || "ROM  OK"
	.align	2


_l_3B92:

*       .org 0x3FFF
*       .db 0x2E                                   | checksum


*       .org 0x0FFF
*       .db 0xFF
* end of ROM
* input file int.s
*
* int.s:
*  gg1-1.3p 'maincpu' (Z80)
*
*  Z80 interrupt vectors, maincpu.
*
*
*.module int0
*.area INTVEC (ABS,OVR)


*

*.org  0x0000

*=============================================================================
* RST_00()
*  Description:
*   Z80 reset
*   Reset/clear the chip command state and jump to the reset handler ($10).
*   NMI is disabled when  IO_CMD & $0F == 0
* IN:
*
* OUT:
*  ...
*-----------------------------------------------------------------------------
rst_00_cpu0:
	move.b	#0x10,d0                        	| [ld   a,#0x10]
	*move.b	d0,0x7100                       	| [ld   (0x7100),a] IO cmd ($10 -> reset/clr chip command state)
	jra	CPU0_RESET                         	| [jp   CPU0_RESET]


*


*=============================================================================
* RST_28()
*  Description:
*   memset(tbl, 0, $F0)
* IN:
* OUT:
*  ...
*-----------------------------------------------------------------------------
	lea	ds_bug_motion_que_9100,a0           	| [ld   hl,#ds_bug_motion_que_9100] memset(..., 0, $F0)
	move.b	#0xF0,d1                        	| [ld   b,#0xF0]
	clr.b	d0                               	| [xor  a] A==00
	jbsr	rst_18                            	| [rst  0x18] memset((HL), A=fill, B=ct)
	rts                                    	| [ret]


*

*.org 0x0030

*=============================================================================
* string_out_pe_30()
*  Description:
*   Entry point to display string function at _139A
* IN:
*   If set Cy flag, indicates to _139A to expect a position encoded string
*   D2: index of string
* OUT:
*  HL == final offset in video ram (some code actually uses this!)
*-----------------------------------------------------------------------------
string_out_pe_30:
	st.b	d7                              	| [ex   af,af']
	jra	j_string_out_pe_139a                    	| [jp   j_string_out_pe_139a]


*

*.org 0x0038
galaga_irq:
*=============================================================================
*  Description:
*   RST $38 handler.
*   jp to the task manager
* IN:
*  ...
* OUT:
*  ...
*-----------------------------------------------------------------------------
	* we shunted all NMI shit to copy number of credits and controls
	* we handle that directly from an osd routine
	lea		ds3_io_input_99b5,a0
	jbsr	osd_update_inputs
	
	jbsr	galaga1_irq
	jra	jp_Task_man_0237                        	| [jp   jp_Task_man_0237]


*=============================================================================
* c_task_switcher()
*  Description: returns from the jp'd task.
* IN:
*  ...
* OUT:
*  ...
* PRESERVES:
*  BC
*-----------------------------------------------------------------------------
c_task_switcher:
	jra	(a0)                               	| [jp   (hl)]


*=============================================================================
* c_sctrl_sprite_ram_clr_003c()
*  Description: could be optimized
*   Initialize screen control registers.
* IN:
*  ...
* OUT:
*  ...
*-----------------------------------------------------------------------------
c_sctrl_sprite_ram_clr_003c:
* memset($9300, 0, $80)
	lea	ds_sprite_posn_9300,a0              	| [ld   hl,#ds_sprite_posn_9300]
	move.b	#0x80,d1                        	| [ld   b,#0x80]
	clr.b	d0                               	| [xor  a]
	jbsr	rst_18                            	| [rst  0x18] memset((HL), A=fill, B=ct)
* memset($9b00, 0, $80)
	lea	ds_sprite_ctrl_9B00,a0              	| [ld   hl,#ds_sprite_ctrl_9B00]
	move.b	#0x80,d1                        	| [ld   b,#0x80]
	jbsr	rst_18                            	| [rst  0x18] memset((HL), A=fill, B=ct)
* memset($8800, $80, $80)
	lea	b_8800,a0                      	| [ld   hl,#b_8800] $80 byte with sprite data buffer blocks
	move.b	#0x80,d0                        	| [ld   a,#0x80]
	move.b	#0x80,d1                        	| [ld   b,#0x80]
	jbsr	rst_18                            	| [rst  0x18] memset((HL), A=fill, B=ct)

	rts                                    	| [ret]


*

*.org 0x0066

*=============================================================================
* NMI
*  Description:
*   NMI
* IN:
* OUT:
*  ...
* called 3 times with various registers set in input
* without that routine (retn at start) game runs but inputs
* (insert coin, joystick...) don't work. It also seems to handle
* ship hit sound or whatnot...
* I think we can live without that in the port... we'll do the readings some other
* way
*-----------------------------------------------------------------------------
*	jbsr	exx                               	| [$0066: exx] Load function params from aux regs
*   actually copy 7000-7002 in 99B5-99B7
*   99B5: number of credits
*   99B6: player 1 controls
*   99B7: player 2 controls (cocktail, we ignore that here!)
*	jbsr	ldi                               	| [$0067: ldi] each nmi will move one byte, so BC--, DE++, HL++
*
**  if ( BC > 0 )  { goto l_008F } ... exit if still copying data
*	jvc	l_008F                             	    | [$0069: jp   pe,l_008F] !P/V when BC==0
*
*	move.w	d0,-(sp)                        	| [$006C: push af] save AF, it's not part of the exx exchange
*
** Signal the chip that the parameter transfer is finished.
*	lea	l_7100,a0                      	        | [$006D: ld   hl,#0x7100] $10 - command params complete.
*	move.b	#0x10,(a0)                      	| [$0070: ld   (hl),#0x10] IO_CMD_DONE
*
**  if ( !player_hit )
*	move.b	b_9AA0+0x19,d0                  	| [$0072: ld   a,(b_9AA0 + 0x19)] sound-fx count/enable registers, ship hit
*	                               	            | [$0075: and  a] A!=0 or maybe 02 when you get hit
*	jeq	l_plyr_ok                          	    | [$0076: jr   z,l_plyr_ok]
** else
*	clr.b	d0                               	| [$0078: xor  a]
*	move.b	d0,b_9AA0+0x19                  	| [$0079: ld   (b_9AA0 + 0x19),a] 0 ... sound-fx count/enable registers, ship hit
*
*	lea	d_IO_ChipParms,a0              	        | [$007C: ld   hl,#d_IO_ChipParms]
*	lea	l_7000,a1                      	        | [$007F: ld   de,#0x7000] IO data xfer (write)
*	move.b	#0x00,d1                        	| [$0082: ld   bc,#0x0004] 4
*	move.b	#0x04,d2                        	| [$0082: ld   bc,#0x0004] 4
*	jbsr	exx                               	| [$0085: exx]
*
*	move.b	#0xA8,d0                        	| [$0086: ld   a,#0xA8]
*	*move.b	d0,0x7100                       	| [$0088: ld   (0x7100),a] IO cmd ($A8 -> trigger bang sound)
*	move.w	(sp)+,d0                        	| [$008B: pop  af]
*	                                            | [$008C: retn]
*l_plyr_ok:
*	move.w	(sp)+,d0                        	| [$008E: pop  af]
*l_008F:
*	jbsr	exx                               	| [$008F: exx] restore regs for the main "thread"
*	rts                                         | [$0090: retn] end 'NMI'

*
*
* data for NMI sub
*
*d_IO_ChipParms:
*	.byte 0x10,0x10,0x20,0x20


*_l_0096:
*            00000096  d_OS_TaskTable                     task_man

*

* input file new_stage.s
*
* new_stage.s:
*  gg1-3.2m, 'maincpu' (Z80)
*
* loads the new parameters for the game stages
*
*
*.module new_stage



**.area ROM (ABS,OVR)
* .org 0x2C00
*.area CSEG2C

*=============================================================================
* stg_bombr_setparms()
*  Description:
*   new stage setup
*   selects table based on level and difficulty setting, loads the new
*   parameters for the stage
* IN:
*  ...
* OUT:
*  ...
*-----------------------------------------------------------------------------
new_stage_setup_2c00:
	move.b	ds_plyr_actv+_b_stgctr,d0       	| [$2C00: ld   a,(ds_plyr_actv +_b_stgctr)] new stage setup 9821
l_2C03:
* while (A > 0x1B)  A -= 4
	cmp.b	#0x1B,d0                         	| [$2C03: cp   #0x1B]
	jcs	l_2C0B                             	    | [$2C05: jr   c,l_2C0B] goto 2C0B
	subq.b	#4,d0                           	| [$2C07: sub  #4]
	jra	l_2C03                             	    | [$2C09: jr   l_2C03]

* E = ( adj_stg_cnt - 1 ) + (adj_stg_cnt-1) * 4  ... multiply by 5
l_2C0B:
	subq.b	#1,d0                           	| [$2C0B: dec  a]
	move.b	d0,d6                               | [$2C0C: ld   l,a]
	rol.b	#2,d0                            	| [$2C0D: rlca] * 2
	add.b	d6,d0                               | [$2C0F: add  a,l]
	move.b	d0,d4                           	| [$2C10: ld   e,a]

* pTbl = bmbr_stg_cfg_lut[mchn_cfg.rank]
	move.b	b_mchn_cfg_rank_9984,d0             | [$2C11: ld   a,(b_mchn_cfg_rank_9984)]
	lea	bmbr_stg_cfg_lut,a0            	        | [$2C14: ld   hl,#bmbr_stg_cfg_lut] ld the table of ptrs
	jbsr	add_4_times_d0_to_a0_0008           | [$2C17: rst  0x08] HL += 2A get pointer
	move.l	(a0),a0                       	    | [$2C18: ld   a,(hl)]
	                       	                    | [$2C19: inc  hl]
	                       	                    | [$2C1A: ld   h,(hl)]
	                       	                    | [$2C1B: ld   l,a]

* pTbl[E]|
	move.b	d4,d0                           	| [$2C1C: ld   a,e] adj_stg_cnt * 5
	jbsr	add_d0_to_a0_0010                   | [$2C1D: rst  0x10] HL += A ... offset into lut

	lea	ds_new_stage_parms_99c0,a1          	| [$2C1E: ld   de,#ds_new_stage_parms_99c0]
	move.b	#5,d1                           	| [$2C21: ld   b,#5]
l_2C23:
	move.b	(a0)+,d0                         	| [$2C23: ld   a,(hl)]
	move.b	d0,d2                           	| [$2C24: ld   c,a] stash data byte
* new_stage_parms[L * 2 + 0] = upper nibble
	rol.b	#4,d0                            	| [$2C25: rlca] * 4
	and.b	#0x0F,d0                         	| [$2C29: and  #0x0F]
	move.b	d0,(a1)+                         	| [$2C2B: ld   (de),a]
* new_stage_parms[L * 2 + 1] = lower nibble
	                           	                | [$2C2C: inc  e]
	move.b	d2,d0                           	| [$2C2D: ld   a,c] retrieve data byte
	and.b	#0x0F,d0                         	| [$2C2E: and  #0x0F]
	move.b	d0,(a1)+                         	| [$2C30: ld   (de),a]
* increment pointers
	                           	                | [$2C31: inc  e]
	                                         	| [$2C32: inc  hl]
	subq.b	#1,d1                           	| [...]
	jne	l_2C23                               	| [$2C33: djnz l_2C23]

* set ds_new_stage_parms_99c0[0x0A] ... number of remaining aliens for enable clone-attack
	move.b	ds_plyr_actv+_b_stgctr,d0       	| [$2C35: ld   a,(ds_plyr_actv +_b_stgctr)] new stage setup
* if ( stage_ctr < 3 )  A = 0 ...
	cmp.b	#3,d0                            	| [cp   #3]
	jcc	l_2C3F                             	    | [jr   nc,l_2C3F]
* ... then
	clr.b	d0                               	| [xor  a]
	jra	l_2C46                             	| [jr   l_2C46]
l_2C3F:
* else if 0xFF == (plyr_state_actv.stage_ctr	| 0x0FC)
	or.b	#~0x03,d0                          	| [or   #~0x03] challenge stages numbered so that bit_0 + bit_1 == 11b
	addq.b	#1,d0                           	| [inc  a]
	jeq	l_2C46                             	    | [jr   z,l_2C46]
* ... then
	move.b	#0x0A,d0                        	| [ld   a,#0x0A] non-challenge stage

l_2C46:
	move.b	d0,(a1)                         	| [ld   (de),a] ds_new_stage_parms_99c0[$A]

* 16 02 02 i.e. start of round defaults for yellow, red, boss bomber timers
	move.b	#0x02,d1                        	| [ld   bc,#0x0216] 534
	move.b	#0x16,d2                        	| [ld   bc,#0x0216] 534
	move.b	d2,b_92C0+0x00                  	| [ld   (b_92C0 + 0x00),bc] = $0216 (int values for ready timers of each bomber type)
	move.b	d1,b_92C0+0x01                  	| [ld   (b_92C0 + 0x01),bc] = $0216 (int values for ready timers of each bomber type)
	move.b	d1,b_92C0+0x02                  	| [ld   (b_92C0 + 0x01),bc] = $0216 (int values for ready timers of each bomber type)

* adjust star speed

*  A = (stage_ctr < $10) : stage_ctr ? $10
	move.b	ds_plyr_actv+_b_stgctr,d0       	| [ld   a,(ds_plyr_actv +_b_stgctr)] limit is 10
	cmp.b	#0x10,d0                         	| [cp   #0x10]
	jcs	l_2C5B                             	    | [jr   c,l_2C5B]
	move.b	#0x10,d0                        	| [ld   a,#0x10]
l_2C5B:
	rol.b	#2,d0                            	| [rlca] * 2
	and.b	#0x70,d0                         	| [and  #0x70]
	add.b	#0x40,d0                         	| [add  a,#0x40]
	move.b	d0,ds_99B9_star_ctrl+0x02       	| [ld   (ds_99B9_star_ctrl + 0x02),a]

	rts                                    	| [ret]

*=============================================================================
* selected table is by difficulty (rank) configured by dip switch setting
*-----------------------------------------------------------------------------
bmbr_stg_cfg_lut:
	.long bmbr_stg_cfg_dat + 0x82 * 1
	.long bmbr_stg_cfg_dat + 0x82 * 2
	.long bmbr_stg_cfg_dat + 0x82 * 3
	.long bmbr_stg_cfg_dat + 0x82 * 0

* 26 stages of data: 4 sub-tables for the ranks, 5-bytes per stage (1 parameter per nibble)

* 0: parameter for set bomb drop enable flags
* 1: parameter for setting launch counter, bomber-type 0
* 2: parameter for setting launch counter, bomber-type 1
* 3: parameter for setting launch counter, bomber-type 2
* 4: allowable max_bombers
* 5: increases allowable max_bombers after a time
* 6: ds_plyr_actv +_b_captr_flag
* 7: number of aliens left when continous bombing can start
* 8: flag for reload attack-wave flite vector table pointer after stage-8
* 9: flag for reload bombing flite vector table pointer after stage-8

bmbr_stg_cfg_dat:
	.byte 0x00,0x00,0x22,0xC6,0x00, 0x00,0x11,0x23,0xC7,0x00
	.byte 0x00,0x00,0x00,0xC0,0x00, 0x11,0x12,0x23,0x97,0x00
	.byte 0x11,0x23,0x23,0x98,0x00, 0x21,0x24,0x33,0x98,0x00
	.byte 0x00,0x00,0x00,0x90,0x00, 0x22,0x25,0x33,0x99,0x10
	.byte 0x22,0x36,0x34,0x69,0x10, 0x10,0x11,0x23,0x97,0x00
	.byte 0x00,0x00,0x00,0x60,0x00, 0x32,0x46,0x34,0x67,0x11
	.byte 0x32,0x67,0x44,0x68,0x11, 0x32,0x67,0x45,0x68,0x11
	.byte 0x00,0x00,0x00,0x60,0x00, 0x42,0x78,0x45,0x69,0x11
	.byte 0x42,0x78,0x45,0x69,0x11, 0x11,0x22,0x23,0x97,0x11
	.byte 0x00,0x00,0x00,0x60,0x00, 0x52,0x88,0x46,0x3A,0x11
	.byte 0x52,0x88,0x56,0x3A,0x11, 0x52,0x88,0x56,0x3C,0x11
	.byte 0x00,0x00,0x00,0x30,0x00, 0x62,0x89,0x57,0x3C,0x11
	.byte 0x62,0x99,0x57,0x3C,0x11, 0x62,0x99,0x57,0x3C,0x11

	.byte 0x00,0x00,0x12,0xC6,0x00, 0x00,0x11,0x22,0xC6,0x00
	.byte 0x00,0x00,0x00,0xC0,0x00, 0x11,0x12,0x23,0x97,0x00
	.byte 0x11,0x12,0x23,0x97,0x00, 0x00,0x11,0x23,0xC7,0x00
	.byte 0x00,0x00,0x00,0x90,0x00, 0x21,0x23,0x33,0x98,0x10
	.byte 0x21,0x24,0x33,0x98,0x10, 0x21,0x25,0x34,0x98,0x10
	.byte 0x00,0x00,0x00,0x60,0x00, 0x22,0x25,0x34,0x68,0x11
	.byte 0x32,0x36,0x44,0x68,0x11, 0x11,0x11,0x23,0x67,0x01
	.byte 0x00,0x00,0x00,0x60,0x00, 0x32,0x36,0x45,0x68,0x11
	.byte 0x32,0x46,0x45,0x69,0x11, 0x32,0x67,0x45,0x69,0x11
	.byte 0x00,0x00,0x00,0x60,0x00, 0x42,0x67,0x46,0x3A,0x11
	.byte 0x42,0x78,0x56,0x3A,0x11, 0x52,0x78,0x56,0x3A,0x11
	.byte 0x00,0x00,0x00,0x30,0x00, 0x52,0x88,0x56,0x3C,0x11
	.byte 0x62,0x99,0x57,0x3C,0x11, 0x62,0x99,0x57,0x3C,0x11

	.byte 0x00,0x00,0x23,0xC6,0x00, 0x10,0x11,0x23,0x97,0x00
	.byte 0x00,0x00,0x00,0xC0,0x00, 0x11,0x12,0x33,0x98,0x00
	.byte 0x21,0x23,0x34,0x68,0x00, 0x21,0x24,0x34,0x68,0x00
	.byte 0x00,0x00,0x00,0x90,0x00, 0x32,0x36,0x34,0x67,0x10
	.byte 0x32,0x46,0x44,0x68,0x10, 0x11,0x11,0x23,0x97,0x10
	.byte 0x00,0x00,0x00,0x60,0x00, 0x42,0x67,0x45,0x68,0x11
	.byte 0x42,0x67,0x45,0x69,0x11, 0x42,0x78,0x46,0x69,0x11
	.byte 0x00,0x00,0x00,0x60,0x00, 0x52,0x78,0x46,0x3A,0x11
	.byte 0x52,0x88,0x56,0x3A,0x11, 0x52,0x88,0x56,0x3A,0x11
	.byte 0x00,0x00,0x00,0x60,0x00, 0x62,0x88,0x56,0x3C,0x11
	.byte 0x62,0x89,0x57,0x3C,0x11, 0x62,0x89,0x57,0x3E,0x11
	.byte 0x00,0x00,0x00,0x30,0x00, 0x72,0x99,0x57,0x3E,0x11
	.byte 0x72,0x99,0x68,0x3E,0x11, 0x72,0x99,0x68,0x3E,0x11

	.byte 0x00,0x00,0x23,0xC6,0x00, 0x10,0x11,0x23,0x97,0x00
	.byte 0x00,0x00,0x00,0xC0,0x00, 0x11,0x12,0x34,0x98,0x00
	.byte 0x21,0x23,0x34,0x68,0x00, 0x21,0x24,0x34,0x68,0x00
	.byte 0x00,0x00,0x00,0x90,0x00, 0x32,0x36,0x45,0x67,0x11
	.byte 0x32,0x46,0x46,0x68,0x11, 0x32,0x56,0x46,0x69,0x11
	.byte 0x00,0x00,0x00,0x60,0x00, 0x42,0x67,0x56,0x6A,0x11
	.byte 0x42,0x67,0x56,0x6A,0x11, 0x42,0x78,0x57,0x6A,0x11
	.byte 0x00,0x00,0x00,0x60,0x00, 0x52,0x78,0x57,0x3A,0x11
	.byte 0x52,0x88,0x57,0x3A,0x11, 0x52,0x88,0x68,0x3C,0x11
	.byte 0x00,0x00,0x00,0x60,0x00, 0x62,0x88,0x68,0x3C,0x11
	.byte 0x62,0x89,0x68,0x3C,0x11, 0x62,0x89,0x68,0x3E,0x11
	.byte 0x00,0x00,0x00,0x30,0x00, 0x72,0x99,0x68,0x3E,0x11
	.byte 0x72,0x99,0x68,0x3E,0x11, 0x72,0x99,0x68,0x3E,0x11


_l_2E75:
*           00003000  _top5_dlg_proc

*

* input file task_man.s
*
* task_man.s
*  gg1-1.3p 'maincpu' (Z80)
*
*  The "task manager" is triggered by the v-blank interrupt (RST 38)
*  thus the base execution rate is 60Hz. Some tasks will implement
*  their own sub-rates (e.g. 1 Hz, 4 Hz etc) by checking a global timer.
*
*  ds_cpu0_task_actv_9000 ($20 bytes) is indexed by order of the
*  function pointers in d_cpu0_task_table. Periodic tasks can be prioritized,
*  enabled and disabled by changing the appropriate index in the table.
*  The task enable table is accessed globally allowing one task to enable or
*  disable another task. At startup, actv_task_tbl ($20 bytes) is loaded with
*  a default configuration from ROM.
*
*  In ds_cpu0_task_actv_9000 the following values are used:
*   $00 - will skip first entry ($0873) but continue with second
*   $01
*   $1f - execute first then skip to last? (but it sets to $00 again?)
*   $20 - will execute $0873 (empty task) then immediately exit scheduler
*
*
*.module task_man



*           00000096  _l_0096                            int0
**.area ROM (ABS,OVR)
*       .org 0x0096
*.area CSEG00


*=============================================================================
* d_cpu0_task_table
*  Description:
*   Function pointers to periodic tasks (dispatch table for scheduler)
*   void (* const d_cpu0_task_table[32])(void)
*-----------------------------------------------------------------------------
d_cpu0_task_table:
	.long f_rts_0827                                         | $00
	.long f_update_sprites_0828                              | $01
	.long f_manage_attract_mode_17B2                         | $02
	.long f_ship_demo_controls_1700                          | $03
	.long f_clone_attack_manager_1A80                        | $04
	.long f_misc_gameplay_events_0857                        | $05
	.long f_rts_0827                                         | $06
	.long f_rts_0827                                         | $07
	.long f_insert_attackers_2916                            | $08
	.long f_pulsating_swarm_movement_1de6                    | $09
	.long f_lateral_movement_at_round_start_2a90             | $0A
	.long f_update_enemy_status_1db3                         | $0B
	.long f_update_objects_23dd                              | $0C
	.long f_bomb_position_updater_1ea4                       | $0D
	.long f_move_swarm_when_player_changes_1d32              | $0E
	.long f_blink_players_text_0935                          | $0F
	.long f_manage_bomber_attacks_1b65                       | $10
	.long f_manage_ship_capture_movement_19b2                | $11
	.long f_star_control_1d76                                | $12
	.long f_rts_0827                                         | $13
	.long f_controller_io_and_ship_movement_1f85             | $14
	.long f_read_fire_button_1f04                            | $15
	.long f_rts_0827                                         | $16
	.long f_update_timers_1dd2                               | $17
	.long f_boss_starts_tractor_beam_2222                    | $18
	.long f_boss_diving_down_to_capture_ship_21cb            | $19
	.long f_rts_0827                                         | $1A
	.long f_rts_0827                                         | $1B
	.long f_tractor_beam_captures_ship_20f2                  | $1C
	.long f_boss_capturing_ship_killed_2000                  | $1D
	.long f_rts_0827                                         | $1E
	.long f_credit_game_state_management_0977                | $1F

*=============================================================================
* c_textout_1uphighscore_onetime()
*  Description:
*   display score text top of screen (1 time only after boot)
* IN:
*  ...
* OUT:
*  ...
*-----------------------------------------------------------------------------
c_textout_1uphighscore_onetime:
	move.w	#0x8000+0x03E0+0x0D,d7      	| [ld   de,#0x8000 + 0x03E0 + 0x0D]
	lea	d_str20000,a0                  	| [ld   hl,#d_str20000] source of string "20000" (stored backwards)
	move.w	#0x05-1,d1                        	| [ld   bc,#0x0005] strlen 5
0:
	move.b	(a0)+,d0
	jbsr	osd_w_videoram
	addq.w	#1,d7                              	| [ldir]
	dbf		d1,0b
	move.w		#0x83CB,d7               	| [ld   e,#<<0x03C0 + 0x0B] $83CB
	lea	d_TxtScore,a0                  	| [ld   hl,#d_TxtScore] source of string "1UP    HIGH SCORE"
	move.w	#0x11-1,d1                        	| [ld   c,#0x11] strlen
0:
	move.b	(a0)+,d0
	jbsr	osd_w_videoram
	addq.w	#1,d7                              	| [ldir]
	dbf		d1,0b
                              	| [ldir]
	rts                                    	| [ret]

*=============================================================================
* string "1UP    HIGH SCORE"  (reversed)
d_TxtScore:
	.byte 0x0E,0x1B,0x18,0x0C,0x1C,0x24,0x11,0x10,0x12,0x11,0x24,0x24,0x24,0x24,0x19,0x1E,0x01


*=============================================================================

     ds.b 0x04                                   | pad

*=============================================================================
* Home positions of objects in the cylon fleet. Replicated in gg1-5.s
* Refer to diagram:
*
* object[] {
*  location.row    ...index to row pixel LUTs
*  location.column ...index to col pixel LUTs
* }
*                  00 02 04 06 08 0A 0C 0E 10 12
*
*     14                    00 04 06 02            | captured vipers
*     16                    30 34 36 32            | base stars
*     18              40 48 50 58 5A 52 4A 42      | raiders
*     1A              44 4C 54 5C 5E 56 4E 46
*     1C           08 10 18 20 28 2A 22 1A 12 0A
*     1E           0C 14 1C 24 2C 2E 26 1E 16 0E
*
*  organization of row and column pixel position LUTs (fmtn_hpos):
*
*                                       	|<-------------- COLUMNS --------------------->|<---------- ROWS ---------->|
*
*      00   02   04   06   08   0A   0C   0E   10   12   14   16   18   1A   1C   1E
*
*-----------------------------------------------------------------------------
db_obj_home_posn_rc:
	.byte 0x14,0x06,0x14,0x0C,0x14,0x08,0x14,0x0A,0x1C,0x00,0x1C,0x12,0x1E,0x00,0x1E,0x12
	.byte 0x1C,0x02,0x1C,0x10,0x1E,0x02,0x1E,0x10,0x1C,0x04,0x1C,0x0E,0x1E,0x04,0x1E,0x0E
	.byte 0x1C,0x06,0x1C,0x0C,0x1E,0x06,0x1E,0x0C,0x1C,0x08,0x1C,0x0A,0x1E,0x08,0x1E,0x0A
	.byte 0x16,0x06,0x16,0x0C,0x16,0x08,0x16,0x0A,0x18,0x00,0x18,0x12,0x1A,0x00,0x1A,0x12
	.byte 0x18,0x02,0x18,0x10,0x1A,0x02,0x1A,0x10,0x18,0x04,0x18,0x0E,0x1A,0x04,0x1A,0x0E
	.byte 0x18,0x06,0x18,0x0C,0x1A,0x06,0x1A,0x0C,0x18,0x08,0x18,0x0A,0x1A,0x08,0x1A,0x0A
	.align	2

*=============================================================================
* c_sctrl_playfld_clr_0160()
*  Description:
*    clears playfield tileram (not the score and credit texts at top & bottom).
* IN:
*  ...
* OUT:
*  ...
*-----------------------------------------------------------------------------
c_sctrl_playfld_clr_0160:
	move.w	#0x8000+0x0040,d7           	| [ld   hl,#0x8000 + 0x0040]
											| [ld   de,#0x8000 + 0x0041]
	move.w	#0x037F,d1                      | [ld   bc,#0x037F] 895
	move.b	#0x24,d0                      	| [ld   (hl),#0x24] clear Tile RAM with $24 (space)
0:
	jbsr	osd_w_videoram 		        	| [ldir]
	addq.w	#1,d7
	dbf		d1,0b
	move.w	#0x8440,d7          	| [ld   hl,#m_color_ram + 0x0040] clear Color RAM with $00
	          	| [ld   de,#m_color_ram + 0x0041]
	move.w	#0x037F,d1                | [ld   bc,#0x037F] 895
	moveq	#0,d0							| [ld   (hl),#0]
0:
	jbsr	osd_w_colorram                  | [$0178: ldir]
	addq.w	#1,d7
	dbf		d1,0b

* HL==87bf
	lea		0x87BF,a0
* Set the color (red) of the topmost row: let the pointer in HL wrap
* around to the top row from where it left off from the loop above.
	move.b	#0x04,d0                        	| [$017A: ld   a,#0x04]
	move.b	#0x20,d1                        	| [$017C: ld   b,#0x20]
	jbsr	rst_18_color                        | [$017E: rst  0x18] memset((HL), A=fill, B=ct)

* HL==87df
* Set color of 2nd row from top, again retaining pointer value from.
* previous loop. Why $4E? I don't know but it ends up white.
	move.b	#0x4E,d0                        	| [$017F: ld   a,#0x4E]
	move.b	#0x20,d1                        	| [$0181: ld   b,#0x20]
	jbsr	rst_18_color                        | [$0183: rst  0x18] memset((HL), A=fill, B=ct)

	rts                                    	| [ret]
* end

*=============================================================================
* stg_splash_scrn()
*  Description:
*   clears a stage (on two-player game, runs at the first turn of each player)
*   Increments stage_ctr (and dedicated challenge stage %4 indicator)
* IN:
*  ...
* OUT:
*  ...
*-----------------------------------------------------------------------------
stg_init_splash_0185:
* plyr_state_active.stage_ctr++
	lea	ds_plyr_actv+_b_stgctr,a0      	        | [$0185: ld   hl,#ds_plyr_actv +_b_stgctr] ++ ($9821)	
	tst.b	(a0)
	bne		0f
	move.b	start_level,(a0)
0:
	addq.b	#1,(a0)                         	| [$0188: inc  (hl)]

* plyr_state_active.not_chllng_stg = *HL & 0x03  ... gives 0 for challenge stage
	move.b	(a0),d0                         	| [$0189: ld   a,(hl)]
	addq.b	#1,d0                           	| [$018A: inc  a]
	and.b	#0x03,d0                         	| [$018B: and  #0x03]
	move.b	d0,ds_plyr_actv+_b_not_chllg_stg	| [$018D: ld   (ds_plyr_actv +_b_not_chllg_stg),a] ==(stg_ctr+1)%4 ...i.e. 0 if challenge stage

*  if ( 0 != plyr_state_active.not_chllng_stg ) ...
	jeq	l_01A2_set_challeng_stg            	    | [$0190: jr   z,l_01A2_set_challeng_stg]
* then {
	move.b	#0x06,d2                        	| [$0192: ld   c,#0x06] C=string_out_pe_index
	jbsr	string_out_pe_30                    | [$0194: rst  0x30] string_out_pe "STAGE "
* HL == $81B0 ... "X" of STAGE X.
	exg	a1,a0                              	    | [$0195: ex   de,hl] DE now 81B0 (points to X in "STAGE X")
	move.b	ds_plyr_actv+_b_stgctr,d0       	| [$0196: ld   a,(ds_plyr_actv +_b_stgctr)] show score
	clr.w	d5                               	| [$019A: ld   h,#0]
	move.b	d0,d5                           	| [$0199: ld   l,a]
	jbsr	c_text_out_i_to_d_0A53              | [$019C: call c_text_out_i_to_d_0A53] Print "X" of STAGE X.
	clr.b	d0                               	| [$019F: xor  a] 0 ... start value for wave_bonus_ctr (irrelevant if !challenge)
	jra	l_01AC                             	    | [$01A0: jr   l_01AC]
* } else {
l_01A2_set_challeng_stg:
	move.b	#0x07,d2                        	| [$01A2: ld   c,#0x07] C=string_out_pe_index
	jbsr	string_out_pe_30                    | [$01A4: rst  0x30] string_out_pe "CHALLENGING STAGE"
	move.b	#1,d0                           	| [$01A5: ld   a,#1]
	move.b	d0,b_9AA0+0x0D                  	| [$01A7: ld   (b_9AA0 + 0x0D),a] 1 ... sound-fx count/enable registers, start challenge stage
	move.w	#CHALLENGING_STAGE_SND,D0
	jbsr	osd_sound_start
	move.b	#8,d0                           	| [$01AA: ld   a,#8] start value for wave_bonus_ctr (decremented by cpu-b when bug destroyed)
* }

l_01AC:
	move.b	d0,w_bug_flying_hit_cnt_92a8        | [$01AC: ld   (w_bug_flying_hit_cnt_92a8),a] 8 for challenge stage (else 0 i.e. don't care)

* set the timer to synchronize finish of c_new_level_tokens_117f
	move.b	#3,d0                           	| [$01AF: ld   a,#3]
	move.b	d0,ds4_game_tmrs_92ac+2             | [$01B1: ld   (ds4_game_tmrs_92ac + 2),a] 3
	move.b	d0,ds_9200_glbls+0x0B           	| [$01B4: ld   (ds_9200_glbls + 0x0B),a] 3: enemy_enable, begin round, needs to be !0 (use 3 for optimization)

* if ( 0 != plyr_actv.b_not_chllg_stg ) Cy' = 0 ... set Cy to inhibit sound clicks for level tokens at challenge stage (1211)
	move.b	ds_plyr_actv+_b_not_chllg_stg,d0	| [$01B7: ld   a,(ds_plyr_actv +_b_not_chllg_stg)] parameter to sound manager passed through to c_build_token_1
	                               	            | [$01BA: and  a] clear Cy if A != 0
	seq	d7                              	    | [$01BB: ex   af,af']
	jbsr	c_new_level_tokens_117f             | [$01BC: call c_new_level_tokens_117f] A' == 0 if challenge stg, else non-zero (stage_ct + 1)

* while ( game_tmrs[2] ){}
l_01BF:
	move.b	ds4_game_tmrs_92ac+2,d0             | [$01BF: ld   a,(ds4_game_tmrs_92ac + 2)]
	                               	            | [$01C2: and  a]
	jne	l_01BF                             	    | [$01C3: jr   nz,l_01BF]

* _init_env()|

*=============================================================================
* stg_init_env_01c5()
*  Description:
*   Initialize new stage environment and handle rack-advance if enabled.
*   This section is broken out so that splash screen can be skipped in demo.
* IN:
*  ...
* OUT:
*  ...
*-----------------------------------------------------------------------------
stg_init_env_01c5:
	move.b	#120,d0                         	| [$01C5: ld   a,#120]
	move.b	d0,ds4_game_tmrs_92ac+2             | [$01C7: ld   (ds4_game_tmrs_92ac + 2),a] load the timer ($78 - new stage)
	jbsr	c_2896                            	| [$01CA: call c_2896] Initializes each creature by position
	jbsr	gctl_stg_new_atk_wavs_init_25a2     | [$01CD: call gctl_stg_new_atk_wavs_init_25a2] mob setup

* set game_tmrs[0] (attack formation timing)
	move.b	#2,d0                           	| [$01D0: ld   a,#2]
	move.b	d0,ds4_game_tmrs_92ac+0             | [$01D2: ld   (ds4_game_tmrs_92ac + 0),a] 2
	clr.b	d0                               	| [$01D5: xor  a]
	jbsr	c_12C3                            	| [$01D6: call c_12C3] A == 0 .... set MOB coordinates, new stage

* initialize array (even-bytes)
	clr.b	d0                               	| [$01D9: xor  a]
	move.b	#0x30,d1                        	| [$01DA: ld   b,#0x30]
	lea	b_obj_collsn_notif_9200,a0            	| [$01DC: ld   hl,#b_obj_collsn_notif_9200] 00-5F, even-bytes = 0
l_01DF:
	move.b	d0,(a0)                         	| [$01DF: ld   (hl),a]
	addq.w	#2,a0                           	| [$01E0: inc  l] * 2
	subq.b	#1,d1                           	| [...]
	jne	l_01DF                             	    | [$01E2: djnz l_01DF]
	move.b	d0,ds_cpu0_task_actv_9000+0x09      | [$01E4: ld   (ds_cpu0_task_actv_9000 + 0x09),a] 0  (f_pulsating_swarm_movement_1de6 ... collective bug movement)
	move.b	d0,ds_cpu0_task_actv_9000+0x10      | [$01E7: ld   (ds_cpu0_task_actv_9000 + 0x10),a] 0  (f_manage_bomber_attacks_1b65 ... manage bomber attack )
	move.b	d0,ds_cpu0_task_actv_9000+0x04      | [$01EA: ld   (ds_cpu0_task_actv_9000 + 0x04),a] 0  (f_clone_attack_manager_1A80 ... bonus-bee manager)
	move.b	d0,b_bug_flyng_hits_p_round_9288     	| [$01ED: ld   (b_bug_flyng_hits_p_round_9288),a] 0
	move.b	d0,ds_plyr_actv+_b_bmbr_boss_wingm	| [$01F0: ld   (ds_plyr_actv +_b_bmbr_boss_wingm),a] 0: bomber boss wingman-enable will toggle to 1 on first boss-bomber launch
	move.b	d0,ds_plyr_actv+_b_bbee_tmr     	| [$01F3: ld   (ds_plyr_actv +_b_bbee_tmr),a] 0: bonus bee launch timer
	move.b	d0,ds_plyr_actv+_b_atk_wv_enbl  	| [$01F6: ld   (ds_plyr_actv +_b_atk_wv_enbl),a] 0: attack_wave_enable
	move.b	d0,ds_plyr_actv+_b_attkwv_ctr   	| [$01F9: ld   (ds_plyr_actv +_b_attkwv_ctr),a] 0: atack_wave_ctr
	move.b	d0,b8_99B0_X3attackcfg_ct       	| [$01FC: ld   (b8_99B0_X3attackcfg_ct),a] 0
	move.b	d0,ds_plyr_actv+_b_nestlr_inh   	| [$01FF: ld   (ds_plyr_actv +_b_nestlr_inh),a] 0: nest_lr_flag
	addq.b	#1,d0                           	| [$0202: inc  a]
	move.b	d0,ds_plyr_actv+_b_bbee_obj     	| [$0203: ld   (ds_plyr_actv +_b_bbee_obj),a] 1: bonus_bee_obj_offs
	move.b	d0,ds_plyr_susp+_b_bbee_obj     	| [$0206: ld   (ds_plyr_susp +_b_bbee_obj),a] 1
	move.b	d0,ds_plyr_actv+_b_bmbr_boss_cobj	| [$0209: ld   (ds_plyr_actv +_b_bmbr_boss_cobj),a] 1: invalidate the capture boss object
	move.b	d0,ds_cpu0_task_actv_9000+0x0B      | [$020C: ld   (ds_cpu0_task_actv_9000 + 0x0B),a] 1: f_update_enemy_status_1db3 ... Update enemy status.
	move.b	d0,ds_cpu0_task_actv_9000+0x08      | [$020F: ld   (ds_cpu0_task_actv_9000 + 0x08),a] 1: f_insert_attackers_2916 ... Launches the attack formations
	move.b	d0,ds_cpu0_task_actv_9000+0x0A      | [$0212: ld   (ds_cpu0_task_actv_9000 + 0x0A),a] 1: f_lateral_movement_at_round_start_2a90 ... left/right movement of collective while attack waves coming
	jbsr	new_stage_setup_2c00                | [$0215: call new_stage_setup_2c00] new stage setup
	lea	ds_plyr_actv+_ds_bmbr_boss_scode,a0	    | [$0218: ld   hl,#ds_plyr_actv +_ds_bmbr_boss_scode] set 8 bytes "01B501B501B501B5"
	move.w	#0x0100+0x80+0x35,d3            	| [$021B: ld   de,#0x0100 + 0x80 + 0x35] 400 sprite (d = $04 - $03)
	LOAD_D3D4_FROM_D3_16
	move.b	#4,d1                           	| [ld   b,#4]
l_0220:
	move.b	d3,(a0)+                         	| [ld   (hl),d]
	                           	                | [inc  l]
	move.b	d4,(a0)+                         	| [ld   (hl),e]
	                           	                | [inc  l]
	subq.b	#1,d1                           	| [...]
	jne	l_0220                             	    | [djnz l_0220]

*  if ( !RackAdvance ) return (active low)
*	move.b	_sfr_dsw6,d0                    	| [ld   a,(_sfr_dsw6)] DSWA rack advance operation
*	btst.b	#1,d0                           	| [bit  1,a]
*	beq.b	0f                               	| [...]
	rts                                    	    | [ret  nz] _plyr_startup [...]
0:
*  else handle rack advance operation
	move.b	#0x0B,d2                        	| [ld   c,#0x0B]
	lea	0x8000+0x03A0+0x10,a0      	            | [ld   hl,#0x8000 + 0x03A0 + 0x10]
	jbsr	c_string_out_1398                   | [call c_string_out_1398] erase "stage X" text"
	jra	stg_init_splash_0185                    	    | [jp   stg_init_splash_0185] start over again


*=============================================================================
* jp_Task_man_0237()
*  Description:
*   handler for rst $38
*   Updates star control registers.
*   Executes the Scheduler.
*   Sets IO chip for control input.
*   The task enable table is composed of 1-byte entries corresponding to each
*   of $20 tasks. Each cycle starts at task[0] and advances an index for each
*   entry in the table. The increment value is actually obtained from the
*   task_enable table entry itself, which is normally 1, but other values are
*   also used, such as $20. The "while" logic exits at >$20, so this is used
*   to exit the task loop without iterating through all $20 entries. The
*   possible enable values are:
*     $00 - disables task
*     $01 - enables task_man
*     $0A -
*     $1F -   1F + 0A = $29     (where else could $0A be used?)
*     $20 - exit current task man step after the currently executed task.
* IN:
*  ...
* OUT:
*  ...
*-----------------------------------------------------------------------------
jp_Task_man_0237:
	move.w	d7,-(sp)                        	| [push af]
	move.w	d0,-(sp)                        	| [push af]
	movem.w	d1/d2,-(sp)                    	    | [push bc]
	movem.w	d3/d4,-(sp)                    	    | [push de]
	move.l	a1,-(sp)                        	| [push de]
	move.l	a0,-(sp)                        	| [push hl]
	move.l	a2,-(sp)                        	| [push ix]
	move.l	a3,-(sp)                        	| [push iy]
	move.w	ix,-(sp)
* determine star_ctrl param bits based on some modulus of frame timer?
* $A000-$A005 starfield scroll speed (only bit 0 is significant)
*	move.b	_sfr_dsw5,d0                    	| [ld   a,(_sfr_dsw5)] DSWA: freeze video
*	move.b	d0,d3                           	| [ld   d,a]
*	move.b	ds3_frame_cts_92A0+0,d0         	| [ld   a,(ds3_frame_cts_92A0 + 0)]
*	and.b	#0x1C,d0                         	| [and  #0x1C] 0000XXX0
*	move.b	d0,d2                           	| [ld   c,a]
*	ror.b	#1,d0                            	| [rrca] 00000XXX
*	eor.b	d2,d0                            	| [xor  c] A ^ C
*	and.b	#0x18,d0                         	| [and  #0x18] 000XX000
*	move.b	d0,d2                           	| [ld   c,a]
*
**  if ( ! freezed_dsw set )
*	move.b	ds_99B9_star_ctrl+0x05,d0       	| [ld   a,(ds_99B9_star_ctrl + 0x05)]
*	btst.b	#1,d3                           	| [bit  1,d] freeze_ctrl_dsw
*	jne	l_0259                             	| [jr   nz,l_0259]
**  else
*	move.b	#7,d0                           	| [ld   a,#7] 7==star_ctrl_bits=freezed
*
l_0259:
	and.b	#0x07,d0                         	| [and  #0x07]
	or.b	d2,d0                             	| [or   c]

*	move.b	#5,d1                           	| [ld   b,#5]
*	lea	l_A000,a0                      	| [ld   hl,#0xA000] star_ctrl_port
*
*l_0261:
*	move.b	d0,(a0)+                         	| [ld   (hl),a] A==star_ctrl_bits
*	                           	| [inc  l]
*	ror.b	#1,d0                            	| [rrca] star_ctrl_bits >>= 1
*	subq.b	#1,d1                           	| [...]
*	jne	l_0261                             	| [djnz l_0261]

	*move.b	d0,_sfr_watchdog                	| [ld   (_sfr_watchdog),a]

	clr.b	d0                               	| [xor  a]
	jbsr	osd_interrupt_control                    	| [ld   (_sfr_6820),a] 0 ... disable IRQ1

*  if ( freezed )  exit
	*btst.b	#1,d3                           	| [bit  1,d]
	*jeq	l_02A8_pop_regs_and_exit           	| [jp   z,l_02A8_pop_regs_and_exit]

*
* Execute the Scheduler
*
* D0: start task
	moveq	#0,d2
	move.b	d0,d2                           	| [$00272: ld   c,a] A == 0 ... initialize index into Task Enable Table
l_while_zero_0273:
* while ( 0 == A = *(task_activ_tbl + C) )  C++   ... loop until non-zero: assumes we will find a valid entry in the table!
	lea	ds_cpu0_task_actv_9000,a0           	| [$0273: ld   hl,#ds_cpu0_task_actv_9000]
	                           	| [ld   a,c]
	add.w	d2,a0                            	| [add  a,l]
	                           	| [ld   l,a]
	move.b	(a0),d0                         	| [ld   a,(hl)] task_activ_tbl[index]
	                               	| [and  a]
	jne	l_0280_nonzero_tbl_entry           	| [jr   nz,l_0280_nonzero_tbl_entry]
	addq.b	#1,d2                           	| [inc  c]
	cmp.b	#0x20,d2
	* JOTD: probably race condition between interrupt and non-interrupt code
	* if no task is active then try again
	* this avoids that the game finds non-zero index too far in the table => crash
	jne	l_while_zero_0273
	moveq	#0,d2
	jra	l_while_zero_0273                       	| [jr   l_while_zero]

l_0280_nonzero_tbl_entry:
* save the table entry for later...
	move.b	d0,d1                           	| [ld   b,a] *(task_activ_tbl + C)
* multiply index 'd0' by 4 to form a 32-bit function pointer
* p_taskfn = d_cpu0_task_table[C]
	lea	d_cpu0_task_table,a0           	| [ld   hl,#d_cpu0_task_table]
	moveq	#0,d0

	move.b	d2,d0                           	| [ld   a,c] index
	CHECK_D0W_UPPER_BOUND	0x20
	asl.b	#2,d0                            	| [sla  a] <<=2 ... sizeof 16-bit function pointer
	move.l	(a0,d0.w),a1                         	| [add  a,l]
	                                         	| [ld   l,a]
	                                         	| [ld   e,(hl)] lo-byte of pointer
	                                         	| [inc  hl]
	                                         	| [ld   d,(hl)] hi-byte of pointer
	exg	a1,a0                              	| [ex   de,hl] jp address in HL

	movem.w	d1/d2,-(sp)                    	| [push bc]
	jbsr	(a0)                   	| [call c_task_switcher] p_taskfn()
	movem.w	(sp)+,d1/d2                    	| [pop  bc]

*    index+=task_activ_tbl[index]
	move.b	d1,d0                           	| [ld   a,b] *(task_activ_tbl + C)
	add.b	d2,d0                            	| [add  a,c] +=index
	move.b	d0,d2                           	| [ld   c,a]

* while (index < $20)
	and.b	#0xE0,d0                         	| [and  #0xE0] control values are $00, $01, $20, $1f
	jeq	l_while_zero_0273                      	| [jr   z,l_while_index]

* setup regs for input from IO chip
	*lea	l_7000,a0                      	| [ld   hl,#0x7000] IO data xfer (read)
	lea	ds3_io_input_99b5,a1      	| [ld   de,#ds3_io_input_99b5 + 0x00] read 3 bytes
	move.b	#0x00,d1                        	| [ld   bc,#0x0003] 3
	move.b	#0x03,d2                        	| [ld   bc,#0x0003] 3
	jbsr	exx                               	| [exx]

* send command to IO chip
	move.b	#0x71,d0                        	| [ld   a,#0x71] cmd==read ctrl inputs
	*move.b	d0,0x7100                       	| [ld   (0x7100),a] IO cmd ($71 -> enable NMI to trigger when data is available)

l_02A8_pop_regs_and_exit:
	move.b	#1,d0                           	| [ld   a,#1]
	jbsr	osd_interrupt_control               | [ld   (_sfr_6820),a] 1 ... enable IRQ1

	move.w	(sp)+,ix
	move.l	(sp)+,a3                        	| [pop  iy]
	move.l	(sp)+,a2                        	| [pop  ix]
	move.l	(sp)+,a0                        	| [pop  hl]
	move.l	(sp)+,a1                        	| [pop  de]
	movem.w	(sp)+,d3/d4                    	    | [pop  de]

	movem.w	(sp)+,d1/d2                    	    | [pop  bc]
	move.w	(sp)+,d0                        	| [pop  af]
	move.w	(sp)+,d7                        	| [pop  af]
	rts                                    	    | [ret]
* } end 'rst  $0038' handler

*=============================================================================
d_str20000:
	.byte 0x00,0x00,0x00,0x00,0x02,0x24  || "20000" (reversed)
d_strScore:
	.byte 0x17,0x0A,0x16,0x0C,0x18       || "SCORE" (reversed)
	.align	2
*=============================================================================
* RESET()
*  Description:
*   jp here from z80 reset vector
* IN:
*  ...
* OUT:
*  ...
*-----------------------------------------------------------------------------
	.include	"flv_defs.inc"

	.ifne	0
	.include	"galaga_tiles.s"
	
galaga_mock:
	* temp
	lea		galaga_tiles,a0
	move.w	#0x3FF,d1
	move.w	#0x8000,d7
0:
	move.b	(a0)+,d0
	jbsr	osd_w_videoram
	addq.w	#1,d7
	dbf		d1,0b
	move.w	#0x3FF,d1
	
0:
	move.b	(a0)+,d0
	jbsr	osd_w_colorram
	addq.w	#1,d7
	dbf		d1,0b
	
	rts
	.endif
	
*VIDEO_TEST = 0

galaga_reset:
	.ifndef		RELEASE
	tst.b	break_at_startup_flag
	beq.b	0f
	

	jbsr	osd_break
0:

	* those are the locations where the game updates
	* the sprite logic (mrw), before copying into the hardware
	* sprite buffers (sfr)
	move.l	#mrw_sprite_code_8B00,0x100
	move.l	#mrw_sprite_posn_9300,0x104
	move.l	#mrw_sprite_ctrl_9B00,0x108
	.endif
	
	.ifdef		VIDEO_TEST
	bsr		galaga_mock
	dc.w	0x60FE
	bsr		c_textout_1uphighscore_onetime
	move.w	#0x8000+0x03E0+0x400+0x10,d7      	| score value 2nd row
	move.b	#0x4E,d0
	jbsr	osd_w_colorram
	move.w		#0x87CB,d7
	move.b	#4,d0
	jbsr	osd_w_colorram

	move.w		#0x85C2,d7
	move.b	#0,d0
	jbsr	osd_w_colorram

	moveq	#0x0e,d2                           	| [$199B: ld   c,a] C = 0x0D + A ... string index
	jbsr	string_out_pe_30                    | [$199C: rst  0x30] string_out_pe ("GALAGA", "--SCORE--", etc)
	dc.w	0x60FE
	.endif



CPU0_RESET:
* set interrupt mode
	*im   1

* memset(mchn_data,0,$10)
	clr.b	d0                               	| [xor  a]
	lea	ds10_99E0_mchn_data,a0         	| [ld   hl,#ds10_99E0_mchn_data] clear $10 bytes
	move.b	#0x10,d1                        	| [ld   b,#0x10]
l_02CC:
	move.b	d0,(a0)+                         	| [ld   (hl),a]
												| [inc  hl]
	subq.b	#1,d1                           	| [...]
	jne	l_02CC                             	| [djnz l_02CC]

* let the fun begin!
*=============================================================================
* j_Test_menu_init()
*  Description:
*   jr here from completion of ROM tests.
*   'RAM OK' and 'ROM OK' actually shown right side up, but then in ShowCfg the
*   flip screen gets set because of the check that is done on the IO input value.
* IN:
*  ...
* OUT:
*  ...
*-----------------------------------------------------------------------------
	lea	str_3B88(pc),a0                    	    | [ld   hl,#str_3B88] ld src address of string "ROM  OK"
	jbsr	c_text_out_331b                        	| [call c_text_out_331b] display "ROM OK"
	jbsr	c_svc_updt_dsply                  	| [call c_svc_updt_dsply] prints remaining dsw configured options (upside down)
* Initialize scheduler table before interrupts are enabled (otherwise task scheduler could infinite loop!)
	move.b	#0x20,d0                        	| [ld   a,#0x20]
	move.b	d0,ds_cpu0_task_actv_9000+0          	| [ld   (ds_cpu0_task_actv + 0),a] $20 ... only task 0 (empty task) can be called
	jra	jp_RAM_test                        	| [jp   jp_RAM_test]



	.include	"register_op.inc"
	